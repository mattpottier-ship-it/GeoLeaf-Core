(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.GeoLeaf = {}));
})(this, (function (exports) { 'use strict';

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    /**
     * @module log/logger
     * @description GeoLeaf.Log — gestion centralisée des logs
     *
     * Objectif :
     * - remplacer tous les console.log/console.warn/... du projet
     * - fournir un niveau de verbosité configurable via la config JSON
     * - s'assurer que chaque message possède un préfixe normalisé [GeoLeaf.X]
     */

    const LEVELS = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };

    let currentLevel = LEVELS.INFO; // niveau par défaut
    let quietMode = false; // mode silencieux pour les logs répétitifs
    const groupedMessageCounts = new Map(); // pour grouper les messages similaires
    const MAX_GROUPED_ENTRIES = 200; // cap to prevent unbounded growth

    const formatPrefix = (type) => `[GeoLeaf.${type}]`;

    // Détecte si un message est répétitif ou informatif non critique
    const isRepetitiveMessage = (message) => {
        const patterns = [
            /Chargement du sprite SVG/,
            /Sprite SVG détecté/,
            /IconsConfig récupéré/,
            /Module.*chargé/,
            /Module.*initialisé/,
            /Contrôle.*ajouté/,
            /Bouton.*ajouté/,
            /Panneau.*créé/,
            /Section.*remplie/,
            /Profil.*chargé/,
            /Couche.*chargée/,
            /Style.*appliqué/,
            /ThemeApplier/,
            /LayerManager/,
            /Storage/,
            /CacheButton/,
            /Renderers\./,
            /FormRenderer/,
            /ResourceEnumerator/,
            /LayerSelector/,
            /CacheControl/,
            /POI.*DEBUG/,
            /AddForm/
        ];
        return patterns.some(pattern => pattern.test(message));
    };

    // Messages critiques qui doivent toujours être affichés
    const isCriticalMessage = (message) => {
        const criticalPatterns = [
            /ERROR/,
            /WARN/,
            /Failed/,
            /Error/,
            /Exception/,
            /Carte initialisée avec succès/,
            /All.*modules loaded/,
            /Mode.*activé/
        ];
        return criticalPatterns.some(pattern => pattern.test(message));
    };

    // Gère les messages groupés
    const handleGroupedMessage = (message, args) => {
        const key = message.replace(/\d+/g, 'X').replace(/[{}:,]/g, ''); // normalise
        const count = (groupedMessageCounts.get(key) || 0) + 1;
        groupedMessageCounts.set(key, count);

        // Evict oldest entries when cap is reached
        if (groupedMessageCounts.size > MAX_GROUPED_ENTRIES) {
            const firstKey = groupedMessageCounts.keys().next().value;
            groupedMessageCounts.delete(firstKey);
        }

        if (count === 1) {
            return true; // affiche le premier
        } else if (count === 3 && !isCriticalMessage(message)) {
            console.info(`${formatPrefix('INFO')} [Groupé] Message répété - suite masquée: ${message.substring(0, 60)}...`);
            return false;
        } else if (count > 3) {
            return false; // supprime après 3 occurrences pour les non-critiques
        }
        return count <= 2; // affiche max 2 fois les messages non critiques
    };

    /**
     * Logger centralisé GeoLeaf (implementation)
     * @type {Object}
     */
    const _LogImpl = {
        /**
         * Définir le niveau de logs global
         * @param {string} level  "debug" | "info" | "warn" | "error" | "production"
         */
        setLevel(level) {
            const lvl = String(level).toLowerCase();
            switch (lvl) {
                case "debug":
                    currentLevel = LEVELS.DEBUG;
                    break;
                case "info":
                    currentLevel = LEVELS.INFO;
                    break;
                case "warn":
                    currentLevel = LEVELS.WARN;
                    break;
                case "error":
                    currentLevel = LEVELS.ERROR;
                    break;
                case "production":
                    currentLevel = LEVELS.WARN; // En production, seulement WARN et ERROR
                    quietMode = true;
                    break;
                default:
                    console.warn(`${formatPrefix("WARN")} Niveau de log inconnu :`, level);
            }
        },

        /**
         * Retourne le niveau de log courant (valeur numérique)
         * @returns {number}
         */
        getLevel() {
            return currentLevel;
        },

        /**
         * Retourne le nom du niveau de log courant
         * @returns {string}
         */
        getLevelName() {
            for (const [name, value] of Object.entries(LEVELS)) {
                if (value === currentLevel) return name;
            }
            return 'UNKNOWN';
        },

        /**
         * Active/désactive le mode silencieux pour les messages répétitifs
         */
        setQuietMode(enabled) {
            if (quietMode === enabled) return; // éviter les répétitions
            quietMode = enabled;
            if (enabled) {
                console.info(`${formatPrefix("INFO")} Mode silencieux activé - logs répétitifs réduits`);
            }
        },

        /**
         * Affiche un résumé des messages groupés
         */
        showSummary() {
            if (groupedMessageCounts.size > 0) {
                console.group(`${formatPrefix("INFO")} Résumé des logs groupés:`);
                for (const [message, count] of groupedMessageCounts) {
                    if (count > 3) {
                        console.info(`• ${count}x: ${message.substring(0, 60)}...`);
                    }
                }
                console.groupEnd();
            }
        },

        debug(...args) {
            if (currentLevel <= LEVELS.DEBUG) {
                const message = args.join(' ');
                if (quietMode && isRepetitiveMessage(message)) {
                    if (!handleGroupedMessage(message)) return;
                }
                console.debug(formatPrefix("DEBUG"), ...args);
            }
        },

        info(...args) {
            if (currentLevel <= LEVELS.INFO) {
                const message = args.join(' ');

                // En mode silencieux, filtrer plus agressivement
                if (quietMode) {
                    // Toujours afficher les messages critiques
                    if (isCriticalMessage(message)) {
                        console.info(formatPrefix("INFO"), ...args);
                        return;
                    }

                    // Grouper/masquer les messages répétitifs
                    if (isRepetitiveMessage(message)) {
                        if (!handleGroupedMessage(message)) return;
                    }
                }

                console.info(formatPrefix("INFO"), ...args);
            }
        },

        warn(...args) {
            if (currentLevel <= LEVELS.WARN) {
                console.warn(formatPrefix("WARN"), ...args);
            }
        },

        error(...args) {
            if (currentLevel <= LEVELS.ERROR) {
                console.error(formatPrefix("ERROR"), ...args);
            }
        }
    };

    // ── Local globalThis reference (for test-mock Proxy delegation) ──
    const _g$J = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};

    /**
     * Exported Log proxy — delegates to LogImpl; provides CJS test override surface
     * (global.GeoLeaf.Log = mock)
     * while modules use the standard `import { Log }` pattern.
     * @type {Object}
     */
    const Log = new Proxy(_LogImpl, {
        get(_target, prop, receiver) {
            const current = _g$J.GeoLeaf && _g$J.GeoLeaf.Log;
            if (current && current !== _LogImpl && current !== receiver && prop in current) {
                return current[prop];
            }
            return _LogImpl[prop];
        }
    });

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ── Base class ──

    class GeoLeafError extends Error {
        constructor(message, context = {}) {
            super(message);
            this.name = this.constructor.name;
            this.context = context;
            this.timestamp = new Date().toISOString();
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        }

        toJSON() {
            return {
                name: this.name,
                message: this.message,
                context: this.context,
                timestamp: this.timestamp,
                stack: this.stack
            };
        }

        toString() {
            const contextStr = Object.keys(this.context).length > 0
                ? ` [Context: ${JSON.stringify(this.context)}]`
                : '';
            return `${this.name}: ${this.message}${contextStr}`;
        }
    }

    // ── Specific error types ──

    class ValidationError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'VALIDATION_ERROR';
        }
    }

    class SecurityError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'SECURITY_ERROR';
        }
    }

    class ConfigError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'CONFIG_ERROR';
        }
    }

    class NetworkError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'NETWORK_ERROR';
        }
    }

    class InitializationError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'INITIALIZATION_ERROR';
        }
    }

    class MapError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'MAP_ERROR';
        }
    }

    class DataError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'DATA_ERROR';
        }
    }

    class POIError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'POI_ERROR';
        }
    }

    class RouteError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'ROUTE_ERROR';
        }
    }

    class UIError extends GeoLeafError {
        constructor(message, context = {}) {
            super(message, context);
            this.code = 'UI_ERROR';
        }
    }

    // ── Error codes enum ──

    const ErrorCodes = Object.freeze({
        VALIDATION: 'VALIDATION_ERROR',
        SECURITY: 'SECURITY_ERROR',
        CONFIG: 'CONFIG_ERROR',
        NETWORK: 'NETWORK_ERROR',
        INITIALIZATION: 'INITIALIZATION_ERROR',
        MAP: 'MAP_ERROR',
        DATA: 'DATA_ERROR',
        POI: 'POI_ERROR',
        ROUTE: 'ROUTE_ERROR',
        UI: 'UI_ERROR'
    });

    // ── Utility functions ──

    function normalizeError(error, defaultMessage = 'An unknown error occurred') {
        if (error instanceof Error) return error;
        if (typeof error === 'string') return new GeoLeafError(error);
        if (error && typeof error === 'object') {
            const message = error.message || error.error || defaultMessage;
            return new GeoLeafError(message, { originalError: error });
        }
        return new GeoLeafError(defaultMessage, { originalError: error });
    }

    function isErrorType(error, ErrorClass) {
        return error instanceof ErrorClass;
    }

    function getErrorCode(error) {
        if (error && typeof error === 'object' && 'code' in error) return error.code;
        return 'UNKNOWN_ERROR';
    }

    function createError(ErrorClass, message, context = {}) {
        const error = new ErrorClass(message, context);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(error, createError);
        }
        return error;
    }

    function createErrorByType(type, message, context = {}) {
        const errorMap = {
            'validation': ValidationError,
            'security': SecurityError,
            'config': ConfigError,
            'network': NetworkError,
            'initialization': InitializationError,
            'map': MapError,
            'data': DataError,
            'poi': POIError,
            'route': RouteError,
            'ui': UIError
        };
        const ErrorClass = errorMap[type.toLowerCase()] || GeoLeafError;
        return createError(ErrorClass, message, context);
    }

    function sanitizeErrorMessage(message, maxLength = 500) {
        if (message == null) return 'Unknown error';
        let str = typeof message === 'string' ? message : String(message);
        str = str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        if (str.length > maxLength) {
            str = str.slice(0, maxLength) + '...';
        }
        return str;
    }

    function safeErrorHandler(handler, error) {
        if (typeof handler !== 'function') return;
        try {
            handler(error);
        } catch (handlerError) {
            Log.error('[GeoLeaf.Errors] Error in error handler:', handlerError);
            Log.error('[GeoLeaf.Errors] Original error:', error);
        }
    }

    // ── Aggregate export (facade) ──

    const Errors = {
        GeoLeafError,
        ValidationError,
        SecurityError,
        ConfigError,
        NetworkError,
        InitializationError,
        MapError,
        DataError,
        POIError,
        RouteError,
        UIError,
        normalizeError,
        isErrorType,
        getErrorCode,
        createError,
        createErrorByType,
        sanitizeErrorMessage,
        safeErrorHandler,
        ErrorCodes
    };

    // ── Backward compatibility moved to globals.js ──

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    /**
     * @module constants
     * @description Constantes globales GeoLeaf — valeurs numériques centralisées.
     */

    const CONSTANTS = Object.freeze({
        // Carte — vue neutre, le fitBounds positionne après chargement des couches
        DEFAULT_ZOOM: 3,
        DEFAULT_CENTER: [0, 0],
        MAX_ZOOM_ON_FIT: 15,

        // POI
        POI_MARKER_SIZE: 12,
        POI_MAX_ZOOM: 18,
        POI_SWIPE_THRESHOLD: 50,
        POI_LIGHTBOX_TRANSITION_MS: 300,
        POI_SIDEPANEL_DEFAULT_WIDTH: 420,

        // Route
        ROUTE_MAX_ZOOM_ON_FIT: 14,
        ROUTE_WAYPOINT_RADIUS: 5,

        // GeoJSON
        GEOJSON_MAX_ZOOM_ON_FIT: 15,
        GEOJSON_POINT_RADIUS: 6,

        // UI
        FULLSCREEN_TRANSITION_MS: 10
    });

    // ── Backward compatibility moved to globals.js ──

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ── HTML Escaping ──

    /**
     * Escape dangerous HTML characters to prevent XSS
     * @param {string} str - String to escape
     * @returns {string} Escaped string
     */
    function escapeHtml(str) {
        if (str === null || str === undefined) {
            return '';
        }
        if (typeof str !== 'string') {
            str = String(str);
        }
        const div = document.createElement('div');
        div.textContent = str;
        // SAFE: innerHTML here gets the escaped version of textContent
        return div.innerHTML;
    }

    /**
     * Escape HTML attributes for safe use in attribute values
     * @param {string} str - String to escape
     * @returns {string} Escaped string
     */
    function escapeAttribute(str) {
        if (str === null || str === undefined) {
            return '';
        }
        if (typeof str !== 'string') {
            str = String(str);
        }
        return str
            .replace(/&/g, '&amp;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    // ── URL Validation ──

    /**
     * Validate a URL strictly with protocol whitelist
     * @param {string} url - URL to validate
     * @param {string} [baseUrl] - Base URL for resolving relative URLs
     * @returns {string} Validated URL
     * @throws {Error} If URL is invalid or protocol not allowed
     */
    function validateUrl$2(url, baseUrl) {
        if (!url || typeof url !== 'string') {
            throw new TypeError('URL must be a non-empty string');
        }

        url = url.trim();

        const _loc = typeof globalThis !== 'undefined' && globalThis.location ? globalThis.location : (typeof location !== 'undefined' ? location : null);
        const base = baseUrl || (_loc && _loc.origin) || 'https://localhost';

        try {
            const parsed = new URL(url, base);

            const ALLOWED_PROTOCOLS = ['http:', 'https:', 'data:'];
            if (!ALLOWED_PROTOCOLS.includes(parsed.protocol)) {
                throw new Error(
                    `Protocol "${parsed.protocol}" not allowed. Allowed protocols: ${ALLOWED_PROTOCOLS.join(', ')}`
                );
            }

            // Additional validation for data: URLs
            if (parsed.protocol === 'data:') {
                const allowedDataTypes = [
                    'image/png', 'image/jpeg', 'image/jpg', 'image/gif',
                    'image/svg+xml', 'image/webp'
                ];
                const dataPrefix = url.split(',')[0];
                const mimeMatch = dataPrefix.match(/data:([^;,]+)/);
                if (!mimeMatch) {
                    throw new Error('Invalid data URL format');
                }
                if (!allowedDataTypes.includes(mimeMatch[1])) {
                    throw new Error(
                        `Data URL type "${mimeMatch[1]}" not allowed. Allowed: ${allowedDataTypes.join(', ')}`
                    );
                }
            }

            return parsed.href;
        } catch (e) {
            if (e.message.includes('not allowed')) {
                throw e;
            }
            throw new Error(`Invalid URL "${url}": ${e.message}`);
        }
    }

    // ── Coordinate Validation ──

    /**
     * Validate geographic coordinates
     * @param {number} lat - Latitude
     * @param {number} lng - Longitude
     * @returns {[number, number]} Validated coordinates [lat, lng]
     * @throws {TypeError|RangeError} If coordinates are invalid
     */
    function validateCoordinates$2(lat, lng) {
        if (typeof lat !== 'number' || typeof lng !== 'number') {
            throw new TypeError(
                `Coordinates must be numbers, got lat=${typeof lat}, lng=${typeof lng}`
            );
        }
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            throw new RangeError('Coordinates must be finite numbers (not NaN or Infinity)');
        }
        if (lat < -90 || lat > 90) {
            throw new RangeError(`Latitude must be between -90 and 90, got ${lat}`);
        }
        if (lng < -180 || lng > 180) {
            throw new RangeError(`Longitude must be between -180 and 180, got ${lng}`);
        }
        return [lat, lng];
    }

    // ── POI Sanitization ──

    /**
     * Sanitize a POI properties object — escapes text fields and validates URLs
     * @param {Object} props - Properties to sanitize
     * @returns {Object} Sanitized properties
     */
    function sanitizePoiProperties(props) {
        if (!props || typeof props !== 'object') {
            return {};
        }

        const sanitized = {};
        const textFields = ['label', 'name', 'title', 'description', 'desc', 'address', 'phone', 'email', 'category', 'type'];
        const urlFields = ['url', 'website', 'image', 'photo', 'icon'];

        for (const [key, value] of Object.entries(props)) {
            if (typeof value === 'function' || typeof value === 'symbol') continue;

            if (value === null || value === undefined) {
                sanitized[key] = '';
                continue;
            }

            if (textFields.includes(key) && typeof value === 'string') {
                sanitized[key] = escapeHtml(value);
            } else if (urlFields.includes(key) && typeof value === 'string') {
                try {
                    sanitized[key] = validateUrl$2(value);
                } catch (e) {
                    Log.warn(`[Security] Invalid URL for ${key}: ${e.message}`);
                    sanitized[key] = '';
                }
            } else if (Array.isArray(value)) {
                sanitized[key] = value.map(item => {
                    if (typeof item === 'object' && item !== null) return sanitizePoiProperties(item);
                    if (typeof item === 'string') return escapeHtml(item);
                    return item;
                });
            } else if (typeof value === 'object' && value !== null) {
                sanitized[key] = sanitizePoiProperties(value);
            } else {
                sanitized[key] = value;
            }
        }

        return sanitized;
    }

    // ── HTML Detection & Stripping ──

    /**
     * Check if a string contains potentially dangerous HTML
     * @param {string} str - String to check
     * @returns {boolean} True if contains dangerous HTML
     */
    function containsDangerousHtml(str) {
        if (typeof str !== 'string') return false;

        const dangerousPatterns = [
            /<script/i, /javascript:/i, /on\w+\s*=/i,
            /<iframe/i, /<object/i, /<embed/i,
            /<applet/i, /<meta/i, /<link/i,
            /vbscript:/i, /data:text\/html/i
        ];

        return dangerousPatterns.some(pattern => pattern.test(str));
    }

    /**
     * Strip all HTML from a string, keeping only text content
     * @param {string} html - HTML to strip
     * @returns {string} Plain text
     */
    function stripHtml(html) {
        if (typeof html !== 'string') return '';

        // SAFE: DOMParser instead of innerHTML to avoid script execution
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        return doc.body.textContent || doc.body.innerText || '';
    }

    // ── Safe DOM Creation ──

    /**
     * Create a DOM element safely with automatic content escaping
     * @param {string} tagName - HTML tag name
     * @param {Object} options - Configuration
     * @returns {Element} Created DOM element
     */
    function createSafeElement(tagName, options = {}) {
        const element = document.createElement(tagName);

        if (options.className) element.className = options.className;
        if (options.id) element.id = options.id;
        if (options.textContent) {
            // SAFE: textContent automatically escapes HTML
            element.textContent = options.textContent;
        }
        if (options.attributes) {
            Object.keys(options.attributes).forEach(key => {
                element.setAttribute(key, escapeAttribute(options.attributes[key]));
            });
        }
        if (options.children && Array.isArray(options.children)) {
            options.children.forEach(child => {
                if (child instanceof Element) element.appendChild(child);
            });
        }

        return element;
    }

    // ── SVG Sanitization ──

    /**
     * Parse and sanitize SVG content safely
     * @param {string} svgContent - Raw SVG content
     * @returns {SVGElement|null} Sanitized SVG element or null
     */
    function sanitizeSvgContent(svgContent) {
        if (!svgContent || typeof svgContent !== 'string') return null;

        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgContent, 'image/svg+xml');

            const parserError = doc.querySelector('parsererror');
            if (parserError) {
                Log.warn('[Security] Erreur parsing SVG:', parserError.textContent);
                return null;
            }

            const svgEl = doc.documentElement;
            if (!svgEl || svgEl.tagName.toLowerCase() !== 'svg') {
                Log.warn("[Security] Contenu SVG invalide: élément racine n'est pas SVG");
                return null;
            }

            // Remove dangerous elements
            const dangerousElements = ['script', 'foreignObject', "use[href^='data:']"];
            dangerousElements.forEach(selector => {
                const elements = svgEl.querySelectorAll(selector);
                elements.forEach(el => el.remove());
            });

            // Remove event handler attributes
            const allElements = svgEl.querySelectorAll('*');
            allElements.forEach(el => {
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.toLowerCase().startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                    if ((attr.name === 'href' || attr.name === 'xlink:href') &&
                        attr.value.toLowerCase().trim().startsWith('javascript:')) {
                        el.removeAttribute(attr.name);
                    }
                });
            });

            return svgEl;
        } catch (e) {
            Log.warn('[Security] Erreur sanitization SVG:', e.message);
            return null;
        }
    }

    // ── Number Validation ──

    /**
     * Validate that a value is a number within a given range
     * @param {*} value - Value to validate
     * @param {number} [min=-Infinity] - Minimum value
     * @param {number} [max=Infinity] - Maximum value
     * @returns {number|null} Validated number or null
     */
    function validateNumber$1(value, min = -Infinity, max = Infinity) {
        const num = Number(value);
        if (!Number.isFinite(num)) return null;
        if (num < min || num > max) return null;
        return num;
    }

    // ── Safe HTML Parsing ──

    /**
     * Parse HTML safely with tag whitelist
     * @param {string} html - HTML to parse
     * @param {string[]} [allowedTags] - Allowed tag names
     * @returns {DocumentFragment} Cleaned DOM fragment
     */
    function parseHtmlSafely(html, allowedTags = ['p', 'br', 'strong', 'em', 'span', 'a', 'ul', 'ol', 'li', 'b', 'i']) {
        const fragment = document.createDocumentFragment();
        if (!html || typeof html !== 'string') return fragment;

        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            const cleanNode = (node) => {
                if (node.nodeType === Node.TEXT_NODE) {
                    return document.createTextNode(node.textContent);
                }
                if (node.nodeType !== Node.ELEMENT_NODE) return null;

                const tagName = node.tagName.toLowerCase();
                if (!allowedTags.includes(tagName)) {
                    return document.createTextNode(node.textContent);
                }

                const cleanElement = document.createElement(tagName);

                if (tagName === 'a' && node.hasAttribute('href')) {
                    try {
                        const href = validateUrl$2(node.getAttribute('href'));
                        cleanElement.setAttribute('href', href);
                        cleanElement.setAttribute('rel', 'noopener noreferrer');
                        cleanElement.setAttribute('target', '_blank');
                    } catch (_) {
                        // Invalid URL — ignore the link
                    }
                }

                node.childNodes.forEach(child => {
                    const cleanChild = cleanNode(child);
                    if (cleanChild) cleanElement.appendChild(cleanChild);
                });

                return cleanElement;
            };

            doc.body.childNodes.forEach(child => {
                const cleanChild = cleanNode(child);
                if (cleanChild) fragment.appendChild(cleanChild);
            });
        } catch (e) {
            Log.warn('[Security] Erreur parsing HTML sécurisé:', e.message);
        }

        return fragment;
    }

    // ── Alias for backward compatibility ──

    /**
     * Sanitize HTML content and inject into a DOM element safely.
     * @param {Element} element - Target DOM element
     * @param {string} html - HTML string to sanitize
     * @param {Object} [options] - Options
     * @param {boolean} [options.stripAll=false] - Strip all HTML, keep text only
     * @param {string[]} [options.allowedTags] - Whitelist of allowed tags
     * @returns {Element|null} The element for chaining, or null if invalid
     */
    function sanitizeHTML(element, html, options = {}) {
        if (!element || typeof element.appendChild !== 'function') return null;

        if (html == null) {
            element.innerHTML = '';
            return element;
        }

        const str = typeof html === 'string' ? html : String(html);

        // SECURITY: 'trusted' option removed — all content is now sanitized.
        // Use parseHtmlSafely with a broad allowedTags list if you need rich HTML.
        if (options.trusted) {
            Log.warn('[GeoLeaf.Security] sanitizeHTML({ trusted: true }) is deprecated and ignored. All content is now sanitized.');
        }

        if (options.stripAll) {
            element.textContent = stripHtml(str);
            return element;
        }

        const allowedTags = options.allowedTags || ['p', 'br', 'strong', 'em', 'span', 'a', 'ul', 'ol', 'li', 'b', 'i'];
        const fragment = parseHtmlSafely(str, allowedTags);
        element.innerHTML = '';
        element.appendChild(fragment);
        return element;
    }

    // ── Aggregate export (facade) ──

    const Security = {
        escapeHtml,
        escapeAttribute,
        validateUrl: validateUrl$2,
        validateCoordinates: validateCoordinates$2,
        sanitizePoiProperties,
        containsDangerousHtml,
        stripHtml,
        createSafeElement,
        sanitizeSvgContent,
        validateNumber: validateNumber$1,
        parseHtmlSafely,
        sanitizeHTML
    };

    // ── Backward compatibility moved to globals.js ──

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const _g$I = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};


    /**
     * CSRF Token Manager
     */
    const CSRFToken = {
        /** @private */
        _token: null,
        /** @private */
        _tokenExpiry: null,
        /** @private */
        _tokenDuration: 3600000, // 1 hour
        /** @private interval handle */
        _refreshIntervalId: null,

        /**
         * Initialize CSRF protection — generates initial token and starts auto-refresh.
         */
        init() {
            try {
                this._token = this._generateToken();
                this._tokenExpiry = Date.now() + this._tokenDuration;
                this._startAutoRefresh();
                Log.info('[CSRF] Token initialized');
            } catch (e) {
                Log.error('[CSRF] Init failed — crypto.getRandomValues unavailable:', e.message);
                this._token = null;
            }
        },

        /**
         * Generate a cryptographically secure token
         * @private
         * @returns {string}
         * @throws {Error} When crypto.getRandomValues is unavailable (insecure environment)
         */
        _generateToken() {
            if (_g$I.crypto && _g$I.crypto.getRandomValues) {
                const array = new Uint8Array(32);
                _g$I.crypto.getRandomValues(array);
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }
            // 8.1.2 Phase 8: Math.random() fallback removed — insecure for CSRF tokens.
            // Environments without crypto.getRandomValues cannot generate safe CSRF tokens.
            Log.error('[CSRF] crypto.getRandomValues not available — CSRF protection disabled');
            throw new Error('[CSRF] Secure random number generation not available');
        },

        /**
         * Get current CSRF token (auto-refreshes if expired)
         * @returns {string|null} token or null if crypto unavailable
         */
        getToken() {
            if (!this._token || Date.now() >= this._tokenExpiry) {
                Log.info('[CSRF] Token expired, generating new one');
                try {
                    this._token = this._generateToken();
                    this._tokenExpiry = Date.now() + this._tokenDuration;
                } catch (e) {
                    Log.error('[CSRF] Token generation failed:', e.message);
                    this._token = null;
                }
            }
            return this._token;
        },

        /**
         * Validate a token
         * @param {string} token
         * @returns {boolean}
         */
        validateToken(token) {
            if (!token || typeof token !== 'string') return false;
            if (token === this._token && Date.now() < this._tokenExpiry) return true;
            Log.warn('[CSRF] Token validation failed');
            return false;
        },

        /**
         * Add CSRF token to form data or plain object
         * @param {FormData|Object} data
         * @returns {FormData|Object}
         */
        addTokenToData(data) {
            const token = this.getToken();
            if (data instanceof FormData) {
                data.append('csrf_token', token);
            } else if (typeof data === 'object' && data !== null) {
                data.csrf_token = token;
            }
            return data;
        },

        /**
         * Add CSRF token as X-CSRF-Token header to fetch options
         * @param {Object} options
         * @returns {Object}
         */
        addTokenToHeaders(options = {}) {
            const token = this.getToken();
            if (!options.headers) options.headers = {};
            options.headers['X-CSRF-Token'] = token;
            return options;
        },

        /**
         * Create a hidden input field with CSRF token
         * @returns {HTMLInputElement}
         */
        createTokenInput() {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'csrf_token';
            input.value = this.getToken();
            input.className = 'csrf-token-input';
            return input;
        },

        /**
         * Add CSRF token input to a form
         * @param {HTMLFormElement} form
         */
        addTokenToForm(form) {
            if (!form || !(form instanceof HTMLFormElement)) {
                Log.error('[CSRF] Invalid form element');
                return;
            }
            const existingInput = form.querySelector('input[name="csrf_token"]');
            if (existingInput) {
                existingInput.value = this.getToken();
                return;
            }
            form.appendChild(this.createTokenInput());
        },

        /**
         * Validate CSRF token from form submission data
         * @param {FormData|Object} data
         * @returns {boolean}
         */
        validateFormToken(data) {
            let token;
            if (data instanceof FormData) {
                token = data.get('csrf_token');
            } else if (typeof data === 'object' && data !== null) {
                token = data.csrf_token;
            }
            return this.validateToken(token);
        },

        /**
         * Set a SameSite secure cookie
         * @param {string} cookieName
         * @param {string} value
         * @param {Object} [options]
         */
        setSecureCookie(cookieName, value, options = {}) {
            const {
                maxAge = 3600,
                path = '/',
                sameSite = 'Strict',
                secure = true
            } = options;

            let cookie = `${encodeURIComponent(cookieName)}=${encodeURIComponent(value)}`;
            cookie += `; Max-Age=${maxAge}`;
            cookie += `; Path=${path}`;
            cookie += `; SameSite=${sameSite}`;

            if (secure && _g$I.location && _g$I.location.protocol === 'https:') {
                cookie += '; Secure';
            }

            document.cookie = cookie;
            Log.info(`[CSRF] Secure cookie set: ${cookieName}`);
        },

        /**
         * Auto-refresh token before expiry
         * @private
         */
        _startAutoRefresh() {
            const refreshInterval = this._tokenDuration - (5 * 60 * 1000);
            this._refreshIntervalId = setInterval(() => {
                Log.info('[CSRF] Auto-refreshing token');
                this._token = this._generateToken();
                this._tokenExpiry = Date.now() + this._tokenDuration;

                if (typeof CustomEvent !== 'undefined') {
                    const event = new CustomEvent('geoleaf:csrf:refreshed', {
                        detail: { token: this._token }
                    });
                    document.dispatchEvent(event);
                }
            }, refreshInterval);
        },

        /**
         * Stoppe l'auto-refresh et nettoie le token.
         */
        destroy() {
            if (this._refreshIntervalId !== null) {
                clearInterval(this._refreshIntervalId);
                this._refreshIntervalId = null;
            }
            this._token = null;
            this._tokenExpiry = null;
            Log.debug('[CSRF] Destroyed');
        },

        /**
         * Force new token generation (call after sensitive operations)
         */
        rotateToken() {
            Log.info('[CSRF] Rotating token');
            this._token = this._generateToken();
            this._tokenExpiry = Date.now() + this._tokenDuration;

            if (typeof CustomEvent !== 'undefined') {
                const event = new CustomEvent('geoleaf:csrf:rotated', {
                    detail: { token: this._token }
                });
                document.dispatchEvent(event);
            }
        },

        /**
         * Get token info (debugging only)
         * @returns {Object}
         */
        getTokenInfo() {
            return {
                hasToken: !!this._token,
                expiresIn: this._tokenExpiry ? Math.max(0, this._tokenExpiry - Date.now()) : 0,
                isValid: this._token && Date.now() < this._tokenExpiry
            };
        }
    };

    // ── Backward compatibility moved to globals.js ──

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /**
     * Logger unifié
     */

    /**
     * Module Config.Storage
     *
     * Responsabilités :
     * - Stockage et gestion de la configuration consolidée
     * - API get/set avec chemins "a.b.c"
     * - Fusion profonde (deep merge)
     * - Helpers de navigation dans l'arbre de config
     */
    const StorageModule = {
        /**
         * Configuration interne (référence partagée)
         * @type {Object}
         * @private
         */
        _config: null,

        /**
         * Initialise le module avec une référence à la config.
         *
         * @param {Object} config - Référence à l'objet de configuration global
         */
        init(config) {
            this._config = config;
        },

        /**
         * Retourne la configuration complète (objet).
         *
         * @returns {Object}
         */
        getAll() {
            return this._config || {};
        },

        /**
         * Récupère une valeur via un chemin de type "map.center" ou "basemaps.street.url".
         *
         * @param {string} path - Chemin avec des points.
         * @param {*} [defaultValue] - Valeur renvoyée si le chemin n'existe pas.
         * @returns {*}
         */
        get(path, defaultValue) {
            if (!this._config || !path || typeof path !== "string") {
                return typeof defaultValue === "undefined" ? undefined : defaultValue;
            }
            // Phase 4 dedup: delegate to getValueByPath
            const result = this.getValueByPath(this._config, path);
            return result === undefined
                ? (typeof defaultValue === "undefined" ? undefined : defaultValue)
                : result;
        },

        /**
         * Définit une valeur via un chemin de type "map.center" ou "basemaps.street.url".
         * Crée les objets intermédiaires si nécessaire.
         *
         * @param {string} path
         * @param {*} value
         */
        set(path, value) {
            if (!this._config) {
                Log.warn("[GeoLeaf.Config.Storage] Configuration non initialisée.");
                return;
            }

            if (!path || typeof path !== "string") {
                Log.warn("[GeoLeaf.Config.Storage] set() requiert un chemin string.");
                return;
            }

            const segments = path.split(".");
            let current = this._config;

            for (let i = 0; i < segments.length; i++) {
                const key = segments[i];

                if (i === segments.length - 1) {
                    current[key] = value;
                } else {
                    if (
                        !Object.prototype.hasOwnProperty.call(current, key) ||
                        typeof current[key] !== "object" ||
                        current[key] === null
                    ) {
                        current[key] = {};
                    }
                    current = current[key];
                }
            }
        },

        /**
         * Retourne une section de configuration (ex : "basemaps", "map").
         *
         * @param {string} sectionName
         * @param {Object} [defaultValue]
         * @returns {Object|*}
         */
        getSection(sectionName, defaultValue) {
            if (!sectionName) {
                return typeof defaultValue === "undefined" ? undefined : defaultValue;
            }
            const value = this.get(sectionName);
            if (typeof value === "undefined") {
                return typeof defaultValue === "undefined" ? undefined : defaultValue;
            }
            return value;
        },

        /**
         * Fusion profonde (deep merge) simple pour objets JSON.
         *
         * @param {Object} target
         * @param {Object} source
         * @returns {Object}
         */
        deepMerge(target, source) {
            const output = Object.assign({}, target || {});
            if (!source || typeof source !== "object") {
                return output;
            }

            Object.keys(source).forEach((key) => {
                const srcVal = source[key];
                const tgtVal = output[key];

                if (
                    srcVal &&
                    typeof srcVal === "object" &&
                    !Array.isArray(srcVal) &&
                    tgtVal &&
                    typeof tgtVal === "object" &&
                    !Array.isArray(tgtVal)
                ) {
                    output[key] = this.deepMerge(tgtVal, srcVal);
                } else {
                    output[key] = srcVal;
                }
            });

            return output;
        },

        /**
         * Lecture d'une valeur via un chemin "a.b.c".
         *
         * @param {Object} source
         * @param {string} path
         * @returns {*}
         */
        getValueByPath(source, path) {
            if (!source || !path) return undefined;
            const parts = path.split(".");
            let current = source;

            for (let i = 0; i < parts.length; i += 1) {
                if (current == null) {
                    return undefined;
                }
                current = current[parts[i]];
            }

            return current;
        },

        /**
         * Écriture d'une valeur via un chemin "a.b.c".
         * Crée les sous-objets intermédiaires si nécessaire.
         *
         * @param {Object} target
         * @param {string} path
         * @param {*} value
         */
        setValueByPath(target, path, value) {
            if (!target || !path) return;
            const parts = path.split(".");
            let current = target;

            for (let i = 0; i < parts.length - 1; i += 1) {
                const key = parts[i];
                if (
                    !Object.prototype.hasOwnProperty.call(current, key) ||
                    current[key] == null
                ) {
                    current[key] = {};
                }
                current = current[key];
            }

            current[parts[parts.length - 1]] = value;
        }
    };

    // Exposer le module
    const StorageHelper = StorageModule;

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    // Perf 6.3.5: Cache the Security module reference — resolved lazily, avoids re-lookup per fetch
    let _cachedSecurity = null;
    function _getSecurity() {
        if (_cachedSecurity !== null) return _cachedSecurity;
        const sec = Security || null;
        if (sec) _cachedSecurity = sec;
        return sec;
    }


    /**
     * Logger unifié
     */

    /**
     * Module Config.Loader
     *
     * Responsabilités :
     * - Chargement HTTP via fetch() avec validation CSRF/XSS
     * - Validation Content-Type stricte
     * - Gestion des headers personnalisés
     * - Helper générique _fetchJson()
     */
    const LoaderModule = {
        /**
         * Charge une configuration depuis une URL JSON et retourne l'objet.
         *
         * @param {string} url - URL du fichier JSON
         * @param {Object} [options] - Options de chargement
         * @param {Object} [options.headers] - Headers HTTP personnalisés (ex: CSRF token)
         * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type
         * @returns {Promise<Object>}
         * @example
         * Loader.loadUrl('/api/config.json', {
         *     headers: { 'X-CSRF-Token': '...' },
         *     strictContentType: true
         * })
         */
        loadUrl(url, options = {}) {
            if (!url) {
                Log.warn("[GeoLeaf.Config.Loader] URL JSON manquante dans loadUrl().");
                return Promise.resolve({});
            }

            const { headers = {}, strictContentType = true } = options;

            // Validation de l'URL avec le module Security (Perf 6.3.5: lazy-cached)
            const Security = _getSecurity();

            // Pour les URLs relatives (commençant par ./ ou ../ ou /), on les laisse passer
            const isRelative = /^\.{0,2}\//.test(url) || /^\/[^/]/.test(url);

            if (!isRelative) {
                // URL absolue : validation stricte avec Security.validateUrl
                if (Security && typeof Security.validateUrl === "function") {
                    try {
                        const validation = Security.validateUrl(url);
                        if (validation && typeof validation === 'object') {
                            if (!validation.valid) {
                                throw new Error(validation.error || 'URL validation failed');
                            }
                            url = validation.url || url;
                        } else if (typeof validation === 'string') {
                            url = validation;
                        }
                    } catch (e) {
                        const errMsg = "[GeoLeaf.Config.Loader] " + e.message;
                        Log.error(errMsg);
                        return Promise.reject(new Error(errMsg));
                    }
                } else {
                    // Fallback : vérification basique si Security pas disponible
                    if (!/^https?:\/\//i.test(url)) {
                        const errMsg =
                            "[GeoLeaf.Config.Loader] URL doit être relative ou commencer par http:// ou https://";
                        Log.error(errMsg);
                        return Promise.reject(new Error(errMsg));
                    }
                }
            }

            // Configuration fetch avec headers personnalisés
            const fetchOptions = {
                method: "GET",
                headers: {
                    Accept: "application/json",
                    ...headers
                }
            };

            return fetch(url, fetchOptions)
                .then((response) => {
                    if (!response.ok) {
                        throw new Error("HTTP " + response.status + " pour " + url);
                    }

                    // Validation Content-Type stricte
                    const contentType = response.headers.get("content-type");
                    if (strictContentType) {
                        if (!contentType || !contentType.includes("application/json")) {
                            throw new Error(
                                "[GeoLeaf.Config.Loader] Content-Type invalide: attendu 'application/json', reçu '" +
                                (contentType || "null") +
                                "'. Cela peut indiquer une attaque XSS ou un serveur mal configuré."
                            );
                        }
                    } else if (contentType && !contentType.includes("application/json")) {
                        Log.warn("[GeoLeaf.Config.Loader] Content-Type inattendu:", contentType);
                    }

                    // Security: Wrap response.json() to handle parse errors
                    return response.json().catch((parseErr) => {
                        const errMsg = "[GeoLeaf.Config.Loader] Erreur de parsing JSON pour " + url + ": " + parseErr.message;
                        Log.error(errMsg);
                        throw new Error(errMsg);
                    });
                })
                .then((jsonCfg) => {
                    if (typeof jsonCfg !== "object" || jsonCfg === null) {
                        throw new Error("Le JSON de configuration n'est pas un objet valide.");
                    }

                    return jsonCfg;
                })
                .catch((err) => {
                    Log.error("[GeoLeaf.Config.Loader] Erreur lors du chargement JSON :", err);
                    throw err;
                });
        },

        /**
         * Helper interne pour charger un JSON sans le fusionner dans la configuration.
         *
         * @param {string} url
         * @param {Object} [options]
         * @param {Object} [options.headers]
         * @param {boolean} [options.strictContentType=true]
         * @returns {Promise<Object|null>}
         */
        fetchJson(url, options = {}) {
            if (!url) {
                Log.warn("[GeoLeaf.Config.Loader] fetchJson() appelé sans URL.");
                return Promise.resolve(null);
            }

            const { headers = {}, strictContentType = true } = options;

            // Perf 6.3.5: lazy-cached Security module reference
            const Security = _getSecurity();

            const isRelative =
                /^\.{0,2}\//.test(url) || /^\/[^/]/.test(url);

            if (!isRelative) {
                if (Security && typeof Security.validateUrl === "function") {
                    try {
                        const validation = Security.validateUrl(url);
                        if (validation && typeof validation === 'object') {
                            if (!validation.valid) {
                                throw new Error(validation.error || 'URL validation failed');
                            }
                            url = validation.url || url;
                        } else if (typeof validation === 'string') {
                            url = validation;
                        }
                    } catch (e) {
                        const errMsg =
                            "[GeoLeaf.Config.Loader] " + e.message;
                        Log.error(errMsg);
                        return Promise.reject(new Error(errMsg));
                    }
                } else {
                    if (!/^https?:\/\//i.test(url)) {
                        const errMsg =
                            "[GeoLeaf.Config.Loader] URL doit être relative ou commencer par http:// ou https://";
                        Log.error(errMsg);
                        return Promise.reject(new Error(errMsg));
                    }
                }
            }

            const fetchOptions = {
                method: "GET",
                headers: {
                    Accept: "application/json",
                    ...headers
                }
            };

            return fetch(url, fetchOptions)
                .then((response) => {
                    if (!response.ok) {
                        throw new Error("HTTP " + response.status + " pour " + url);
                    }

                    const contentType = response.headers.get("content-type");
                    if (strictContentType) {
                        if (!contentType || !contentType.includes("application/json")) {
                            throw new Error(
                                "[GeoLeaf.Config.Loader] Content-Type invalide dans fetchJson: attendu 'application/json', reçu '" +
                                (contentType || "null") +
                                "'."
                            );
                        }
                    } else if (contentType && !contentType.includes("application/json")) {
                        Log.warn("[GeoLeaf.Config.Loader] fetchJson() Content-Type inattendu:", contentType);
                    }

                    // Security: Wrap response.json() to handle parse errors
                    return response.json().catch((parseErr) => {
                        const errMsg = "[GeoLeaf.Config.Loader] Erreur de parsing JSON dans fetchJson pour " + url + ": " + parseErr.message;
                        Log.error(errMsg);
                        throw new Error(errMsg);
                    });
                })
                .then((json) => {
                    if (typeof json !== "object" || json === null) {
                        Log.warn(
                            "[GeoLeaf.Config.Loader] fetchJson() a reçu un JSON non-objet pour l'URL :",
                            url
                        );
                    }
                    return json;
                })
                .catch((err) => {
                    Log.error(
                        "[GeoLeaf.Config.Loader] Erreur fetchJson() pour " + url + " :",
                        err
                    );
                    throw err; // Re-throw pour que l'appelant puisse gérer l'erreur
                });
        }
    };

    // Exposer le module
    const ProfileLoader$1 = LoaderModule;

    /**
     * Logger unifié
     */

    /**
     * Module Config.Taxonomy
     *
     * Responsabilités :
     * - Chargement et gestion de la taxonomie (catégories/sous-catégories)
     * - Lecture des catégories depuis mapping.json (ancienne taxonomie)
     * - Lecture des catégories depuis profile.json (nouvelle taxonomie)
     * - API de consultation : getCategories(), getCategory(), getSubcategory()
     */
    const TaxonomyModule = {
        /**
         * Configuration interne (référence partagée)
         * @type {Object}
         * @private
         */
        _config: null,

        /**
         * Initialise le module avec une référence à la config.
         *
         * @param {Object} config - Référence à l'objet de configuration global
         */
        init(config) {
            this._config = config;
        },

        /**
         * Charge un fichier de taxonomie (mapping catégories / sous-catégories)
         * et le fusionne dans la configuration existante.
         *
         * @param {string} [url] - URL du fichier de mapping (depuis le profil)
         * @param {Object} [options]
         * @param {Object} [options.headers]
         * @param {boolean} [options.strictContentType=true]
         * @returns {Promise<Object>} - Objet categories consolidé
         */
        loadTaxonomy(url = null, options = {}) {
            const Loader = ProfileLoader$1;
            if (!Loader) {
                Log.error("[GeoLeaf.Config.Taxonomy] Module Loader non disponible.");
                return Promise.reject(new Error("Loader module not available"));
            }

            if (!url) {
                Log.info("[GeoLeaf.Config.Taxonomy] Aucune URL de mapping fournie — skip.");
                return Promise.resolve({});
            }

            return Loader.loadUrl(url, options)
                .then((cfg) => {
                    const hasCategories =
                        cfg &&
                        typeof cfg === "object" &&
                        cfg.categories &&
                        typeof cfg.categories === "object" &&
                        !Array.isArray(cfg.categories);

                    if (!hasCategories) {
                        Log.warn(
                            "[GeoLeaf.Config.Taxonomy] Fichier de mapping catégories chargé mais " +
                            "aucune propriété 'categories' valide trouvée (attendu: { \"categories\": { ... } })."
                        );
                    } else {
                        // Fusionner dans la config
                        if (!this._config.categories || typeof this._config.categories !== "object") {
                            this._config.categories = {};
                        }
                        Object.assign(this._config.categories, cfg.categories);

                        Log.info(
                            "[GeoLeaf.Config.Taxonomy] Mapping catégories fusionné avec succès."
                        );
                    }

                    return this.getCategories();
                })
                .catch((err) => {
                    Log.error("[GeoLeaf.Config.Taxonomy] Erreur lors du chargement de la taxonomie :", err);
                    return {};
                });
        },

        /**
         * Retourne l'objet complet des catégories (mapping interne).
         *
         * @returns {Object} - { [categoryId]: { label, icon, colorFill, colorStroke, subcategories? } }
         */
        getCategories() {
            if (!this._config) return {};
            const cats = this._config.categories;
            return (cats && typeof cats === "object" && !Array.isArray(cats)) ? cats : {};
        },

        /**
         * Retourne une catégorie à partir de son identifiant.
         *
         * @param {string} categoryId
         * @returns {Object|undefined}
         */
        getCategory(categoryId) {
            if (!categoryId || typeof categoryId !== "string") {
                return undefined;
            }

            const cats = this.getCategories();
            if (!Object.prototype.hasOwnProperty.call(cats, categoryId)) {
                return undefined;
            }

            return cats[categoryId];
        },

        /**
         * Retourne une sous-catégorie à partir de son identifiant et de celui
         * de la catégorie parente.
         *
         * @param {string} categoryId
         * @param {string} subCategoryId
         * @returns {Object|undefined}
         */
        getSubcategory(categoryId, subCategoryId) {
            if (
                !categoryId || typeof categoryId !== "string" ||
                !subCategoryId || typeof subCategoryId !== "string"
            ) {
                return undefined;
            }

            const category = this.getCategory(categoryId);
            if (
                !category ||
                !category.subcategories ||
                typeof category.subcategories !== "object" ||
                Array.isArray(category.subcategories)
            ) {
                return undefined;
            }

            const subs = category.subcategories;
            if (!Object.prototype.hasOwnProperty.call(subs, subCategoryId)) {
                return undefined;
            }

            return subs[subCategoryId];
        }
    };

    // Exposer le module
    const TaxonomyManager = TaxonomyModule;

    /**
     * Logger unifié
     */

    /**
     * Module Config.Normalization
     *
     * Responsabilités :
     * - Normalisation structurelle des POI (mapping brut → format GeoLeaf)
     * - Application de mapping.json sur POI non normalisés
     * - Normalisation des avis (reviews) : ancien/nouveau format
     * - Validation de la structure POI : id/title/location
     */
    const NormalizationModule = {
        /**
         * Safe object assignment that prevents prototype pollution.
         * Blocks dangerous keys: __proto__, constructor, prototype
         * @param {Object} target
         * @param {Object} source
         * @returns {Object}
         * @private
         */
        _safeAssign(target, source) {
            const dangerousKeys = ['__proto__', 'constructor', 'prototype'];

            for (const key in source) {
                if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
                if (dangerousKeys.includes(key)) {
                    Log.warn('[GeoLeaf.Config.Normalization] Tentative de pollution de prototype bloquée', { key });
                    continue;
                }
                target[key] = source[key];
            }

            return target;
        },

        /**
         * Vérifie si un POI est déjà normalisé au format GeoLeaf :
         * {
         *   id: string,
         *   title: string,
         *   location: { lat: number, lng: number },
         *   attributes?: object
         * }
         *
         * @param {Object} poi
         * @returns {boolean}
         */
        isPoiStructNormalized(poi) {
            if (!poi || typeof poi !== "object") return false;

            if (typeof poi.id !== "string" || poi.id.trim() === "") {
                return false;
            }

            // Supporter les deux formats de label/titre
            const hasTitle = typeof poi.title === "string" && poi.title.trim() !== "";
            const hasLabel = typeof poi.label === "string" && poi.label.trim() !== "";
            if (!hasTitle && !hasLabel) {
                return false;
            }

            // Nouveau format : latlng = [lat, lng]
            if (Array.isArray(poi.latlng) && poi.latlng.length >= 2) {
                const lat = poi.latlng[0];
                const lng = poi.latlng[1];
                if (typeof lat === "number" && !Number.isNaN(lat) &&
                    typeof lng === "number" && !Number.isNaN(lng)) {
                    return true;
                }
            }

            // Ancien format : location.lat/lng
            if (poi.location && typeof poi.location === "object") {
                const lat = poi.location.lat;
                const lng = poi.location.lng;
                if (typeof lat === "number" && !Number.isNaN(lat) &&
                    typeof lng === "number" && !Number.isNaN(lng)) {
                    return true;
                }
            }

            return false;
        },

        /**
         * Applique un mapping brut → POI normalisé pour un POI donné.
         *
         * @param {Object} rawPoi
         * @param {Object} mappingDef  mappingConfig.mapping
         * @returns {Object|null}
         */
        mapRawPoiToNormalized(rawPoi, mappingDef) {
            if (!rawPoi || !mappingDef || typeof mappingDef !== "object") {
                return null;
            }

            const Storage = StorageHelper;
            if (!Storage) {
                Log.error("[GeoLeaf.Config.Normalization] Module Storage non disponible.");
                return null;
            }

            // Socle minimal conforme au cahier des charges POI
            const normalized = {
                id: "",
                title: "",
                location: { lat: 0, lng: 0 },
                attributes: {}
            };

            Object.keys(mappingDef).forEach((targetPath) => {
                const sourcePath = mappingDef[targetPath];
                if (!sourcePath) return;

                const value = Storage.getValueByPath(rawPoi, sourcePath);
                if (typeof value === "undefined") return;

                Storage.setValueByPath(normalized, targetPath, value);
            });

            if (
                !normalized.attributes ||
                typeof normalized.attributes !== "object" ||
                Array.isArray(normalized.attributes)
            ) {
                normalized.attributes = {};
            }

            return normalized;
        },

        /**
         * Normalise structurellement un tableau de POI en utilisant
         * éventuellement mapping.json du profil actif.
         *
         * Règles :
         *  - SANS mapping.json :
         *      → on renvoie les POI tels quels (comportement 100 % rétrocompatible).
         *  - AVEC mapping.json :
         *      → si le POI est déjà normalisé → on le garde tel quel ;
         *      → sinon, on applique le mapping ;
         *      → si après mapping le POI reste non normalisé → POI ignoré (warning).
         *
         * @param {Array} rawPoiArray
         * @param {Object|null} mappingConfig  mapping.json complet ou null
         * @returns {Array}
         */
        normalizePoiWithMapping(rawPoiArray, mappingConfig) {
            if (!Array.isArray(rawPoiArray)) {
                return [];
            }

            const hasMapping =
                mappingConfig &&
                typeof mappingConfig === "object" &&
                mappingConfig.mapping &&
                typeof mappingConfig.mapping === "object";

            // 🔁 CAS 1 — AUCUN mapping.json fourni :
            // on ne touche à rien, on renvoie les POI du profil tels quels.
            if (!hasMapping) {
                Log.debug(
                    "[GeoLeaf.Config.Normalization] Aucun mapping.json fourni ; " +
                    "les POI sont utilisés tels quels (aucune normalisation structurelle)."
                );
                return rawPoiArray;
            }

            // 🔁 CAS 2 — mapping.json présent : on applique vraiment la normalisation
            const mappingDef = mappingConfig.mapping;
            const result = [];

            rawPoiArray.forEach((rawPoi, index) => {
                // 1) Déjà normalisé → on garde
                if (this.isPoiStructNormalized(rawPoi)) {
                    result.push(rawPoi);
                    return;
                }

                // 2) Non normalisé + mapping → tentative de normalisation
                const normalized = this.mapRawPoiToNormalized(rawPoi, mappingDef);
                if (normalized && this.isPoiStructNormalized(normalized)) {
                    result.push(normalized);
                } else {
                    Log.warn(
                        "[GeoLeaf.Config.Normalization] POI non normalisé même après application du mapping ; POI ignoré.",
                        {
                            poiIndex: index,
                            poiId: rawPoi && rawPoi.id
                        }
                    );
                }
            });

            return result;
        },

        /**
         * Normalise le tableau de POI, notamment pour les avis (reviews).
         *
         * - Alimente systématiquement `attributes.reviews` si des avis sont présents.
         * - Supporte l'ancien format (tableau simple) et le nouveau format objet
         *   `{ rating, count, summary, recent[] }`.
         *
         * @param {Array} poiArray
         * @returns {Array}
         */
        normalizePoiArray(poiArray) {
            if (!Array.isArray(poiArray)) {
                return poiArray;
            }

            return poiArray.map((poi, index) => {
                if (!poi || typeof poi !== "object") {
                    return poi;
                }

                // Perf 6.3.6: Mutate in place — avoids 1 object copy per POI (~10k+ POIs).
                // _safeAssign({}, poi) had O(n) cost per POI; callers discard the original array.
                const normalized = poi;

                // Bloc attributes existant ou nouveau
                const baseAttributes =
                    normalized.attributes &&
                    typeof normalized.attributes === "object" &&
                    !Array.isArray(normalized.attributes)
                        ? normalized.attributes
                        : {};

                // Use null-prototype object to block prototype pollution (kept for security)
                const attributes = Object.assign(Object.create(null), baseAttributes);

                // Handle reviews - preserve full structure when it exists
                // 1) If attributes.reviews is already an object with recent array (new format), preserve it
                if (
                    attributes.reviews &&
                    typeof attributes.reviews === "object" &&
                    !Array.isArray(attributes.reviews) &&
                    Array.isArray(attributes.reviews.recent)
                ) {
                    // Keep the full reviews object: { rating, count, summary, recent: [...] }
                    // Just limit the recent array to 5
                    attributes.reviews = {
                        ...attributes.reviews,
                        recent: attributes.reviews.recent.slice(0, 5)
                    };
                }
                // 2) If poi.reviews is an object with recent array (new format at root), move to attributes
                else if (
                    normalized.reviews &&
                    typeof normalized.reviews === "object" &&
                    !Array.isArray(normalized.reviews) &&
                    Array.isArray(normalized.reviews.recent)
                ) {
                    attributes.reviews = {
                        ...normalized.reviews,
                        recent: normalized.reviews.recent.slice(0, 5)
                    };
                }
                // 3) Legacy: attributes.reviews is already a flat array
                else if (Array.isArray(attributes.reviews)) {
                    attributes.reviews = attributes.reviews.slice(0, 5);
                }
                // 4) Legacy: poi.reviews is a flat array at root
                else if (Array.isArray(normalized.reviews)) {
                    attributes.reviews = normalized.reviews.slice(0, 5);
                }
                // 5) Unexpected format
                else if (normalized.reviews !== undefined || attributes.reviews !== undefined) {
                    Log.warn("[GeoLeaf.Config.Normalization] Format de `reviews` inattendu pour le POI :", {
                        poiIndex: index,
                        poiId: normalized.id,
                        reviewsType: typeof normalized.reviews,
                        attributesReviewsType: typeof attributes.reviews
                    });
                    attributes.reviews = [];
                }
                // 6) No reviews at all
                else {
                    attributes.reviews = [];
                }

                normalized.attributes = attributes;

                return normalized;
            });
        }
    };

    // Exposer le module
    const ConfigNormalizer = NormalizationModule;

    /**
     * @fileoverview Chargeur de profil modulaire pour GeoLeaf
     * Gère le chargement modulaire des profils avec structure:
     * - profile.json (métadonnées)
     * - taxonomy.json (catégories/sous-catégories)
     * - themes.json (thèmes visuels)
     * - layers.json (index des couches)
     * - layers/{layerId}/{layerId}_config.json (config par couche)
     * @module config/profile-loader
     */



    /**
     * Module de chargement de profils modulaires
     * @namespace ProfileLoader
     */
    const ProfileLoader = {
        /**
         * Charge un profil avec structure modulaire
         * @param {Object} profile - Objet profile.json modulaire
         * @param {string} baseUrl - URL de base du profil
         * @param {string} profileId - ID du profil
         * @param {number} timestamp - Timestamp pour cache busting
         * @param {Object} fetchOptions - Options de fetch
         * @returns {Promise<Object>} Profil enrichi avec toutes les données chargées
         */
        async loadModularProfile(profile, baseUrl, profileId, timestamp = Date.now(), fetchOptions = {}) {
            const Loader = ProfileLoader$1;

            if (!Loader) {
                throw new Error("GeoLeaf._ConfigLoader non disponible");
            }

            Log.info(`[ProfileLoader] Chargement profil modulaire: ${profileId}`);

            try {
                // 1. Charger les ressources en parallèle
                const [taxonomyData, themesData, layersFileData] = await Promise.all([
                    this._loadTaxonomy(profile, baseUrl, timestamp, fetchOptions),
                    this._loadThemes(profile, baseUrl, timestamp, fetchOptions),
                    this._loadLayersFile(profile, baseUrl, timestamp, fetchOptions)
                ]);

                // 2. Déterminer la source des layers
                const layersSource = layersFileData || profile.layers || [];

                // 3. Charger les configurations individuelles des layers
                const layersConfigs = await this._loadLayerConfigs(
                    layersSource,
                    baseUrl,
                    timestamp,
                    fetchOptions
                );

                // 4. Construire le profil enrichi
                const enrichedProfile = this._buildEnrichedProfile({
                    profile,
                    baseUrl,
                    profileId,
                    taxonomy: taxonomyData,
                    themes: themesData,
                    layersSource,
                    layersConfigs
                });

                Log.info("[ProfileLoader] Profil modulaire chargé avec succès", {
                    profileId,
                    hasTaxonomy: !!enrichedProfile.taxonomy,
                    hasThemes: !!enrichedProfile.themes,
                    layersCount: enrichedProfile.layers ? enrichedProfile.layers.length : 0
                });

                return enrichedProfile;

            } catch (error) {
                Log.error("[ProfileLoader] Erreur chargement profil modulaire:", error);
                throw error;
            }
        },

        /**
         * Charge taxonomy.json si référencé ET si des features ont des catégories
         * @private
         */
        async _loadTaxonomy(profile, baseUrl, timestamp, fetchOptions) {
            const Loader = ProfileLoader$1;
            const taxonomyFile = profile.Files?.taxonomyFile || profile.taxonomyFile;

            if (!taxonomyFile && !profile.taxonomy) {
                return null;
            }

            if (taxonomyFile) {
                try {
                    const taxonomy = await Loader.fetchJson(
                        `${baseUrl}/${taxonomyFile}?t=${timestamp}`,
                        fetchOptions
                    );
                    Log.info("[ProfileLoader] Taxonomy.json chargé avec succès");
                    return taxonomy;
                } catch (err) {
                    Log.warn("[ProfileLoader] Erreur chargement taxonomy.json:", err);
                    return null;
                }
            }

            return profile.taxonomy || null;
        },

        /**
         * Charge themes.json si référencé
         * @private
         */
        async _loadThemes(profile, baseUrl, timestamp, fetchOptions) {
            const Loader = ProfileLoader$1;
            const themesFile = profile.Files?.themesFile || profile.themesFile;

            if (themesFile) {
                try {
                    const themes = await Loader.fetchJson(
                        `${baseUrl}/${themesFile}?t=${timestamp}`,
                        fetchOptions
                    );
                    return themes;
                } catch (err) {
                    Log.warn("[ProfileLoader] Erreur chargement themes.json:", err);
                    return null;
                }
            }

            return profile.themes || null;
        },

        /**
         * Charge layers.json si référencé
         * @private
         */
        async _loadLayersFile(profile, baseUrl, timestamp, fetchOptions) {
            const Loader = ProfileLoader$1;
            const layersFile = profile.Files?.layersFile;

            if (layersFile) {
                try {
                    const layers = await Loader.fetchJson(
                        `${baseUrl}/${layersFile}?t=${timestamp}`,
                        fetchOptions
                    );
                    return layers;
                } catch (err) {
                    Log.warn("[ProfileLoader] Erreur chargement layers.json:", err);
                    return null;
                }
            }

            return null;
        },

        /**
         * Charge les configurations individuelles des layers
         * @private
         */
        async _loadLayerConfigs(layersSource, baseUrl, timestamp, fetchOptions) {
            const Loader = ProfileLoader$1;

            if (!Array.isArray(layersSource) || layersSource.length === 0) {
                return [];
            }

            const promises = layersSource.map(async (layerRef) => {
                if (!layerRef.configFile) {
                    return {
                        id: layerRef.id,
                        config: null,
                        layerDirectory: null,
                        layerManagerId: layerRef.layerManagerId || null
                    };
                }

                const layerDirectory = layerRef.configFile.replace(/\/[^\/]+$/, '');

                try {
                    const layerConfig = await Loader.fetchJson(
                        `${baseUrl}/${layerRef.configFile}?t=${timestamp}`,
                        fetchOptions
                    );

                    return {
                        id: layerRef.id,
                        config: layerConfig,
                        layerDirectory: layerDirectory,
                        layerManagerId: layerRef.layerManagerId || null
                    };
                } catch (err) {
                    Log.error(`[ProfileLoader] Erreur chargement ${layerRef.configFile}:`, err);
                    return {
                        id: layerRef.id,
                        config: null,
                        layerDirectory: layerDirectory,
                        layerManagerId: layerRef.layerManagerId || null
                    };
                }
            });

            return Promise.all(promises);
        },

        /**
         * Construit le profil enrichi avec toutes les données chargées
         * @private
         */
        _buildEnrichedProfile(params) {
            const { profile, baseUrl, profileId, taxonomy, themes, layersSource, layersConfigs } = params;

            const enrichedProfile = { ...profile };

            // Ajouter le basePath pour résolution des chemins
            enrichedProfile.basePath = baseUrl;
            enrichedProfile._profileId = profileId;

            // Intégrer la taxonomie
            if (taxonomy) {
                enrichedProfile.taxonomy = taxonomy;
            }

            // Intégrer les thèmes
            if (themes) {
                enrichedProfile.themes = themes;
            }

            // Intégrer les configurations de couches
            if (layersConfigs && layersConfigs.length > 0) {
                enrichedProfile.layers = layersConfigs.map(layerData => {
                    if (layerData.config) {
                        // Ajouter le layerDirectory, profileId ET layerManagerId à la config
                        const normalized = {
                            ...layerData.config,
                            _layerDirectory: layerData.layerDirectory,
                            _profileId: profileId,
                            layerManagerId: layerData.layerManagerId || layerData.config.layerManagerId || 'geojson-default'
                        };

                        // Normaliser data.file → dataFile pour compatibilité GeoJSON loader
                        if (normalized.data && normalized.data.file && !normalized.dataFile) {
                            const dataDir = normalized.data.directory || 'data';
                            normalized.dataFile = `${dataDir}/${normalized.data.file}`;
                        }

                        return normalized;
                    }
                    // Fallback si erreur de chargement
                    const original = layersSource.find(l => l.id === layerData.id);
                    return original || { id: layerData.id, error: "Failed to load config" };
                });
            }

            return enrichedProfile;
        },

        /**
         * Détermine si un profil utilise la structure modulaire
         * @param {Object} profile - Objet profile.json
         * @returns {boolean} True si profil modulaire (v3.0+)
         */
        isModularProfile(profile) {
            if (!profile || typeof profile !== 'object') {
                return false;
            }

            // Détection modulaire: présence de Files ou version >= 3.0.0
            if (profile.Files && typeof profile.Files === 'object') {
                return true;
            }

            if (profile.version) {
                const versionMatch = profile.version.match(/^(\d+)\.(\d+)/);
                if (versionMatch) {
                    const major = parseInt(versionMatch[1], 10);
                    return major >= 3;
                }
            }

            return false;
        }
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /**
     * Logger unifié
     */

    /**
     * Module Config.Profile
     *
     * Responsabilités :
     * - Chargement des profils métier (tourism, etc.)
     * - Gestion des ressources de profil : profile.json, poi.json, routes.json, mapping.json
     * - API de consultation : getActiveProfile*()
     * - Événements DOM : geoleaf:profile:loaded
     */
    const ProfileModule = {
        /**
         * Configuration interne (référence partagée)
         * @type {Object}
         * @private
         */
        _config: null,

        /**
         * Profil actuellement actif (ID du profil).
         * @type {string|null}
         * @private
         */
        _activeProfileId: null,

        /**
         * Description du profil actif (contenu de profile.json).
         * @type {Object|null}
         * @private
         */
        _activeProfile: null,

        /**
         * Données rattachées au profil actif :
         * - poi.json normalisé
         * - routes.json
         * - mapping.json
         * @type {{poi: Array, routes: Array, mapping: Object|null}}
         * @private
         */
        _activeProfileData: {
            poi: [],
            routes: [],
            mapping: null
        },

        /**
         * Initialise le module avec une référence à la config.
         *
         * @param {Object} config - Référence à l'objet de configuration global
         */
        init(config) {
            this._config = config;
        },

        /**
         * Indique si l'usage de mapping.json pour normaliser les POI de profil est activé.
         *
         * 🔎 Cherche plusieurs noms possibles dans config.data pour rester robuste :
         *   - config.data.enableProfilePoiMapping (nom recommandé)
         *   - config.data.useProfilePoiMapping
         *   - config.data.useMapping (compatibilité éventuelle)
         *
         * @returns {boolean} true si le mapping doit être utilisé, false sinon.
         */
        isProfilePoiMappingEnabled() {
            const dataCfg = this._config && this._config.data;
            if (!dataCfg || typeof dataCfg !== "object") {
                return true; // par défaut : mapping actif
            }

            if (typeof dataCfg.enableProfilePoiMapping === "boolean") {
                return dataCfg.enableProfilePoiMapping;
            }
            if (typeof dataCfg.useProfilePoiMapping === "boolean") {
                return dataCfg.useProfilePoiMapping;
            }
            if (typeof dataCfg.useMapping === "boolean") {
                return dataCfg.useMapping;
            }

            return true;
        },

        /**
         * Charge les ressources liées au profil actif :
         * - profile.json
         * - poi.json
         * - mapping.json
         * - routes.json
         *
         * Utilise config.data.activeProfile et config.data.profilesBasePath.
         * Injecte aussi, pour compatibilité, les POI et routes dans this._config.poi / this._config.routes.
         * Injecte désormais la taxonomie (categories) depuis profile.json dans this._config.categories.
         *
         * @param {Object} [options]
         * @param {Object} [options.headers] - Headers HTTP optionnels.
         * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
         * @returns {Promise<Object>} Configuration consolidée incluant les données du profil.
         */
        loadActiveProfileResources(options = {}) {
            const dataCfg = this._config && this._config.data;
            if (!dataCfg || !dataCfg.activeProfile) {
                Log.info(
                    "[GeoLeaf.Config.Profile] Aucun profil actif défini dans config.data.activeProfile ; aucun chargement de profil effectué."
                );
                return Promise.resolve(this._config);
            }

            // Nouveau : mode layers-only (pas de poi.json / routes.json). Par défaut activé.
            const useLegacyProfileData =
                typeof dataCfg.useLegacyProfileData === "boolean"
                    ? dataCfg.useLegacyProfileData
                    : false;

            const profileId = dataCfg.activeProfile;
            const basePath = dataCfg.profilesBasePath || "data/profiles";
            const baseUrl = `${basePath}/${profileId}`;

            Log.info("[GeoLeaf.Config.Profile] Début du chargement du profil :", {
                profileId,
                baseUrl,
                configData: dataCfg
            });

            const fetchOptions = {
                headers: options.headers || {},
                strictContentType:
                    typeof options.strictContentType === "boolean"
                        ? options.strictContentType
                        : true
            };

            const Loader = ProfileLoader$1;
            const Normalization = ConfigNormalizer;

            if (!Loader || !Normalization) {
                Log.error("[GeoLeaf.Config.Profile] Modules Loader ou Normalization non disponibles.");
                return Promise.reject(new Error("Required modules not available"));
            }

            // 🔧 Nouveau : pilotage global de l'usage de mapping.json via config.data.*
            const isPoiMappingEnabled = this.isProfilePoiMappingEnabled();
            if (!isPoiMappingEnabled) {
                Log.info(
                    "[GeoLeaf.Config.Profile] Mapping de POI désactivé via configuration globale ; " +
                    "les POI du profil seront considérés comme déjà normalisés."
                );
            }

            Log.info("[GeoLeaf.Config.Profile] Chargement des ressources du profil actif :", {
                profileId,
                baseUrl
            });

            const timestamp = Date.now();

            // Branche legacy (maintien backward compat) : charge poi.json/routes.json
            if (useLegacyProfileData) {
                // Si le mapping est désactivé, on ne charge pas mapping.json (Promise.resolve(null))
                const mappingPromise = isPoiMappingEnabled
                    ? Loader.fetchJson(`${baseUrl}/mapping.json?t=${timestamp}`, fetchOptions)
                    : Promise.resolve(null);

                // routes.json est optionnel - on tente de le charger mais on tolère son absence
                const routesPromise = Loader.fetchJson(`${baseUrl}/routes.json?t=${timestamp}`, fetchOptions)
                    .catch(() => {
                        Log.info("[GeoLeaf.Config.Profile] routes.json non disponible ou invalide, utilisation d'un tableau vide.");
                        return [];
                    });

                return Promise.all([
                    Loader.fetchJson(`${baseUrl}/profile.json?t=${timestamp}`, fetchOptions),
                    Loader.fetchJson(`${baseUrl}/poi.json?t=${timestamp}`, fetchOptions),
                    mappingPromise,
                    routesPromise
                ])
                    .then(([profile, poi, mapping, routes]) => {
                        return this._finalizeProfileLoad({
                            profile,
                            poi,
                            routes,
                            mapping,
                            mappingEnabled: isPoiMappingEnabled
                        });
                    })
                    .catch((err) => {
                        Log.error(
                            "[GeoLeaf.Config.Profile] Erreur lors du chargement des ressources du profil actif :",
                            err
                        );
                        return this._config;
                    });
            }

            // Nouveau chemin : layers-only. On charge d'abord profile.json pour vérifier si mapping est requis.
            return Loader.fetchJson(`${baseUrl}/profile.json?t=${timestamp}`, fetchOptions)
                .then((profile) => {
                    // Utiliser la logique de détection du ProfileLoader pour cohérence
                    const isModular = ProfileLoader && ProfileLoader.isModularProfile(profile);

                    if (isModular) {
                        Log.info("[GeoLeaf.Config.Profile] Profil modulaire détecté - Chargement modulaire");
                        // Pour profil modulaire, retourner directement la config (pas besoin du .then suivant)
                        return this._loadModularProfile(profile, baseUrl, timestamp, fetchOptions);
                    }

                    // Version 2.0 (ancien comportement)
                    // Vérifier si au moins une couche a normalized:false (nécessite mapping)
                    let requiresMapping = false;
                    if (profile && Array.isArray(profile.layers)) {
                        requiresMapping = profile.layers.some(layer => layer.normalized === false);
                    }

                    // Charger mapping seulement si requis
                    const mappingPromise = isPoiMappingEnabled && requiresMapping
                        ? Loader.fetchJson(`${baseUrl}/mapping.json?t=${timestamp}`, fetchOptions).catch((err) => {
                              Log.error("[GeoLeaf.Config.Profile] mapping.json requis (normalized:false) mais non trouvé ou invalide.", err);
                              return null;
                          })
                        : Promise.resolve(null);

                    return Promise.all([Promise.resolve(profile), mappingPromise]);
                })
                .then((result) => {
                    // Si c'est un profil modulaire, on le retourne directement (pas un array)
                    if (result && !Array.isArray(result)) {
                        return result;
                    }

                    // Sinon c'est un array [profile, mapping] (v2.0)
                    const [profile, mapping] = result;
                    this._activeProfileId = profileId;
                    this._activeProfile = profile || null;

                    Log.info("[GeoLeaf.Config.Profile] Profil chargé (layers-only)", {
                        profileId,
                        profileLoaded: !!profile,
                        profileKeys: profile ? Object.keys(profile) : []
                    });

                    // Dans ce mode, on ne précharge pas les POI/Routes : ils seront lus via GeoJSON layers.
                    this._activeProfileData = {
                        poi: [],
                        routes: [],
                        mapping: mapping && typeof mapping === "object" ? mapping : null
                    };

                    // Taxonomie : reste depuis profile.json
                    if (
                        profile &&
                        typeof profile === "object" &&
                        profile.taxonomy &&
                        profile.taxonomy.categories &&
                        typeof profile.taxonomy.categories === "object" &&
                        !Array.isArray(profile.taxonomy.categories)
                    ) {
                        this._config.categories = profile.taxonomy.categories;
                        Log.info(
                            "[GeoLeaf.Config.Profile] Taxonomie des catégories chargée (layers-only).",
                            {
                                profileId,
                                categoriesCount: Object.keys(profile.taxonomy.categories || {}).length
                            }
                        );
                    }

                    // Stockage par profil
                    if (
                        !this._config.profiles ||
                        typeof this._config.profiles !== "object" ||
                        Array.isArray(this._config.profiles)
                    ) {
                        this._config.profiles = {};
                    }

                    this._config.profiles[profileId] = {
                        profile: this._activeProfile,
                        poi: this._activeProfileData.poi,
                        routes: this._activeProfileData.routes,
                        mapping: this._activeProfileData.mapping
                    };

                    // Événement pour les autres modules
                    this._fireProfileLoadedEvent(profileId, {
                        profile: this._activeProfile,
                        poi: this._activeProfileData.poi,
                        routes: this._activeProfileData.routes,
                        mapping: this._activeProfileData.mapping
                    });

                    return this._config;
                })
                .catch((err) => {
                    Log.error(
                        "[GeoLeaf.Config.Profile] Erreur lors du chargement des ressources du profil actif :",
                        err
                    );
                    return this._config;
                });
        },

        /**
         * Charge un profil modulaire avec structure modulaire
         * @param {Object} profile - Objet profile.json modulaire
         * @param {string} baseUrl - URL de base du profil
         * @param {number} timestamp - Timestamp pour cache busting
         * @param {Object} fetchOptions - Options de fetch
         * @returns {Promise<Object>} Config consolidée
         * @private
         */
        _loadModularProfile(profile, baseUrl, timestamp, fetchOptions) {
            const profileId = this._config.data.activeProfile;

            // Utiliser le ProfileLoader pour charger le profil
            if (!ProfileLoader) {
                Log.error("[GeoLeaf.Config.Profile] ProfileLoader non disponible");
                return Promise.reject(new Error("ProfileLoader non disponible"));
            }

            return ProfileLoader.loadModularProfile(
                profile,
                baseUrl,
                profileId,
                timestamp,
                fetchOptions
            ).then(enrichedProfile => {
                // Stocker le profil enrichi
                this._activeProfileId = profileId;
                this._activeProfile = enrichedProfile;

                Log.info("[GeoLeaf.Config.Profile] Profil modulaire chargé avec succès", {
                    profileId,
                    hasTaxonomy: !!enrichedProfile.taxonomy,
                    hasThemes: !!enrichedProfile.themes,
                    layersCount: enrichedProfile.layers ? enrichedProfile.layers.length : 0
                });

                this._activeProfileData = {
                    poi: [],
                    routes: [],
                    mapping: null
                };

                // Stocker la taxonomie dans config.categories pour compatibilité
                if (enrichedProfile.taxonomy && enrichedProfile.taxonomy.categories) {
                    this._config.categories = enrichedProfile.taxonomy.categories;
                    Log.info("[GeoLeaf.Config.Profile] Taxonomie chargée depuis profil modulaire", {
                        categoriesCount: Object.keys(enrichedProfile.taxonomy.categories || {}).length
                    });
                }

                // Copier toutes les propriétés du profil dans this._config
                Object.keys(enrichedProfile).forEach(key => {
                    if (key !== 'layers' && key !== 'taxonomy' && key !== 'themes') {
                        this._config[key] = enrichedProfile[key];
                    }
                });

                // Stocker par profil
                if (!this._config.profiles || typeof this._config.profiles !== "object") {
                    this._config.profiles = {};
                }

                this._config.profiles[profileId] = {
                    profile: this._activeProfile,
                    poi: [],
                    routes: [],
                    mapping: null
                };

                // Événement
                this._fireProfileLoadedEvent(profileId, {
                    profile: this._activeProfile,
                    poi: [],
                    routes: [],
                    mapping: null
                });

                return enrichedProfile;
            });
        },

        // Factorise la fin du chargement (branche legacy uniquement)
        _finalizeProfileLoad({ profile, poi, routes, mapping, mappingEnabled }) {
            const Normalization = ConfigNormalizer;

            this._activeProfile = profile || null;

            Log.info(
                "[GeoLeaf.Config.Profile] Profil chargé depuis profile.json :",
                {
                    profileId: this._activeProfileId,
                    profileLoaded: profile !== null && profile !== undefined,
                    profileKeys: profile ? Object.keys(profile) : []
                }
            );

            // Si le mapping est coupé au niveau global, on l'ignore même s'il existe
            const mappingForNormalization =
                mappingEnabled && mapping && typeof mapping === "object"
                    ? mapping
                    : null;

            // 1) Normalisation STRUCTURELLE des POI
            const structurallyNormalizedPoi = Array.isArray(poi)
                ? Normalization.normalizePoiWithMapping(poi, mappingForNormalization)
                : [];

            // 2) Normalisation métier des avis
            const normalizedPoi = Normalization.normalizePoiArray(structurallyNormalizedPoi);

            const safeMapping = mappingForNormalization;
            const safeRoutes = Array.isArray(routes) ? routes : [];

            this._activeProfileData = {
                poi: normalizedPoi,
                mapping: safeMapping,
                routes: safeRoutes
            };

            // Injection rétrocompatible dans la config globale
            if (normalizedPoi.length) {
                this._config.poi = normalizedPoi;
            }
            if (safeRoutes.length) {
                this._config.routes = safeRoutes;
            }

            // Taxonomie
            if (
                profile &&
                typeof profile === "object" &&
                profile.taxonomy &&
                profile.taxonomy.categories &&
                typeof profile.taxonomy.categories === "object" &&
                !Array.isArray(profile.taxonomy.categories)
            ) {
                this._config.categories = profile.taxonomy.categories;
                Log.info(
                    "[GeoLeaf.Config.Profile] Taxonomie des catégories chargée depuis le profil actif.",
                    {
                        profileId: this._activeProfileId,
                        categoriesCount: Object.keys(profile.taxonomy.categories || {}).length
                    }
                );
            }

            // Stockage par profil
            if (
                !this._config.profiles ||
                typeof this._config.profiles !== "object" ||
                Array.isArray(this._config.profiles)
            ) {
                this._config.profiles = {};
            }

            this._config.profiles[this._activeProfileId] = {
                profile: this._activeProfile,
                poi: this._activeProfileData.poi,
                routes: this._activeProfileData.routes,
                mapping: this._activeProfileData.mapping
            };

            // Événement
            this._fireProfileLoadedEvent(this._activeProfileId, {
                profile: this._activeProfile,
                poi: this._activeProfileData.poi,
                routes: this._activeProfileData.routes,
                mapping: this._activeProfileData.mapping
            });

            return this._config;
        },

        /**
         * Retourne l'identifiant du profil actuellement chargé (ou null).
         *
         * @returns {string|null}
         */
        getActiveProfileId() {
            return this._activeProfileId;
        },

        /**
         * Retourne l'objet profile.json du profil actif (ou null).
         *
         * @returns {Object|null}
         */
        getActiveProfile() {
            return this._activeProfile;
        },

        /**
         * Retourne le tableau de POI normalisés du profil actif.
         *
         * @returns {Array}
         */
        getActiveProfilePoi() {
            return (this._activeProfileData && Array.isArray(this._activeProfileData.poi))
                ? this._activeProfileData.poi
                : [];
        },

        /**
         * Retourne le tableau de routes du profil actif.
         *
         * @returns {Array}
         */
        getActiveProfileRoutes() {
            return (this._activeProfileData && Array.isArray(this._activeProfileData.routes))
                ? this._activeProfileData.routes
                : [];
        },

        /**
         * Retourne l'objet de mapping du profil actif (mapping.json).
         *
         * @returns {Object|null}
         */
        getActiveProfileMapping() {
            return (this._activeProfileData && this._activeProfileData.mapping)
                ? this._activeProfileData.mapping
                : null;
        },

        /**
         * Retourne la configuration des icônes depuis la taxonomie du profil actif.
         *
         * @returns {Object|null}
         */
        getIconsConfig() {
            return (this._activeProfile && this._activeProfile.taxonomy && this._activeProfile.taxonomy.icons)
                ? this._activeProfile.taxonomy.icons
                : null;
        },

        /**
         * Retourne les configurations de couches chargées depuis le profil actif modulaire
         *
         * @returns {Array|null}
         */
        getActiveProfileLayersConfig() {
            return (this._activeProfile && this._activeProfile.layers)
                ? this._activeProfile.layers
                : null;
        },

        /**
         * Émet un événement DOM "geoleaf:profile:loaded" lorsque le profil
         * actif et ses données associées sont chargés.
         *
         * @param {string} profileId
         * @param {Object} payload
         * @private
         */
        _fireProfileLoadedEvent(profileId, payload) {
            if (typeof document === "undefined" || typeof document.dispatchEvent !== "function") {
                return;
            }

            try {
                const event = new CustomEvent("geoleaf:profile:loaded", {
                    detail: {
                        profileId,
                        data: payload
                    }
                });
                document.dispatchEvent(event);
            } catch (e) {
                try {
                    const legacyEvent = document.createEvent("CustomEvent");
                    legacyEvent.initCustomEvent(
                        "geoleaf:profile:loaded",
                        false,
                        false,
                        {
                            profileId,
                            data: payload
                        }
                    );
                    document.dispatchEvent(legacyEvent);
                } catch (err) {
                    Log.warn(
                        "[GeoLeaf.Config.Profile] Impossible d'émettre l'événement geoleaf:profile:loaded."
                    );
                }
            }
        }
    };

    // Exposer le module
    const ProfileManager = ProfileModule;

    /*!
     * GeoLeaf Core – Config / Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    /**
     * Logger unifié (défini par geoleaf.logger-shim.js chargé en premier)
     */

    /**
     * Module GeoLeaf.Config
     *
     * Rôle :
     * - Centraliser la configuration de GeoLeaf (options carte, basemaps, thèmes, etc.)
     * - Charger une configuration depuis un objet JS ou un fichier JSON externe (fetch)
     * - Fournir des helpers pour lire / écrire via chemins de type "map.center" ou "basemaps.street.url"
     * - Gérer les profils métiers (tourism, etc.) et leurs ressources associées
     *
     * Architecture Phase 4 :
     * - config/loader.js       : Chargement HTTP, fetch, validation CSRF
     * - config/taxonomy.js     : Gestion taxonomie (catégories/sous-catégories)
     * - config/storage.js      : get/set/merge config, helpers paths
     * - config/normalization.js: Normalisation POI (mapping brut→GeoLeaf)
     * - config/profile.js      : Gestion profils métier (profile.json, poi.json, routes.json)
     */
    const Config = {};

    /* ------------------------------------------------------------------ */
    /*  Module-level state                                                 */
    /* ------------------------------------------------------------------ */

    /**
     * Configuration interne consolidée
     * @type {Object}
     * @private
     */
    Config._config = {};

    /**
     * Indicateur de chargement
     * @type {boolean}
     * @private
     */
    Config._isLoaded = false;

    /**
     * Garde d'idempotence pour _initSubModules() — reseté par _applyConfig() avant chaque rechargement
     * @type {boolean}
     * @private
     */
    Config._subModulesInitialized = false;

    /**
     * Source de la configuration ("inline", "url", null)
     * @type {string|null}
     * @private
     */
    Config._source = null;

    /**
     * Options internes
     * @type {{autoEvent: boolean}}
     * @private
     */
    Config._options = {
        /**
         * Si true, émet un événement DOM "geoleaf:config:loaded" après chargement.
         */
        autoEvent: true,
    };

    /* ------------------------------------------------------------------ */
    /*  Core methods                                                       */
    /* ------------------------------------------------------------------ */

    /**
     * Initialisation du module de configuration.
     *
     * @param {Object} [options]
     * @param {Object} [options.config] - Objet de configuration fourni directement.
     * @param {string} [options.url] - URL d'un fichier JSON à charger.
     * @param {Object} [options.headers] - Headers HTTP personnalisés pour loadUrl (ex: CSRF token).
     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
     * @param {boolean} [options.autoEvent] - Désactiver ou non l'événement auto.
     * @param {Function} [options.onLoaded] - Callback appelé une fois la config disponible (après mapping).
     *
     * @param {Object}  [options.mappingHeaders]
     *        Headers HTTP spécifiques pour le mapping (sinon ceux de headers sont réutilisés).
     * @param {boolean} [options.mappingStrictContentType]
     *        Si défini, surcharge strictContentType pour le mapping.
     *
     * @returns {Promise<Object>} - Promesse résolue avec l'objet de configuration.
     */
    Config.init = function (options = {}) {
        this._options = Object.assign({}, this._options, {
            autoEvent:
                typeof options.autoEvent === "boolean" ? options.autoEvent : this._options.autoEvent,
        });

        // Cas 1 : configuration inline (objet JS directement fourni)
        if (options.config && typeof options.config === "object") {
            this._applyConfig(options.config, "inline");

            // Si un profileId est spécifié, le mettre à jour après l'application de la config
            if (typeof options.profileId === "string" && options.profileId.length > 0) {
                if (!this._config.data) {
                    this._config.data = {};
                }
                this._config.data.activeProfile = options.profileId;
                Log.info("[GeoLeaf.Config] Profil actif changé vers:", options.profileId);
            }

            this._maybeFireLoadedEvent();

            if (typeof options.onLoaded === "function") {
                try {
                    options.onLoaded(this._config);
                } catch (e) {
                    Log.error("[GeoLeaf.Config] Erreur dans onLoaded (inline) :", e);
                }
            }

            return Promise.resolve(this._config);
        }

        // Cas 2 : chargement via URL JSON
        if (typeof options.url === "string" && options.url.length > 0) {
            const loadOptions = {
                headers: options.headers,
                strictContentType:
                    typeof options.strictContentType === "boolean" ? options.strictContentType : true,
            };

            const mappingUrl =
                typeof options.mappingUrl === "string" && options.mappingUrl.length > 0
                    ? options.mappingUrl
                    : null;

            const mappingOptions = {
                headers: options.mappingHeaders || options.headers,
                strictContentType:
                    typeof options.mappingStrictContentType === "boolean"
                        ? options.mappingStrictContentType
                        : loadOptions.strictContentType,
            };

            // 1) Charger la config principale
            return (
                this.loadUrl(options.url, loadOptions)
                    .then((cfg) => {
                        // Appliquer le profileId APRÈS le chargement de l'URL
                        if (typeof options.profileId === "string" && options.profileId.length > 0) {
                            if (!cfg.data) {
                                cfg.data = {};
                            }
                            cfg.data.activeProfile = options.profileId;
                            this._config.data.activeProfile = options.profileId;
                            Log.info("[GeoLeaf.Config] Profil actif changé vers:", options.profileId);
                        }
                        return cfg;
                    })
                    // 2) Charger le mapping catégories (si URL fournie)
                    .then((cfg) => {
                        if (!mappingUrl) {
                            return cfg;
                        }

                        return this.loadTaxonomy(mappingUrl, mappingOptions)
                            .then(() => cfg)
                            .catch((err) => {
                                Log.warn(
                                    "[GeoLeaf.Config] Échec du chargement du mapping catégories depuis " +
                                        mappingUrl +
                                        " (GeoLeaf continuera sans mapping dédié) :",
                                    err
                                );
                                return cfg;
                            });
                    })
                    // 3) Appeler onLoaded une fois TOUT chargé (config + mapping)
                    .then((cfg) => {
                        if (typeof options.onLoaded === "function") {
                            try {
                                options.onLoaded(cfg);
                            } catch (e) {
                                Log.error("[GeoLeaf.Config] Erreur dans onLoaded (url+mapping) :", e);
                            }
                        }
                        return cfg;
                    })
                    .catch((err) => {
                        Log.error("[GeoLeaf.Config] Erreur init() avec url :", err);

                        // Appeler onError si fourni
                        if (typeof options.onError === "function") {
                            try {
                                options.onError(err);
                            } catch (e) {
                                Log.error("[GeoLeaf.Config] Erreur dans onError :", e);
                            }
                        }

                        throw err; // Re-throw pour que la Promise soit rejetée
                    })
            );
        }

        // Cas 3 : Aucun paramètre fourni : on se contente d'un objet vide
        this._applyConfig({}, "inline");

        // Si un profileId est spécifié, le mettre à jour
        if (typeof options.profileId === "string" && options.profileId.length > 0) {
            if (!this._config.data) {
                this._config.data = {};
            }
            this._config.data.activeProfile = options.profileId;
            Log.info("[GeoLeaf.Config] Profil actif changé vers:", options.profileId);
        }

        this._maybeFireLoadedEvent();

        if (typeof options.onLoaded === "function") {
            try {
                options.onLoaded(this._config);
            } catch (e) {
                Log.error("[GeoLeaf.Config] Erreur dans onLoaded (vide) :", e);
            }
        }

        return Promise.resolve(this._config);
    };

    /**
     * Initialise les sous-modules avec la référence partagée à la config.
     *
     * @private
     */
    Config._initSubModules = function () {
        // B1 [PERF-01]: garde d'idempotence — évite double/triple init depuis les accesseurs defensifs
        if (this._subModulesInitialized) return;
        this._subModulesInitialized = true;

        const Storage = StorageHelper;
        const Taxonomy = TaxonomyManager;
        const Profile = ProfileManager;

        if (Storage && typeof Storage.init === "function") {
            Storage.init(this._config);
        }
        if (Taxonomy && typeof Taxonomy.init === "function") {
            Taxonomy.init(this._config);
        }
        if (Profile && typeof Profile.init === "function") {
            Profile.init(this._config);
        }
    };

    /**
     * Applique une configuration brute (remplace la précédente de manière fusionnée).
     *
     * @param {Object} cfg
     * @param {string} source
     * @private
     */
    Config._applyConfig = function (cfg, source) {
        if (typeof cfg !== "object" || cfg === null) {
            cfg = {};
        }

        // Validation de la structure du JSON
        this._validateConfig(cfg);

        // Fusion profonde avec la configuration existante
        const Storage = StorageHelper;
        if (Storage && typeof Storage.deepMerge === "function") {
            this._config = Storage.deepMerge(this._config, cfg);
        } else {
            this._config = Object.assign({}, this._config, cfg);
        }

        // Normalisation des POI (avis) après fusion
        const Normalization = ConfigNormalizer;
        if (Array.isArray(this._config.poi) && Normalization) {
            this._config.poi = Normalization.normalizePoiArray(this._config.poi);
        }

        this._isLoaded = true;
        this._source = source || "inline";

        // Initialiser les sous-modules maintenant que _config est chargé
        // Reset du flag pour permettre une ré-initialisation propre avec la nouvelle config
        this._subModulesInitialized = false;
        this._initSubModules();

        try {
            // On récupère le bloc "logging" soit depuis le cfg brut, soit depuis la configuration consolidée
            const loggingCfg =
                cfg && typeof cfg === "object" && cfg.logging
                    ? cfg.logging
                    : this._config && this._config.logging
                      ? this._config.logging
                      : null;

            // Prise en compte du flag global debug
            let level = loggingCfg && loggingCfg.level;
            let debugFlag = false;
            if (cfg && typeof cfg.debug !== "undefined") {
                debugFlag = !!cfg.debug;
            } else if (this._config && typeof this._config.debug !== "undefined") {
                debugFlag = !!this._config.debug;
            }

            if (!level) {
                level = debugFlag ? "debug" : "info";
            }

            if (level && Log && typeof Log.setLevel === "function") {
                Log.setLevel(level);
                Log.info(
                    "[GeoLeaf.Config] Niveau de log appliqué depuis la configuration :",
                    level,
                    "(debug:",
                    debugFlag,
                    ")"
                );
            }
        } catch (e) {
            Log.warn(
                "[GeoLeaf.Config] Impossible d'appliquer le niveau de log depuis la configuration :",
                e
            );
        }
    };

    /**
     * Indique si la configuration est considérée comme "chargée".
     *
     * @returns {boolean}
     */
    Config.isLoaded = function () {
        return this._isLoaded;
    };

    /**
     * Retourne la source de la config ("inline", "url", null).
     *
     * @returns {string|null}
     */
    Config.getSource = function () {
        return this._source;
    };

    /**
     * Envoie un événement DOM "geoleaf:config:loaded" si autoEvent = true.
     *
     * @private
     */
    Config._maybeFireLoadedEvent = function () {
        if (!this._options.autoEvent) {
            return;
        }

        if (typeof document === "undefined" || typeof document.dispatchEvent !== "function") {
            return;
        }

        try {
            const event = new CustomEvent("geoleaf:config:loaded", {
                detail: {
                    config: this._config,
                    source: this._source,
                },
            });
            document.dispatchEvent(event);
        } catch (e) {
            // En environnement très ancien, CustomEvent peut ne pas exister
            try {
                const legacyEvent = document.createEvent("CustomEvent");
                legacyEvent.initCustomEvent("geoleaf:config:loaded", false, false, {
                    config: this._config,
                    source: this._source,
                });
                document.dispatchEvent(legacyEvent);
            } catch (err) {
                // On ne bloque pas le fonctionnement si l'événement échoue
                Log.warn("[GeoLeaf.Config] Impossible d'émettre l'événement geoleaf:config:loaded.");
            }
        }
    };

    /*!
     * GeoLeaf Core – Core / Map Factory
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$H =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    /**
     * Construit les options Leaflet à partir des options GeoLeaf.
     * @param {object} options
     * @returns {object} leafletMapOptions
     */
    function buildLeafletOptions(options) {
        const center = Array.isArray(options.center) ? options.center : CONSTANTS.DEFAULT_CENTER;
        const zoom = Number.isFinite(options.zoom) ? options.zoom : CONSTANTS.DEFAULT_ZOOM;

        return Object.assign({}, options.mapOptions || {}, {
            center,
            zoom,
            zoomControl: options.mapOptions?.zoomControl ?? true,
            attributionControl: options.mapOptions?.attributionControl ?? false,
            zoomSnap: options.mapOptions?.zoomSnap ?? 1,
            zoomDelta: options.mapOptions?.zoomDelta ?? 1,
            wheelPxPerZoomLevel: options.mapOptions?.wheelPxPerZoomLevel ?? 120,
            preferCanvas: options.mapOptions?.preferCanvas ?? true,
        });
    }

    /**
     * Valide le DOM container et retourne l'élément cible.
     * @param {string} mapId
     * @returns {HTMLElement}
     * @throws {Error} si mapId manquant ou élément introuvable
     */
    function resolveMapContainer(mapId) {
        if (!mapId) throw new Error("L'option obligatoire 'mapId' est manquante.");
        const el = document.getElementById(mapId);
        if (!el) throw new Error(`Aucun élément DOM trouvé pour mapId='${mapId}'.`);
        return el;
    }

    /**
     * Crée une instance Leaflet Map.
     * @param {HTMLElement} targetEl
     * @param {object} leafletOptions
     * @returns {L.Map}
     */
    function createLeafletMap(targetEl, leafletOptions) {
        if (typeof L === "undefined") {
            throw new Error("Leaflet (L) est introuvable. Assurez-vous d'avoir chargé Leaflet 1.9.x.");
        }
        return L.map(targetEl, leafletOptions);
    }

    /**
     * Applique le thème via GeoLeaf.UI si disponible.
     * @param {string} theme
     */
    function applyThemeSafe(theme) {
        try {
            if (_g$H.GeoLeaf?.UI && typeof _g$H.GeoLeaf.UI.applyTheme === "function") {
                _g$H.GeoLeaf.UI.applyTheme(theme);
            }
        } catch (err) {
            Log.warn("[GeoLeaf.Core] Impossible d'appliquer le thème :", err);
        }
    }

    /**
     * Initialise Legend si activé dans la config.
     * @param {L.Map} mapInstance
     */
    function initLegendSafe(mapInstance) {
        const uiConfig = _g$H.GeoLeaf?.Config?.get ? _g$H.GeoLeaf.Config.get("ui") : null;
        const showLegend = uiConfig ? uiConfig.showLegend !== false : true;

        if (showLegend && typeof _g$H.GeoLeaf?.Legend?.init === "function") {
            try {
                _g$H.GeoLeaf.Legend.init(mapInstance, {
                    position: "bottomleft",
                    collapsible: true,
                    collapsed: false,
                });
            } catch (err) {
                Log.warn("[GeoLeaf.Core] Impossible d'initialiser Legend :", err);
            }
        }
    }

    /*!
     * GeoLeaf Core – Core / Theme
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    let _theme = "light";

    /**
     * Applique une classe de thème sur document.body.
     * @param {string} theme - "light" | "dark"
     */
    function _applyThemeToBody(theme) {
        const body = document.body;
        if (!body) {
            Log.warn("[GeoLeaf.Core] Impossible d'appliquer le thème : document.body introuvable.");
            return;
        }
        body.classList.remove("gl-theme-light", "gl-theme-dark");
        body.classList.add(theme === "dark" ? "gl-theme-dark" : "gl-theme-light");
    }

    /**
     * Définit et applique le thème actif.
     * @param {string} theme - "light" | "dark"
     */
    function setTheme(theme) {
        if (!theme || (theme !== "light" && theme !== "dark")) {
            Log.warn("[GeoLeaf.Core] setTheme() : thème invalide →", theme);
            return;
        }
        _theme = theme;
        _applyThemeToBody(theme);
    }

    /**
     * Retourne le thème actif.
     * @returns {string}
     */
    function getTheme() {
        return _theme;
    }

    /*!
     * GeoLeaf Core – Core / Index (barrel)
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$G =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    let _mapInstance = null;
    let _map$2 = null;

    // ---------------------------------------------------------
    // init
    // ---------------------------------------------------------
    function init$2(options = {}) {
        const context = "[GeoLeaf.Core]";
        try {
            if (_mapInstance) {
                Log.warn(`${context} Carte déjà initialisée. Recyclage de l'instance existante.`);
                return _mapInstance;
            }

            const targetEl = resolveMapContainer(options.mapId);
            const leafletOptions = buildLeafletOptions(options);
            const theme = options.theme || "light";

            _mapInstance = createLeafletMap(targetEl, leafletOptions);
            _map$2 = _mapInstance;

            applyThemeSafe(theme);
            initLegendSafe(_mapInstance);

            Log.info(`${context} Carte initialisée avec succès.`);
            return _mapInstance;
        } catch (err) {
            Log.error(`${context} ERREUR :`, err.message);

            if (typeof _g$G.GeoLeaf?.Core?.onError === "function") {
                try {
                    _g$G.GeoLeaf.Core.onError(err);
                } catch (cbErr) {
                    Log.error(`${context} Erreur dans Core.onError() :`, cbErr);
                }
            }

            _mapInstance = null;
            _map$2 = null;
            return null;
        }
    }

    // ---------------------------------------------------------
    // initMap (compat descendante)
    // ---------------------------------------------------------
    function initMap(a, b, c, d) {
        Log.warn("[GeoLeaf.Core] GeoLeaf.Core.initMap() est obsolète, utilisez GeoLeaf.Core.init().");

        if (_g$G.GeoLeaf?.Config?.get) {
            try {
                const mapCfg = _g$G.GeoLeaf.Config.get("map") || {};
                const uiCfg = _g$G.GeoLeaf.Config.get("ui") || {};
                return init$2({
                    center: mapCfg.center || CONSTANTS.DEFAULT_CENTER,
                    zoom: typeof mapCfg.zoom === "number" ? mapCfg.zoom : CONSTANTS.DEFAULT_ZOOM,
                    theme: uiCfg.theme || "light",
                    mapOptions: mapCfg.mapOptions || {},
                });
            } catch (err) {
                Log.error("[GeoLeaf.Core] initMap() n'a pas pu construire les options :", err);
            }
        }

        if (a && typeof a === "object" && !Array.isArray(a)) return init$2(a);

        if (typeof a === "string" && Array.isArray(b) && typeof c === "number") {
            return init$2({ center: b, zoom: c, theme: d || "light" });
        }

        Log.error("[GeoLeaf.Core] initMap() appelé avec une signature obsolète ou invalide.");
        return null;
    }

    // ---------------------------------------------------------
    // Accesseur
    // ---------------------------------------------------------
    function getMap() {
        return _map$2;
    }

    // ---------------------------------------------------------
    // API publique
    // ---------------------------------------------------------
    const Core = {
        init: init$2,
        initMap,
        getMap,
        setTheme,
        getTheme,
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    /**
     * Valide et nettoie une URL
     * @param {string} url - URL à valider
     * @param {Array<string>} allowedProtocols - Protocoles autorisés (défaut: http, https, mailto, tel)
     * @returns {string|null} - URL validée ou null si invalide
     */
    /**
     * Phase 4 dedup: delegates to Security.validateUrl when available.
     * Wraps the throwing API into a null-on-failure pattern.
     */
    function validateUrl$1(url, _allowedProtocols = ['http:', 'https:', 'mailto:', 'tel:']) {
        if (!url || typeof url !== 'string') return null;
        // Use canonical Security.validateUrl (static ESM import)
        try { return validateUrl$2(url); } catch { return null; }
    }

    /**
     * Merge profond d'objets
     * @param {Object} target - Objet cible
     * @param {Object} source - Objet source
     * @returns {Object} - Objet fusionné
     */
    function deepMerge(target, source) {
        if (!source || typeof source !== 'object') return target;
        if (!target || typeof target !== 'object') return source;

        const DANGEROUS_KEYS = ['__proto__', 'constructor', 'prototype'];
        const output = Object.assign({}, target);

        Object.keys(source).forEach(key => {
            // Prototype pollution protection
            if (DANGEROUS_KEYS.includes(key)) return;

            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                output[key] = deepMerge(target[key] || {}, source[key]);
            } else {
                output[key] = source[key];
            }
        });

        return output;
    }

    /**
     * Résout la carte Leaflet depuis les options ou GeoLeaf.Core
     * Utilitaire partagé pour éviter duplication dans POI/GeoJSON/Route
     * @param {L.Map|null} explicitMap - Carte passée explicitement
     * @returns {L.Map|null} - Instance de la carte ou null
     */
    /**
     * Phase 4 dedup: delegates to MapHelpers.ensureMap (duck-typing) when available
     */
    function ensureMap$1(explicitMap) {
        // Phase 4 dedup: delegates to MapHelpers.ensureMap (duck-typing) when available
        if (explicitMap) return explicitMap;
        if (Core && typeof Core.getMap === 'function') {
            return Core.getMap();
        }
        return null;
    }

    /**
     * Merge shallow d'options (pour les modules POI/GeoJSON/Route)
     * @param {Object} defaults - Options par défaut
     * @param {Object} override - Options fournies par l'utilisateur
     * @returns {Object} - Options fusionnées
     */
    function mergeOptions(defaults, override) {
        if (!override || typeof override !== 'object') return defaults;
        return Object.assign({}, defaults, override);
    }

    /**
     * Émet un événement personnalisé sur la carte Leaflet
     * Phase 4 dedup: thin wrapper — canonical is EventHelpers.dispatchMapEvent
     * @param {L.Map} map - Instance de la carte
     * @param {string} eventName - Nom de l'événement
     * @param {Object} payload - Données à transmettre
     */
    function fireMapEvent(map, eventName, payload) {
        if (!map || typeof map.fire !== 'function') return;
        try {
            map.fire(eventName, payload || {});
        } catch (err) {
            if (Log) Log.warn('[Utils] fireMapEvent error:', eventName, err);
        }
    }

    /**
     * Debounce — Phase 4 dedup: delegates to EventHelpers.debounce at runtime
     * (EventHelpers version supports `immediate` param)
     * @param {Function} func
     * @param {number} [wait=250]
     * @param {boolean} [immediate=false]
     * @returns {Function}
     */
    function debounce(func, wait = 250, immediate = false) {
        // EventHelpers loaded later via bundle-entry; at runtime it overwrites Utils.debounce
        // This ESM export is kept for any direct import usage
        let timeout;
        return function debounced(...args) {
            const context = this;
            const later = () => { timeout = null; if (!immediate) func.apply(context, args); };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    }

    /**
     * Throttle — Phase 4 dedup: delegates to EventHelpers.throttle at runtime
     * @param {Function} func
     * @param {number} [limit=100]
     * @returns {Function}
     */
    function throttle(func, limit = 100) {
        let lastRan;
        return function throttled(...args) {
            const context = this;
            const now = Date.now();
            if (!lastRan || (now - lastRan >= limit)) {
                func.apply(context, args);
                lastRan = now;
            }
        };
    }

    /**
     * Calcule la distance entre deux points géographiques (formule de Haversine)
     * @param {number} lat1 - Latitude du point 1 (degrés)
     * @param {number} lng1 - Longitude du point 1 (degrés)
     * @param {number} lat2 - Latitude du point 2 (degrés)
     * @param {number} lng2 - Longitude du point 2 (degrés)
     * @returns {number} - Distance en kilomètres
     *
     * @example
     * const distance = getDistance(48.8566, 2.3522, 51.5074, -0.1278);
     * console.log(`Distance: ${distance.toFixed(2)} km`);
     */
    function getDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Rayon de la Terre en kilomètres
        const dLat = (lat2 - lat1) * (Math.PI / 180);
        const dLng = (lng2 - lng1) * (Math.PI / 180);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    /**
     * Résout la valeur d'un champ depuis plusieurs chemins possibles dans un objet
     * Élimine les longues chaînes conditionnelles de résolution de champs
     * @param {Object} obj - Objet source
     * @param {...string} paths - Chemins à tester dans l'ordre
     * @returns {*} - Première valeur trouvée ou chaîne vide si rien trouvé
     *
     * @example
     * const title = resolveField(poi,
     *     'label', 'attributes.label', 'properties.label',
     *     'name', 'attributes.name', 'properties.name'
     * );
     */
    function resolveField$1(obj, ...paths) {
        if (!obj || typeof obj !== 'object') return '';

        for (const path of paths) {
            const keys = path.split('.');
            let value = obj;

            for (const key of keys) {
                if (value && typeof value === 'object' && key in value) {
                    value = value[key];
                } else {
                    value = null;
                    break;
                }
            }

            // Return any truthy value (string, object, array, number, etc.)
            if (value != null) {
                // For strings, ensure they're not empty
                if (typeof value === 'string') {
                    if (value.trim()) return value;
                } else {
                    // For non-strings (objects, arrays, numbers, booleans), return as-is
                    return value;
                }
            }
        }

        return '';
    }

    /**
     * Comparator for sorting config items by their `order` property.
     * Items without an order field are sorted last (default: 999).
     * Phase 4 dedup — single canonical comparator.
     *
     * @param {Object} a - First item (must have optional `order` number)
     * @param {Object} b - Second item
     * @param {number} [fallback=999] - Default order for items without `order`
     * @returns {number} Negative if a<b, positive if a>b, 0 if equal
     *
     * @example
     * config.sort(compareByOrder);
     * sections.sort((a, b) => compareByOrder(a, b, 0));
     */
    function compareByOrder(a, b, fallback = 999) {
        const orderA = typeof a.order === 'number' ? a.order : fallback;
        const orderB = typeof b.order === 'number' ? b.order : fallback;
        return orderA - orderB;
    }

    /**
     * Phase 4 dedup: shared getLog() — canonical lazy logger accessor
     * @returns {Object} Logger (GeoLeaf.Log or console)
     */
    function getLog() {
        return Log;
    }

    /**
     * Phase 4 dedup: shared getActiveProfile() — canonical profile accessor
     * @returns {Object|null} Active profile or null
     */
    function getActiveProfile() {
        if (Config && typeof Config.getActiveProfile === 'function') {
            return Config.getActiveProfile() || null;
        }
        return null;
    }

    /**
     * Utils facade — groups all general utilities under one object
     * @namespace
     */
    const Utils = {
        validateUrl: validateUrl$1,
        deepMerge,
        ensureMap: ensureMap$1,
        mergeOptions,
        fireMapEvent,
        debounce,
        throttle,
        getDistance,
        resolveField: resolveField$1,
        compareByOrder,
        getLog,
        getActiveProfile
    };

    /**
     * GeoLeaf - DOM Security Module
     *
     * @description Wrappers sécurisés pour manipuler le DOM sans vulnérabilités XSS
     * @module GeoLeaf.DOMSecurity
     * @version 3.0.1
     * @date 2026-01-17
     *
     * USAGE:
     * - Remplace innerHTML par des alternatives sécurisées
     * - Utilise textContent pour données non-HTML
     * - Sanitize via GeoLeaf.Security pour HTML nécessaire
     * - Crée SVG de manière sécurisée
     */


    /**
     * Définit le contenu texte d'un élément de manière sécurisée
     * Remplace: element.innerHTML = text
     *
     * @param {HTMLElement} element - Élément DOM cible
     * @param {string|number} text - Contenu texte (sera converti en string)
     * @returns {void}
     *
     * @example
     * // ❌ AVANT (vulnérable XSS)
     * div.innerHTML = userData;
     *
     * // ✅ APRÈS (sécurisé)
     * DOMSecurity.setTextContent(div, userData);
     */
    function setTextContent(element, text) {
        if (!element || !element.nodeType) {
            Log.warn('[DOMSecurity] Invalid element in setTextContent');
            return;
        }
        element.textContent = text != null ? String(text) : '';
    }

    /**
     * Injecte du HTML dans un élément après sanitisation (whitelist de balises sûres).
     * Remplace: element.innerHTML = html (quand du HTML enrichi doit être rendu)
     *
     * @param {HTMLElement} element - Élément DOM cible
     * @param {string} html - Contenu HTML à sanitiser et injecter
     * @param {string[]} [allowedTags] - Balises autorisées (défaut: p br strong em span a ul ol li)
     * @returns {void}
     *
     * @example
     * // ✅ Rendu HTML sanitisé
     * DOMSecurity.setSafeHTML(div, '<strong>Important</strong>');
     */
    function setSafeHTML(element, html, allowedTags) {
        if (!element || !element.nodeType) {
            Log.warn('[DOMSecurity] Invalid element in setSafeHTML');
            return;
        }

        // Utiliser Security.sanitizeHTML si disponible — sanitisation avec whitelist
        if (Security && typeof Security.sanitizeHTML === 'function') {
            Security.sanitizeHTML(element, html, allowedTags ? { allowedTags } : {});
        } else {
            // Fallback sûr : textContent si Security non disponible
            Log.warn('[DOMSecurity] Security.sanitizeHTML unavailable, falling back to textContent');
            element.textContent = html ? String(html) : '';
        }
    }

    /**
     * Vide un élément de manière sécurisée
     * Remplace: element.innerHTML = ""
     *
     * @param {HTMLElement} element - Élément DOM à vider
     * @returns {void}
     *
     * @example
     * DOMSecurity.clearElement(container);
     */
    function clearElement(element) {
        if (!element || !element.nodeType) {
            Log.warn('[DOMSecurity] Invalid element in clearElement');
            return;
        }

        // Méthode la plus performante et sûre
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }

    /**
     * Vide rapidement en utilisant textContent (alternative)
     * Plus rapide que removeChild mais moins propre
     *
     * @param {HTMLElement} element - Élément DOM à vider
     * @returns {void}
     */
    function clearElementFast(element) {
        if (!element || !element.nodeType) {
            Log.warn('[DOMSecurity] Invalid element in clearElementFast');
            return;
        }
        element.textContent = '';
    }

    /**
     * Crée un élément SVG de manière sécurisée
     *
     * @param {number} width - Largeur SVG
     * @param {number} height - Hauteur SVG
     * @param {string} pathData - Données du path SVG
     * @param {Object} [options={}] - Options SVG
     * @param {string} [options.viewBox] - ViewBox SVG
     * @param {string} [options.fill='none'] - Couleur de remplissage
     * @param {string} [options.stroke='currentColor'] - Couleur de trait
     * @param {string|number} [options.strokeWidth='2'] - Épaisseur trait
     * @param {string} [options.strokeLinecap='round'] - Style bout de trait
     * @param {string} [options.strokeLinejoin='round'] - Style jonction
     * @returns {SVGElement} Élément SVG créé
     *
     * @example
     * const icon = DOMSecurity.createSVGIcon(18, 18, 'M6 9l6 6 6-6');
     * button.appendChild(icon);
     */
    function createSVGIcon(width, height, pathData, options = {}) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.setAttribute('viewBox', options.viewBox || `0 0 24 24`);
        svg.setAttribute('fill', options.fill || 'none');
        svg.setAttribute('stroke', options.stroke || 'currentColor');
        svg.setAttribute('stroke-width', String(options.strokeWidth || '2'));
        svg.setAttribute('stroke-linecap', options.strokeLinecap || 'round');
        svg.setAttribute('stroke-linejoin', options.strokeLinejoin || 'round');

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        svg.appendChild(path);

        return svg;
    }

    /**
     * Bibliothèque d'icônes SVG communes
     * @constant
     */
    const SVG_ICONS = {
        // Chevrons
        'chevron-down': 'M6 9l6 6 6-6',
        'chevron-up': 'M18 15l-6-6-6 6',
        'chevron-left': 'M15 18l-6-6 6-6',
        'chevron-right': 'M9 18l6-6-6-6',

        // Arrows
        'arrow-left': '‹',
        'arrow-right': '›',

        // UI Controls
        'close': '✕',
        'check': '✓',
        'star': '★',
        'star-empty': '☆',

        // Triangles (collapse/expand)
        'triangle-right': '▶',
        'triangle-down': '▼',

        // Home/Layers
        'home': 'M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z',
        'layers': 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5',

        // Location
        'marker': 'M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z',
        'map-pin': 'M12 22s-8-4.5-8-11.8A8 8 0 0 1 12 2a8 8 0 0 1 8 8.2c0 7.3-8 11.8-8 11.8z',

        // Actions
        'download': 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3',
        'upload': 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12',
        'trash': 'M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2',
        'copy': 'M8 4v12a2 2 0 002 2h8a2 2 0 002-2V7.242a2 2 0 00-.602-1.43L16.083 2.57A2 2 0 0014.685 2H10a2 2 0 00-2 2z',

        // Status
        'sync': 'M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15'
    };

    /**
     * Obtient une icône SVG prédéfinie
     *
     * @param {string} name - Nom de l'icône
     * @param {number} [size=18] - Taille de l'icône
     * @param {Object} [options={}] - Options SVG supplémentaires
     * @returns {SVGElement|null} Élément SVG ou null si non trouvé
     *
     * @example
     * const homeIcon = DOMSecurity.getIcon('home', 24);
     * button.appendChild(homeIcon);
     */
    function getIcon(name, size = 18, options = {}) {
        const pathData = SVG_ICONS[name];
        if (!pathData) {
            Log.warn(`[DOMSecurity] Icon '${name}' not found`);
            return null;
        }
        return createSVGIcon(size, size, pathData, options);
    }

    /**
     * Crée un élément avec attributs de manière sécurisée
     * Alternative sécurisée à innerHTML pour structures simples
     *
     * @param {string} tagName - Nom de la balise
     * @param {Object} [attributes={}] - Attributs de l'élément
     * @param {string|HTMLElement|Array} [children] - Enfants (texte ou éléments)
     * @returns {HTMLElement} Élément créé
     *
     * @example
     * const div = DOMSecurity.createElement('div',
     *   { class: 'container', id: 'main' },
     *   ['Hello ', DOMSecurity.createElement('strong', {}, 'World')]
     * );
     */
    function createElement$2(tagName, attributes = {}, children = null) {
        const element = document.createElement(tagName);

        // Définir les attributs
        for (const [key, value] of Object.entries(attributes)) {
            if (key === 'class' || key === 'className') {
                element.className = value;
            } else if (key === 'style' && typeof value === 'object') {
                Object.assign(element.style, value);
            } else if (key.startsWith('data-')) {
                element.setAttribute(key, value);
            } else {
                element[key] = value;
            }
        }

        // Ajouter les enfants
        if (children) {
            if (Array.isArray(children)) {
                children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else if (child && child.nodeType) {
                        element.appendChild(child);
                    }
                });
            } else if (typeof children === 'string') {
                element.textContent = children;
            } else if (children.nodeType) {
                element.appendChild(children);
            }
        }

        return element;
    }

    // API publique
    const DOMSecurity = {
        setTextContent,
        setSafeHTML,
        clearElement,
        clearElementFast,
        createSVGIcon,
        getIcon,
        createElement: createElement$2,
        SVG_ICONS // Exposer la liste pour référence
    };

    /**
     * @module GeoLeaf.Utils.DomHelpers
     * Helpers pour création et manipulation d'éléments DOM
     * Simplifie et standardise la création d'éléments DOM dans tout le projet
     *
     * @version 1.0.0
     * @requires GeoLeaf.Security (pour sanitization)
     */



    /**
     * Crée un élément DOM avec propriétés et enfants de manière déclarative
     * Cette fonction simplifie la création d'éléments DOM complexes
     *
     * @param {string} tag - Nom du tag HTML (ex: 'div', 'span', 'button')
     * @param {Object} [props={}] - Propriétés de l'élément
     * @param {string} [props.className] - Classes CSS
     * @param {string} [props.id] - ID de l'élément
     * @param {Object} [props.style] - Styles inline (objet)
     * @param {Object} [props.dataset] - Data attributes (objet)
     * @param {Object} [props.attributes] - Attributs HTML (objet)
     * @param {Function} [props.on*] - Event handlers (ex: onClick, onMouseOver)
     * @param {string} [props._eventContext] - Context for EventListenerManager tracking
     * @param {Array} [props._cleanupArray] - Array to store cleanup functions
     * @param {...(Node|string|number)} children - Enfants de l'élément
     * @returns {HTMLElement} L'élément créé
     *
     * @example
     * // Simple div avec classe
     * createElement('div', { className: 'card' })
     *
     * @example
     * // Div avec enfants
     * createElement('div', { className: 'card' },
     *     createElement('h2', {}, 'Title'),
     *     createElement('p', {}, 'Content')
     * )
     *
     * @example
     * // Bouton avec event handler (auto-cleanup with EventListenerManager)
     * createElement('button', {
     *     className: 'btn',
     *     onClick: (e) => console.log('Clicked!'),
     *     dataset: { action: 'submit' },
     *     _eventContext: 'MyModule.button'
     * }, 'Click me')
     *
     * @example
     * // With cleanup tracking
     * const cleanups = [];
     * createElement('button', {
     *     onClick: handler,
     *     _cleanupArray: cleanups,
     *     _eventContext: 'MyModule'
     * }, 'Click')
     * // Later: cleanups.forEach(fn => fn())
     */
    function createElement$1(tag, props = {}, ...children) {
        // Validate tag parameter
        if (typeof tag !== 'string' || !tag.trim()) {
            throw new TypeError('[DomHelpers] createElement: tag must be a non-empty string');
        }

        const element = document.createElement(tag);

        // Traiter les propriétés spéciales en premier
        const {
            className,
            id,
            style,
            dataset,
            attributes,
            textContent,
            innerHTML,
            _eventContext,
            _cleanupArray,
            ...otherProps
        } = props;

        // Appliquer className
        if (className) {
            element.className = className;
        }

        // Appliquer ID
        if (id) {
            element.id = id;
        }

        // Appliquer styles
        if (style && typeof style === 'object') {
            Object.assign(element.style, style);
        }

        // Appliquer data attributes
        if (dataset && typeof dataset === 'object') {
            for (const [key, value] of Object.entries(dataset)) {
                element.dataset[key] = value;
            }
        }

        // Appliquer attributes HTML
        if (attributes && typeof attributes === 'object') {
            for (const [key, value] of Object.entries(attributes)) {
                element.setAttribute(key, value);
            }
        }

        // Appliquer les autres propriétés (event handlers, etc.)
        const events = GeoLeaf.Utils?.events;

        for (const [key, value] of Object.entries(otherProps)) {
            // Event handlers (onClick, onMouseOver, etc.)
            if (key.startsWith('on') && typeof value === 'function') {
                const event = key.substring(2).toLowerCase();

                // Use EventListenerManager for auto-cleanup if available
                if (events) {
                    const cleanup = events.on(
                        element,
                        event,
                        value,
                        false,
                        _eventContext || 'DomHelpers.createElement'
                    );

                    // Store cleanup function if array provided
                    if (_cleanupArray && Array.isArray(_cleanupArray)) {
                        _cleanupArray.push(cleanup);
                    }
                } else {
                    // Fallback to native addEventListener
                    element.addEventListener(event, value);
                }
            }
            // Propriétés aria-*
            else if (key.startsWith('aria')) {
                const attrName = 'aria-' + key.substring(4).toLowerCase();
                element.setAttribute(attrName, value);
            }
            // Autres propriétés directes
            else if (key in element) {
                element[key] = value;
            }
            // Fallback: setAttribute
            else {
                element.setAttribute(key, value);
            }
        }

        // Appliquer textContent si fourni (écrase innerHTML et children)
        if (textContent !== undefined) {
            element.textContent = textContent;
            return element; // Ignorer children si textContent est fourni
        }

        // Appliquer innerHTML si fourni (écrase children)
        // WARNING: N'utiliser qu'avec du contenu sécurisé/sanitizé
        if (innerHTML !== undefined) {
            if (Log && Log.warn) {
                Log.warn(
                    '[DomHelpers] createElement avec innerHTML - assurez-vous que le contenu est sanitizé',
                    { tag, innerHTML: innerHTML.substring(0, 100) }
                );
            }

            // Use DOMSecurity if available, otherwise use textContent as safer fallback
            if (GeoLeaf.DOMSecurity && typeof GeoLeaf.DOMSecurity.setSafeHTML === 'function') {
                GeoLeaf.DOMSecurity.setSafeHTML(element, innerHTML);
            } else {
                // Fallback: convert to text for security
                if (Log && Log.error) {
                    Log.error('[DomHelpers] DOMSecurity not available, using textContent fallback');
                }
                element.textContent = innerHTML;
            }
            return element; // Ignorer children si innerHTML est fourni
        }

        // Ajouter les enfants
        appendChild(element, ...children);

        return element;
    }

    /**
     * Ajoute des enfants à un élément parent
     * Gère automatiquement les strings, numbers, nodes, et tableaux
     *
     * @param {HTMLElement} parent - Élément parent
     * @param {...(Node|string|number|Array)} children - Enfants à ajouter
     * @returns {HTMLElement} Le parent (pour chaînage)
     *
     * @example
     * appendChild(div, 'Text', createElement('span', {}, 'More text'))
     *
     * @example
     * // Avec tableau
     * appendChild(ul, items.map(item => createElement('li', {}, item)))
     */
    function appendChild(parent, ...children) {
        for (const child of children) {
            if (child == null || child === false) {
                // Ignorer null, undefined, false (utile pour render conditionnel)
                continue;
            }

            // Si c'est un tableau, l'aplatir récursivement
            if (Array.isArray(child)) {
                appendChild(parent, ...child);
            }
            // Si c'est une string ou number, créer un TextNode
            else if (typeof child === 'string' || typeof child === 'number') {
                parent.appendChild(document.createTextNode(String(child)));
            }
            // Si c'est un Node, l'ajouter directement
            else if (child instanceof Node) {
                parent.appendChild(child);
            }
            // Sinon, convertir en string et ajouter comme TextNode
            else {
                parent.appendChild(document.createTextNode(String(child)));
            }
        }
        return parent;
    }

    // Alias sur GeoLeaf.Utils pour compatibilité et facilité d'usage

    /**
     * @fileoverview Animation Helper - 60 FPS Animation Manager
     * @description Optimized animation utilities using requestAnimationFrame
     * @version 1.0.0
     * @phase Phase 5 Section 5.2 - Animation Optimization
     *
     * Features:
     * - requestAnimationFrame-based animations (60 FPS)
     * - Automatic frame batching for multiple animations
     * - CSS transition optimization with will-change
     * - Animation queue management
     * - Performance monitoring (FPS counter)
     * - Mobile-optimized animations
     * - Graceful degradation for older browsers
     *
     * @example Basic usage
     * ```javascript
     * const helper = GeoLeaf.Utils.AnimationHelper;
     *
     * // Animate element
     * helper.animate(element, {
     *     from: { opacity: 0, translateY: -20 },
     *     to: { opacity: 1, translateY: 0 },
     *     duration: 300,
     *     easing: 'easeOutCubic'
     * });
     * ```
     */


    // Perf 6.1.5: Module-level Set for O(1) transform property lookup (avoids array.includes per frame)
    const _TRANSFORM_PROPS = new Set([
        "translateX",
        "translateY",
        "translateZ",
        "scale",
        "scaleX",
        "scaleY",
        "rotate",
        "rotateX",
        "rotateY",
        "rotateZ",
        "skewX",
        "skewY",
    ]);

    // Perf 6.1.4: Module-level easing dictionary — created once, not per animation call
    const _EASINGS = {
        linear: (t) => t,
        easeInQuad: (t) => t * t,
        easeOutQuad: (t) => t * (2 - t),
        easeInOutQuad: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),
        easeInCubic: (t) => t * t * t,
        easeOutCubic: (t) => --t * t * t + 1,
        easeInOutCubic: (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1),
        easeInQuart: (t) => t * t * t * t,
        easeOutQuart: (t) => 1 - --t * t * t * t,
        easeInOutQuart: (t) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t),
        easeOutBack: (t) => {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        },
    };

    /**
     * @class AnimationHelper
     * @description Manages high-performance animations using requestAnimationFrame
     */
    class AnimationHelper {
        constructor() {
            /** @private {Map<number, Function>} Active animations */
            this._animations = new Map();

            /** @private {number} Animation frame ID */
            this._rafId = null;

            /** @private {number} Last frame timestamp */
            this._lastFrameTime = 0;

            /** @private {Array<number>} FPS history (last 60 frames) */
            this._fpsHistory = [];

            /** @private {boolean} Debug mode */
            this._debug = false;

            /** @private {number} Next animation ID */
            this._nextId = 1;

            /** @private {WeakMap<HTMLElement, Set>} Element animations tracking */
            this._elementAnimations = new WeakMap();

            // Performance monitoring
            this._stats = {
                totalFrames: 0,
                droppedFrames: 0,
                averageFPS: 0,
            };

            // Bind methods
            this._tick = this._tick.bind(this);
        }

        /**
         * Enable debug mode with FPS counter
         * @param {boolean} enabled - Enable debug
         */
        setDebug(enabled) {
            this._debug = enabled;
            if (enabled && !this._rafId) {
                this._startLoop();
            }
        }

        /**
         * Get animation statistics
         * @returns {Object} Animation stats
         */
        getStats() {
            return {
                ...this._stats,
                activeAnimations: this._animations.size,
                currentFPS: this._getCurrentFPS(),
            };
        }

        /**
         * Animate element with requestAnimationFrame
         * @param {HTMLElement} element - Target element
         * @param {Object} options - Animation options
         * @param {Object} options.from - Start values
         * @param {Object} options.to - End values
         * @param {number} [options.duration=300] - Duration in ms
         * @param {string} [options.easing='easeOutCubic'] - Easing function
         * @param {Function} [options.onComplete] - Completion callback
         * @param {Function} [options.onUpdate] - Update callback (progress 0-1)
         * @returns {number} Animation ID (can be used to cancel)
         */
        animate(element, options = {}) {
            if (!element || !(element instanceof HTMLElement)) {
                this._log("warn", "animate: invalid element", element);
                return null;
            }

            const {
                from = {},
                to = {},
                duration = 300,
                easing = "easeOutCubic",
                onComplete = null,
                onUpdate = null,
            } = options;

            const id = this._nextId++;
            const startTime = performance.now();
            const easingFn = this._getEasingFunction(easing);

            // Optimize with will-change
            this._optimizeElement(element, to);

            // Track animation for this element
            this._trackElementAnimation(element, id);

            const animationFn = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = easingFn(progress);

                // Apply transformations
                this._applyTransform(element, from, to, easedProgress);

                // Update callback
                if (onUpdate) {
                    onUpdate(easedProgress);
                }

                // Check completion
                if (progress >= 1) {
                    this._animations.delete(id);
                    this._untrackElementAnimation(element, id);
                    this._cleanupElement(element);

                    if (onComplete) {
                        onComplete();
                    }

                    this._log("debug", `Animation ${id} completed`);
                    return false; // Stop animation
                }

                return true; // Continue animation
            };

            this._animations.set(id, animationFn);
            this._startLoop();

            this._log("debug", `Animation ${id} started`, { duration, easing });
            return id;
        }

        /**
         * Fade in element
         * @param {HTMLElement} element - Target element
         * @param {number} [duration=300] - Duration in ms
         * @param {Function} [onComplete] - Completion callback
         * @returns {number} Animation ID
         */
        fadeIn(element, duration = 300, onComplete = null) {
            if (!element.style.display || element.style.display === "none") {
                element.style.display = "block";
            }
            return this.animate(element, {
                from: { opacity: 0 },
                to: { opacity: 1 },
                duration,
                easing: "easeOutCubic",
                onComplete,
            });
        }

        /**
         * Fade out element
         * @param {HTMLElement} element - Target element
         * @param {number} [duration=300] - Duration in ms
         * @param {Function} [onComplete] - Completion callback
         * @returns {number} Animation ID
         */
        fadeOut(element, duration = 300, onComplete = null) {
            return this.animate(element, {
                from: { opacity: 1 },
                to: { opacity: 0 },
                duration,
                easing: "easeOutCubic",
                onComplete: () => {
                    element.style.display = "none";
                    if (onComplete) onComplete();
                },
            });
        }

        /**
         * Slide in element (from top)
         * @param {HTMLElement} element - Target element
         * @param {number} [duration=300] - Duration in ms
         * @param {Function} [onComplete] - Completion callback
         * @returns {number} Animation ID
         */
        slideIn(element, duration = 300, onComplete = null) {
            element.style.display = element.style.display || "block";
            return this.animate(element, {
                from: { opacity: 0, translateY: -20 },
                to: { opacity: 1, translateY: 0 },
                duration,
                easing: "easeOutBack",
                onComplete,
            });
        }

        /**
         * Slide out element (to top)
         * @param {HTMLElement} element - Target element
         * @param {number} [duration=300] - Duration in ms
         * @param {Function} [onComplete] - Completion callback
         * @returns {number} Animation ID
         */
        slideOut(element, duration = 300, onComplete = null) {
            return this.animate(element, {
                from: { opacity: 1, translateY: 0 },
                to: { opacity: 0, translateY: -20 },
                duration,
                easing: "easeInCubic",
                onComplete: () => {
                    element.style.display = "none";
                    if (onComplete) onComplete();
                },
            });
        }

        /**
         * Cancel animation
         * @param {number} id - Animation ID
         * @returns {boolean} True if cancelled
         */
        cancel(id) {
            const existed = this._animations.has(id);
            if (existed) {
                this._animations.delete(id);
                this._log("debug", `Animation ${id} cancelled`);
            }
            return existed;
        }

        /**
         * Cancel all animations for element
         * @param {HTMLElement} element - Target element
         * @returns {number} Number of animations cancelled
         */
        cancelForElement(element) {
            const ids = this._elementAnimations.get(element);
            if (!ids) return 0;

            let count = 0;
            ids.forEach((id) => {
                if (this._animations.delete(id)) {
                    count++;
                }
            });

            this._elementAnimations.delete(element);
            this._cleanupElement(element);

            this._log("debug", `Cancelled ${count} animations for element`);
            return count;
        }

        /**
         * Cancel all animations
         */
        cancelAll() {
            const count = this._animations.size;
            this._animations.clear();

            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }

            this._log("info", `Cancelled all ${count} animations`);
        }

        /**
         * Wait for next frame (utility for chaining animations)
         * @returns {Promise<DOMHighResTimeStamp>} Resolves with timestamp
         */
        nextFrame() {
            return new Promise((resolve) => {
                requestAnimationFrame(resolve);
            });
        }

        /**
         * Batch multiple animations to run in same frame
         * @param {Array<Function>} animations - Array of animation functions
         */
        batch(animations) {
            if (!Array.isArray(animations)) return;

            requestAnimationFrame(() => {
                animations.forEach((fn) => {
                    if (typeof fn === "function") {
                        try {
                            fn();
                        } catch (error) {
                            this._log("error", "Batch animation error:", error);
                        }
                    }
                });
            });
        }

        /**
         * Main animation loop
         * @private
         * @param {DOMHighResTimeStamp} currentTime - Current timestamp
         */
        _tick(currentTime) {
            // Calculate FPS
            if (this._lastFrameTime) {
                const delta = currentTime - this._lastFrameTime;
                const fps = 1000 / delta;
                this._updateFPS(fps);

                // Detect dropped frames (< 50 FPS)
                if (fps < 50) {
                    this._stats.droppedFrames++;
                }
            }

            this._lastFrameTime = currentTime;
            this._stats.totalFrames++;

            // Run all active animations
            const toRemove = [];
            this._animations.forEach((animationFn, id) => {
                try {
                    const shouldContinue = animationFn(currentTime);
                    if (!shouldContinue) {
                        toRemove.push(id);
                    }
                } catch (error) {
                    this._log("error", `Animation ${id} error:`, error);
                    toRemove.push(id);
                }
            });

            // Cleanup completed animations
            toRemove.forEach((id) => this._animations.delete(id));

            // Continue loop if animations active or debug mode
            if (this._animations.size > 0 || this._debug) {
                this._rafId = requestAnimationFrame(this._tick);
            } else {
                this._rafId = null;
            }
        }

        /**
         * Start animation loop
         * @private
         */
        _startLoop() {
            if (!this._rafId) {
                this._rafId = requestAnimationFrame(this._tick);
            }
        }

        /**
         * Apply transform to element
         * @private
         * @param {HTMLElement} element - Target element
         * @param {Object} from - Start values
         * @param {Object} to - End values
         * @param {number} progress - Progress (0-1)
         */
        _applyTransform(element, from, to, progress) {
            const transforms = [];
            const styles = {};

            Object.keys(to).forEach((key) => {
                const startValue = from[key] !== undefined ? from[key] : this._getDefaultValue(key);
                const endValue = to[key];
                const currentValue = this._interpolate(startValue, endValue, progress);

                if (this._isTransformProperty(key)) {
                    transforms.push(this._formatTransform(key, currentValue));
                } else {
                    styles[key] = this._formatValue(key, currentValue);
                }
            });

            // Apply transforms
            if (transforms.length > 0) {
                element.style.transform = transforms.join(" ");
            }

            // Apply styles
            Object.keys(styles).forEach((key) => {
                element.style[key] = styles[key];
            });
        }

        /**
         * Interpolate between two values
         * @private
         * @param {number} start - Start value
         * @param {number} end - End value
         * @param {number} progress - Progress (0-1)
         * @returns {number} Interpolated value
         */
        _interpolate(start, end, progress) {
            return start + (end - start) * progress;
        }

        /**
         * Check if property is a transform
         * @private
         * @param {string} key - Property name
         * @returns {boolean} True if transform property
         */
        _isTransformProperty(key) {
            // Perf 6.1.5: Use module-level Set for O(1) lookup instead of Array.includes()
            return _TRANSFORM_PROPS.has(key);
        }

        /**
         * Format transform property
         * @private
         * @param {string} key - Property name
         * @param {number} value - Value
         * @returns {string} Formatted transform
         */
        _formatTransform(key, value) {
            if (key.includes("translate")) {
                return `${key}(${value}px)`;
            } else if (key.includes("rotate") || key.includes("skew")) {
                return `${key}(${value}deg)`;
            } else {
                return `${key}(${value})`;
            }
        }

        /**
         * Format CSS value
         * @private
         * @param {string} key - Property name
         * @param {number} value - Value
         * @returns {string} Formatted value
         */
        _formatValue(key, value) {
            if (key === "opacity") {
                return value.toString();
            }
            return `${value}px`;
        }

        /**
         * Get default value for property
         * @private
         * @param {string} key - Property name
         * @returns {number} Default value
         */
        _getDefaultValue(key) {
            if (key === "opacity") return 1;
            if (key === "scale" || key === "scaleX" || key === "scaleY") return 1;
            return 0;
        }

        /**
         * Optimize element for animation
         * @private
         * @param {HTMLElement} element - Target element
         * @param {Object} properties - Properties to animate
         */
        _optimizeElement(element, properties) {
            const willChange = [];

            Object.keys(properties).forEach((key) => {
                if (this._isTransformProperty(key)) {
                    if (!willChange.includes("transform")) {
                        willChange.push("transform");
                    }
                } else {
                    willChange.push(key);
                }
            });

            if (willChange.length > 0) {
                element.style.willChange = willChange.join(", ");
            }
        }

        /**
         * Cleanup element optimization
         * @private
         * @param {HTMLElement} element - Target element
         */
        _cleanupElement(element) {
            element.style.willChange = "auto";
        }

        /**
         * Track animation for element
         * @private
         * @param {HTMLElement} element - Target element
         * @param {number} id - Animation ID
         */
        _trackElementAnimation(element, id) {
            let ids = this._elementAnimations.get(element);
            if (!ids) {
                ids = new Set();
                this._elementAnimations.set(element, ids);
            }
            ids.add(id);
        }

        /**
         * Untrack animation for element
         * @private
         * @param {HTMLElement} element - Target element
         * @param {number} id - Animation ID
         */
        _untrackElementAnimation(element, id) {
            const ids = this._elementAnimations.get(element);
            if (ids) {
                ids.delete(id);
                if (ids.size === 0) {
                    this._elementAnimations.delete(element);
                }
            }
        }

        /**
         * Get easing function
         * @private
         * @param {string} name - Easing name
         * @returns {Function} Easing function
         */
        _getEasingFunction(name) {
            // Perf 6.1.4: Use module-level dictionary — not recreated every call
            return _EASINGS[name] || _EASINGS.easeOutCubic;
        }

        /**
         * Update FPS history
         * @private
         * @param {number} fps - Current FPS
         */
        _updateFPS(fps) {
            this._fpsHistory.push(fps);
            if (this._fpsHistory.length > 60) {
                this._fpsHistory.shift();
            }

            // Calculate average
            const sum = this._fpsHistory.reduce((a, b) => a + b, 0);
            this._stats.averageFPS = Math.round(sum / this._fpsHistory.length);
        }

        /**
         * Get current FPS
         * @private
         * @returns {number} Current FPS
         */
        _getCurrentFPS() {
            if (this._fpsHistory.length === 0) return 0;
            return Math.round(this._fpsHistory[this._fpsHistory.length - 1]);
        }

        /**
         * Log message
         * @private
         * @param {string} level - Log level
         * @param {...*} args - Log arguments
         */
        _log(level, ...args) {
            if (!this._debug && level === "debug") return;

            const log = Log || console;
            if (log[level]) {
                log[level]("[AnimationHelper]", ...args);
            }
        }
    }

    // Create singleton instance — lazy (perf 5.2: création différée au premier accès)
    let _animationHelperInstance = null;

    function getAnimationHelper() {
        if (!_animationHelperInstance) {
            _animationHelperInstance = new AnimationHelper();
        }
        return _animationHelperInstance;
    }

    /**
     * GeoLeaf Error Logger
     *
     * Centralised error logging for consistent error reporting across all modules.
     * Replaces 60+ LOC of repetitive logging patterns with unified interface.
     *
     * @module GeoLeaf.Utils.ErrorLogger
     * @version 3.0.0
     */



    const ErrorLogger = {
        /**
         * Niveaux de log
         * @private
         */
        LEVELS: {
            ERROR: 'error',
            WARN: 'warn',
            INFO: 'info',
            DEBUG: 'debug'
        },

        /**
         * Logue une erreur avec contexte
         * @param {string} module - Nom du module (ex: "CacheManager", "LayerSelector")
         * @param {string} message - Message d'erreur
         * @param {Error|*} [error] - L'erreur originale (optionnel)
         */
        error: function (module, message, error) {
            const fullMessage = `[${module}] ${message}`;

            if (Log && typeof Log.error === 'function') {
                Log.error(fullMessage, error);
                // Inclure le stack trace si disponible
                if (error && error.stack) {
                    Log.error(`  Stack: ${error.stack}`);
                }
            }
        },

        /**
         * Logue un avertissement
         * @param {string} module - Nom du module
         * @param {string} message - Message d'avertissement
         */
        warn: function (module, message) {
            const fullMessage = `[${module}] ${message}`;

            if (Log && typeof Log.warn === 'function') {
                Log.warn(fullMessage);
            }
        },

        /**
         * Logue une info
         * @param {string} module - Nom du module
         * @param {string} message - Message d'info
         */
        info: function (module, message) {
            const fullMessage = `[${module}] ${message}`;

            if (Log && typeof Log.info === 'function') {
                Log.info(fullMessage);
            }
        },

        /**
         * Logue un debug
         * @param {string} module - Nom du module
         * @param {string} message - Message de debug
         */
        debug: function (module, message) {
            const fullMessage = `[${module}] ${message}`;

            if (Log && typeof Log.debug === 'function') {
                Log.debug(fullMessage);
            } else {
                console.debug(fullMessage);
            }
        },

        /**
         * Logue une erreur quota spécifiquement
         * @param {string} module - Nom du module
         * @param {number} available - Espace disponible en bytes
         * @param {number} needed - Espace nécessaire en bytes
         */
        quotaError: function (module, available, needed) {
            const availableGB = (available / 1024 / 1024 / 1024).toFixed(2);
            const neededGB = (needed / 1024 / 1024 / 1024).toFixed(2);
            const shortageGB = ((needed - available) / 1024 / 1024 / 1024).toFixed(2);

            const message = `QUOTA EXCEEDED - Available: ${availableGB}GB, Needed: ${neededGB}GB, Shortage: ${shortageGB}GB`;
            this.error(module, message);
        },

        /**
         * Logue une erreur de réseau
         * @param {string} module - Nom du module
         * @param {string} url - URL qui a échoué
         * @param {number|string} status - Statut HTTP
         * @param {Error} [error] - L'erreur originale
         */
        networkError: function (module, url, status, error) {
            const message = `Network error [${status}] - ${url}`;
            this.error(module, message, error);
        },

        /**
         * Logue une erreur de validation
         * @param {string} module - Nom du module
         * @param {string} field - Champ validé
         * @param {string} expectedFormat - Format attendu
         */
        validationError: function (module, field, expectedFormat) {
            const message = `Validation error - ${field} (expected: ${expectedFormat})`;
            this.warn(module, message);
        },

        /**
         * Logue une erreur IndexedDB
         * @param {string} module - Nom du module
         * @param {string} operation - Opération (query, insert, update, delete)
         * @param {Error} [error] - L'erreur IDB
         */
        idbError: function (module, operation, error) {
            const message = `IndexedDB error (${operation})`;
            this.error(module, message, error);
        },

        /**
         * Logue les détails d'une performance
         * @param {string} module - Nom du module
         * @param {string} operation - Opération effectuée
         * @param {number} milliseconds - Temps en ms
         */
        performance: function (module, operation, milliseconds) {
            const message = `${operation} completed in ${milliseconds}ms`;
            this.info(module, message);
        },

        /**
         * Logue un warning de mémoire
         * @param {string} module - Nom du module
         * @param {number} usedMB - Mémoire utilisée en MB
         */
        memoryWarning: function (module, usedMB) {
            const message = `⚠️ High memory usage: ${usedMB}MB`;
            this.warn(module, message);
        },

        /**
         * Crée un contexte de log pour une opération
         * @param {string} module - Nom du module
         * @param {string} operation - Nom de l'opération
         * @returns {Object} Objet avec start/end/error methods
         */
        operation: function (module, operation) {
            const startTime = performance.now();

            return {
                success: (result) => {
                    const duration = performance.now() - startTime;
                    this.info(module, `${operation} succeeded (${duration.toFixed(0)}ms)`);
                    return result;
                },
                error: (error) => {
                    const duration = performance.now() - startTime;
                    this.error(module, `${operation} failed (${duration.toFixed(0)}ms)`, error);
                    throw error;
                },
                warn: (warning) => {
                    const duration = performance.now() - startTime;
                    this.warn(module, `${operation} warning (${duration.toFixed(0)}ms): ${warning}`);
                }
            };
        }
    };

    if (Log) {
        Log.debug("[ErrorLogger] Module loaded");
    }

    /**
     * @fileoverview Event Helpers - Utilities for custom event dispatching
     * @module utils/event-helpers
     *
     * @description
     * Provides cross-browser compatible event dispatching utilities.
     * Eliminates duplicate CustomEvent patterns and provides consistent error handling.
     *
     * @author GeoLeaf
     * @version 2.1.0
     * @since Phase 3 - Code Deduplication
     */


    /**
     * @namespace EventHelpers
     * @memberof GeoLeaf.Utils
     * @description Utilities for custom event management
     */
    const EventHelpers = {
        /**
         * Dispatches a custom event on document with cross-browser compatibility
         *
         * @param {string} eventName - Event name (ex: 'geoleaf:poi:loaded')
         * @param {Object} [detail={}] - Event detail payload
         * @param {Object} [options={}] - Additional options
         * @param {boolean} [options.bubbles=true] - Event bubbles up DOM tree
         * @param {boolean} [options.cancelable=true] - Event can be cancelled
         * @param {EventTarget} [options.target=document] - Event target (default: document)
         * @returns {boolean} True if event was dispatched successfully
         *
         * @description
         * Uses modern CustomEvent constructor with IE11 fallback.
         * Provides consistent error handling and logging.
         *
         * @example
         * // Simple event dispatch
         * EventHelpers.dispatchCustomEvent('geoleaf:data:loaded', {
         *   count: 42,
         *   source: 'api'
         * });
         *
         * @example
         * // With custom options
         * EventHelpers.dispatchCustomEvent('geoleaf:ui:changed',
         *   { theme: 'dark' },
         *   { bubbles: false, target: window }
         * );
         *
         * @example
         * // Error handling
         * const success = EventHelpers.dispatchCustomEvent('my:event', data);
         * if (!success) {
         *   console.warn('Event dispatch failed');
         * }
         */
        dispatchCustomEvent(eventName, detail = {}, options = {}) {
            const { bubbles = true, cancelable = true, target = document } = options;

            try {
                const event = new CustomEvent(eventName, {
                    detail,
                    bubbles,
                    cancelable,
                });

                target.dispatchEvent(event);
                return true;
            } catch (error) {
                if (Log.error) {
                    Log.error(`[EventHelpers] Failed to dispatch event '${eventName}':`, error);
                }
                return false;
            }
        },

        /**
         * Dispatches a Leaflet map event with fallback
         *
         * @param {L.Map} map - Leaflet map instance
         * @param {string} eventName - Event name (ex: 'geoleaf:filters:changed')
         * @param {Object} [detail={}] - Event detail payload
         * @returns {boolean} True if event was dispatched successfully
         *
         * @description
         * Uses Leaflet's map.fire() method for map-specific events.
         * Validates map instance before dispatch.
         *
         * @example
         * // Dispatch map event
         * const map = globalThis.GeoLeaf?.Core?.getMap();
         * EventHelpers.dispatchMapEvent(map, 'geoleaf:layer:added', {
         *   layerId: 'my-layer',
         *   type: 'geojson'
         * });
         *
         * @example
         * // With validation
         * if (this._map) {
         *   EventHelpers.dispatchMapEvent(this._map, 'custom:event', data);
         * }
         */
        dispatchMapEvent(map, eventName, detail = {}) {
            if (!map || typeof map.fire !== "function") {
                if (Log.warn) {
                    Log.warn(`[EventHelpers] Invalid map instance, cannot fire '${eventName}'`);
                }
                return false;
            }

            try {
                map.fire(eventName, detail);
                return true;
            } catch (error) {
                if (Log.error) {
                    Log.error(`[EventHelpers] Failed to fire map event '${eventName}':`, error);
                }
                return false;
            }
        },

        /**
         * Dispatches both document and map events simultaneously
         *
         * @param {string} eventName - Event name (without 'geoleaf:' prefix)
         * @param {Object} [detail={}] - Event detail payload
         * @param {L.Map|null} [map=null] - Optional map instance
         * @returns {Object} Dispatch results { document: boolean, map: boolean }
         *
         * @description
         * Convenience method to dispatch to both document and map.
         * Automatically adds 'geoleaf:' prefix to event name.
         *
         * @example
         * // Dispatch to both targets
         * const results = EventHelpers.dispatchBoth('poi:loaded', {
         *   count: 10,
         *   source: 'api'
         * }, this._map);
         *
         * console.log(`Document: ${results.document}, Map: ${results.map}`);
         *
         * @example
         * // Without map (document only)
         * EventHelpers.dispatchBoth('data:loaded', { count: 42 });
         */
        dispatchBoth(eventName, detail = {}, map = null) {
            // Ensure geoleaf: prefix
            const fullEventName = eventName.startsWith("geoleaf:") ? eventName : `geoleaf:${eventName}`;

            const results = {
                document: false,
                map: false,
            };

            // Dispatch to document
            results.document = this.dispatchCustomEvent(fullEventName, detail);

            // Dispatch to map if available
            if (map) {
                results.map = this.dispatchMapEvent(map, fullEventName, detail);
            }

            return results;
        },

        /**
         * Creates an event listener with automatic cleanup tracking
         *
         * @param {EventTarget} target - Event target (element, document, window)
         * @param {string} eventName - Event name to listen for
         * @param {Function} handler - Event handler function
         * @param {Object} [options={}] - addEventListener options
         * @returns {Function} Cleanup function to remove listener
         *
         * @description
         * Wraps addEventListener with automatic cleanup function.
         * Useful for component lifecycle management.
         *
         * @example
         * // In component initialization
         * this._cleanup = EventHelpers.addEventListener(
         *   document,
         *   'geoleaf:data:loaded',
         *   (e) => this.handleDataLoaded(e.detail)
         * );
         *
         * // In component cleanup
         * if (this._cleanup) this._cleanup();
         *
         * @example
         * // Multiple listeners
         * this._cleanups = [
         *   EventHelpers.addEventListener(map, 'moveend', this.onMove),
         *   EventHelpers.addEventListener(document, 'geoleaf:refresh', this.onRefresh)
         * ];
         *
         * // Cleanup all
         * this._cleanups.forEach(fn => fn());
         */
        addEventListener(target, eventName, handler, options = {}) {
            if (!target || typeof target.addEventListener !== "function") {
                if (Log.warn) {
                    Log.warn(`[EventHelpers] Invalid target for addEventListener '${eventName}'`);
                }
                return () => {}; // noop cleanup
            }

            target.addEventListener(eventName, handler, options);

            // Return cleanup function
            return () => {
                try {
                    target.removeEventListener(eventName, handler, options);
                } catch (error) {
                    if (Log.error) {
                        Log.error(`[EventHelpers] Failed to remove listener '${eventName}':`, error);
                    }
                }
            };
        },

        /**
         * Creates multiple event listeners with batch cleanup
         *
         * @param {Array<Object>} listeners - Array of listener configurations
         * @returns {Function} Cleanup function to remove all listeners
         *
         * @description
         * Batch version of addEventListener for multiple listeners.
         * Returns single cleanup function for all.
         *
         * @example
         * // Batch listener setup
         * this._cleanup = EventHelpers.addEventListeners([
         *   { target: document, event: 'geoleaf:data:loaded', handler: this.onLoad },
         *   { target: this._map, event: 'moveend', handler: this.onMove },
         *   { target: window, event: 'resize', handler: this.onResize }
         * ]);
         *
         * // Single cleanup call
         * this._cleanup();
         */
        addEventListeners(listeners = []) {
            const cleanups = listeners.map(({ target, event, handler, options }) => {
                return this.addEventListener(target, event, handler, options);
            });

            // Return batch cleanup function
            return () => {
                cleanups.forEach((cleanup) => cleanup());
            };
        },

        /**
         * Debounce function - delays execution until after wait time
         *
         * @param {Function} func - Function to debounce
         * @param {number} [wait=300] - Wait time in milliseconds
         * @param {boolean} [immediate=false] - Execute immediately on leading edge
         * @returns {Function} Debounced function
         *
         * @description
         * Delays function execution until after wait time has elapsed since last call.
         * Useful for expensive operations like search, resize, scroll handlers.
         *
         * @example
         * // Search with debounce
         * const debouncedSearch = EventHelpers.debounce((query) => {
         *   fetchResults(query);
         * }, 300);
         *
         * input.addEventListener('input', (e) => debouncedSearch(e.target.value));
         *
         * @example
         * // Immediate execution (leading edge)
         * const saveImmediate = EventHelpers.debounce(saveData, 1000, true);
         */
        debounce(func, wait = 300, immediate = false) {
            let timeout;

            return function debounced(...args) {
                const context = this;

                const later = () => {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                };

                const callNow = immediate && !timeout;

                clearTimeout(timeout);
                timeout = setTimeout(later, wait);

                if (callNow) {
                    func.apply(context, args);
                }
            };
        },

        /**
         * Throttle function - limits execution to once per interval
         *
         * @param {Function} func - Function to throttle
         * @param {number} [limit=300] - Interval limit in milliseconds
         * @returns {Function} Throttled function
         *
         * @description
         * Limits function execution to once per interval, executing immediately.
         * First call executes immediately, subsequent calls wait for interval.
         * Useful for scroll, resize, mousemove handlers.
         *
         * @example
         * // Scroll handler with throttle
         * const throttledScroll = EventHelpers.throttle(() => {
         *   updateScrollPosition();
         * }, 100);
         *
         * window.addEventListener('scroll', throttledScroll);
         *
         * @example
         * // Mouse move tracking (limited to 60fps)
         * const trackMouse = EventHelpers.throttle((e) => {
         *   updateCursor(e.clientX, e.clientY);
         * }, 16); // ~60fps
         */
        throttle(func, limit = 300) {
            let lastRan;

            return function throttled(...args) {
                const context = this;
                const now = Date.now();

                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = now;
                } else {
                    if (now - lastRan >= limit) {
                        func.apply(context, args);
                        lastRan = now;
                    }
                }
            };
        },
    };

    // Export to GeoLeaf namespace

    // Convenient aliases at root level

    // Utility aliases (Sprint 3.2 - consolidated from helpers.js)

    /**
     * @fileoverview EventListenerManager - Gestion centralisée des event listeners
     * Permet de tracker et nettoyer tous les event listeners
     * pour éviter les fuites mémoire
     *
     * @module GeoLeaf.Utils.EventListenerManager
     * @version 2.0.0
     * @author GeoLeaf Project
     */



    /**
     * EventListenerManager - Gestionnaire centralisé d'event listeners
     * @class
     */
    class EventListenerManager {
        constructor(name = 'default') {
            this.name = name;
            this.listeners = [];
            this._nextId = 1;
        }

        /**
         * Ajoute un event listener avec tracking
         * @param {Element|Window|Document} target - Élément cible
         * @param {string} event - Nom de l'événement
         * @param {Function} handler - Handler de l'événement
         * @param {Object|boolean} [options] - Options (capture, once, passive, etc.)
         * @param {string} [label] - Label optionnel pour debug
         * @returns {number} ID du listener pour removal ultérieur
         */
        addEventListener(target, event, handler, options = false, label = '') {
            if (!target || typeof target.addEventListener !== 'function') {
                Log.warn(`[EventListenerManager.${this.name}] Invalid target for addEventListener`);
                return null;
            }

            const id = this._nextId++;

            target.addEventListener(event, handler, options);

            this.listeners.push({
                id,
                target,
                event,
                handler,
                options,
                label,
                createdAt: Date.now()
            });

            Log.debug(`[EventListenerManager.${this.name}] Listener added:`, id, event, label);
            return id;
        }

        /**
         * Ajoute un event listener Leaflet avec tracking
         * @param {L.Evented} target - Objet Leaflet (map, marker, etc.)
         * @param {string} event - Nom de l'événement
         * @param {Function} handler - Handler de l'événement
         * @param {string} [label] - Label optionnel pour debug
         * @returns {number} ID du listener
         */
        addLeafletListener(target, event, handler, label = '') {
            if (!target || typeof target.on !== 'function') {
                Log.warn(`[EventListenerManager.${this.name}] Invalid Leaflet target`);
                return null;
            }

            const id = this._nextId++;

            target.on(event, handler);

            this.listeners.push({
                id,
                target,
                event,
                handler,
                label,
                type: 'leaflet',
                createdAt: Date.now()
            });

            Log.debug(`[EventListenerManager.${this.name}] Leaflet listener added:`, id, event, label);
            return id;
        }

        /**
         * Retire un listener spécifique par ID
         * @param {number} id - ID du listener
         * @returns {boolean} True si le listener a été trouvé et retiré
         */
        removeListener(id) {
            const index = this.listeners.findIndex(l => l.id === id);
            if (index === -1) return false;

            const listener = this.listeners[index];

            if (listener.type === 'leaflet') {
                if (listener.target && typeof listener.target.off === 'function') {
                    listener.target.off(listener.event, listener.handler);
                }
            } else {
                if (listener.target && typeof listener.target.removeEventListener === 'function') {
                    listener.target.removeEventListener(listener.event, listener.handler, listener.options);
                }
            }

            this.listeners.splice(index, 1);

            Log.debug(`[EventListenerManager.${this.name}] Listener removed:`, id, listener.label);
            return true;
        }

        /**
         * Retire tous les listeners d'un élément spécifique
         * @param {Element|L.Evented} target - Élément cible
         * @returns {number} Nombre de listeners retirés
         */
        removeListenersForTarget(target) {
            const matchingListeners = this.listeners.filter(l => l.target === target);

            matchingListeners.forEach(listener => {
                if (listener.type === 'leaflet') {
                    if (listener.target && typeof listener.target.off === 'function') {
                        listener.target.off(listener.event, listener.handler);
                    }
                } else {
                    if (listener.target && typeof listener.target.removeEventListener === 'function') {
                        listener.target.removeEventListener(listener.event, listener.handler, listener.options);
                    }
                }
            });

            this.listeners = this.listeners.filter(l => l.target !== target);

            if (Log && matchingListeners.length > 0) {
                Log.info(`[EventListenerManager.${this.name}] Removed ${matchingListeners.length} listener(s) for target`);
            }

            return matchingListeners.length;
        }

        /**
         * Retire tous les listeners
         */
        removeAll() {
            const count = this.listeners.length;

            this.listeners.forEach(listener => {
                try {
                    if (listener.type === 'leaflet') {
                        if (listener.target && typeof listener.target.off === 'function') {
                            listener.target.off(listener.event, listener.handler);
                        }
                    } else {
                        if (listener.target && typeof listener.target.removeEventListener === 'function') {
                            listener.target.removeEventListener(listener.event, listener.handler, listener.options);
                        }
                    }
                } catch (error) {
                    Log.warn(`[EventListenerManager.${this.name}] Error removing listener:`, error);
                }
            });

            this.listeners = [];

            if (Log && count > 0) {
                Log.info(`[EventListenerManager.${this.name}] Removed ${count} listener(s)`);
            }
        }

        /**
         * Obtient le nombre de listeners actifs
         * @returns {number}
         */
        getCount() {
            return this.listeners.length;
        }

        /**
         * Liste tous les listeners actifs (pour debug)
         * @returns {Array}
         */
        listActiveListeners() {
            return this.listeners.map(l => ({
                id: l.id,
                event: l.event,
                label: l.label,
                type: l.type || 'dom',
                age: Date.now() - l.createdAt
            }));
        }

        /**
         * Détruit le manager et nettoie tous les listeners
         */
        destroy() {
            this.removeAll();
            Log.info(`[EventListenerManager.${this.name}] Destroyed`);
        }
    }

    /**
     * Instance globale par défaut
     */
    const globalEventManager = new EventListenerManager('global');

    /**
     * API simplifiée pour l'instance globale
     */

    // Cleanup automatique avant unload
    if (typeof window !== 'undefined') {
        window.addEventListener('beforeunload', () => {
            const count = globalEventManager.getCount();
            if (count > 0) {
                Log.warn(`[EventListenerManager] ${count} listener(s) still active at page unload`);
                globalEventManager.removeAll();
            }
        });
    }

    /**
     * API simplifiée pour l'instance globale (shortcuts sur globalEventManager)
     */
    const events = {
        /**
         * addEventListener avec tracking global
         */
        on: (target, event, handler, options, label) =>
            globalEventManager.addEventListener(target, event, handler, options, label),

        /**
         * Leaflet event listener avec tracking global
         */
        onLeaflet: (target, event, handler, label) =>
            globalEventManager.addLeafletListener(target, event, handler, label),

        /**
         * Retire un listener par ID
         */
        off: (id) => globalEventManager.removeListener(id),

        /**
         * Retire tous les listeners d'une cible
         */
        offTarget: (target) => globalEventManager.removeListenersForTarget(target),

        /**
         * Retire tous les listeners globaux
         */
        offAll: () => globalEventManager.removeAll(),

        /**
         * Obtient le nombre de listeners actifs
         */
        getCount: () => globalEventManager.getCount(),

        /**
         * Liste les listeners actifs
         */
        listActive: () => globalEventManager.listActiveListeners(),

        /**
         * Crée une nouvelle instance pour un composant
         * @param {string} name - Nom du manager
         * @returns {EventListenerManager}
         */
        createManager: (name) => new EventListenerManager(name)
    };

    /**
     * GeoLeaf - Event Bus léger (pub/sub)
     * Bus d'événements interne pour découpler les modules.
     *
     * Usage :
     *   import { bus } from './event-bus.js';
     *   const off = bus.on('poi:loaded', ({ count }) => console.log(count));
     *   bus.emit('poi:loaded', { count: 42 });
     *   off(); // désabonnement
     *
     * @module utils/event-bus
     */

    /**
     * Crée une nouvelle instance de bus d'événements.
     * @returns {{ on, off, emit, once, clear }}
     */
    function createEventBus() {
        /** @type {Map<string, Set<Function>>} */
        const _listeners = new Map();

        /**
         * Abonne un handler à un événement.
         * @param {string} event - Nom de l'événement
         * @param {Function} handler - Callback(data)
         * @returns {Function} Fonction de désabonnement
         */
        function on(event, handler) {
            if (!_listeners.has(event)) _listeners.set(event, new Set());
            _listeners.get(event).add(handler);
            return () => off(event, handler);
        }

        /**
         * Désabonne un handler d'un événement.
         * @param {string} event
         * @param {Function} handler
         */
        function off(event, handler) {
            const handlers = _listeners.get(event);
            if (handlers) handlers.delete(handler);
        }

        /**
         * Émet un événement, en passant `data` à tous les handlers abonnés.
         * @param {string} event
         * @param {*} [data]
         */
        function emit(event, data) {
            const handlers = _listeners.get(event);
            if (!handlers) return;
            handlers.forEach(h => {
                try { h(data); } catch (e) { /* isolation des erreurs */ }
            });
        }

        /**
         * Abonne un handler pour une seule exécution.
         * @param {string} event
         * @param {Function} handler
         * @returns {Function} Fonction de désabonnement
         */
        function once(event, handler) {
            const wrapper = (data) => { off(event, wrapper); handler(data); };
            return on(event, wrapper);
        }

        /**
         * Supprime tous les handlers d'un événement (ou tous si non spécifié).
         * @param {string} [event]
         */
        function clear(event) {
            if (event) { _listeners.delete(event); }
            else { _listeners.clear(); }
        }

        return { on, off, emit, once, clear };
    }

    /** Instance globale partagée */
    const bus = createEventBus();

    /**
     * @fileoverview FetchHelper - Unified HTTP client with timeout, retry, and cache strategies
     * @module GeoLeaf.Utils.FetchHelper
     *
     * Sprint 3.3: Unified fetch() implementation across codebase
     * Consolidates scattered fetch logic into one robust helper
     *
     * @version 1.0.0
     * @since Sprint 3.3 - Performance Phase
     */



    /**
     * Default configuration for fetch operations
     * @private
     */
    const DEFAULT_CONFIG$2 = {
        timeout: 10000,        // 10s timeout (was 5s in helpers.js)
        retries: 2,           // Max retry attempts
        retryDelay: 1000,     // Delay between retries (ms)
        retryDelayMultiplier: 1.5,  // Exponential backoff multiplier
        cache: 'default',     // Cache strategy
        credentials: 'same-origin', // CORS credentials
        parseResponse: true,  // Auto-parse JSON/text responses
        throwOnError: true,   // Throw on HTTP errors (4xx, 5xx)
        validateUrl: true     // Use Security.validateUrl if available
    };

    /**
     * Rate limiter — prevents excessive concurrent requests
     * @private
     */
    const _rateLimiter = {
        /** @type {Map<string, number[]>} Per-domain request timestamps */
        _requests: new Map(),
        /** Max requests per domain per window */
        maxPerDomain: 50,
        /** Time window in ms (10 seconds) */
        windowMs: 10000,

        /**
         * Check if a request to this domain is allowed.
         * @param {string} url
         * @returns {boolean}
         */
        allow(url) {
            let domain;
            try {
                domain = new URL(url, globalThis.location?.origin || 'https://localhost').hostname;
            } catch {
                domain = '_relative';
            }

            const now = Date.now();
            let timestamps = this._requests.get(domain) || [];

            // Purge old entries
            timestamps = timestamps.filter(t => now - t < this.windowMs);

            if (timestamps.length >= this.maxPerDomain) {
                return false;
            }

            timestamps.push(now);
            this._requests.set(domain, timestamps);
            return true;
        },

        /** Reset rate limiter (for testing) */
        reset() {
            this._requests.clear();
        }
    };

    /**
     * @namespace FetchHelper
     * @memberof GeoLeaf.Utils
     * @description Unified HTTP client with advanced features
     */
    const FetchHelper = {

        /**
         * Execute HTTP request with comprehensive error handling and retry logic
         *
         * @param {string} url - Request URL
         * @param {Object} [options={}] - Fetch options + FetchHelper extensions
         * @param {number} [options.timeout=10000] - Request timeout in ms
         * @param {number} [options.retries=2] - Max retry attempts
         * @param {number} [options.retryDelay=1000] - Base delay between retries
         * @param {number} [options.retryDelayMultiplier=1.5] - Exponential backoff multiplier
         * @param {boolean} [options.parseResponse=true] - Auto-parse response based on content-type
         * @param {boolean} [options.throwOnError=true] - Throw on HTTP error status
         * @param {boolean} [options.validateUrl=true] - Validate URL with Security
         * @param {Function} [options.onRetry] - Callback on retry attempt
         * @param {Function} [options.onTimeout] - Callback on timeout
         * @returns {Promise<Response|Object>} Response or parsed data
         * @throws {FetchError} Enhanced error with retry info and context
         *
         * @example
         * // Simple request
         * const data = await FetchHelper.fetch('/api/data');
         *
         * @example
         * // Advanced request with custom options
         * const result = await FetchHelper.fetch('/api/config', {
         *   method: 'POST',
         *   timeout: 5000,
         *   retries: 3,
         *   parseResponse: true,
         *   onRetry: (attempt, error) => console.log(`Retry ${attempt}:`, error.message)
         * });
         *
         * @example
         * // HEAD request for resource checking
         * const response = await FetchHelper.fetch('/resource.json', {
         *   method: 'HEAD',
         *   parseResponse: false,
         *   throwOnError: false
         * });
         */
        async fetch(url, options = {}) {
            const config = { ...DEFAULT_CONFIG$2, ...options };
            let attempt = 0;

            // Rate limiting
            if (!_rateLimiter.allow(url)) {
                throw new FetchError('Rate limit exceeded for this domain', {
                    url,
                    type: 'rate_limit_error'
                });
            }

            // URL validation
            if (config.validateUrl && Security?.validateUrl) {
                try {
                    const validation = Security.validateUrl(url);
                    if (validation && typeof validation === 'object') {
                        if (!validation.valid) {
                            throw new Error(validation.error || 'URL validation failed');
                        }
                        url = validation.url || url;
                    } else if (typeof validation === 'string') {
                        url = validation;
                    }
                } catch (error) {
                    throw new FetchError(`URL validation failed: ${error.message}`, {
                        url,
                        cause: error,
                        type: 'validation_error'
                    });
                }
            }

            // Retry loop
            while (attempt <= config.retries) {
                try {
                    const result = await this._executeRequest(url, config, attempt);

                    // Log successful request (with retry info if applicable)
                    if (Log && attempt > 0) {
                        Log.info(`[FetchHelper] ✓ ${url} (succeeded after ${attempt} retries)`);
                    }

                    return result;

                } catch (error) {
                    attempt++;

                    // If this was the last attempt, throw the error
                    if (attempt > config.retries) {
                        throw new FetchError(
                            `Request failed after ${config.retries + 1} attempts: ${error.message}`,
                            {
                                url,
                                attempts: attempt,
                                cause: error,
                                type: error.name === 'AbortError' ? 'timeout' : 'network_error'
                            }
                        );
                    }

                    // Calculate delay with exponential backoff
                    const delay = config.retryDelay * Math.pow(config.retryDelayMultiplier, attempt - 1);

                    // Call retry callback if provided
                    if (config.onRetry && typeof config.onRetry === 'function') {
                        try {
                            config.onRetry(attempt, error, delay);
                        } catch (callbackError) {
                            Log.warn('[FetchHelper] onRetry callback failed:', callbackError);
                        }
                    }

                    if (Log) {
                        Log.warn(`[FetchHelper] Retry ${attempt}/${config.retries} for ${url} in ${delay}ms (${error.message})`);
                    }

                    // Wait before retry
                    await this._delay(delay);
                }
            }
        },

        /**
         * Execute single HTTP request with timeout
         * @private
         */
        async _executeRequest(url, config, attempt) {
            // Create abort controller for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                if (config.onTimeout && typeof config.onTimeout === 'function') {
                    try {
                        config.onTimeout(url, config.timeout, attempt);
                    } catch (callbackError) {
                        Log.warn('[FetchHelper] onTimeout callback failed:', callbackError);
                    }
                }
            }, config.timeout);

            try {
                // Prepare fetch options (remove our custom options)
                const fetchOptions = { ...config };
                delete fetchOptions.timeout;
                delete fetchOptions.retries;
                delete fetchOptions.retryDelay;
                delete fetchOptions.retryDelayMultiplier;
                delete fetchOptions.parseResponse;
                delete fetchOptions.throwOnError;
                delete fetchOptions.validateUrl;
                delete fetchOptions.onRetry;
                delete fetchOptions.onTimeout;

                // Add abort signal
                fetchOptions.signal = controller.signal;

                // Execute fetch
                const response = await fetch(url, fetchOptions);

                // Clear timeout
                clearTimeout(timeoutId);

                // Handle HTTP errors
                if (!response.ok && config.throwOnError) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // Parse response if requested
                if (config.parseResponse && response.ok) {
                    return await this._parseResponse(response);
                }

                return response;

            } catch (error) {
                clearTimeout(timeoutId);

                // Enhance AbortError with more context
                if (error.name === 'AbortError') {
                    throw new Error(`Request timed out after ${config.timeout}ms`);
                }

                throw error;
            }
        },

        /**
         * Parse response based on content-type
         * @private
         */
        async _parseResponse(response) {
            const contentType = response.headers.get('content-type') || '';

            if (contentType.includes('application/json')) {
                return await response.json();
            }

            if (contentType.includes('text/') || contentType.includes('application/javascript')) {
                return await response.text();
            }

            if (contentType.startsWith('image/') || contentType.includes('application/octet-stream')) {
                return await response.blob();
            }

            // Default to text for unknown types
            return await response.text();
        },

        /**
         * Delay utility for retry logic
         * @private
         */
        async _delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        },

        /**
         * Convenience method for GET requests
         *
         * @param {string} url - Request URL
         * @param {Object} [options={}] - Request options
         * @returns {Promise} Parsed response data
         */
        async get(url, options = {}) {
            return this.fetch(url, { ...options, method: 'GET' });
        },

        /**
         * Convenience method for POST requests
         *
         * @param {string} url - Request URL
         * @param {Object} data - Request body data
         * @param {Object} [options={}] - Request options
         * @returns {Promise} Parsed response data
         */
        async post(url, data, options = {}) {
            const postOptions = {
                ...options,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                body: typeof data === 'string' ? data : JSON.stringify(data)
            };

            return this.fetch(url, postOptions);
        },

        /**
         * Convenience method for HEAD requests (check resource existence)
         *
         * @param {string} url - Request URL
         * @param {Object} [options={}] - Request options
         * @returns {Promise<Response>} Raw response (not parsed)
         */
        async head(url, options = {}) {
            return this.fetch(url, {
                ...options,
                method: 'HEAD',
                parseResponse: false
            });
        },

        /**
         * Check if resource exists (HEAD request)
         *
         * @param {string} url - Resource URL
         * @param {Object} [options={}] - Request options
         * @returns {Promise<boolean>} True if resource exists (2xx status)
         */
        async exists(url, options = {}) {
            try {
                const response = await this.head(url, {
                    ...options,
                    throwOnError: false
                });
                return response.ok;
            } catch (error) {
                Log.debug(`[FetchHelper] exists() failed for ${url}:`, error.message);
                return false;
            }
        },

        /**
         * Configure default options
         *
         * @param {Object} config - Default configuration to merge
         * @example
         * FetchHelper.configure({
         *   timeout: 15000,
         *   retries: 3
         * });
         */
        configure(config) {
            Object.assign(DEFAULT_CONFIG$2, config);
            Log.debug('[FetchHelper] Configuration updated:', DEFAULT_CONFIG$2);
        },

        /**
         * Get current default configuration
         *
         * @returns {Object} Current default config
         */
        getConfig() {
            return { ...DEFAULT_CONFIG$2 };
        }
    };

    /**
     * Enhanced Error class for fetch operations
     *
     * @class FetchError
     * @extends Error
     */
    class FetchError extends Error {
        constructor(message, context = {}) {
            super(message);
            this.name = 'FetchError';
            this.url = context.url;
            this.attempts = context.attempts;
            this.type = context.type || 'unknown';
            this.cause = context.cause;

            // Maintain stack trace
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, FetchError);
            }
        }
    }

    // Export to GeoLeaf namespace

    // Convenient aliases for common usage

    /**
     * @module GeoLeaf.Utils.Formatters
     * Formatters pour dates, nombres, distances et autres valeurs
     * Centralise tous les formatages pour cohérence et internationalisation
     *
     * @version 1.0.0
     */



    // Configuration par défaut (peut être écrasée par l'utilisateur)
    const defaultConfig = {
        locale: 'fr-FR'};

    /**
     * Formate un nombre avec séparateurs de milliers
     *
     * @param {number} value - Valeur à formater
     * @param {Object} [options={}] - Options de formatage
     * @param {string} [options.locale='fr-FR'] - Locale pour formatage
     * @param {number} [options.decimals] - Nombre de décimales (auto si non spécifié)
     * @param {number} [options.minDecimals=0] - Nombre minimum de décimales
     * @param {number} [options.maxDecimals=2] - Nombre maximum de décimales
     * @returns {string} Nombre formaté
     *
     * @example
     * formatNumber(1234567.89) // "1 234 567,89"
     * formatNumber(1234.5, { decimals: 0 }) // "1 235"
     * formatNumber(1234.5, { locale: 'en-US' }) // "1,234.5"
     */
    function formatNumber$1(value, options = {}) {
        const {
            locale = defaultConfig.locale,
            decimals = null,
            minDecimals = 0,
            maxDecimals = 2
        } = options;

        if (value == null || isNaN(value)) {
            return '0';
        }

        const formatOptions = {};

        if (decimals !== null) {
            formatOptions.minimumFractionDigits = decimals;
            formatOptions.maximumFractionDigits = decimals;
        } else {
            formatOptions.minimumFractionDigits = minDecimals;
            formatOptions.maximumFractionDigits = maxDecimals;
        }

        return value.toLocaleString(locale, formatOptions);
    }

    /**
     * Formate une taille de fichier en unités lisibles
     *
     * @param {number} bytes - Taille en bytes
     * @param {Object} [options={}] - Options de formatage
     * @param {number} [options.precision=2] - Nombre de décimales
     * @param {string} [options.locale='fr-FR'] - Locale pour formatage
     * @returns {string} Taille formatée
     *
     * @example
     * formatFileSize(1024) // "1.00 KB"
     * formatFileSize(1536000) // "1.50 MB"
     * formatFileSize(1536000, { precision: 0 }) // "1 MB"
     */
    function formatFileSize(bytes, options = {}) {
        const {
            precision = 2,
            locale = defaultConfig.locale
        } = options;

        if (bytes == null || isNaN(bytes) || bytes === 0) {
            return '0 B';
        }

        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        const k = 1024;
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        const value = bytes / Math.pow(k, i);

        const formatted = value.toLocaleString(locale, {
            minimumFractionDigits: i === 0 ? 0 : precision,
            maximumFractionDigits: i === 0 ? 0 : precision
        });

        return `${formatted} ${units[i]}`;
    }

    /**
     * GeoLeaf File Validator Module
     * Security-focused file validation for uploads
     *
     * Features:
     * - Magic bytes validation (file signature check)
     * - MIME type verification
     * - File size limits
     * - Extension whitelist
     *
     * @module utils/file-validator
     * @version 1.0.0
     */



    // ========================================
    //   CONSTANTS
    // ========================================

    /**
     * Maximum file size: 100 MB
     * @const {number}
     */
    const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100 MB

    /**
     * Magic bytes signatures for common file types
     * Each entry: [signature bytes, offset, mime type, extensions]
     * @const {Array}
     */
    const MAGIC_BYTES = [
        // Images
        { signature: [0xFF, 0xD8, 0xFF], offset: 0, mime: 'image/jpeg', extensions: ['jpg', 'jpeg'] },
        { signature: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A], offset: 0, mime: 'image/png', extensions: ['png'] },
        { signature: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61], offset: 0, mime: 'image/gif', extensions: ['gif'] },
        { signature: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61], offset: 0, mime: 'image/gif', extensions: ['gif'] },
        { signature: [0x52, 0x49, 0x46, 0x46], offset: 0, mime: 'image/webp', extensions: ['webp'], extraCheck: (bytes) => {
            // WEBP: RIFF....WEBP
            return bytes.length >= 12 && bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50;
        }},
        { signature: [0x42, 0x4D], offset: 0, mime: 'image/bmp', extensions: ['bmp'] },

        // Documents
        { signature: [0x25, 0x50, 0x44, 0x46], offset: 0, mime: 'application/pdf', extensions: ['pdf'] },

        // Archives
        { signature: [0x50, 0x4B, 0x03, 0x04], offset: 0, mime: 'application/zip', extensions: ['zip', 'kmz'] },
        { signature: [0x50, 0x4B, 0x05, 0x06], offset: 0, mime: 'application/zip', extensions: ['zip', 'kmz'] },
        { signature: [0x50, 0x4B, 0x07, 0x08], offset: 0, mime: 'application/zip', extensions: ['zip', 'kmz'] },

        // GeoJSON (JSON text file - no magic bytes, validate by parsing)
        // KML/GPX (XML text file - validate by parsing)
    ];

    /**
     * Whitelist of allowed file extensions
     * @const {Array<string>}
     */
    const ALLOWED_EXTENSIONS = [
        // Images
        'jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg',

        // Geo formats
        'geojson', 'json', 'kml', 'gpx', 'kmz',

        // Documents
        'pdf', 'txt', 'csv'
    ];

    /**
     * Whitelist of allowed MIME types
     * @const {Array<string>}
     */
    const ALLOWED_MIME_TYPES = [
        // Images
        'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/bmp', 'image/svg+xml',

        // Geo formats
        'application/json', 'application/geo+json', 'application/vnd.google-earth.kml+xml',
        'application/vnd.google-earth.kmz', 'application/gpx+xml',

        // Documents
        'application/pdf', 'text/plain', 'text/csv',

        // Archives
        'application/zip'
    ];

    // ========================================
    //   FILE VALIDATOR MODULE
    // ========================================

    const FileValidator = {
        /**
         * Validate a file for security and format compliance
         *
         * @param {File} file - File object to validate
         * @param {Object} [options] - Validation options
         * @param {number} [options.maxSize] - Max file size in bytes (default: 100 MB)
         * @param {Array<string>} [options.allowedExtensions] - Allowed extensions (default: ALLOWED_EXTENSIONS)
         * @param {Array<string>} [options.allowedMimeTypes] - Allowed MIME types (default: ALLOWED_MIME_TYPES)
         * @param {boolean} [options.checkMagicBytes=true] - Verify magic bytes signature
         * @returns {Promise<Object>} Validation result { valid: boolean, error?: string, details: {} }
         */
        async validateFile(file, options = {}) {
            const {
                maxSize = MAX_FILE_SIZE,
                allowedExtensions = ALLOWED_EXTENSIONS,
                allowedMimeTypes = ALLOWED_MIME_TYPES,
                checkMagicBytes = true
            } = options;

            const result = {
                valid: false,
                error: null,
                details: {
                    fileName: file.name,
                    fileSize: file.size,
                    mimeType: file.type,
                    extension: this._getFileExtension(file.name)
                }
            };

            try {
                // 1. Check if file exists
                if (!file) {
                    result.error = 'No file provided';
                    return result;
                }

                // 1b. Check filename for path traversal and dangerous characters
                if (file.name) {
                    const dangerousPatterns = [
                        /\.\./,              // path traversal
                        /[/\\]/,             // directory separators
                        /[\0-\x1f]/,         // eslint-disable-line no-control-regex -- control chars
                        /^\.+$/,             // only dots (., ..)
                    ];
                    for (const pattern of dangerousPatterns) {
                        if (pattern.test(file.name)) {
                            result.error = 'Filename contains dangerous characters (path traversal attempt?)';
                            Log.warn('[FileValidator] Dangerous filename rejected:', file.name.substring(0, 50));
                            return result;
                        }
                    }
                    // Max filename length
                    if (file.name.length > 255) {
                        result.error = 'Filename too long (max 255 characters)';
                        return result;
                    }
                }

                // 2. Check file size
                if (file.size > maxSize) {
                    result.error = `File size (${this._formatBytes(file.size)}) exceeds maximum allowed (${this._formatBytes(maxSize)})`;
                    Log.warn('[FileValidator] File too large:', result.error);
                    return result;
                }

                if (file.size === 0) {
                    result.error = 'File is empty';
                    return result;
                }

                // 3. Check file extension
                const extension = this._getFileExtension(file.name);
                if (!extension) {
                    result.error = 'File has no extension';
                    return result;
                }

                if (!allowedExtensions.includes(extension.toLowerCase())) {
                    result.error = `File extension '.${extension}' is not allowed. Allowed: ${allowedExtensions.join(', ')}`;
                    Log.warn('[FileValidator] Invalid extension:', result.error);
                    return result;
                }

                // 4. Check MIME type
                if (file.type && !allowedMimeTypes.includes(file.type)) {
                    result.error = `MIME type '${file.type}' is not allowed`;
                    Log.warn('[FileValidator] Invalid MIME type:', result.error);
                    return result;
                }

                // 5. Check magic bytes (file signature)
                if (checkMagicBytes && this._needsMagicBytesCheck(extension)) {
                    const magicBytesValid = await this._validateMagicBytes(file, extension);
                    if (!magicBytesValid.valid) {
                        result.error = magicBytesValid.error || 'Magic bytes validation failed';
                        Log.warn('[FileValidator] Magic bytes check failed:', result.error);
                        return result;
                    }
                    result.details.magicBytesMatch = magicBytesValid.matchedType;
                }

                // 6. Text file validation (JSON, XML, etc.)
                if (this._isTextFile(extension)) {
                    const textValid = await this._validateTextFile(file, extension);
                    if (!textValid.valid) {
                        result.error = textValid.error || 'Text file validation failed';
                        Log.warn('[FileValidator] Text file validation failed:', result.error);
                        return result;
                    }
                }

                // All checks passed
                result.valid = true;
                Log.info('[FileValidator] File validation successful:', file.name);
                return result;

            } catch (error) {
                result.error = `Validation error: ${error.message}`;
                Log.error('[FileValidator] Validation exception:', error);
                return result;
            }
        },

        /**
         * Validate magic bytes (file signature)
         *
         * @private
         * @param {File} file - File to check
         * @param {string} extension - File extension
         * @returns {Promise<Object>} { valid: boolean, error?: string, matchedType?: string }
         */
        async _validateMagicBytes(file, extension) {
            try {
                // Read first 32 bytes (enough for most signatures)
                const headerBytes = await this._readFileBytes(file, 0, 32);

                // Find matching signatures
                const matches = MAGIC_BYTES.filter(magic => {
                    // Check if extension matches
                    if (!magic.extensions.includes(extension.toLowerCase())) {
                        return false;
                    }

                    // Check signature bytes
                    for (let i = 0; i < magic.signature.length; i++) {
                        if (headerBytes[magic.offset + i] !== magic.signature[i]) {
                            return false;
                        }
                    }

                    // Extra check if defined (e.g., WEBP)
                    if (magic.extraCheck && !magic.extraCheck(headerBytes)) {
                        return false;
                    }

                    return true;
                });

                if (matches.length === 0) {
                    return {
                        valid: false,
                        error: `File signature does not match extension '.${extension}'. File may be corrupted or renamed.`
                    };
                }

                return {
                    valid: true,
                    matchedType: matches[0].mime
                };

            } catch (error) {
                return {
                    valid: false,
                    error: `Error reading file signature: ${error.message}`
                };
            }
        },

        /**
         * Validate text-based files (JSON, XML, etc.)
         *
         * @private
         * @param {File} file - File to validate
         * @param {string} extension - File extension
         * @returns {Promise<Object>} { valid: boolean, error?: string }
         */
        async _validateTextFile(file, extension) {
            try {
                const text = await this._readFileAsText(file, 1024 * 1024); // Read first 1MB

                if (extension === 'json' || extension === 'geojson') {
                    // Validate JSON syntax
                    try {
                        JSON.parse(text);
                        return { valid: true };
                    } catch (e) {
                        return {
                            valid: false,
                            error: `Invalid JSON: ${e.message}`
                        };
                    }
                }

                if (extension === 'kml' || extension === 'gpx' || extension === 'svg') {
                    // Basic XML validation
                    if (!text.trim().startsWith('<?xml') && !text.trim().startsWith('<')) {
                        return {
                            valid: false,
                            error: 'Invalid XML: File does not start with XML declaration or tag'
                        };
                    }
                }

                return { valid: true };

            } catch (error) {
                return {
                    valid: false,
                    error: `Error reading text file: ${error.message}`
                };
            }
        },

        /**
         * Read file bytes from start to end
         *
         * @private
         * @param {File} file - File to read
         * @param {number} start - Start byte position
         * @param {number} length - Number of bytes to read
         * @returns {Promise<Uint8Array>} Byte array
         */
        _readFileBytes(file, start, length) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                const blob = file.slice(start, start + length);

                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const bytes = new Uint8Array(arrayBuffer);
                    resolve(bytes);
                };

                reader.onerror = () => {
                    reject(new Error('Failed to read file bytes'));
                };

                reader.readAsArrayBuffer(blob);
            });
        },

        /**
         * Read file as text
         *
         * @private
         * @param {File} file - File to read
         * @param {number} [maxLength] - Maximum characters to read
         * @returns {Promise<string>} File text content
         */
        _readFileAsText(file, maxLength = null) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                const blob = maxLength ? file.slice(0, maxLength) : file;

                reader.onload = (e) => {
                    resolve(e.target.result);
                };

                reader.onerror = () => {
                    reject(new Error('Failed to read file as text'));
                };

                reader.readAsText(blob);
            });
        },

        /**
         * Get file extension from filename
         *
         * @private
         * @param {string} filename - File name
         * @returns {string} Extension (without dot)
         */
        _getFileExtension(filename) {
            if (!filename || typeof filename !== 'string') return '';
            const parts = filename.split('.');
            return parts.length > 1 ? parts[parts.length - 1] : '';
        },

        /**
         * Check if file extension requires magic bytes validation
         *
         * @private
         * @param {string} extension - File extension
         * @returns {boolean}
         */
        _needsMagicBytesCheck(extension) {
            const ext = extension.toLowerCase();
            // Images and PDFs need magic bytes check
            const binaryExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'pdf'];
            return binaryExtensions.includes(ext);
        },

        /**
         * Check if file is text-based
         *
         * @private
         * @param {string} extension - File extension
         * @returns {boolean}
         */
        _isTextFile(extension) {
            const ext = extension.toLowerCase();
            const textExtensions = ['json', 'geojson', 'kml', 'gpx', 'svg', 'txt', 'csv'];
            return textExtensions.includes(ext);
        },

        /**
         * Format bytes to human-readable size
         *
         * @private
         * @param {number} bytes - Byte count
         * @returns {string} Formatted size (e.g., "1.5 MB")
         */
        _formatBytes(bytes) {
            // Phase 4 dedup: delegate to Formatters.formatFileSize
            return formatFileSize(bytes, { precision: 2 });
        },

        /**
         * Get configuration constants (for testing/documentation)
         *
         * @returns {Object} Configuration object
         */
        getConfig() {
            return {
                maxFileSize: MAX_FILE_SIZE,
                allowedExtensions: [...ALLOWED_EXTENSIONS],
                allowedMimeTypes: [...ALLOWED_MIME_TYPES],
                magicBytesSignatures: MAGIC_BYTES.map(m => ({
                    mime: m.mime,
                    extensions: m.extensions
                }))
            };
        }
    };

    // ========================================
    //   EXPORT
    // ========================================

    /**
     * @fileoverview Map Helpers - Utilities for Leaflet map instance management
     * @module utils/map-helpers
     * @requires geoleaf.core
     *
     * @description
     * Provides centralized functions for retrieving and validating Leaflet map instances.
     * Eliminates duplicate map retrieval patterns across 15+ modules.
     *
     * @author GeoLeaf
     * @version 2.1.0
     * @since Phase 3 - Code Deduplication
     */

    const MapHelpers = {

        /**
         * Safely retrieves a Leaflet map instance from various sources
         *
         * @param {L.Map|null} [explicitMap=null] - Explicitly provided map instance
         * @returns {L.Map|null} The map instance or null if not found
         *
         * @description
         * Resolution order:
         * 1. Explicit map parameter (if provided and valid)
         * 2. (globalThis.GeoLeaf && globalThis.GeoLeaf.Core).getMap() (if Core module loaded)
         * 3. null (no map found)
         *
         * @example
         * // With explicit map
         * const map = MapHelpers.ensureMap(myMap);
         *
         * @example
         * // Auto-resolve from (globalThis.GeoLeaf && globalThis.GeoLeaf.Core)
         * const map = MapHelpers.ensureMap();
         * if (map) {
         *   map.setView([lat, lng], zoom);
         * }
         *
         * @example
         * // In module initialization
         * init(options = {}) {
         *   this._map = MapHelpers.ensureMap(options.map);
         *   if (!this._map) {
         *     // ...
         *   }
         * }
         */
        ensureMap(explicitMap = null) {
            // 1. Check explicit map parameter
            if (explicitMap && typeof explicitMap === "object") {
                // Validate it's a Leaflet map
                if (this._isLeafletMap(explicitMap)) {
                    return explicitMap;
                }
            }

            // 2. Try Core.getMap()
            if (Core?.getMap && typeof Core.getMap === "function") {
                const coreMap = Core.getMap();
                if (coreMap && this._isLeafletMap(coreMap)) {
                    return coreMap;
                }
            }

            // 3. No map found
            return null;
        },

        /**
         * Retrieves a Leaflet map instance and throws if not found (strict mode)
         *
         * @param {L.Map|null} [explicitMap=null] - Explicitly provided map instance
         * @param {string} [contextInfo='Unknown'] - Context for error message (module name)
         * @returns {L.Map} The map instance (never null)
         * @throws {Error} If no valid map instance found
         *
         * @description
         * Use this when map instance is REQUIRED for functionality.
         * Will throw descriptive error if map cannot be resolved.
         *
         * @example
         * // In critical initialization
         * init(options = {}) {
         *   try {
         *     this._map = MapHelpers.requireMap(options.map, 'Baselayers');
         *     this._setupControls();
         *   } catch (error) {
         *     // ...
         *   }
         * }
         *
         * @example
         * // Short form in methods
         * fitBounds(bounds) {
         *   const map = MapHelpers.requireMap(this._map, 'Table');
         *   map.fitBounds(bounds, { padding: [50, 50] });
         * }
         */
        requireMap(explicitMap = null, contextInfo = "Unknown") {
            const map = this.ensureMap(explicitMap);

            if (!map) {
                const sources = [];
                if (explicitMap !== null) sources.push("explicit parameter");
                if (Core) sources.push("(Core module)");

                throw new Error(
                    `[${contextInfo}] No Leaflet map instance found. ` +
                    `Tried: ${sources.length ? sources.join(", ") : "no sources available"}. ` +
                    `Ensure map is initialized or passed as option.`
                );
            }

            return map;
        },

        /**
         * Validates if an object is a Leaflet map instance
         *
         * @param {*} obj - Object to validate
         * @returns {boolean} True if valid Leaflet map
         *
         * @private
         * @description
         * Checks for Leaflet map duck-typing:
         * - Has getCenter() method
         * - Has setView() method
         * - Has getBounds() method
         *
         * @example
         * if (MapHelpers._isLeafletMap(obj)) {
         *   obj.setView([lat, lng], zoom);
         * }
         */
        _isLeafletMap(obj) {
            if (!obj || typeof obj !== "object") return false;

            // Duck-typing check for Leaflet map
            return (
                typeof obj.getCenter === "function" &&
                typeof obj.setView === "function" &&
                typeof obj.getBounds === "function" &&
                typeof obj.on === "function" &&
                typeof obj.off === "function"
            );
        },

        /**
         * Checks if a Leaflet map instance is currently available
         *
         * @param {L.Map|null} [explicitMap=null] - Explicitly provided map instance
         * @returns {boolean} True if map is available
         *
         * @description
         * Non-throwing version for conditional checks.
         * Useful in optional features or progressive enhancement.
         *
         * @example
         * // Conditional feature activation
         * if (MapHelpers.hasMap()) {
         *   this._enableMapFeatures();
         * } else {
         *   // ...
         * }
         *
         * @example
         * // Guard in event handlers
         * handleClick() {
         *   if (!MapHelpers.hasMap(this._map)) return;
         *   const map = MapHelpers.ensureMap(this._map);
         *   map.panTo([lat, lng]);
         * }
         */
        hasMap(explicitMap = null) {
            return this.ensureMap(explicitMap) !== null;
        },

        /**
         * Retrieves map instance with detailed diagnostic info for debugging
         *
         * @param {L.Map|null} [explicitMap=null] - Explicitly provided map instance
         * @returns {Object} Diagnostic object with map and status info
         *
         * @description
         * Returns object with:
         * - map: The map instance or null
         * - found: Boolean indicating if map was found
         * - source: Where map was found ('explicit', 'core', or 'none')
         * - isValid: Boolean indicating if map passes Leaflet validation
         *
         * @example
         * // Debug map resolution issues
         * const diagnostic = MapHelpers.getMapDiagnostic(options.map);
         * // ...
         * // {
         * //   map: L.Map {...},
         * //   found: true,
         * //   source: 'core',
         * //   isValid: true
         * // }
         */
        getMapDiagnostic(explicitMap = null) {
            const diagnostic = {
                map: null,
                found: false,
                source: "none",
                isValid: false
            };

            // Check explicit map
            if (explicitMap && typeof explicitMap === "object") {
                if (this._isLeafletMap(explicitMap)) {
                    diagnostic.map = explicitMap;
                    diagnostic.found = true;
                    diagnostic.source = "explicit";
                    diagnostic.isValid = true;
                    return diagnostic;
                }
            }

            // Check Core.getMap()
            if (Core?.getMap && typeof Core.getMap === "function") {
                const coreMap = Core.getMap();
                if (coreMap && this._isLeafletMap(coreMap)) {
                    diagnostic.map = coreMap;
                    diagnostic.found = true;
                    diagnostic.source = "core";
                    diagnostic.isValid = true;
                    return diagnostic;
                }
            }

            return diagnostic;
        }
    };

    // Export to GeoLeaf namespace

    // Convenient aliases at root level

    /**
     * GeoLeaf Performance Profiler – Baseline Storage
     * Pure storage helpers extracted from performance-profiler.js (Phase 8.2.5)
     *
     * @module utils/performance/baseline-storage
     */

    const STORAGE_KEY = 'geoleaf_performance_baseline';

    /**
     * Charge le profil de baseline depuis le storage navigateur.
     * Retourne la baseline ou null si absente / invalide.
     *
     * @param {'localStorage'|'sessionStorage'} storageType
     * @returns {Object|null}
     */
    function loadBaselineFromStorage(storageType) {
        try {
            const storage = storageType === 'localStorage' ? localStorage : sessionStorage;
            const saved = storage.getItem(STORAGE_KEY);
            if (saved) {
                return JSON.parse(saved);
            }
        } catch (_) {
            // Storage non disponible ou données corrompues
        }
        return null;
    }

    /**
     * Sauvegarde le profil de baseline dans le storage navigateur.
     *
     * @param {Object} baseline     - Objet baseline à sauvegarder
     * @param {'localStorage'|'sessionStorage'} storageType
     */
    function saveBaselineToStorage(baseline, storageType) {
        try {
            const storage = storageType === 'localStorage' ? localStorage : sessionStorage;
            storage.setItem(STORAGE_KEY, JSON.stringify(baseline));
        } catch (_) {
            // Storage non disponible
        }
    }

    /**
     * GeoLeaf Performance Profiler – DevTools Export
     * Pure DevTools trace builder extracted from performance-profiler.js (Phase 8.2.5)
     *
     * @module utils/performance/devtools-export
     */

    /**
     * Construit un objet de trace Chrome DevTools (profil JSON) à partir des
     * marks et measures collectés par `PerformanceProfiler`.
     *
     * Compatible avec l'onglet Performance de Chrome DevTools:
     * `DevTools → Performance → Load Profile → sélectionner le fichier JSON`
     *
     * @param {{ marks: Map<string, number>, measures: Map<string, number> }} data
     * @returns {{traceEvents: Array, metadata: Object}} Objet de trace DevTools
     */
    function buildDevToolsTrace({ marks, measures }) {
        const devToolsData = {
            traceEvents: [],
            metadata: {
                'cpu-family': 6,
                'cpu-model': 70,
                'cpu-stepping': 1,
                'field-name-mappings': {},
                'os-name': navigator.platform,
                'trace-capture-datetime': new Date().toISOString(),
                'user-agent': navigator.userAgent
            }
        };

        // Convert marks → Instant trace events
        marks.forEach((timestamp, name) => {
            devToolsData.traceEvents.push({
                name,
                cat: 'blink.user_timing',
                ph: 'I', // Instant event
                ts: timestamp * 1000, // µs
                pid: 1,
                tid: 1
            });
        });

        // Convert measures → Begin/End trace event pairs
        measures.forEach((duration, name) => {
            const startTime = performance.now() - duration;
            devToolsData.traceEvents.push(
                {
                    name,
                    cat: 'blink.user_timing',
                    ph: 'B', // Begin
                    ts: startTime * 1000,
                    pid: 1,
                    tid: 1
                },
                {
                    name,
                    cat: 'blink.user_timing',
                    ph: 'E', // End
                    ts: (startTime + duration) * 1000,
                    pid: 1,
                    tid: 1
                }
            );
        });

        return devToolsData;
    }

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    /**
     * @module config/debug-flag
     * @description Centralized debug mode accessor.
     *
     * Phase 10-A: Extracts the `globalThis.GeoLeaf.DEBUG` lookup into a dedicated
     * utility so modules can declare the dependency explicitly rather than
     * reading the global namespace directly.
     *
     * NOTE: This still reads `globalThis.GeoLeaf.DEBUG` at call time to support
     * the use case where end users set `window.GeoLeaf.DEBUG = true` after init.
     * A future Phase 10-D migration could replace this with a build-time replace()
     * plugin (Rollup) or a proper ESM-level init function.
     */

    /**
     * Returns whether GeoLeaf debug mode is currently active.
     * Reads the runtime flag set by end users via `window.GeoLeaf.DEBUG = true`.
     * @returns {boolean}
     */
    function getDebugMode() {
        return globalThis.GeoLeaf?.DEBUG === true;
    }

    /**
     * @fileoverview GeoLeaf Performance Profiler
     * Sprint 3.5: Advanced performance monitoring and Chrome DevTools integration
     *
     * Features:
     * - Real-time performance monitoring
     * - Memory usage tracking and leak detection
     * - Chrome DevTools integration
     * - Performance baseline establishment
     * - Automated performance regression detection
     * - Detailed profiling reports
     *
     * @version 1.0.0
     * @author GeoLeaf Team
     * @since 2026-01-17
     */


    // Perf 6.1.3: Pre-compile regex at module level to avoid re-creation in loops
    const _RE_IMAGE_EXT = /\.(jpg|jpeg|png|gif|svg|webp)$/i;

    /**
     * Performance monitoring configuration
     */
    const DEFAULT_CONFIG$1 = {
        // Monitoring intervals
        monitoring: {
            enabled: false, // Enable only in dev mode
            interval: 5000, // 5 seconds (reduced CPU overhead)
            maxDataPoints: 60 // 5 minutes of data at 5s interval
        },
        // Memory monitoring
        memory: {
            enabled: true,
            threshold: 200 * 1024 * 1024, // 200MB threshold (realistic for GeoJSON apps)
            leakDetection: true
        },
        // Performance marks
        marks: {
            enabled: true,
            autoMark: ['init', 'ready', 'firstLoad']
        },
        // Baseline
        baseline: {
            enabled: true,
            storage: 'sessionStorage' // or 'localStorage'
        }
    };

    /**
     * Performance data storage
     */
    let performanceData = {
        marks: new Map(),
        measures: new Map(),
        memory: [],
        baseline: null
    };

    /**
     * @class PerformanceProfiler
     * @description Advanced performance profiling for GeoLeaf
     */
    class PerformanceProfiler {
        constructor(config = {}) {
            this.config = this._mergeConfig(DEFAULT_CONFIG$1, config);
            this.monitoringInterval = null;
            this.baselineEstablished = false;
            // Ne pas appeler init() ici — les observers et setInterval doivent être
            // démarrés uniquement au premier accès via getPerformanceProfiler().
            // Cela évite de créer des PerformanceObserver/setInterval à l'import.
        }

        /**
         * Initialize performance profiler
         */
        init() {
            // Check if we're in development mode
            this.config.monitoring.enabled = this._isDevelopmentMode();

            this._initPerformanceObserver();
            this._loadBaseline();

            if (this.config.monitoring.enabled) {
                this._startMonitoring();
            }

            if (Log) {
                Log.info('[GeoLeaf.Utils.PerformanceProfiler] Performance profiler initialized');
            }
        }

        /**
         * Start performance monitoring
         */
        startMonitoring() {
            if (this.monitoringInterval) {
                this.stopMonitoring();
            }

            this._startMonitoring();

            if (Log) {
                Log.info('[PerformanceProfiler] Monitoring started');
            }
        }

        /**
         * Stop performance monitoring
         */
        stopMonitoring() {
            if (this.monitoringInterval) {
                clearInterval(this.monitoringInterval);
                this.monitoringInterval = null;

                if (Log) {
                    Log.info('[PerformanceProfiler] Monitoring stopped');
                }
            }
        }

        /**
         * Create performance mark
         * @param {string} name - Mark name
         */
        mark(name) {
            if (!this.config.marks.enabled) return;

            const timestamp = performance.now();

            try {
                performance.mark(name);
                performanceData.marks.set(name, timestamp);

                if (Log) {
                    Log.debug(`[PerformanceProfiler] Mark: ${name} at ${timestamp.toFixed(2)}ms`);
                }
            } catch (error) {
                if (Log) {
                    Log.warn(`[PerformanceProfiler] Failed to create mark ${name}:`, error);
                }
            }
        }

        /**
         * Create performance measure
         * @param {string} name - Measure name
         * @param {string} startMark - Start mark name
         * @param {string} [endMark] - End mark name (optional)
         * @returns {number} Duration in milliseconds
         */
        measure(name, startMark, endMark) {
            try {
                performance.measure(name, startMark, endMark);

                const entries = performance.getEntriesByName(name, 'measure');
                const latestEntry = entries[entries.length - 1];
                const duration = latestEntry ? latestEntry.duration : 0;

                performanceData.measures.set(name, duration);

                if (Log) {
                    Log.debug(`[PerformanceProfiler] Measure: ${name} = ${duration.toFixed(2)}ms`);
                }

                return duration;
            } catch (error) {
                if (Log) {
                    Log.warn(`[PerformanceProfiler] Failed to create measure ${name}:`, error);
                }
                return 0;
            }
        }

        /**
         * Get current memory usage
         * @returns {Object} Memory information
         */
        getMemoryUsage() {
            const memory = {
                timestamp: performance.now(),
                used: 0,
                total: 0,
                available: 0
            };

            try {
                if (performance.memory) {
                    memory.used = performance.memory.usedJSHeapSize;
                    memory.total = performance.memory.totalJSHeapSize;
                    memory.available = performance.memory.jsHeapSizeLimit;
                }
            } catch (error) {
                // Memory API not available
            }

            return memory;
        }

        /**
         * Analyze memory for potential leaks
         * @returns {Object} Leak analysis
         */
        analyzeMemoryLeaks() {
            if (performanceData.memory.length < 10) {
                return { status: 'insufficient_data' };
            }

            const recentData = performanceData.memory.slice(-30); // Last 30 data points
            const firstUsed = recentData[0].used;
            const lastUsed = recentData[recentData.length - 1].used;
            const growthRate = (lastUsed - firstUsed) / firstUsed;

            const analysis = {
                status: 'normal',
                growthRate: growthRate,
                memoryTrend: lastUsed > firstUsed ? 'increasing' : 'decreasing',
                recommendation: 'No action needed'
            };

            if (growthRate > 0.2) { // 20% increase
                analysis.status = 'warning';
                analysis.recommendation = 'Monitor memory usage - potential leak detected';
            }

            if (growthRate > 0.5) { // 50% increase
                analysis.status = 'critical';
                analysis.recommendation = 'Investigate memory leak - significant growth detected';
            }

            return analysis;
        }

        /**
         * Generate comprehensive performance report
         * @returns {Object} Performance report
         */
        generateReport() {
            const currentMemory = this.getMemoryUsage();
            const memoryAnalysis = this.analyzeMemoryLeaks();

            const report = {
                timestamp: new Date().toISOString(),
                session: {
                    duration: performance.now(),
                    marks: Object.fromEntries(performanceData.marks),
                    measures: Object.fromEntries(performanceData.measures)
                },
                memory: {
                    current: currentMemory,
                    peak: this._getPeakMemory(),
                    analysis: memoryAnalysis,
                    history: performanceData.memory.slice(-10) // Last 10 samples
                },
                performance: {
                    navigation: this._getNavigationTiming(),
                    paint: this._getPaintTiming(),
                    resources: this._getResourceTiming(),
                    longTasks: this._getLongTasks()
                },
                baseline: this._compareWithBaseline(),
                recommendations: this._generateRecommendations()
            };

            return report;
        }

        /**
         * Establish performance baseline
         */
        establishBaseline() {
            const baseline = {
                timestamp: new Date().toISOString(),
                navigation: this._getNavigationTiming(),
                paint: this._getPaintTiming(),
                memory: this.getMemoryUsage(),
                userAgent: navigator.userAgent,
                viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };

            performanceData.baseline = baseline;
            this.baselineEstablished = true;

            if (this.config.baseline.enabled) {
                this._saveBaseline(baseline);
            }

            if (Log) {
                Log.info('[PerformanceProfiler] Performance baseline established');
            }

            return baseline;
        }

        /**
         * Export profiling data for Chrome DevTools
         * @returns {Object} Chrome DevTools compatible data
         */
        exportForDevTools() {
            return buildDevToolsTrace(performanceData);
        }

        /**
         * Initialize performance observer
         * @private
         */
        _initPerformanceObserver() {
            if (!('PerformanceObserver' in window)) {
                return;
            }

            try {
                // Observe navigation and paint timings
                const observer = new PerformanceObserver((list) => {
                    this._processPerformanceEntries(list.getEntries());
                });

                observer.observe({ entryTypes: ['navigation', 'paint', 'measure', 'mark', 'longtask'] });

            } catch (error) {
                if (Log) {
                    Log.warn('[PerformanceProfiler] PerformanceObserver initialization failed:', error);
                }
            }
        }

        /**
         * Process performance entries
         * @private
         */
        _processPerformanceEntries(entries) {
            entries.forEach(entry => {
                switch (entry.entryType) {
                    case 'longtask':
                        if (Log) {
                            Log.warn(`[PerformanceProfiler] Long task detected: ${entry.duration.toFixed(2)}ms`);
                        }
                        break;
                    case 'measure':
                        performanceData.measures.set(entry.name, entry.duration);
                        break;
                    case 'mark':
                        performanceData.marks.set(entry.name, entry.startTime);
                        break;
                }
            });
        }

        /**
         * Start monitoring loop
         * @private
         */
        _startMonitoring() {
            this.monitoringInterval = setInterval(() => {
                this._collectPerformanceData();
            }, this.config.monitoring.interval);
        }

        /**
         * Collect performance data
         * @private
         */
        _collectPerformanceData() {
            const memory = this.getMemoryUsage();

            // Add to memory history
            performanceData.memory.push(memory);

            // Limit data points
            if (performanceData.memory.length > this.config.monitoring.maxDataPoints) {
                performanceData.memory.shift();
            }

            // Check memory threshold
            if (this.config.memory.enabled && memory.used > this.config.memory.threshold) {
                if (Log) {
                    Log.warn(`[PerformanceProfiler] Memory usage high: ${(memory.used / 1024 / 1024).toFixed(2)}MB`);
                }
            }
        }

        /**
         * Get navigation timing
         * @private
         */
        _getNavigationTiming() {
            try {
                const timing = performance.getEntriesByType('navigation')[0];
                if (!timing) return null;

                return {
                    domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
                    load: timing.loadEventEnd - timing.loadEventStart,
                    domComplete: timing.domComplete - timing.navigationStart,
                    firstByte: timing.responseStart - timing.requestStart,
                    dns: timing.domainLookupEnd - timing.domainLookupStart,
                    tcp: timing.connectEnd - timing.connectStart
                };
            } catch (error) {
                return null;
            }
        }

        /**
         * Get paint timing
         * @private
         */
        _getPaintTiming() {
            try {
                const paintEntries = performance.getEntriesByType('paint');
                const result = {};

                paintEntries.forEach(entry => {
                    result[entry.name] = entry.startTime;
                });

                return result;
            } catch (error) {
                return {};
            }
        }

        /**
         * Get resource timing
         * @private
         */
        _getResourceTiming() {
            try {
                const resources = performance.getEntriesByType('resource');
                const summary = {
                    total: resources.length,
                    scripts: 0,
                    stylesheets: 0,
                    images: 0,
                    totalSize: 0,
                    totalDuration: 0
                };

                resources.forEach(resource => {
                    if (resource.name.includes('.js')) summary.scripts++;
                    else if (resource.name.includes('.css')) summary.stylesheets++;
                    else if (_RE_IMAGE_EXT.test(resource.name)) summary.images++;

                    if (resource.transferSize) summary.totalSize += resource.transferSize;
                    summary.totalDuration += resource.duration;
                });

                return summary;
            } catch (error) {
                return { total: 0 };
            }
        }

        /**
         * Get long tasks
         * @private
         */
        _getLongTasks() {
            try {
                return performance.getEntriesByType('longtask').map(task => ({
                    duration: task.duration,
                    startTime: task.startTime
                }));
            } catch (error) {
                return [];
            }
        }

        /**
         * Get peak memory usage
         * @private
         */
        _getPeakMemory() {
            if (performanceData.memory.length === 0) {
                return this.getMemoryUsage();
            }

            return performanceData.memory.reduce((peak, current) => {
                return current.used > peak.used ? current : peak;
            });
        }

        /**
         * Compare with baseline
         * @private
         */
        _compareWithBaseline() {
            if (!performanceData.baseline) {
                return { status: 'no_baseline' };
            }

            const current = {
                navigation: this._getNavigationTiming(),
                paint: this._getPaintTiming(),
                memory: this.getMemoryUsage()
            };

            const comparison = {
                navigation: {},
                paint: {},
                memory: {},
                overall: 'similar'
            };

            // Compare navigation timing
            if (current.navigation && performanceData.baseline.navigation) {
                Object.keys(performanceData.baseline.navigation).forEach(key => {
                    const baselineValue = performanceData.baseline.navigation[key];
                    const currentValue = current.navigation[key];
                    const diff = ((currentValue - baselineValue) / baselineValue) * 100;

                    comparison.navigation[key] = {
                        baseline: baselineValue,
                        current: currentValue,
                        difference: diff,
                        status: Math.abs(diff) > 20 ? (diff > 0 ? 'worse' : 'better') : 'similar'
                    };
                });
            }

            // Compare paint timing
            Object.keys(performanceData.baseline.paint).forEach(key => {
                if (current.paint[key]) {
                    const diff = ((current.paint[key] - performanceData.baseline.paint[key]) / performanceData.baseline.paint[key]) * 100;
                    comparison.paint[key] = {
                        baseline: performanceData.baseline.paint[key],
                        current: current.paint[key],
                        difference: diff,
                        status: Math.abs(diff) > 20 ? (diff > 0 ? 'worse' : 'better') : 'similar'
                    };
                }
            });

            // Compare memory
            if (performanceData.baseline.memory.used > 0) {
                const memDiff = ((current.memory.used - performanceData.baseline.memory.used) / performanceData.baseline.memory.used) * 100;
                comparison.memory = {
                    baseline: performanceData.baseline.memory.used,
                    current: current.memory.used,
                    difference: memDiff,
                    status: Math.abs(memDiff) > 30 ? (memDiff > 0 ? 'worse' : 'better') : 'similar'
                };
            }

            return comparison;
        }

        /**
         * Generate recommendations
         * @private
         */
        _generateRecommendations() {
            const recommendations = [];
            const memoryAnalysis = this.analyzeMemoryLeaks();
            const resources = this._getResourceTiming();
            const longTasks = this._getLongTasks();

            // Memory recommendations
            if (memoryAnalysis.status === 'warning') {
                recommendations.push({
                    type: 'memory',
                    priority: 'medium',
                    message: 'Monitor memory usage - potential leak detected',
                    action: 'Check for event listener cleanup and object references'
                });
            } else if (memoryAnalysis.status === 'critical') {
                recommendations.push({
                    type: 'memory',
                    priority: 'high',
                    message: 'Critical memory usage detected',
                    action: 'Immediate investigation required - check for memory leaks'
                });
            }

            // Long task recommendations
            if (longTasks.length > 0) {
                const avgLongTask = longTasks.reduce((sum, task) => sum + task.duration, 0) / longTasks.length;
                recommendations.push({
                    type: 'performance',
                    priority: 'medium',
                    message: `${longTasks.length} long tasks detected (avg: ${avgLongTask.toFixed(2)}ms)`,
                    action: 'Consider breaking up long-running operations with setTimeout or requestIdleCallback'
                });
            }

            // Resource recommendations
            if (resources.total > 50) {
                recommendations.push({
                    type: 'resources',
                    priority: 'low',
                    message: `High number of resources loaded (${resources.total})`,
                    action: 'Consider bundling or lazy loading resources'
                });
            }

            return recommendations;
        }

        /**
         * Check if in development mode
         * @private
         */
        _isDevelopmentMode() {
            return (
                (globalThis.location && globalThis.location.hostname === 'localhost') ||
                (globalThis.location && globalThis.location.hostname === '127.0.0.1') ||
                (globalThis.location && globalThis.location.port) ||
                getDebugMode()
            );
        }

        /**
         * Load baseline from storage
         * @private
         */
        _loadBaseline() {
            if (!this.config.baseline.enabled) return;
            const saved = loadBaselineFromStorage(this.config.baseline.storage);
            if (saved) {
                performanceData.baseline = saved;
                this.baselineEstablished = true;
            }
        }

        /**
         * Save baseline to storage
         * @private
         */
        _saveBaseline(baseline) {
            saveBaselineToStorage(baseline, this.config.baseline.storage);
        }

        /**
         * Merge configuration objects
         * @private
         */
        _mergeConfig(defaultConfig, userConfig) {
            const merged = { ...defaultConfig };

            for (const key in userConfig) {
                if (typeof userConfig[key] === 'object' && !Array.isArray(userConfig[key])) {
                    merged[key] = { ...defaultConfig[key], ...userConfig[key] };
                } else {
                    merged[key] = userConfig[key];
                }
            }

            return merged;
        }
    }

    // Singleton lazy — perf 5.2 / C9: création ET initialisation différées au premier accès.
    // Le constructeur ne démarre plus d'observers/setInterval automatiquement.
    let _performanceProfilerInstance = null;

    function getPerformanceProfiler() {
        if (!_performanceProfilerInstance) {
            _performanceProfilerInstance = new PerformanceProfiler();
            // init() démarre PerformanceObserver + setInterval : uniquement ici, pas dans le constructeur
            _performanceProfilerInstance.init();
        }
        return _performanceProfilerInstance;
    }

    // Auto-establish baseline — perf 5.8: différé après load, uniquement si profiler déjà instancié
    window.addEventListener('load', () => {
        if (_performanceProfilerInstance) {
            _performanceProfilerInstance.establishBaseline();
        }
    }, { once: true });

    /**
     * @fileoverview GeoLeaf Lazy Loading Module
     * Sprint 3.4: Advanced lazy loading for modules, images, and code splitting
     *
     * Features:
     * - Module lazy loading with caching
     * - Image lazy loading with intersection observer
     * - Dynamic imports for code splitting
     * - Performance monitoring
     * - Error handling and fallbacks
     *
     * @version 1.0.0
     * @author GeoLeaf Team
     * @since 2026-01-17
     */


    // Phase 7 B2 fix: globalThis used directly (replaces legacy namespace shim from _namespace.js)
    const _g$F =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    /**
     * Lazy Loading Configuration
     */
    const DEFAULT_CONFIG = {
        // Module loading
        modules: {
            timeout: 15000,
            retries: 2,
            cacheBust: false,
        },
        // Image lazy loading
        images: {
            rootMargin: "50px",
            threshold: 0.1,
            loadingClass: "lazy-loading",
            loadedClass: "lazy-loaded",
            errorClass: "lazy-error",
        },
        // Code splitting
        chunks: {
            preload: ["core", "ui"],
            defer: ["poi", "geojson", "route", "legend"],
        },
    };

    /**
     * Module cache for loaded modules
     */
    const moduleCache = new Map();
    const loadingPromises = new Map();

    /**
     * Performance metrics
     */
    const metrics = {
        modulesLoaded: 0,
        imagesLoaded: 0,
        totalLoadTime: 0,
        errors: 0,
    };

    /**
     * @class LazyLoader
     * @description Advanced lazy loading system for GeoLeaf
     */
    class LazyLoader {
        constructor(config = {}) {
            this.config = this._mergeConfig(DEFAULT_CONFIG, config);
            this.imageObserver = null;
            this.init();
        }

        /**
         * Initialize lazy loader
         */
        init() {
            // B2 [PERF-02]: _initImageObserver() est désormais différé au premier scan()
            // via _ensureObserver() — évite une allocation IntersectionObserver inutile au boot.
            this._preloadCoreModules();

            if (Log) {
                Log.info("[GeoLeaf.Utils.LazyLoader] Lazy loading system initialized");
            }
        }

        /**
         * Lazy load a module dynamically
         * @param {string} moduleName - Module identifier
         * @param {string} modulePath - Path to module file
         * @param {Object} options - Loading options
         * @returns {Promise<Object>} Module exports
         */
        async loadModule(moduleName, modulePath, options = {}) {
            const startTime = performance.now();

            try {
                // Check cache first
                if (moduleCache.has(moduleName)) {
                    return moduleCache.get(moduleName);
                }

                // Check if already loading
                if (loadingPromises.has(moduleName)) {
                    return await loadingPromises.get(moduleName);
                }

                // Create loading promise
                const loadingPromise = this._loadModuleScript(moduleName, modulePath, options);
                loadingPromises.set(moduleName, loadingPromise);

                const result = await loadingPromise;

                // Cache and metrics
                moduleCache.set(moduleName, result);
                loadingPromises.delete(moduleName);

                const loadTime = performance.now() - startTime;
                metrics.modulesLoaded++;
                metrics.totalLoadTime += loadTime;

                if (Log) {
                    Log.info(`[LazyLoader] Module "${moduleName}" loaded in ${loadTime.toFixed(2)}ms`);
                }

                return result;
            } catch (error) {
                loadingPromises.delete(moduleName);
                metrics.errors++;

                if (Log) {
                    Log.error(`[LazyLoader] Failed to load module "${moduleName}":`, error);
                }

                throw error;
            }
        }

        /**
         * Load module dynamically via ESM import() — remplace l'ancienne injection <script>
         * B6 [DEAD-04]: _loadModuleScript() (script injection) supprimé — remplacé par import()
         * @private
         */
        async _loadModuleScript(moduleName, modulePath, options) {
            const config = { ...this.config.modules, ...options };
            const finalPath = config.cacheBust ? `${modulePath}?v=${Date.now()}` : modulePath;

            const importPromise = import(/* webpackIgnore: true */ finalPath);

            if (!config.timeout) return importPromise;

            // Timeout wrapper
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(
                    () => reject(new Error(`Module "${moduleName}" load timeout`)),
                    config.timeout
                )
            );
            return Promise.race([importPromise, timeoutPromise]);
        }

        /**
         * Extract module exports from global namespace
         * @private
         */
        _extractModuleExports(moduleName) {
            // Common patterns for GeoLeaf modules
            const patterns = [
                `GeoLeaf.${moduleName}`,
                `GeoLeaf._${moduleName}`,
                `GeoLeaf.Utils.${moduleName}`,
                moduleName,
            ];

            for (const pattern of patterns) {
                const moduleExports = this._getNestedProperty(_g$F, pattern);
                if (moduleExports) {
                    return moduleExports;
                }
            }

            // Fallback - return the module name (for modules that register themselves)
            return { name: moduleName, loaded: true };
        }

        /**
         * Get nested property from object
         * @private
         */
        _getNestedProperty(obj, path) {
            return path.split(".").reduce((current, key) => {
                return current && current[key] !== undefined ? current[key] : null;
            }, obj);
        }

        /**
         * Garantit que l'ImageObserver est initialisé avant utilisation (lazy-init)
         * B2 [PERF-02]: création différée au premier appel de scan() ou enableImageLazyLoading()
         * @private
         */
        _ensureObserver() {
            if (!this.imageObserver) {
                this._initImageObserver();
            }
        }

        /**
         * Initialize image lazy loading with Intersection Observer
         * @private
         * @note Ne pas appeler _loadAllImages() ici : la requête DOM doit être différée
         *       jusqu'au premier appel explicite de scan() / enableImageLazyLoading().
         */
        _initImageObserver() {
            if (!("IntersectionObserver" in window)) {
                // Fallback pour navigateurs anciens — pas de requête DOM ici.
                // enableImageLazyLoading() / scan() gère le fallback naturellement
                // (imageObserver === null → chargement direct dans enableImageLazyLoading).
                return;
            }

            this.imageObserver = new IntersectionObserver(
                (entries) => this._handleImageIntersection(entries),
                {
                    rootMargin: this.config.images.rootMargin,
                    threshold: this.config.images.threshold,
                }
            );
        }

        /**
         * Handle image intersection
         * @private
         */
        _handleImageIntersection(entries) {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    this._loadImage(img);
                    this.imageObserver.unobserve(img);
                }
            });
        }

        /**
         * Load a single image
         * @private
         */
        _loadImage(img) {
            const config = this.config.images;

            img.classList.add(config.loadingClass);

            const startTime = performance.now();

            const tempImg = new Image();

            tempImg.onload = () => {
                img.src = tempImg.src;
                img.classList.remove(config.loadingClass);
                img.classList.add(config.loadedClass);

                const loadTime = performance.now() - startTime;
                metrics.imagesLoaded++;

                if (Log) {
                    Log.debug(`[LazyLoader] Image loaded in ${loadTime.toFixed(2)}ms: ${img.src}`);
                }
            };

            tempImg.onerror = () => {
                img.classList.remove(config.loadingClass);
                img.classList.add(config.errorClass);
                metrics.errors++;

                if (Log) {
                    Log.warn(`[LazyLoader] Image load failed: ${tempImg.src}`);
                }
            };

            tempImg.src = img.dataset.src || img.src;
        }

        /**
         * Enable lazy loading for images
         * @param {string} selector - CSS selector for images (default: 'img[data-src]')
         */
        enableImageLazyLoading(selector = "img[data-src]") {
            this._ensureObserver(); // B2: init différé au premier appel
            const images = document.querySelectorAll(selector);

            if (this.imageObserver) {
                images.forEach((img) => this.imageObserver.observe(img));
            } else {
                // Fallback - load all images immediately
                images.forEach((img) => this._loadImage(img));
            }

            if (Log) {
                Log.info(`[LazyLoader] Enabled lazy loading for ${images.length} images`);
            }
        }

        /**
         * Scanne le DOM et active le lazy loading sur les images trouvées.
         * C'est ici que la requête DOM est effectuée — jamais dans le constructeur.
         * @param {string} [selector='img[data-src]'] - Sélecteur CSS
         * @returns {number} Nombre d'images trouvées
         */
        scan(selector = "img[data-src]") {
            this._ensureObserver(); // B2: init différé au premier appel
            const images = document.querySelectorAll(selector);
            if (images.length) {
                if (this.imageObserver) {
                    images.forEach((img) => this.imageObserver.observe(img));
                } else {
                    // Fallback : pas d'IntersectionObserver — chargement immédiat
                    images.forEach((img) => this._loadImage(img));
                }
                if (Log) {
                    Log.info(`[LazyLoader] scan() — ${images.length} image(s) trouvée(s)`);
                }
            }
            return images.length;
        }

        /**
         * Initialise le lazy loading en différant le scan jusqu'au DOMContentLoaded
         * si le DOM n'est pas encore prêt. Remplace l'auto-scan du constructeur.
         * @param {object} [options={}]
         * @param {boolean} [options.autoScan=true] - Lancer automatiquement scan()
         * @param {string} [options.selector='img[data-src]'] - Sélecteur CSS
         */
        initialize(options = {}) {
            const { autoScan = true, selector = "img[data-src]" } = options;
            if (!autoScan) return;

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => this.scan(selector), {
                    once: true,
                });
            } else {
                this.scan(selector);
            }
        }

        /**
         * Preload core modules
         * @private
         */
        _preloadCoreModules() {
            const coreModules = this.config.chunks.preload;

            coreModules.forEach((moduleName) => {
                // Only preload if not already loaded
                if (!moduleCache.has(moduleName) && this._shouldPreloadModule(moduleName)) {
                    this._preloadModule(moduleName);
                }
            });
        }

        /**
         * Check if module should be preloaded
         * @private
         */
        _shouldPreloadModule(moduleName) {
            // Check if module is already available in GeoLeaf namespace
            const moduleExists = this._extractModuleExports(moduleName);
            return !moduleExists || moduleExists.name === moduleName;
        }

        /**
         * Preload a module (non-blocking)
         * @private
         */
        _preloadModule(moduleName) {
            const modulePath = this._getModulePath(moduleName);
            if (modulePath) {
                // Create link prefetch for better performance
                const link = document.createElement("link");
                link.rel = "prefetch";
                link.href = modulePath;
                document.head.appendChild(link);

                if (Log) {
                    Log.debug(`[LazyLoader] Prefetching module: ${moduleName}`);
                }
            }
        }

        /**
         * Get module path from name
         * @private
         */
        _getModulePath(moduleName) {
            // Common GeoLeaf module paths
            const pathMap = {
                poi: "poi/add-form-orchestrator.js",
                geojson: "geojson/loader.js",
                route: "geoleaf.route.js",
                legend: "geoleaf.legend.js",
                themes: "themes/theme-loader.js",
            };

            const basePath = this._getBasePath();
            return pathMap[moduleName] ? `${basePath}/${pathMap[moduleName]}` : null;
        }

        /**
         * Get base path for GeoLeaf modules
         * @private
         */
        _getBasePath() {
            // Try to detect base path from current script
            const scripts = document.getElementsByTagName("script");
            for (const script of scripts) {
                if (script.src && script.src.includes("geoleaf")) {
                    const srcParts = script.src.split("/");
                    srcParts.pop(); // Remove filename
                    return srcParts.join("/");
                }
            }
            // Fallback
            return "./src/modules";
        }

        /**
         * Load all images immediately (fallback)
         * @private
         */
        _loadAllImages() {
            const images = document.querySelectorAll("img[data-src]");
            images.forEach((img) => this._loadImage(img));
        }

        /**
         * Get performance metrics
         * @returns {Object} Performance metrics
         */
        getMetrics() {
            return {
                ...metrics,
                averageLoadTime:
                    metrics.modulesLoaded > 0 ? metrics.totalLoadTime / metrics.modulesLoaded : 0,
            };
        }

        /**
         * Clear module cache
         */
        clearCache() {
            moduleCache.clear();
            loadingPromises.clear();

            if (Log) {
                Log.info("[LazyLoader] Module cache cleared");
            }
        }

        /**
         * Merge configuration objects
         * @private
         */
        _mergeConfig(defaultConfig, userConfig) {
            const merged = { ...defaultConfig };

            for (const key in userConfig) {
                if (typeof userConfig[key] === "object" && !Array.isArray(userConfig[key])) {
                    merged[key] = { ...defaultConfig[key], ...userConfig[key] };
                } else {
                    merged[key] = userConfig[key];
                }
            }

            return merged;
        }
    }

    // Singleton lazy — perf 5.2: création différée au premier accès
    let _lazyLoaderInstance = null;

    function getLazyLoader() {
        if (!_lazyLoaderInstance) {
            _lazyLoaderInstance = new LazyLoader();
        }
        return _lazyLoaderInstance;
    }

    // Auto-scan au démarrage via initialize() — la requête DOM est différée
    // jusqu'au DOMContentLoaded ou à la microtâche post-parsing (jamais à l'import).
    // perf 5.7 / C9: plus de querySelectorAll au niveau module.
    if (document.readyState === "loading") {
        document.addEventListener(
            "DOMContentLoaded",
            () => {
                getLazyLoader().initialize();
            },
            { once: true }
        );
    } else {
        // DOM déjà prêt : activer via microtâche pour ne pas bloquer le parsing
        Promise.resolve().then(() => getLazyLoader().initialize());
    }

    /**
     * @fileoverview TimerManager - Gestion centralisée des timers
     * Permet de tracker et nettoyer tous les setTimeout/setInterval
     * pour éviter les fuites mémoire
     *
     * @module GeoLeaf.Utils.TimerManager
     * @version 2.0.0
     * @author GeoLeaf Project
     */



    /**
     * TimerManager - Gestionnaire centralisé de timers
     * @class
     */
    class TimerManager {
        constructor(name = 'default') {
            this.name = name;
            this.timers = new Map();
            this.intervals = new Map();
            this._nextId = 1;
        }

        /**
         * Crée un setTimeout avec tracking
         * @param {Function} callback - Fonction à exécuter
         * @param {number} delay - Délai en ms
         * @param {string} [label] - Label optionnel pour debug
         * @returns {number} ID du timer
         */
        setTimeout(callback, delay, label = '') {
            const id = this._nextId++;
            const timerId = setTimeout(() => {
                try {
                    callback();
                } finally {
                    // Auto-cleanup après exécution
                    this.timers.delete(id);
                }
            }, delay);

            this.timers.set(id, {
                timerId,
                label,
                type: 'timeout',
                createdAt: Date.now(),
                delay
            });

            Log.debug(`[TimerManager.${this.name}] setTimeout created:`, id, label);
            return id;
        }

        /**
         * Crée un setInterval avec tracking
         * @param {Function} callback - Fonction à exécuter
         * @param {number} interval - Intervalle en ms
         * @param {string} [label] - Label optionnel pour debug
         * @returns {number} ID de l'interval
         */
        setInterval(callback, interval, label = '') {
            const id = this._nextId++;
            const intervalId = setInterval(() => {
                try {
                    callback();
                } catch (error) {
                    Log.error(`[TimerManager.${this.name}] Error in interval ${id}:`, error);
                }
            }, interval);

            this.intervals.set(id, {
                intervalId,
                label,
                type: 'interval',
                createdAt: Date.now(),
                interval
            });

            Log.debug(`[TimerManager.${this.name}] setInterval created:`, id, label);
            return id;
        }

        /**
         * Clear un timer spécifique
         * @param {number} id - ID du timer
         * @returns {boolean} True si le timer a été trouvé et nettoyé
         */
        clearTimeout(id) {
            const timer = this.timers.get(id);
            if (timer) {
                clearTimeout(timer.timerId);
                this.timers.delete(id);
                Log.debug(`[TimerManager.${this.name}] setTimeout cleared:`, id, timer.label);
                return true;
            }
            return false;
        }

        /**
         * Clear un interval spécifique
         * @param {number} id - ID de l'interval
         * @returns {boolean} True si l'interval a été trouvé et nettoyé
         */
        clearInterval(id) {
            const interval = this.intervals.get(id);
            if (interval) {
                clearInterval(interval.intervalId);
                this.intervals.delete(id);
                Log.debug(`[TimerManager.${this.name}] setInterval cleared:`, id, interval.label);
                return true;
            }
            return false;
        }

        /**
         * Clear tous les timers et intervals
         */
        clearAll() {
            // Clear tous les timeouts
            for (const [id, timer] of this.timers.entries()) {
                clearTimeout(timer.timerId);
            }

            // Clear tous les intervals
            for (const [id, interval] of this.intervals.entries()) {
                clearInterval(interval.intervalId);
            }

            const totalCleared = this.timers.size + this.intervals.size;
            this.timers.clear();
            this.intervals.clear();

            if (Log && totalCleared > 0) {
                Log.info(`[TimerManager.${this.name}] Cleared ${totalCleared} timer(s)`);
            }
        }

        /**
         * Obtient le nombre de timers actifs
         * @returns {{timeouts: number, intervals: number, total: number}}
         */
        getStats() {
            return {
                timeouts: this.timers.size,
                intervals: this.intervals.size,
                total: this.timers.size + this.intervals.size
            };
        }

        /**
         * Liste tous les timers actifs (pour debug)
         * @returns {Array} Liste des timers avec leurs infos
         */
        listActiveTimers() {
            const list = [];

            for (const [id, timer] of this.timers.entries()) {
                list.push({
                    id,
                    type: 'timeout',
                    label: timer.label,
                    age: Date.now() - timer.createdAt,
                    delay: timer.delay
                });
            }

            for (const [id, interval] of this.intervals.entries()) {
                list.push({
                    id,
                    type: 'interval',
                    label: interval.label,
                    age: Date.now() - interval.createdAt,
                    interval: interval.interval
                });
            }

            return list;
        }

        /**
         * Détruit le manager et nettoie tous les timers
         */
        destroy() {
            this.clearAll();
            Log.info(`[TimerManager.${this.name}] Destroyed`);
        }
    }

    /**
     * Instance globale par défaut
     */
    const globalTimerManager = new TimerManager('global');

    /**
     * API simplifiée pour l'instance globale
     */

    // Cleanup automatique avant unload de la page
    if (typeof window !== 'undefined') {
        window.addEventListener('beforeunload', () => {
            const stats = globalTimerManager.getStats();
            if (stats.total > 0) {
                Log.warn(`[TimerManager] ${stats.total} timer(s) still active at page unload`);
                globalTimerManager.clearAll();
            }
        });
    }

    /**
     * @module GeoLeaf.Utils.ObjectUtils
     * @description Utilitaires pour manipulation d'objets et accès aux propriétés imbriquées
     * @version 2.1.0
     * @since 2.1.0
     */



    /**
     * Récupère une valeur imbriquée dans un objet via un chemin de propriétés.
     * Gère les valeurs null/undefined de manière sécurisée.
     *
     * @param {Object} obj - Objet source
     * @param {string} path - Chemin vers la propriété avec notation point (ex: 'user.address.city')
     * @returns {*} Valeur trouvée ou null si le chemin n'existe pas
     *
     * @example
     * const user = { name: 'John', address: { city: 'Paris', zip: '75001' } };
     * getNestedValue(user, 'name');               // 'John'
     * getNestedValue(user, 'address.city');       // 'Paris'
     * getNestedValue(user, 'address.country');    // null
     * getNestedValue(user, 'profile.avatar');     // null
     * getNestedValue(null, 'name');               // null
     */
    function getNestedValue$1(obj, path) {
        // Validation des paramètres
        if (!obj || typeof obj !== 'object') {
            return null;
        }

        if (!path || typeof path !== 'string') {
            return null;
        }

        // Parcours du chemin
        const keys = path.split('.');
        let result = obj;

        for (const key of keys) {
            // Vérification à chaque niveau
            if (result == null) {
                return null;
            }
            result = result[key];
        }

        // Retourner null si undefined, sinon la valeur (même falsy comme 0, '', false)
        return result !== undefined ? result : null;
    }

    /**
     * Vérifie si un chemin de propriété existe dans un objet.
     *
     * @param {Object} obj - Objet source
     * @param {string} path - Chemin vers la propriété
     * @returns {boolean} True si le chemin existe, false sinon
     *
     * @example
     * const user = { name: 'John', address: { city: 'Paris' } };
     * hasNestedPath(user, 'address.city');     // true
     * hasNestedPath(user, 'address.country');  // false
     */
    function hasNestedPath(obj, path) {
        if (!obj || typeof obj !== 'object' || !path) {
            return false;
        }

        const keys = path.split('.');
        let current = obj;

        for (const key of keys) {
            if (current == null || !Object.prototype.hasOwnProperty.call(current, key)) {
                return false;
            }
            current = current[key];
        }

        return true;
    }

    /**
     * Définit une valeur dans un objet via un chemin de propriétés.
     * Crée les objets intermédiaires si nécessaire.
     *
     * @param {Object} obj - Objet cible
     * @param {string} path - Chemin vers la propriété
     * @param {*} value - Valeur à définir
     * @returns {Object} L'objet modifié
     *
     * @example
     * const user = {};
     * setNestedValue(user, 'address.city', 'Paris');
     * // user = { address: { city: 'Paris' } }
     */
    function setNestedValue(obj, path, value) {
        if (!obj || typeof obj !== 'object') {
            throw new Error('[ObjectUtils.setNestedValue] Invalid object');
        }

        if (!path || typeof path !== 'string') {
            throw new Error('[ObjectUtils.setNestedValue] Invalid path');
        }

        const keys = path.split('.');
        const lastKey = keys.pop();
        let current = obj;

        // Créer les objets intermédiaires
        for (const key of keys) {
            if (!(key in current) || typeof current[key] !== 'object') {
                current[key] = {};
            }
            current = current[key];
        }

        // Définir la valeur finale
        current[lastKey] = value;

        return obj;
    }

    // Export public

    // Alias pour compatibilité et facilité d'utilisation

    /**
     * @fileoverview Scale utilities - compute map scale and test visibility ranges
     * @module utils/scale-utils
     */



    // Cache basé sur le zoom et la latitude pour éviter des recalculs coûteux
    const _scaleCache = {
        zoom: null,
        lat: null,
        scale: null
    };

    /**
     * Calcule l'échelle (1:X) de la carte pour le zoom et la latitude actuels.
     * Retourne la valeur mise en cache si zoom/latitude inchangés.
     * @param {L.Map} map
     * @param {Object} [options]
     * @param {boolean} [options.force=false] - Ignore le cache et recalcule
     * @param {Object} [options.logger] - Logger optionnel pour debug
     * @returns {number} échelle (ex: 5000000 pour 1:5M)
     */
    function calculateMapScale(map, options = {}) {
        if (!map) return 0;

        const logger = options.logger;
        const center = map.getCenter?.();
        const zoom = map.getZoom?.();

        if (!center || typeof zoom !== "number") {
            return 0;
        }

        // Utiliser le cache si possible
        if (!options.force && _scaleCache.zoom === zoom && _scaleCache.lat === center.lat) {
            return _scaleCache.scale || 0;
        }

        const METERS_PER_PIXEL_AT_ZOOM_0 = 156543.04;
        const metersPerPixel = METERS_PER_PIXEL_AT_ZOOM_0 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);

        const METERS_PER_INCH = 0.0254;
        const DPI = 96;
        const metersPerInch = metersPerPixel * DPI;

        const scale = Math.round(metersPerInch / METERS_PER_INCH);

        _scaleCache.zoom = zoom;
        _scaleCache.lat = center.lat;
        _scaleCache.scale = scale;

        if (logger && typeof logger.debug === "function") {
            logger.debug(`[ScaleUtils] Calcul échelle: zoom=${zoom}, lat=${center.lat.toFixed(2)}, échelle=1:${scale.toLocaleString()}`);
        }

        return scale;
    }

    /**
     * Vérifie si l'échelle courante est dans l'intervalle [maxScale ; minScale].
     * @param {number} currentScale
     * @param {number|null|undefined} minScale - échelle la plus large (dézoom)
     * @param {number|null|undefined} maxScale - échelle la plus détaillée (zoom)
     * @param {Object} [logger]
     * @returns {boolean}
     */
    function isScaleInRange(currentScale, minScale, maxScale, logger) {
        const normalizedMin = (typeof minScale === "number" && minScale > 0) ? minScale : null;
        const normalizedMax = (typeof maxScale === "number" && maxScale > 0) ? maxScale : null;

        if (normalizedMin !== null && currentScale > normalizedMin) {
            if (logger && typeof logger.debug === "function") {
                logger.debug(`[ScaleUtils] ${currentScale} > minScale ${normalizedMin} → invisible (trop dézoomé)`);
            }
            return false;
        }

        if (normalizedMax !== null && currentScale < normalizedMax) {
            if (logger && typeof logger.debug === "function") {
                logger.debug(`[ScaleUtils] ${currentScale} < maxScale ${normalizedMax} → invisible (trop zoomé)`);
            }
            return false;
        }

        if (logger && typeof logger.debug === "function") {
            logger.debug(`[ScaleUtils] ${currentScale} dans [${normalizedMax ?? '∞'} ; ${normalizedMin ?? '∞'}] → visible`);
        }

        return true;
    }

    function clearScaleCache() {
        _scaleCache.zoom = null;
        _scaleCache.lat = null;
        _scaleCache.scale = null;
    }

    /**
     * globals.core.js — Bridge UMD/ESM : B1 + B2 — runtime core
     * log, errors, constants, security, utils
     *
     * @see globals.js (orchestrateur)
     * @see docs/architecture/BOOT_SEQUENCE.md
     */


    const _g$E = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};

    _g$E.GeoLeaf = _g$E.GeoLeaf || {};

    // Version injectable au build — fallback pour le dev sans build
    _g$E.GeoLeaf._version = "4.0.0"
        ;

    // ── B1 assignations ──────────────────────────────────────────────────────────
    _g$E.GeoLeaf.Log = Log;
    _g$E.GeoLeaf.Errors = Errors;
    _g$E.GeoLeaf.CONSTANTS = CONSTANTS;
    if (!_g$E.GeoLeaf.Security) _g$E.GeoLeaf.Security = {};
    Object.assign(_g$E.GeoLeaf.Security, Security);
    _g$E.GeoLeaf.Security.CSRFToken = CSRFToken;

    // ── B2 assignations ──────────────────────────────────────────────────────────
    if (!_g$E.GeoLeaf.Utils) _g$E.GeoLeaf.Utils = {};
    Object.assign(_g$E.GeoLeaf.Utils, Utils);
    _g$E.GeoLeaf.Utils.AnimationHelper = AnimationHelper;
    Object.defineProperty(_g$E.GeoLeaf.Utils, 'animationHelper', {
        get: () => getAnimationHelper(),
        configurable: true
    });
    _g$E.GeoLeaf.Utils.createElement = createElement$1;
    _g$E.GeoLeaf.Utils.DOMSecurity = DOMSecurity;
    _g$E.GeoLeaf.DOMSecurity = DOMSecurity;
    _g$E.GeoLeaf.Utils.ErrorLogger = ErrorLogger;
    _g$E.GeoLeaf.Utils.EventHelpers = EventHelpers;
    _g$E.GeoLeaf.Utils.EventListenerManager = EventListenerManager;
    _g$E.GeoLeaf.Utils.events = events;
    _g$E.GeoLeaf.Utils.globalEventManager = globalEventManager;
    _g$E.GeoLeaf.Bus = bus;
    _g$E.GeoLeaf.Utils.createEventBus = createEventBus;
    _g$E.GeoLeaf.Utils.FetchHelper = FetchHelper;
    _g$E.GeoLeaf.Utils.FetchError = FetchError;
    _g$E.GeoLeaf.Utils.FileValidator = FileValidator;
    _g$E.GeoLeaf.FileValidator = FileValidator;
    _g$E.GeoLeaf.Utils.MapHelpers = MapHelpers;
    _g$E.GeoLeaf.Utils.PerformanceProfiler = PerformanceProfiler;
    Object.defineProperty(_g$E.GeoLeaf.Utils, 'performanceProfiler', {
        get: () => getPerformanceProfiler(),
        configurable: true
    });
    _g$E.GeoLeaf.Utils.LazyLoader = LazyLoader;
    Object.defineProperty(_g$E.GeoLeaf.Utils, 'lazyLoader', {
        get: () => getLazyLoader(),
        configurable: true
    });
    _g$E.GeoLeaf.Utils.TimerManager = TimerManager;
    _g$E.GeoLeaf.Utils.ObjectUtils = { getNestedValue: getNestedValue$1, hasNestedPath, setNestedValue };
    _g$E.GeoLeaf.Utils.getNestedValue = getNestedValue$1;
    _g$E.GeoLeaf.Utils.hasNestedPath = hasNestedPath;
    _g$E.GeoLeaf.Utils.setNestedValue = setNestedValue;
    _g$E.GeoLeaf.Utils.ScaleUtils = { calculateMapScale, isScaleInRange, clearScaleCache };
    // FetchHelper shortcuts
    _g$E.GeoLeaf.fetch = FetchHelper.fetch.bind(FetchHelper);
    _g$E.GeoLeaf.get   = FetchHelper.get.bind(FetchHelper);
    _g$E.GeoLeaf.post  = FetchHelper.post.bind(FetchHelper);
    // MapHelpers shortcuts
    _g$E.GeoLeaf.ensureMap   = MapHelpers.ensureMap.bind(MapHelpers);
    _g$E.GeoLeaf.requireMap  = MapHelpers.requireMap.bind(MapHelpers);
    _g$E.GeoLeaf.hasMap      = MapHelpers.hasMap.bind(MapHelpers);
    // Animation shortcuts
    _g$E.GeoLeaf.animate  = (...args) => getAnimationHelper().animate(...args);
    _g$E.GeoLeaf.fadeIn   = (...args) => getAnimationHelper().fadeIn(...args);
    _g$E.GeoLeaf.fadeOut  = (...args) => getAnimationHelper().fadeOut(...args);
    // PerformanceProfiler shortcuts
    _g$E.GeoLeaf.mark               = (name) => getPerformanceProfiler().mark(name);
    _g$E.GeoLeaf.measure            = (name, s, e) => getPerformanceProfiler().measure(name, s, e);
    _g$E.GeoLeaf.getPerformanceReport = () => getPerformanceProfiler().generateReport();
    _g$E.GeoLeaf.establishBaseline  = () => getPerformanceProfiler().establishBaseline();
    // LazyLoader shortcuts
    _g$E.GeoLeaf.loadModule        = (name, path, opts) => getLazyLoader().loadModule(name, path, opts);
    _g$E.GeoLeaf.enableLazyImages  = (selector) => getLazyLoader().enableImageLazyLoading(selector);
    // EventHelpers shortcuts
    _g$E.GeoLeaf.dispatchEvent    = EventHelpers.dispatchCustomEvent.bind(EventHelpers);
    _g$E.GeoLeaf.dispatchMapEvent = EventHelpers.dispatchMapEvent.bind(EventHelpers);

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    /**
     * Style Resolver - Helper pour résoudre les couleurs depuis les styleRules des couches
     * Remplace l'ancien système category.style.json
     *
     * @module helpers/style-resolver
     */

    // ── Runtime reference for GeoLeaf._GeoJSONShared via globalThis (not yet ESM) ──
    const _gl$4 = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    /**
     * Récupère les couleurs d'un POI depuis les styleRules de sa couche
     * @param {Object} poi - POI avec properties.categoryId, properties.subCategoryId
     * @param {string} layerId - ID de la couche du POI
     * @returns {Object|null} - { fillColor, color } ou null si non trouvé
     */
    function getColorsFromLayerStyle(poi, layerId) {
        if (!poi || !layerId) return null;

        // Récupérer les données de la couche
        const layerData = _gl$4.GeoLeaf?._GeoJSONShared?.state?.layers?.get(layerId);
        if (!layerData) return null;

        // Récupérer le currentStyle (objet chargé en mémoire)
        const styleConfig = layerData.currentStyle;
        if (!styleConfig || !styleConfig.styleRules) return null;

        // Extraire categoryId et subCategoryId
        const categoryId = poi.categoryId || poi.category ||
            (poi.attributes && poi.attributes.categoryId) ||
            (poi.properties && poi.properties.categoryId) ||
            (poi.properties && poi.properties.category);

        const subCategoryId = poi.subCategoryId || poi.subCategory || poi.sub_category ||
            (poi.attributes && poi.attributes.subCategoryId) ||
            (poi.properties && poi.properties.subCategoryId) ||
            (poi.properties && poi.properties.sub_category);

        // Chercher dans les styleRules
        // Priorité 1 : subCategoryId
        if (subCategoryId) {
            const rule = styleConfig.styleRules.find(r =>
                r.when &&
                r.when.field === "properties.subCategoryId" &&
                r.when.value === subCategoryId
            );
            if (rule && rule.style) {
                return {
                    fillColor: rule.style.fillColor,
                    color: rule.style.color,
                    colorFill: rule.style.fillColor,
                    colorStroke: rule.style.color
                };
            }
        }

        // Priorité 2 : categoryId
        if (categoryId) {
            const rule = styleConfig.styleRules.find(r =>
                r.when &&
                r.when.field === "properties.categoryId" &&
                r.when.value === categoryId
            );
            if (rule && rule.style) {
                return {
                    fillColor: rule.style.fillColor,
                    color: rule.style.color,
                    colorFill: rule.style.fillColor,
                    colorStroke: rule.style.color
                };
            }
        }

        // Fallback : defaultStyle
        if (styleConfig.defaultStyle) {
            return {
                fillColor: styleConfig.defaultStyle.fillColor,
                color: styleConfig.defaultStyle.color,
                colorFill: styleConfig.defaultStyle.fillColor,
                colorStroke: styleConfig.defaultStyle.color
            };
        }

        return null;
    }

    /**
     * Récupère les couleurs en fonction du style actif de la couche
     * Cette fonction remplace l'ancien getCategoryStyles()
     * @param {Object} poi - POI avec _layerConfig
     * @returns {Object} - { colorFill, colorStroke, colorRoute }
     */
    function resolvePoiColors(poi) {
        const colors = {
            colorFill: null,
            colorStroke: null,
            colorRoute: null
        };

        if (!poi || !poi._layerConfig) return colors;

        const layerId = poi._layerConfig.id;
        const styleColors = getColorsFromLayerStyle(poi, layerId);

        if (styleColors) {
            colors.colorFill = styleColors.fillColor || styleColors.colorFill;
            colors.colorStroke = styleColors.color || styleColors.colorStroke;
            colors.colorRoute = styleColors.color || styleColors.colorStroke;
        }

        return colors;
    }

    /**
     * Facade objet pour rétrocompatibilité
     * @type {Object}
     */
    const StyleResolver = {
        getColorsFromLayerStyle,
        resolvePoiColors
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    /**
     * @fileoverview Validations des règles de style (styleRules, conditions, scales)
     * Extrait de style-validator.js pour réduire la complexité
     * @module validators/style-validator-rules
     */

    /**
     * Valide les styleRules (règles conditionnelles de style)
     * Vérifie la structure when/style de chaque règle et valide les conditions
     *
     * @param {Array<Object>} rules - Tableau de règles styleRules
     * @param {Object} rules[].when - Condition d'application (simple ou composée avec "all")
     * @param {Object} rules[].style - Style à appliquer si condition vraie
     * @param {Object} [rules[].legend] - Info légende optionnelle pour cette règle
     * @param {Array<Object>} errors - Tableau d'erreurs à remplir (modifié in-place)
     * @param {Array<Object>} warnings - Tableau d'avertissements à remplir (modifié in-place)
     * @param {Object} context - Contexte additionnel (profileId, layerId, etc.)
     * @returns {void} Modifie errors/warnings directement
     * @example
     * const rules = [
     *   { when: { field: 'population', operator: '>', value: 100000 }, style: { color: '#ff0000' } },
     *   { when: { all: [{ field: 'type', operator: '==', value: 'city' }] }, style: { weight: 3 } }
     * ];
     * const errors = [], warnings = [];
     * validateStyleRules(rules, errors, warnings, { layerId: 'cities' });
     */
    function validateStyleRules(rules, errors, warnings, context) {
        if (!Array.isArray(rules)) {
            errors.push({
                field: 'styleRules',
                message: `styleRules doit être un tableau`,
                context: { received: typeof rules, ...context }
            });
            return;
        }

        rules.forEach((rule, index) => {
            const ruleContext = { ...context, ruleIndex: index };

            if (typeof rule !== 'object' || rule === null) {
                errors.push({
                    field: `styleRules[${index}]`,
                    message: `La règle doit être un objet`,
                    context: ruleContext
                });
                return;
            }

            // Validation when
            if (!rule.when) {
                errors.push({
                    field: `styleRules[${index}].when`,
                    message: `Le champ 'when' est requis`,
                    context: ruleContext
                });
            } else {
                validateWhenCondition(rule.when, index, errors, warnings, ruleContext);
            }

            // Validation style
            if (!rule.style) {
                errors.push({
                    field: `styleRules[${index}].style`,
                    message: `Le champ 'style' est requis`,
                    context: ruleContext
                });
            } else if (typeof rule.style !== 'object' || rule.style === null) {
                errors.push({
                    field: `styleRules[${index}].style`,
                    message: `Le style doit être un objet`,
                    context: { received: typeof rule.style, ...ruleContext }
                });
            }

            // Validation legend (optionnel)
            if (rule.legend && typeof rule.legend !== 'object') {
                errors.push({
                    field: `styleRules[${index}].legend`,
                    message: `legend doit être un objet`,
                    context: { received: typeof rule.legend, ...ruleContext }
                });
            }
        });
    }

    /**
     * Valide la condition when d'une règle
     * Supporte conditions simples et composées avec opérateur "all" (ET logique)
     *
     * @param {Object} when - Objet de condition when
     * @param {string} [when.field] - Champ à tester (mode simple)
     * @param {string} [when.operator] - Opérateur de comparaison (mode simple)
     * @param {*} [when.value] - Valeur de référence (mode simple)
     * @param {Array<Object>} [when.all] - Tableau de conditions (mode composé, ET logique)
     * @param {number} ruleIndex - Index de la règle dans styleRules (pour messages d'erreur)
     * @param {Array<Object>} errors - Tableau d'erreurs
     * @param {Array<Object>} warnings - Tableau d'avertissements
     * @param {Object} context - Contexte
     * @returns {void}
     * @example
     * // Condition simple
     * const when1 = { field: 'population', operator: '>', value: 50000 };
     * // Condition composée (AND)
     * const when2 = { all: [
     *   { field: 'type', operator: '==', value: 'restaurant' },
     *   { field: 'rating', operator: '>=', value: 4 }
     * ]};
     */
    function validateWhenCondition(when, ruleIndex, errors, warnings, context) {
        if (typeof when !== 'object' || when === null) {
            errors.push({
                field: `styleRules[${ruleIndex}].when`,
                message: `when doit être un objet`,
                context: { received: typeof when, ...context }
            });
            return;
        }

        // Support pour conditions composées avec "all"
        if (when.all && Array.isArray(when.all)) {
            // Valider chaque condition dans le tableau "all"
            when.all.forEach((condition, condIndex) => {
                validateSimpleCondition(condition, ruleIndex, condIndex, errors, context);
            });
            return;
        }

        // Support pour conditions simples
        validateSimpleCondition(when, ruleIndex, null, errors, context);
    }

    /**
     * Valide une condition simple (field/operator/value)
     * Vérifie la présence des champs requis et la validité de l'opérateur
     *
     * @param {Object} condition - Condition à valider
     * @param {string} condition.field - Nom du champ de feature à tester (ex: 'properties.population')
     * @param {string} condition.operator - Opérateur: '==', '!=', '<', '>', '<=', '>=', 'in', 'contains'
     * @param {*} condition.value - Valeur de référence (string, number, array selon opérateur)
     * @param {number} ruleIndex - Index de la règle dans styleRules
     * @param {number|null} condIndex - Index de la condition dans "all" (null si condition simple)
     * @param {Array<Object>} errors - Tableau d'erreurs
     * @param {Object} context - Contexte
     * @returns {void}
     * @example
     * const condition = { field: 'properties.type', operator: 'in', value: ['hotel', 'restaurant'] };
     * validateSimpleCondition(condition, 0, null, errors, {});
     */
    function validateSimpleCondition(condition, ruleIndex, condIndex = null, errors, context) {
        // Champs requis
        const required = ['field', 'operator', 'value'];
        for (const field of required) {
            if (!(field in condition)) {
                const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
                errors.push({
                    field: `${prefix}.${field}`,
                    message: `Le champ '${field}' est requis dans la condition`,
                    context
                });
            }
        }

        // Validation operator
        const validOperators = ['==', '!=', '<', '>', '<=', '>=', 'in', 'contains'];
        if (condition.operator && !validOperators.includes(condition.operator)) {
            const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
            errors.push({
                field: `${prefix}.operator`,
                message: `Opérateur invalide`,
                context: { received: condition.operator, allowed: validOperators, ...context }
            });
        }

        // Validation field
        if (condition.field && typeof condition.field !== 'string') {
            const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
            errors.push({
                field: `${prefix}.field`,
                message: `field doit être une chaîne de caractères`,
                context: { received: typeof condition.field, ...context }
            });
        }
    }

    /**
     * Valide les échelles (layerScale, labelScale)
     * Vérifie la structure des objets d'échelle et la validité des valeurs min/max
     *
     * @param {Object} styleData - Données du style
     * @param {Object} [styleData.layerScale] - Échelle de visibilité de la couche
     * @param {number|null} [styleData.layerScale.minScale] - Zoom minimum (ou null = pas de limite)
     * @param {number|null} [styleData.layerScale.maxScale] - Zoom maximum (ou null = pas de limite)
     * @param {Object} [styleData.labelScale] - Échelle de visibilité des labels
     * @param {Array<Object>} errors - Tableau d'erreurs
     * @param {Array<Object>} warnings - Tableau d'avertissements
     * @param {Object} context - Contexte
     * @returns {void}
     * @example
     * const styleData = {
     *   layerScale: { minScale: 10, maxScale: 18 },  // Visible du zoom 10 à 18
     *   labelScale: { minScale: 14, maxScale: null }  // Labels visibles à partir du zoom 14
     * };
     */
    function validateScales(styleData, errors, warnings, context) {
        ['layerScale', 'labelScale'].forEach(scaleField => {
            const isRequired = scaleField === 'layerScale';

            if (!styleData[scaleField]) {
                if (isRequired) {
                    errors.push({
                        field: scaleField,
                        message: `${scaleField} est requis`,
                        context
                    });
                }
                return;
            }

            const scale = styleData[scaleField];
            if (typeof scale !== 'object' || scale === null) {
                errors.push({
                    field: scaleField,
                    message: `${scaleField} doit être un objet`,
                    context: { received: typeof scale, ...context }
                });
                return;
            }

            ['minScale', 'maxScale'].forEach(prop => {
                if (!(prop in scale)) {
                    if (isRequired) {
                        errors.push({
                            field: `${scaleField}.${prop}`,
                            message: `${prop} est requis dans ${scaleField}`,
                            context
                        });
                    }
                    return;
                }

                if (scale[prop] !== null) {
                    if (typeof scale[prop] !== 'number' || scale[prop] < 0) {
                        errors.push({
                            field: `${scaleField}.${prop}`,
                            message: `${prop} doit être un nombre >= 0 ou null`,
                            context: { received: scale[prop], ...context }
                        });
                    }
                }
            });
        });
    }

    /**
     * Valide la configuration legend
     * Vérifie la structure et les types des propriétés de légende
     *
     * @param {Object} legend - Configuration legend
     * @param {number} [legend.order] - Ordre d'affichage dans la légende (doit être entier)
     * @param {string} [legend.label] - Label à afficher dans la légende
     * @param {string} [legend.description] - Description complémentaire
     * @param {Array<Object>} errors - Tableau d'erreurs
     * @param {Array<Object>} warnings - Tableau d'avertissements
     * @param {Object} context - Contexte
     * @returns {void}
     * @example
     * const legend = { order: 1, label: 'Grandes villes', description: 'Population > 100k' };
     */
    function validateLegend(legend, errors, warnings, context) {
        if (typeof legend !== 'object' || legend === null) {
            errors.push({
                field: 'legend',
                message: `legend doit être un objet`,
                context: { received: typeof legend, ...context }
            });
            return;
        }

        if ('order' in legend && !Number.isInteger(legend.order)) {
            errors.push({
                field: 'legend.order',
                message: `order doit être un entier`,
                context: { received: legend.order, type: typeof legend.order, ...context }
            });
        }
    }

    /**
     * Facade objet pour rétrocompatibilité
     * @type {Object}
     */
    const StyleValidatorRules = {
        validateStyleRules,
        validateWhenCondition,
        validateSimpleCondition,
        validateScales,
        validateLegend
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    /**
     * Classe d'erreur pour les validations de style
     */
    class StyleValidationError extends Error {
        constructor(message, context = {}) {
            super(message);
            this.name = 'StyleValidationError';
            this.context = context;
        }
    }

    /**
     * Valide un objet de style contre le schéma JSON
     * @param {Object} styleData - Données du style à valider
     * @param {Object} context - Contexte additionnel (profileId, layerId, styleId)
     * @returns {Object} Résultat de validation { valid: boolean, errors: Array, warnings: Array }
     */
    function validateStyle(styleData, context = {}) {
        const errors = [];
        const warnings = [];

        try {
            // Validation de base: objet requis
            if (!styleData || typeof styleData !== 'object') {
                errors.push({
                    field: 'root',
                    message: 'Le style doit être un objet JSON valide',
                    context: { received: typeof styleData, ...context }
                });
                return { valid: false, errors, warnings };
            }

            // Validation des champs requis
            validateRequiredFields$1(styleData, errors, context);

            // Validation du format de l'ID
            validateId(styleData, errors, context);

            // Validation du champ label (string ou objet)
            validateLabel(styleData, errors, warnings, context);

            // Validation du style de base
            validateBaseStyle(styleData, errors, warnings, context);

            // Validation des styleRules si présentes
            if (styleData.styleRules) {
                validateStyleRules(styleData.styleRules, errors, warnings, context);
            }

            // Validation des échelles
            validateScales(styleData, errors, warnings, context);

            // Validation de la légende
            if (styleData.legend) {
                validateLegend(styleData.legend, errors, warnings, context);
            }

        } catch (error) {
            errors.push({
                field: 'validation',
                message: `Erreur inattendue lors de la validation: ${error.message}`,
                stack: error.stack,
                context
            });
        }

        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Valide les champs requis
     */
    function validateRequiredFields$1(styleData, errors, context) {
        // Vérifier l'ID (obligatoire)
        if (!('id' in styleData) || styleData.id === undefined || styleData.id === null) {
            errors.push({
                field: 'id',
                message: `Le champ requis 'id' est manquant`,
                context: { availableFields: Object.keys(styleData), ...context }
            });
        }

        // Vérifier que 'style' OU 'defaultStyle' est présent (au moins un des deux)
        const hasStyle = ('style' in styleData) && styleData.style !== undefined && styleData.style !== null;
        const hasDefaultStyle = ('defaultStyle' in styleData) && styleData.defaultStyle !== undefined && styleData.defaultStyle !== null;

        if (!hasStyle && !hasDefaultStyle) {
            errors.push({
                field: 'style',
                message: `Le champ requis 'style' ou 'defaultStyle' est manquant`,
                context: { availableFields: Object.keys(styleData), ...context }
            });
        }

        if (!('layerScale' in styleData)) {
            errors.push({
                field: 'layerScale',
                message: `Le champ requis 'layerScale' est manquant`,
                context: { availableFields: Object.keys(styleData), ...context }
            });
        }
    }

    /**
     * Valide le format de l'ID
     */
    function validateId(styleData, errors, context) {
        if (!styleData.id) return;

        // Pattern acceptant lettres (y compris accentuées), chiffres, tirets et underscores
        // \p{L} = toutes les lettres Unicode (y compris é, à, ñ, etc.)
        const idPattern = /^[\p{L}0-9_-]+$/u;
        if (typeof styleData.id !== 'string') {
            errors.push({
                field: 'id',
                message: `L'ID doit être une chaîne de caractères`,
                context: { received: typeof styleData.id, value: styleData.id, ...context }
            });
        } else if (!idPattern.test(styleData.id)) {
            errors.push({
                field: 'id',
                message: `L'ID doit contenir uniquement des lettres, chiffres, tirets et underscores`,
                context: { received: styleData.id, pattern: idPattern.toString(), ...context }
            });
        }
    }

    /**
     * Valide le champ label (peut être string ou objet de config label)
     */
    function validateLabel(styleData, errors, warnings, context) {
        if (!('label' in styleData)) return;

        const label = styleData.label;

        // String: nom d'affichage
        if (typeof label === 'string') {
            return;
        }

        // Objet: configuration de labels intégrés
        if (typeof label === 'object' && label !== null) {
            // enabled est requis
            if (!('enabled' in label)) {
                errors.push({
                    field: 'label.enabled',
                    message: `Le champ 'enabled' est requis dans la configuration de labels`,
                    context: { labelConfig: label, ...context }
                });
            } else if (typeof label.enabled !== 'boolean') {
                errors.push({
                    field: 'label.enabled',
                    message: `Le champ 'enabled' doit être un booléen`,
                    context: { received: typeof label.enabled, value: label.enabled, ...context }
                });
            }

            // Si enabled, field devrait être présent
            if (label.enabled && !label.field) {
                warnings.push({
                    field: 'label.field',
                    message: `Les labels sont activés mais aucun champ n'est spécifié`,
                    context: { labelConfig: label, ...context }
                });
            }

            // Validation font
            if (label.font) {
                validateFont(label.font, errors, warnings, context);
            }

            // Validation des couleurs
            if (label.color && !isValidHexColor(label.color)) {
                errors.push({
                    field: 'label.color',
                    message: `Couleur invalide, format attendu: #RRGGBB`,
                    context: { received: label.color, ...context }
                });
            }

            // Validation opacity
            if ('opacity' in label && (typeof label.opacity !== 'number' || label.opacity < 0 || label.opacity > 1)) {
                errors.push({
                    field: 'label.opacity',
                    message: `L'opacité doit être un nombre entre 0 et 1`,
                    context: { received: label.opacity, ...context }
                });
            }

            // Validation buffer
            if (label.buffer) {
                validateLabelComponent(label.buffer, 'label.buffer', errors, warnings, context);
            }

            // Validation background
            if (label.background) {
                validateLabelComponent(label.background, 'label.background', errors, warnings, context);
            }

            // Validation offset
            if (label.offset && typeof label.offset.distancePx !== 'undefined') {
                if (typeof label.offset.distancePx !== 'number') {
                    errors.push({
                        field: 'label.offset.distancePx',
                        message: `distancePx doit être un nombre`,
                        context: { received: typeof label.offset.distancePx, ...context }
                    });
                }
            }

            return;
        }

        // Type invalide
        errors.push({
            field: 'label',
            message: `Le champ 'label' doit être une chaîne de caractères ou un objet de configuration`,
            context: { received: typeof label, value: label, ...context }
        });
    }

    /**
     * Valide la configuration font
     */
    function validateFont(font, errors, warnings, context) {
        if (typeof font !== 'object' || font === null) {
            errors.push({
                field: 'label.font',
                message: `La configuration font doit être un objet`,
                context: { received: typeof font, ...context }
            });
            return;
        }

        if (font.sizePt !== undefined) {
            if (typeof font.sizePt !== 'number' || font.sizePt < 1) {
                errors.push({
                    field: 'label.font.sizePt',
                    message: `sizePt doit être un nombre >= 1`,
                    context: { received: font.sizePt, ...context }
                });
            }
        }

        if (font.weight !== undefined) {
            if (!Number.isInteger(font.weight) || font.weight < 0 || font.weight > 100) {
                errors.push({
                    field: 'label.font.weight',
                    message: `weight doit être un entier entre 0 et 100`,
                    context: { received: font.weight, ...context }
                });
            }
        }
    }

    /**
     * Valide un composant de label (buffer, background)
     */
    function validateLabelComponent(component, fieldPath, errors, warnings, context) {
        if (typeof component !== 'object' || component === null) {
            errors.push({
                field: fieldPath,
                message: `${fieldPath} doit être un objet`,
                context: { received: typeof component, ...context }
            });
            return;
        }

        if (component.color && !isValidHexColor(component.color)) {
            errors.push({
                field: `${fieldPath}.color`,
                message: `Couleur invalide, format attendu: #RRGGBB`,
                context: { received: component.color, ...context }
            });
        }

        if ('opacity' in component && (typeof component.opacity !== 'number' || component.opacity < 0 || component.opacity > 1)) {
            errors.push({
                field: `${fieldPath}.opacity`,
                message: `L'opacité doit être un nombre entre 0 et 1`,
                context: { received: component.opacity, ...context }
            });
        }

        if ('sizePx' in component && (typeof component.sizePx !== 'number' || component.sizePx < 0)) {
            errors.push({
                field: `${fieldPath}.sizePx`,
                message: `sizePx doit être un nombre >= 0`,
                context: { received: component.sizePx, ...context }
            });
        }
    }

    /**
     * Valide le style de base
     */
    function validateBaseStyle(styleData, errors, warnings, context) {
        const style = styleData.style || styleData.defaultStyle;

        if (!style) return;

        if (typeof style !== 'object' || style === null) {
            errors.push({
                field: 'style',
                message: `Le style doit être un objet`,
                context: { received: typeof style, ...context }
            });
            return;
        }

        // Validation des couleurs
        ['fillColor', 'color'].forEach(colorField => {
            if (style[colorField] && !isValidHexColor(style[colorField])) {
                errors.push({
                    field: `style.${colorField}`,
                    message: `Couleur invalide, format attendu: #RRGGBB`,
                    context: { received: style[colorField], ...context }
                });
            }
        });

        // Validation des opacités
        ['fillOpacity', 'opacity'].forEach(opacityField => {
            if (opacityField in style) {
                if (typeof style[opacityField] !== 'number' || style[opacityField] < 0 || style[opacityField] > 1) {
                    errors.push({
                        field: `style.${opacityField}`,
                        message: `${opacityField} doit être un nombre entre 0 et 1`,
                        context: { received: style[opacityField], ...context }
                    });
                }
            }
        });

        // Validation des tailles
        ['weight', 'sizePx', 'radius'].forEach(sizeField => {
            if (sizeField in style) {
                if (typeof style[sizeField] !== 'number' || style[sizeField] < 0) {
                    errors.push({
                        field: `style.${sizeField}`,
                        message: `${sizeField} doit être un nombre >= 0`,
                        context: { received: style[sizeField], ...context }
                    });
                }
            }
        });

        // Validation shape (points)
        if (style.shape && !['circle', 'square'].includes(style.shape)) {
            errors.push({
                field: 'style.shape',
                message: `shape doit être 'circle' ou 'square'`,
                context: { received: style.shape, allowed: ['circle', 'square'], ...context }
            });
        }

        // Validation stroke (lignes)
        if (style.stroke) {
            validateStroke(style.stroke, errors, warnings, context);
        }

        // Validation casing (lignes)
        if (style.casing) {
            validateCasing(style.casing, errors, warnings, context);
        }

        // Validation fillPattern (polygones)
        if (style.fillPattern) {
            validateFillPattern(style.fillPattern, errors, warnings, context);
        }
    }

    /**
     * Valide le stroke (lignes)
     */
    function validateStroke(stroke, errors, warnings, context) {
        if (typeof stroke !== 'object' || stroke === null) {
            errors.push({
                field: 'style.stroke',
                message: `stroke doit être un objet`,
                context: { received: typeof stroke, ...context }
            });
            return;
        }

        if (stroke.color && !isValidHexColor(stroke.color)) {
            errors.push({
                field: 'style.stroke.color',
                message: `Couleur invalide, format attendu: #RRGGBB`,
                context: { received: stroke.color, ...context }
            });
        }

        if ('opacity' in stroke && (typeof stroke.opacity !== 'number' || stroke.opacity < 0 || stroke.opacity > 1)) {
            errors.push({
                field: 'style.stroke.opacity',
                message: `opacity doit être un nombre entre 0 et 1`,
                context: { received: stroke.opacity, ...context }
            });
        }

        if ('weight' in stroke && (typeof stroke.weight !== 'number' || stroke.weight < 0)) {
            errors.push({
                field: 'style.stroke.weight',
                message: `weight doit être un nombre >= 0`,
                context: { received: stroke.weight, ...context }
            });
        }

        if (stroke.dashArray !== null && stroke.dashArray !== undefined && typeof stroke.dashArray !== 'string') {
            errors.push({
                field: 'style.stroke.dashArray',
                message: `dashArray doit être une chaîne de caractères ou null`,
                context: { received: typeof stroke.dashArray, value: stroke.dashArray, ...context }
            });
        }
    }

    /**
     * Valide le casing (lignes)
     */
    function validateCasing(casing, errors, warnings, context) {
        if (typeof casing !== 'object' || casing === null) {
            errors.push({
                field: 'style.casing',
                message: `casing doit être un objet`,
                context: { received: typeof casing, ...context }
            });
            return;
        }

        if ('enabled' in casing && typeof casing.enabled !== 'boolean') {
            errors.push({
                field: 'style.casing.enabled',
                message: `enabled doit être un booléen`,
                context: { received: typeof casing.enabled, ...context }
            });
        }

        if (casing.color && !isValidHexColor(casing.color)) {
            errors.push({
                field: 'style.casing.color',
                message: `Couleur invalide, format attendu: #RRGGBB`,
                context: { received: casing.color, ...context }
            });
        }
    }

    /**
     * Valide le fillPattern (polygones)
     */
    function validateFillPattern(pattern, errors, warnings, context) {
        if (typeof pattern !== 'object' || pattern === null) {
            errors.push({
                field: 'style.fillPattern',
                message: `fillPattern doit être un objet`,
                context: { received: typeof pattern, ...context }
            });
            return;
        }

        if ('enabled' in pattern && typeof pattern.enabled !== 'boolean') {
            errors.push({
                field: 'style.fillPattern.enabled',
                message: `enabled doit être un booléen`,
                context: { received: typeof pattern.enabled, ...context }
            });
        }

        if (pattern.type && !['diagonal', 'horizontal', 'vertical', 'cross', 'x'].includes(pattern.type)) {
            errors.push({
                field: 'style.fillPattern.type',
                message: `type doit être parmi: diagonal, horizontal, vertical, cross, x`,
                context: { received: pattern.type, allowed: ['diagonal', 'horizontal', 'vertical', 'cross', 'x'], ...context }
            });
        }

        if (pattern.color && !isValidHexColor(pattern.color)) {
            errors.push({
                field: 'style.fillPattern.color',
                message: `Couleur invalide, format attendu: #RRGGBB`,
                context: { received: pattern.color, ...context }
            });
        }

        ['weight', 'density'].forEach(field => {
            if (field in pattern && (typeof pattern[field] !== 'number' || pattern[field] < 0)) {
                errors.push({
                    field: `style.fillPattern.${field}`,
                    message: `${field} doit être un nombre >= 0`,
                    context: { received: pattern[field], ...context }
                });
            }
        });
    }

    /**
     * Vérifie si une couleur est au format hex valide (#RRGGBB)
     */
    function isValidHexColor(color) {
        return typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color);
    }

    /**
     * Formate un résultat de validation en message d'erreur lisible
     * @param {Object} validationResult - Résultat de validateStyle()
     * @param {string} styleFilePath - Chemin du fichier de style (optionnel)
     * @returns {string} Message formaté
     */
    function formatValidationErrors(validationResult, styleFilePath = '') {
        if (validationResult.valid) {
            return null;
        }

        const lines = [];
        lines.push('═══════════════════════════════════════════════════════');
        lines.push('❌ ERREUR DE VALIDATION DE STYLE GEOLEAF');
        lines.push('═══════════════════════════════════════════════════════');

        if (styleFilePath) {
            lines.push(`Fichier: ${styleFilePath}`);
            lines.push('');
        }

        if (validationResult.errors.length > 0) {
            lines.push(`❌ ${validationResult.errors.length} erreur(s) détectée(s):`);
            lines.push('');

            validationResult.errors.forEach((error, index) => {
                lines.push(`  ${index + 1}. Champ: ${error.field}`);
                lines.push(`     Message: ${error.message}`);
                if (error.context) {
                    lines.push(`     Contexte: ${JSON.stringify(error.context, null, 2).split('\n').join('\n     ')}`);
                }
                if (error.stack) {
                    lines.push(`     Stack: ${error.stack.split('\n').slice(0, 3).join('\n     ')}`);
                }
                lines.push('');
            });
        }

        if (validationResult.warnings.length > 0) {
            lines.push(`⚠️  ${validationResult.warnings.length} avertissement(s):`);
            lines.push('');

            validationResult.warnings.forEach((warning, index) => {
                lines.push(`  ${index + 1}. Champ: ${warning.field}`);
                lines.push(`     Message: ${warning.message}`);
                if (warning.context) {
                    lines.push(`     Contexte: ${JSON.stringify(warning.context, null, 2).split('\n').join('\n     ')}`);
                }
                lines.push('');
            });
        }

        lines.push('═══════════════════════════════════════════════════════');
        lines.push('💡 Conseil: Vérifiez la documentation dans docs/STYLE_FORMAT_SPEC.md');
        lines.push('═══════════════════════════════════════════════════════');

        return lines.join('\n');
    }

    /**
     * Module Style Validator
     * Expose les fonctions publiques
     */
    const StyleValidator = {
        validateStyle,
        formatValidationErrors,
        StyleValidationError
    };

    /**
     * @fileoverview Abstract Renderer Base Class
     * @description Base class providing common functionality for all renderers
     * @version 1.0.0
     * @phase Phase 5 - Code Optimization
     *
     * @author GeoLeaf Team
     * @since 3.1.0
     *
     * @benefits
     * - Eliminates ~20% code duplication across renderers
     * - Unified dependency resolution pattern
     * - Consistent error handling and logging
     * - Easier testing and maintenance
     */

    // Lazy access to GeoLeaf namespace (globalThis fallback for non-ESM consumers)
    const _gl$3 = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    /**
     * @class AbstractRenderer
     * @description Base class for all renderer implementations
     *
     * Common Patterns Extracted:
     * - Dependency resolution (Log, Security, Config, Utils)
     * - DOM element creation helpers
     * - Event handler registration/cleanup
     * - State management
     * - Error handling and logging
     *
     * @example
     * class MyCustomRenderer extends AbstractRenderer {
     *     constructor(options) {
     *         super(options);
     *         this.init();
     *     }
     *
     *     render(data) {
     *         this.log('info', 'Rendering data', data);
     *         const element = this.createElement('div', 'my-class');
     *         // ... custom rendering logic
     *         return element;
     *     }
     * }
     */
    class AbstractRenderer {
        /**
         * @constructor
         * @param {Object} [options={}] - Renderer configuration options
         * @param {string} [options.name='Renderer'] - Renderer name for logging
         * @param {Object} [options.config={}] - Custom configuration
         * @param {boolean} [options.debug=false] - Enable debug logging
         */
        constructor(options = {}) {
            /**
             * @private
             * @type {string}
             */
            this._name = options.name || 'Renderer';

            /**
             * @private
             * @type {Object}
             */
            this._config = options.config || {};

            /**
             * @private
             * @type {boolean}
             */
            this._debug = options.debug || false;

            /**
             * @private
             * @type {Array<Function>}
             */
            this._eventListeners = [];

            /**
             * @private
             * @type {boolean}
             */
            this._initialized = false;

            /**
             * @private
             * @type {WeakMap<HTMLElement, Object>}
             */
            this._stateMap = new WeakMap();
        }

        // ========================================
        //   DEPENDENCY RESOLUTION
        // ========================================

        /**
         * Get Log utility with fallback
         * @protected
         * @returns {Object} Log object
         */
        getLog() {
            return _gl$3.GeoLeaf && _gl$3.GeoLeaf.Log ? _gl$3.GeoLeaf.Log : console;
        }

        /**
         * Get Security utilities with fallback
         * @protected
         * @returns {Object} Security object with escapeHtml function
         */
        getSecurity() {
            if (_gl$3.GeoLeaf && _gl$3.GeoLeaf.Security && typeof _gl$3.GeoLeaf.Security.escapeHtml === 'function') {
                return _gl$3.GeoLeaf.Security;
            }
            // Fallback security utilities
            return {
                escapeHtml: (str) => {
                    if (str == null) return '';
                    const div = document.createElement('div');
                    div.textContent = String(str);
                    return div.innerHTML;
                },
                setSafeHTML: (element, html) => {
                    if (!element) return;
                    if (_gl$3.GeoLeaf && _gl$3.GeoLeaf.DOMSecurity && typeof _gl$3.GeoLeaf.DOMSecurity.setSafeHTML === 'function') {
                        _gl$3.GeoLeaf.DOMSecurity.setSafeHTML(element, html);
                    } else {
                        element.textContent = html; // Safe fallback
                    }
                }
            };
        }

        /**
         * Get Utils with field resolution
         * @protected
         * @returns {Object} Utils object with resolveField function
         */
        getUtils() {
            if (_gl$3.GeoLeaf && _gl$3.GeoLeaf.Utils && typeof _gl$3.GeoLeaf.Utils.resolveField === 'function') {
                return _gl$3.GeoLeaf.Utils;
            }
            // Fallback resolveField implementation
            return {
                resolveField: (obj, ...paths) => {
                    if (!obj) return null;
                    for (const path of paths) {
                        if (!path) continue;
                        const parts = String(path).split('.');
                        let current = obj;
                        let found = true;
                        for (const part of parts) {
                            if (current && typeof current === 'object' && part in current) {
                                current = current[part];
                            } else {
                                found = false;
                                break;
                            }
                        }
                        if (found && current !== undefined && current !== null) {
                            return current;
                        }
                    }
                    return null;
                }
            };
        }

        /**
         * Get active profile configuration
         * @protected
         * @returns {Object|null} Active profile or null
         */
        getActiveProfile() {
            if (_gl$3.GeoLeaf && _gl$3.GeoLeaf.Config && typeof _gl$3.GeoLeaf.Config.getActiveProfile === 'function') {
                return _gl$3.GeoLeaf.Config.getActiveProfile() || null;
            }
            return null;
        }

        // ========================================
        //   LOGGING UTILITIES
        // ========================================

        /**
         * Log message with level
         * @protected
         * @param {string} level - Log level (debug, info, warn, error)
         * @param {string} message - Log message
         * @param {...*} args - Additional arguments
         */
        log(level, message, ...args) {
            if (level === 'debug' && !this._debug) return;

            const log = this.getLog();
            const prefix = `[${this._name}]`;

            switch (level) {
                case 'debug':
                case 'info':
                    log.info(prefix, message, ...args);
                    break;
                case 'warn':
                    log.warn(prefix, message, ...args);
                    break;
                case 'error':
                    log.error(prefix, message, ...args);
                    break;
                default:
                    log.info(prefix, message, ...args);
            }
        }

        /**
         * Log debug message (if debug enabled)
         * @protected
         * @param {string} message - Debug message
         * @param {...*} args - Additional arguments
         */
        debug(message, ...args) {
            this.log('debug', message, ...args);
        }

        /**
         * Log info message
         * @protected
         * @param {string} message - Info message
         * @param {...*} args - Additional arguments
         */
        info(message, ...args) {
            this.log('info', message, ...args);
        }

        /**
         * Log warning message
         * @protected
         * @param {string} message - Warning message
         * @param {...*} args - Additional arguments
         */
        warn(message, ...args) {
            this.log('warn', message, ...args);
        }

        /**
         * Log error message
         * @protected
         * @param {string} message - Error message
         * @param {...*} args - Additional arguments
         */
        error(message, ...args) {
            this.log('error', message, ...args);
        }

        // ========================================
        //   DOM BUILDERS
        // ========================================

        /**
         * Create DOM element with class and attributes
         * @protected
         * @param {string} tagName - HTML tag name
         * @param {string|Array<string>} [className] - CSS class name(s)
         * @param {Object} [attributes={}] - HTML attributes
         * @returns {HTMLElement} Created element
         *
         * @example
         * const div = this.createElement('div', 'my-class', { id: 'my-id', 'data-value': '123' });
         * const button = this.createElement('button', ['btn', 'btn-primary'], { type: 'button' });
         */
        createElement(tagName, className, attributes = {}) {
            const element = document.createElement(tagName);

            if (className) {
                if (Array.isArray(className)) {
                    element.classList.add(...className);
                } else {
                    element.className = className;
                }
            }

            Object.keys(attributes).forEach(key => {
                element.setAttribute(key, attributes[key]);
            });

            return element;
        }

        /**
         * Create text node with safe content
         * @protected
         * @param {string} text - Text content
         * @returns {Text} Text node
         */
        createTextNode(text) {
            return document.createTextNode(text || '');
        }

        /**
         * Create element with safe text content
         * @protected
         * @param {string} tagName - HTML tag name
         * @param {string} text - Text content
         * @param {string} [className] - CSS class name
         * @returns {HTMLElement} Element with text
         */
        createTextElement(tagName, text, className) {
            const element = this.createElement(tagName, className);
            element.textContent = text || '';
            return element;
        }

        /**
         * Create element with safe HTML content
         * @protected
         * @param {string} tagName - HTML tag name
         * @param {string} html - HTML content (will be sanitized)
         * @param {string} [className] - CSS class name
         * @returns {HTMLElement} Element with HTML
         */
        createHTMLElement(tagName, html, className) {
            const element = this.createElement(tagName, className);
            const security = this.getSecurity();
            security.setSafeHTML(element, html);
            return element;
        }

        /**
         * Append multiple children to parent element
         * @protected
         * @param {HTMLElement} parent - Parent element
         * @param {...HTMLElement} children - Child elements to append
         * @returns {HTMLElement} Parent element (for chaining)
         */
        appendChildren(parent, ...children) {
            children.forEach(child => {
                if (child) parent.appendChild(child);
            });
            return parent;
        }

        // ========================================
        //   EVENT HANDLING
        // ========================================

        /**
         * Register event listener with automatic cleanup
         * @protected
         * @param {HTMLElement} element - Target element
         * @param {string} event - Event name
         * @param {Function} handler - Event handler
         * @param {Object} [options] - Event listener options
         * @returns {Function} Cleanup function
         */
        addEventListener(element, event, handler, options) {
            if (!element || !event || !handler) {
                this.warn('addEventListener: invalid parameters');
                return () => {};
            }

            const boundHandler = handler.bind(this);
            element.addEventListener(event, boundHandler, options);

            // Store for cleanup
            const cleanup = () => {
                element.removeEventListener(event, boundHandler, options);
            };
            this._eventListeners.push(cleanup);

            return cleanup;
        }

        /**
         * Remove all registered event listeners
         * @protected
         */
        removeAllEventListeners() {
            this._eventListeners.forEach(cleanup => cleanup());
            this._eventListeners = [];
        }

        // ========================================
        //   STATE MANAGEMENT
        // ========================================

        /**
         * Set element state
         * @protected
         * @param {HTMLElement} element - Element to store state for
         * @param {Object} state - State data
         */
        setState(element, state) {
            if (element) {
                this._stateMap.set(element, { ...state });
            }
        }

        /**
         * Get element state
         * @protected
         * @param {HTMLElement} element - Element to get state from
         * @returns {Object|null} Element state or null
         */
        getState(element) {
            return element ? this._stateMap.get(element) || null : null;
        }

        /**
         * Update element state (merge with existing)
         * @protected
         * @param {HTMLElement} element - Element to update state for
         * @param {Object} updates - State updates to merge
         */
        updateState(element, updates) {
            if (element) {
                const currentState = this.getState(element) || {};
                this.setState(element, { ...currentState, ...updates });
            }
        }

        /**
         * Delete element state
         * @protected
         * @param {HTMLElement} element - Element to delete state for
         */
        deleteState(element) {
            if (element) {
                this._stateMap.delete(element);
            }
        }

        // ========================================
        //   LIFECYCLE METHODS
        // ========================================

        /**
         * Initialize renderer (called in constructor or manually)
         * Override in subclasses for custom initialization
         * @protected
         */
        init() {
            if (this._initialized) {
                this.warn('Renderer already initialized');
                return;
            }

            this.debug('Initializing renderer');
            this._initialized = true;
        }

        /**
         * Check if renderer is initialized
         * @public
         * @returns {boolean} true if initialized
         */
        isInitialized() {
            return this._initialized;
        }

        /**
         * Destroy renderer and cleanup resources
         * @public
         */
        destroy() {
            this.debug('Destroying renderer');
            this.removeAllEventListeners();
            this._stateMap = new WeakMap();
            this._initialized = false;
        }

        // ========================================
        //   ABSTRACT METHODS (to be overridden)
        // ========================================

        /**
         * Render content (must be implemented by subclasses)
         * @abstract
         * @param {*} data - Data to render
         * @param {Object} [options] - Render options
         * @returns {HTMLElement|string|null} Rendered content
         * @throws {Error} If not implemented
         */
        render(data, options) {
            throw new Error(`${this._name}.render() must be implemented by subclass`);
        }
    }

    /**
     * @fileoverview Example Renderer Implementation using AbstractRenderer
     * @description Demonstrates how to extend AbstractRenderer base class
     * @version 1.0.0
     * @phase Phase 5 - Code Optimization
     *
     * @example Usage
     * ```javascript
     * const renderer = new GeoLeaf._Renderers.SimpleTextRenderer({
     *     name: 'SimpleTextRenderer',
     *     debug: true
     * });
     *
     * const element = renderer.render({
     *     title: 'Hello World',
     *     description: 'This is a test'
     * });
     *
     * document.body.appendChild(element);
     * ```
     */

    /**
     * @class SimpleTextRenderer
     * @extends AbstractRenderer
     * @description Simple renderer for text-based POI information
     *
     * Shows how to:
     * - Extend AbstractRenderer
     * - Use inherited utilities (createElement, log, etc.)
     * - Implement render() method
     * - Leverage dependency resolution
     * - Use state management
     * - Handle events with automatic cleanup
     */
    class SimpleTextRenderer extends AbstractRenderer {
        /**
         * @constructor
         * @param {Object} [options={}] - Renderer options
         * @param {boolean} [options.showIcon=true] - Show icon in title
         * @param {string} [options.theme='light'] - Theme (light/dark)
         */
        constructor(options = {}) {
            super({
                name: 'SimpleTextRenderer',
                debug: options.debug || false,
                config: {
                    showIcon: options.showIcon !== false,
                    theme: options.theme || 'light'
                }
            });

            this.init();
        }

        /**
         * Override init for custom initialization
         * @protected
         */
        init() {
            super.init();
            this.debug('Initializing with config:', this._config);
        }

        /**
         * Render POI data as HTML element
         * @override
         * @param {Object} poi - POI data
         * @param {string} poi.title - POI title
         * @param {string} [poi.description] - POI description
         * @param {string} [poi.categoryId] - Category ID for icon
         * @param {Object} [options={}] - Render options
         * @param {string} [options.context='default'] - Render context
         * @returns {HTMLElement} Rendered element
         */
        render(poi, options = {}) {
            if (!poi) {
                this.warn('render: no POI data provided');
                return null;
            }

            this.debug('Rendering POI:', poi.title || poi.id);

            // Create container
            const container = this.createElement('div', 'simple-text-renderer', {
                'data-poi-id': poi.id || 'unknown',
                'data-context': options.context || 'default'
            });

            // Store state
            this.setState(container, {
                poi: poi,
                renderTime: Date.now(),
                context: options.context
            });

            // Render title
            const title = this._renderTitle(poi);
            if (title) container.appendChild(title);

            // Render description
            const description = this._renderDescription(poi);
            if (description) container.appendChild(description);

            // Add click handler example
            this.addEventListener(container, 'click', (e) => {
                this._handleClick(e, poi);
            });

            this.info('Rendered POI successfully');
            return container;
        }

        /**
         * Render title element
         * @private
         * @param {Object} poi - POI data
         * @returns {HTMLElement} Title element
         */
        _renderTitle(poi) {
            const utils = this.getUtils();
            const title = utils.resolveField(poi, 'title', 'label', 'name') || 'Untitled';

            const titleElement = this.createTextElement('h3', title, 'simple-text-renderer__title');

            // Add icon if enabled
            if (this._config.showIcon && poi.categoryId) {
                const icon = this._createIcon(poi.categoryId);
                if (icon) {
                    titleElement.insertBefore(icon, titleElement.firstChild);
                }
            }

            return titleElement;
        }

        /**
         * Render description element
         * @private
         * @param {Object} poi - POI data
         * @returns {HTMLElement|null} Description element or null
         */
        _renderDescription(poi) {
            const utils = this.getUtils();
            const description = utils.resolveField(poi, 'description', 'desc');

            if (!description) return null;

            return this.createTextElement('p', description, 'simple-text-renderer__description');
        }

        /**
         * Create icon element
         * @private
         * @param {string} categoryId - Category ID
         * @returns {HTMLElement|null} Icon element or null
         */
        _createIcon(categoryId) {
            const profile = this.getActiveProfile();
            if (!profile || !profile.icons) return null;

            const iconSpan = this.createElement('span', 'simple-text-renderer__icon');
            iconSpan.textContent = '📍'; // Fallback emoji icon
            iconSpan.style.marginRight = '8px';

            return iconSpan;
        }

        /**
         * Handle container click
         * @private
         * @param {MouseEvent} event - Click event
         * @param {Object} poi - POI data
         */
        _handleClick(event, poi) {
            const state = this.getState(event.currentTarget);
            this.info('Clicked POI:', poi.title, 'State:', state);

            // Update state
            this.updateState(event.currentTarget, {
                lastClicked: Date.now(),
                clickCount: (state.clickCount || 0) + 1
            });

            // Dispatch custom event
            const customEvent = new CustomEvent('poi:click', {
                detail: { poi, state },
                bubbles: true
            });
            event.currentTarget.dispatchEvent(customEvent);
        }

        /**
         * Override destroy for custom cleanup
         * @override
         * @public
         */
        destroy() {
            this.debug('Destroying SimpleTextRenderer');
            super.destroy();
        }
    }

    /**
     * GeoLeaf Data Normalizer Module
     * Module central pour la normalisation des données provenant de différentes sources.
     * Convertit JSON, GeoJSON, GPX (future) et Routes vers un format POI unifié.
     *
     * @module data/normalizer
     * @version 1.0.0
     */

    // ========================================
    //   TYPES DE SOURCES
    // ========================================

    const SOURCE_TYPES = {
        JSON: 'json',
        GEOJSON: 'geojson',
        GPX: 'gpx',
        ROUTE: 'route'
    };

    // ========================================
    //   UTILITAIRES
    // ========================================

    // getLog imported from general-utils.js (Phase 4 dedup)

    /**
     * Génère un ID unique
     * @returns {string}
     */
    function generateUniqueId() {
        return 'poi_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Détermine le type de géométrie à partir des coordonnées Leaflet
     * @param {Object} layer - Layer Leaflet
     * @returns {string} 'Point', 'Polygon', 'LineString' ou 'Unknown'
     */
    function detectGeometryType(layer) {
        if (!layer) return 'Unknown';

        if (typeof layer.getLatLng === 'function') {
            return 'Point';
        }
        if (typeof layer.getLatLngs === 'function') {
            const latLngs = layer.getLatLngs();
            // Polygon : tableau de tableaux de points (anneau extérieur + trous éventuels)
            // LineString : tableau de points
            if (Array.isArray(latLngs) && latLngs.length > 0) {
                if (Array.isArray(latLngs[0]) && Array.isArray(latLngs[0][0])) {
                    return 'Polygon';
                }
                if (Array.isArray(latLngs[0])) {
                    // Peut être Polygon ou LineString selon si fermé
                    return 'Polygon';
                }
                return 'LineString';
            }
        }
        return 'Unknown';
    }

    /**
     * Extrait les coordonnées d'un layer Leaflet
     * @param {Object} layer - Layer Leaflet
     * @returns {Array|null} Coordonnées [lat, lng] ou null
     */
    function extractCoordinates$1(layer) {
        if (!layer) return null;

        if (typeof layer.getLatLng === 'function') {
            const ll = layer.getLatLng();
            return ll ? [ll.lat, ll.lng] : null;
        }

        if (typeof layer.getCenter === 'function') {
            const center = layer.getCenter();
            return center ? [center.lat, center.lng] : null;
        }

        if (typeof layer.getBounds === 'function') {
            try {
                const bounds = layer.getBounds();
                if (bounds && bounds.isValid()) {
                    const center = bounds.getCenter();
                    return center ? [center.lat, center.lng] : null;
                }
            } catch (e) {
                // Bounds invalides
            }
        }

        return null;
    }

    // ========================================
    //   NORMALISEURS PAR TYPE DE SOURCE
    // ========================================

    /**
     * Normalise une entrée JSON en POI
     * @param {Object} data - Données JSON brutes
     * @param {Object} layerConfig - Configuration du layer
     * @returns {Object} POI normalisé
     */
    function normalizeFromJSON(data, layerConfig = {}) {
        if (!data) return null;

        const id = data.id || data.uid || data.guid || generateUniqueId();
        const dataMapping = layerConfig.dataMapping || {};

        // Extraction du titre
        const titleField = dataMapping.title || 'title';
        const title = data[titleField] || data.title || data.name || data.label || data.nom || 'Sans titre';

        // Extraction de la description
        const descField = dataMapping.description || 'description';
        const description = data[descField] || data.description || data.shortDescription || '';

        // Extraction des coordonnées
        const latField = dataMapping.lat || 'lat';
        const lngField = dataMapping.lng || 'lng';
        let lat = data[latField];
        let lng = data[lngField];

        // Fallbacks pour coordonnées
        if (lat === undefined) lat = data.latitude || data.y;
        if (lng === undefined) lng = data.longitude || data.lng || data.x;

        // Extraction catégorie/sous-catégorie
        const catField = dataMapping.categoryId || 'categoryId';
        const subCatField = dataMapping.subCategoryId || 'subCategoryId';
        const categoryId = data[catField] || data.categoryId || data.category || null;
        const subCategoryId = data[subCatField] || data.subCategoryId || data.subcategory || null;

        // Construction des attributs (toutes les propriétés)
        const attributes = { ...data };

        return {
            id: String(id),
            sourceType: SOURCE_TYPES.JSON,
            geometryType: 'Point',
            title: String(title),
            description: String(description || ''),
            lat: lat !== undefined ? parseFloat(lat) : null,
            lng: lng !== undefined ? parseFloat(lng) : null,
            categoryId: categoryId,
            subCategoryId: subCategoryId,
            attributes: attributes,
            rawData: data
        };
    }

    /**
     * Normalise une feature GeoJSON en POI
     * @param {Object} feature - Feature GeoJSON
     * @param {Object} layerConfig - Configuration du layer
     * @param {Object} layer - Layer Leaflet (optionnel, pour coordonnées)
     * @returns {Object} POI normalisé
     */
    function normalizeFromGeoJSON(feature, layerConfig = {}, layer = null) {
        if (!feature) return null;

        const props = feature.properties || {};
        const geometry = feature.geometry || {};
        const dataMapping = layerConfig.dataMapping || {};

        // ID
        const id = feature.id || props.id || props.uid || props.guid || generateUniqueId();

        // Type de géométrie
        let geometryType = geometry.type || 'Unknown';
        if (layer && geometryType === 'Unknown') {
            geometryType = detectGeometryType(layer);
        }

        // Extraction du titre
        const titleField = dataMapping.title || 'title';
        const titlePath = titleField.includes('.') ? titleField.split('.').pop() : titleField;
        const title = props[titlePath] || props.name || props.nom || props.title || props.label || 'Sans titre';

        // Extraction de la description
        const descField = dataMapping.description || 'description';
        const descPath = descField.includes('.') ? descField.split('.').pop() : descField;
        const description = props[descPath] || props.description || props.shortDescription || '';

        // Coordonnées
        let lat = null, lng = null;
        if (geometry.coordinates) {
            if (geometryType === 'Point') {
                // GeoJSON : [lng, lat]
                lng = geometry.coordinates[0];
                lat = geometry.coordinates[1];
            } else if (layer) {
                const coords = extractCoordinates$1(layer);
                if (coords) {
                    lat = coords[0];
                    lng = coords[1];
                }
            } else if (geometry.coordinates.length > 0) {
                // Calculer le centre approximatif
                const flatCoords = flattenCoordinates(geometry.coordinates, geometry.type);
                if (flatCoords.length > 0) {
                    let sumLat = 0, sumLng = 0;
                    flatCoords.forEach(c => {
                        sumLng += c[0];
                        sumLat += c[1];
                    });
                    lng = sumLng / flatCoords.length;
                    lat = sumLat / flatCoords.length;
                }
            }
        } else if (layer) {
            const coords = extractCoordinates$1(layer);
            if (coords) {
                lat = coords[0];
                lng = coords[1];
            }
        }

        // Catégorie/sous-catégorie
        const catField = dataMapping.categoryId || 'categoryId';
        const catPath = catField.includes('.') ? catField.split('.').pop() : catField;
        const subCatField = dataMapping.subCategoryId || 'subCategoryId';
        const subCatPath = subCatField.includes('.') ? subCatField.split('.').pop() : subCatField;

        const categoryId = props[catPath] || props.categoryId || props.category || null;
        const subCategoryId = props[subCatPath] || props.subCategoryId || props.subcategory || null;

        // Construction des attributs
        // Hoist nested props.attributes.* fields to top level so that config paths like
        // "attributes.reviews.rating" resolve correctly when the GeoJSON stores rich data
        // under properties.attributes (e.g. reviews, gallery, photo, etc.)
        const nestedAttrs = (props.attributes && typeof props.attributes === 'object') ? props.attributes : {};
        const attributes = { ...props, ...nestedAttrs };

        return {
            id: String(id),
            sourceType: SOURCE_TYPES.GEOJSON,
            geometryType: geometryType,
            title: String(title),
            description: String(description || ''),
            lat: lat !== null ? parseFloat(lat) : null,
            lng: lng !== null ? parseFloat(lng) : null,
            categoryId: categoryId,
            subCategoryId: subCategoryId,
            attributes: attributes,
            properties: props, // Conserve aussi properties pour compatibilité
            rawData: feature
        };
    }

    /**
     * Aplatit les coordonnées GeoJSON selon le type de géométrie
     * @param {Array} coords - Coordonnées imbriquées
     * @param {string} type - Type de géométrie
     * @returns {Array} Tableau de [lng, lat]
     */
    function flattenCoordinates(coords, type) {
        if (!coords || !Array.isArray(coords)) return [];

        switch (type) {
            case 'Point':
                return [coords];
            case 'MultiPoint':
            case 'LineString':
                return coords;
            case 'MultiLineString':
            case 'Polygon':
                return coords.flat();
            case 'MultiPolygon':
                return coords.flat(2);
            default:
                // Aplatir récursivement
                const flat = [];
                const flatten = (arr) => {
                    if (!Array.isArray(arr)) return;
                    if (typeof arr[0] === 'number') {
                        flat.push(arr);
                    } else {
                        arr.forEach(flatten);
                    }
                };
                flatten(coords);
                return flat;
        }
    }

    /**
     * Normalise un waypoint GPX en POI (placeholder pour futur module)
     * @param {Object} waypoint - Waypoint GPX
     * @param {Object} layerConfig - Configuration du layer
     * @returns {Object} POI normalisé
     */
    function normalizeFromGPX(waypoint, layerConfig = {}) {
        if (!waypoint) return null;

        getLog().info('[Normalizer] GPX normalization - placeholder for future implementation');

        // Structure de base pour GPX
        const id = waypoint.name || waypoint.sym || generateUniqueId();
        const title = waypoint.name || waypoint.cmt || 'Point GPX';
        const description = waypoint.desc || waypoint.cmt || '';

        return {
            id: String(id),
            sourceType: SOURCE_TYPES.GPX,
            geometryType: 'Point',
            title: String(title),
            description: String(description),
            lat: waypoint.lat !== undefined ? parseFloat(waypoint.lat) : null,
            lng: waypoint.lon !== undefined ? parseFloat(waypoint.lon) : null,
            categoryId: waypoint.type || null,
            subCategoryId: null,
            attributes: { ...waypoint },
            rawData: waypoint
        };
    }

    /**
     * Normalise un point de route en POI
     * @param {Object} routePoint - Point de route
     * @param {Object} routeConfig - Configuration de la route
     * @returns {Object} POI normalisé
     */
    function normalizeFromRoute(routePoint, routeConfig = {}) {
        if (!routePoint) return null;

        const id = routePoint.id || routePoint.placeId || generateUniqueId();
        const title = routePoint.name || routePoint.title || routePoint.address || 'Point de route';
        const description = routePoint.description || routePoint.comment || '';

        let lat = null, lng = null;
        if (routePoint.latLng) {
            lat = routePoint.latLng.lat;
            lng = routePoint.latLng.lng;
        } else if (routePoint.lat !== undefined && routePoint.lng !== undefined) {
            lat = routePoint.lat;
            lng = routePoint.lng;
        }

        return {
            id: String(id),
            sourceType: SOURCE_TYPES.ROUTE,
            geometryType: 'Point',
            title: String(title),
            description: String(description),
            lat: lat !== null ? parseFloat(lat) : null,
            lng: lng !== null ? parseFloat(lng) : null,
            categoryId: routePoint.type || 'route-point',
            subCategoryId: routePoint.order !== undefined ? `stop-${routePoint.order}` : null,
            order: routePoint.order,
            address: routePoint.address,
            attributes: { ...routePoint },
            rawData: routePoint
        };
    }

    // ========================================
    //   FONCTION PRINCIPALE
    // ========================================

    /**
     * Normalise des données selon leur type de source
     * @param {string} sourceType - Type de source ('json', 'geojson', 'gpx', 'route')
     * @param {Object} data - Données brutes
     * @param {Object} layerConfig - Configuration du layer
     * @param {Object} options - Options additionnelles (layer Leaflet, etc.)
     * @returns {Object} POI normalisé
     */
    function normalizeFeature(sourceType, data, layerConfig = {}, options = {}) {
        if (!data) {
            getLog().warn('[Normalizer] Données nulles pour normalisation');
            return null;
        }

        switch (sourceType) {
            case SOURCE_TYPES.JSON:
                return normalizeFromJSON(data, layerConfig);

            case SOURCE_TYPES.GEOJSON:
                return normalizeFromGeoJSON(data, layerConfig, options.layer);

            case SOURCE_TYPES.GPX:
                return normalizeFromGPX(data, layerConfig);

            case SOURCE_TYPES.ROUTE:
                return normalizeFromRoute(data, layerConfig);

            default:
                getLog().warn('[Normalizer] Type de source non reconnu:', sourceType);
                // Tenter une détection automatique
                return autoDetectAndNormalize(data, layerConfig, options);
        }
    }

    /**
     * Détecte automatiquement le type de source et normalise
     * @param {Object} data - Données brutes
     * @param {Object} layerConfig - Configuration du layer
     * @param {Object} options - Options additionnelles
     * @returns {Object} POI normalisé
     */
    function autoDetectAndNormalize(data, layerConfig = {}, options = {}) {
        // Détection GeoJSON
        if (data.type === 'Feature' && data.geometry) {
            return normalizeFromGeoJSON(data, layerConfig, options.layer);
        }

        // Détection GPX (waypoint)
        if (data.lat !== undefined && data.lon !== undefined && (data.name || data.sym)) {
            return normalizeFromGPX(data, layerConfig);
        }

        // Détection Route
        if (data.latLng || (data.order !== undefined && data.address)) {
            return normalizeFromRoute(data, layerConfig);
        }

        // Par défaut : JSON
        return normalizeFromJSON(data, layerConfig);
    }

    /**
     * Normalise un tableau de données
     * @param {string} sourceType - Type de source
     * @param {Array} dataArray - Tableau de données brutes
     * @param {Object} layerConfig - Configuration du layer
     * @param {Object} options - Options additionnelles
     * @returns {Array} Tableau de POIs normalisés
     */
    function normalizeCollection(sourceType, dataArray, layerConfig = {}, options = {}) {
        if (!Array.isArray(dataArray)) {
            getLog().warn('[Normalizer] normalizeCollection attend un tableau');
            return [];
        }

        return dataArray
            .map(data => normalizeFeature(sourceType, data, layerConfig, options))
            .filter(poi => poi !== null);
    }

    // ========================================
    //   EXPORT
    // ========================================

    const DataNormalizer = {
        // Types de sources
        SOURCE_TYPES,

        // Normaliseurs par type
        normalizeFromJSON,
        normalizeFromGeoJSON,
        normalizeFromGPX,
        normalizeFromRoute,

        // Fonctions principales
        normalizeFeature,
        autoDetectAndNormalize,
        normalizeCollection,

        // Utilitaires
        detectGeometryType,
        extractCoordinates: extractCoordinates$1,
        generateUniqueId
    };

    // Log de chargement
    getLog().info('[GeoLeaf._Normalizer] Module Normalizer chargé');

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // Lazy access to Config (not yet ESM — migrated in B4)
    const _gl$2 = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    /**
     * Cache en mémoire des styles chargés
     * Clé: "profileId:layerId:styleId"
     * Valeur: { styleData, labelConfig, timestamp }
     */
    const styleCache = new Map();

    /**
     * Helper to get Log instance lazily
     * @returns {Object|null}
     */
    function _getLog() {
        return Log || null;
    }

    /**
     * Configuration du loader
     */
    let loaderConfig = {
        debug: false,
        throwOnValidationError: true
    };

    function getProfilesBasePath() {
        const cfg = _gl$2.GeoLeaf && _gl$2.GeoLeaf.Config;

        if (cfg && typeof cfg.get === "function") {
            const configured = cfg.get("data.profilesBasePath", "profiles");
            if (typeof configured === "string" && configured.trim().length > 0) {
                return configured.endsWith("/") ? configured.slice(0, -1) : configured;
            }
        }

        return "profiles";
    }

    /**
     * Initialise le style loader avec la configuration GeoLeaf
     * @param {Object} config - Configuration GeoLeaf (doit contenir { debug: boolean })
     */
    function initStyleLoader(config = {}) {
        loaderConfig.debug = config.debug === true;

        if (loaderConfig.debug) {
            const Log = _getLog();
            if (Log) Log.debug('[StyleLoader] Mode debug activé - cache désactivé');
        }
    }

    /**
     * Charge et valide un fichier de style
     * @param {string} profileId - ID du profil
     * @param {string} layerId - ID de la couche
     * @param {string} styleId - ID du style
     * @param {string} styleFileName - Nom du fichier de style (ex: "default.json")
     * @param {string} layerDirectory - Répertoire de la couche (ex: "layers/tourism_poi_all")
     * @returns {Promise<Object>} Style chargé et validé avec labels extraits
     * @throws {Error} Si le fichier est invalide ou introuvable
     */
    async function loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory) {
        const cacheKey = `${profileId}:${layerId}:${styleId}`;

        // Vérifier le cache (sauf en mode debug)
        if (!loaderConfig.debug && styleCache.has(cacheKey)) {
            const cached = styleCache.get(cacheKey);
            return cached;
        }

        try {
            // Construire le chemin du fichier de style
            const profilesBasePath = getProfilesBasePath();
            const stylePath = `${profilesBasePath}/${profileId}/${layerDirectory}/styles/${styleFileName}`;

            // Charger le fichier JSON
            const response = await fetch(stylePath);

            if (!response.ok) {
                throw new Error(
                    `Impossible de charger le fichier de style: ${stylePath}\n` +
                    `HTTP ${response.status}: ${response.statusText}`
                );
            }

            let styleData;
            try {
                styleData = await response.json();
            } catch (jsonError) {
                // Erreur de parsing JSON - format détaillé
                const errorContext = {
                    profileId,
                    layerId,
                    styleId,
                    stylePath,
                    httpStatus: response.status,
                    parseError: jsonError.message
                };

                console.error('═══════════════════════════════════════════════════════');
                console.error('❌ ERREUR DE PARSING JSON - FICHIER STYLE MALFORMÉ');
                console.error('═══════════════════════════════════════════════════════');
                console.error(`Fichier: ${stylePath}`);
                console.error(`Erreur: ${jsonError.message}`);
                console.error('Contexte:', JSON.stringify(errorContext, null, 2));
                console.error('Stack trace:', jsonError.stack);
                console.error('═══════════════════════════════════════════════════════');

                throw new Error(
                    `Le fichier de style contient du JSON malformé: ${stylePath}\n` +
                    `Erreur de parsing: ${jsonError.message}\n` +
                    `Veuillez vérifier la syntaxe JSON du fichier.`
                );
            }

            // VALIDATION STRICTE: Ajouter visibleByDefault si manquant et label.enabled: true
            if (styleData.label && styleData.label.enabled === true) {
                if (styleData.label.visibleByDefault === undefined) {
                    // Fallback automatique à false
                    styleData.label.visibleByDefault = false;
                    console.warn(
                        `[StyleLoader] ⚠️ Paramètre "visibleByDefault" manquant dans le style: ${stylePath}\n` +
                        `Le style a "label.enabled: true" mais pas de "visibleByDefault".\n` +
                        `Fallback appliqué: visibleByDefault = false\n` +
                        `Ajoutez explicitement "visibleByDefault": false ou true dans le fichier de style.`
                    );
                }
            }

            // Valider le style contre le schéma
            {
                if (!StyleValidator) {
                    console.warn('[StyleLoader] StyleValidator non disponible, validation ignorée');
                }

                const validationResult = StyleValidator ? StyleValidator.validateStyle(styleData, {
                    profileId,
                    layerId,
                    styleId,
                    stylePath
                }) : { valid: true, errors: [], warnings: [] };

                if (!validationResult.valid) {
                    const errorMessage = StyleValidator ? StyleValidator.formatValidationErrors(validationResult, stylePath) : 'Erreurs de validation';
                    console.error(errorMessage);

                    if (loaderConfig.throwOnValidationError) {
                        throw new Error(
                            `Le fichier de style ne respecte pas le schéma GeoLeaf: ${stylePath}\n` +
                            `Consultez la console pour les détails des erreurs.`
                        );
                    }
                }

                // Afficher les avertissements même si validation OK
                if (validationResult.warnings.length > 0) {
                    console.warn(`[StyleLoader] ${validationResult.warnings.length} avertissement(s) pour ${stylePath}:`);
                    validationResult.warnings.forEach(warning => {
                        console.warn(`  - ${warning.field}: ${warning.message}`);
                    });
                }
            }

            // Extraire la configuration de labels intégrés
            const labelConfig = extractLabelConfig(styleData);

            // Préparer l'objet de retour
            const result = {
                styleData,
                labelConfig,
                metadata: {
                    profileId,
                    layerId,
                    styleId,
                    stylePath,
                    hasIntegratedLabels: labelConfig !== null,
                    loadedAt: new Date().toISOString()
                }
            };

            // Mettre en cache (sauf en mode debug)
            if (!loaderConfig.debug) {
                styleCache.set(cacheKey, result);
            }

            return result;

        } catch (error) {
            // Re-throw les erreurs avec contexte complet
            if (error.message.includes('JSON malformé') || error.message.includes('schéma GeoLeaf')) {
                throw error;
            }

            // Erreur réseau ou autre
            const errorContext = {
                profileId,
                layerId,
                styleId,
                styleFileName,
                layerDirectory,
                originalError: error.message
            };

            console.error('═══════════════════════════════════════════════════════');
            console.error('❌ ERREUR DE CHARGEMENT DE STYLE');
            console.error('═══════════════════════════════════════════════════════');
            console.error('Contexte:', JSON.stringify(errorContext, null, 2));
            console.error('Stack trace:', error.stack);
            console.error('═══════════════════════════════════════════════════════');

            throw error;
        }
    }

    /**
     * Extrait la configuration de labels depuis un style chargé
     * Détecte automatiquement si les labels sont intégrés dans le style
     * @param {Object} styleData - Données du style
     * @returns {Object|null} Configuration de labels ou null si absents/désactivés
     */
    function extractLabelConfig(styleData) {
        if (!styleData || typeof styleData !== 'object') {
            return null;
        }

        // Vérifier si le champ label est un objet de configuration
        if (styleData.label && typeof styleData.label === 'object' && styleData.label !== null) {
            // Vérifier que enabled est true
            if (styleData.label.enabled === true) {
                return {
                    ...styleData.label,
                    isIntegrated: true
                };
            }
        }

        // Pas de labels intégrés ou désactivés
        return null;
    }

    /**
     * Charge un style avec gestion simplifiée (sans validation stricte)
     * Utilisé pour les cas où on veut charger même si validation échoue
     * @param {string} profileId - ID du profil
     * @param {string} layerId - ID de la couche
     * @param {string} styleId - ID du style
     * @param {string} styleFileName - Nom du fichier
     * @param {string} layerDirectory - Répertoire de la couche
     * @returns {Promise<Object>} Style chargé (peut contenir des erreurs)
     */
    async function loadStyleLenient(profileId, layerId, styleId, styleFileName, layerDirectory) {
        const previousThrowSetting = loaderConfig.throwOnValidationError;
        loaderConfig.throwOnValidationError = false;

        try {
            return await loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory);
        } finally {
            loaderConfig.throwOnValidationError = previousThrowSetting;
        }
    }

    /**
     * Précharge plusieurs styles en parallèle
     * @param {Array<Object>} styleConfigs - Tableau de { profileId, layerId, styleId, styleFileName, layerDirectory }
     * @returns {Promise<Array<Object>>} Résultats de chargement
     */
    async function preloadStyles(styleConfigs) {
        const Log = _getLog();
        if (Log) Log.info(`[StyleLoader] Préchargement de ${styleConfigs.length} style(s)...`);

        const promises = styleConfigs.map(config =>
            loadAndValidateStyle(
                config.profileId,
                config.layerId,
                config.styleId,
                config.styleFileName,
                config.layerDirectory
            ).catch(error => ({
                error: true,
                message: error.message,
                config
            }))
        );

        const results = await Promise.all(promises);

        const successCount = results.filter(r => !r.error).length;
        const errorCount = results.filter(r => r.error).length;

        if (Log) Log.info(`[StyleLoader] Préchargement terminé: ${successCount} succès, ${errorCount} erreurs`);

        return results;
    }

    /**
     * Efface le cache des styles
     * @param {string} [cacheKey] - Clé spécifique à effacer (optionnel, sinon tout le cache)
     */
    function clearStyleCache(cacheKey = null) {
        if (cacheKey) {
            styleCache.delete(cacheKey);
        } else {
            styleCache.clear();
        }
    }

    /**
     * Obtient les statistiques du cache
     * @returns {Object} Statistiques { size, keys, debug }
     */
    function getCacheStats() {
        return {
            size: styleCache.size,
            keys: Array.from(styleCache.keys()),
            debug: loaderConfig.debug,
            cacheEnabled: !loaderConfig.debug
        };
    }

    /**
     * Charge un style depuis une configuration de couche
     * Détecte automatiquement les références obsolètes à styleFile
     * @param {string} profileId - ID du profil
     * @param {Object} layerConfig - Configuration de la couche
     * @param {string} styleIdOrFileName - ID du style ou nom de fichier
     * @returns {Promise<Object>} Style chargé
     */
    async function loadStyleFromLayerConfig(profileId, layerConfig, styleIdOrFileName) {
        const layerId = layerConfig.id;
        const layerDirectory = layerConfig._layerDirectory || `layers/${layerId}`;

        // Vérifier si styleFile est présent dans labels (configuration obsolète)
        if (layerConfig.labels && layerConfig.labels.styleFile) {
            const errorMessage =
                `❌ CONFIGURATION OBSOLÈTE DÉTECTÉE\n` +
                `═══════════════════════════════════════════════════════\n` +
                `La couche "${layerId}" utilise une référence obsolète à un fichier\n` +
                `de labels séparé via "labels.styleFile".\n\n` +
                `GeoLeaf ne supporte plus les fichiers de labels séparés (styleLabel.json).\n` +
                `Les labels doivent être intégrés dans les fichiers de style.\n\n` +
                `Valeur détectée: ${layerConfig.labels.styleFile}\n` +
                `Profil: ${profileId}\n` +
                `Couche: ${layerId}\n\n` +
                `Action requise:\n` +
                `1. Supprimez la propriété "labels.styleFile" de la configuration\n` +
                `2. Intégrez les labels dans les fichiers de style (propriété "label")\n` +
                `3. Consultez docs/STYLE_FORMAT_SPEC.md pour la syntaxe\n` +
                `═══════════════════════════════════════════════════════`;

            console.error(errorMessage);
            throw new Error(`Configuration obsolète: labels.styleFile détecté dans la couche ${layerId}`);
        }

        // Trouver le fichier de style dans styles.available
        let styleFileName = styleIdOrFileName;
        let styleId = styleIdOrFileName;

        if (layerConfig.styles && layerConfig.styles.available) {
            const styleConfig = layerConfig.styles.available.find(s => s.id === styleIdOrFileName || s.file === styleIdOrFileName);
            if (styleConfig) {
                styleFileName = styleConfig.file;
                styleId = styleConfig.id;
            }
        }

        return loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory);
    }

    /**
     * Construit le chemin complet d'un fichier de style
     * @param {string} profileId - ID du profil
     * @param {string} layerDirectory - Répertoire de la couche
     * @param {string} styleFileName - Nom du fichier
     * @returns {string} Chemin complet
     */
    function getStylePath(profileId, layerDirectory, styleFileName) {
        return `profiles/${profileId}/${layerDirectory}/styles/${styleFileName}`;
    }

    /**
     * Module Style Loader
     * Expose toutes les fonctions publiques
     */
    const StyleLoader = {
        initStyleLoader,
        loadAndValidateStyle,
        extractLabelConfig,
        loadStyleLenient,
        preloadStyles,
        clearStyleCache,
        getCacheStats,
        loadStyleFromLayerConfig,
        getStylePath,
        styleCache // Export pour tests/debugging
    };

    /**
     * GeoLeaf Scale Control
     * Gère l'affichage de l'échelle graphique, numérique et du niveau de zoom
     *
     * @module map/scale-control
     */

    // Lazy access to Config (not yet ESM — migrated in B4)
    const _gl$1 = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});


        /**
         * Contrôle d'échelle personnalisé
         */
        const ScaleControl$1 = {
            _map: null,
            _config: null,
            _container: null,
            _scaleLineMetric: null,
            _numericElement: null,
            _zoomElement: null,
            _inputElement: null,
            _scalePrefix: null,
            _mainWrapper: null,
            _eventHandlers: {},

            /**
             * Initialise le contrôle d'échelle
             * @param {L.Map} map - Instance de la carte Leaflet
             * @param {Object} config - Configuration depuis scaleConfig
             */
            init(map, config) {
                if (!map) {
                    Log.error("[GeoLeaf.ScaleControl] Carte non fournie");
                    return;
                }

                this._map = map;
                this._config = config || {};

                // Créer un conteneur unique pour tout
                this._createMainContainer();

                Log.info("[GeoLeaf.ScaleControl] Contrôle d'échelle initialisé");
            },

            /**
             * Crée le conteneur principal avec échelle graphique et bloc personnalisé
             * @private
             */
            _createMainContainer() {
                const position = this._config.position || 'bottomleft';

                // Conteneur principal - disposition horizontale
                this._mainWrapper = L.DomUtil.create('div', 'gl-scale-main-wrapper');

                // 1. Échelle graphique
                if (this._config.scaleGraphic !== false) {
                    const graphicWrapper = L.DomUtil.create('div', 'gl-scale-graphic-wrapper', this._mainWrapper);
                    this._addGraphicScaleToContainer(graphicWrapper);
                }

                // 2. Bloc personnalisé (échelle numérique + zoom) sur la même ligne
                if (this._config.scaleNumeric || this._config.scaleNivel) {
                    this._createCustomScaleBlock(this._mainWrapper);
                }

                // Ajouter le conteneur principal à la carte
                const CustomControl = L.Control.extend({
                    options: {
                        position: position
                    },
                    onAdd: () => {
                        return this._mainWrapper;
                    }
                });

                new CustomControl().addTo(this._map);
            },

            /**
             * Ajoute l'échelle graphique Leaflet dans un conteneur
             * @param {HTMLElement} container - Conteneur cible
             * @private
             */
            _addGraphicScaleToContainer(container) {
                // Créer l'échelle graphique manuellement (pas via L.control.scale)
                const scaleDiv = L.DomUtil.create('div', 'leaflet-control-scale leaflet-control', container);

                const scaleLineMetric = L.DomUtil.create('div', 'leaflet-control-scale-line', scaleDiv);
                this._scaleLineMetric = scaleLineMetric;

                // Fonction de mise à jour de l'échelle graphique
                const updateScale = () => {
                    const y = this._map.getSize().y / 2;
                    const maxMeters = this._map.distance(
                        this._map.containerPointToLatLng([0, y]),
                        this._map.containerPointToLatLng([150, y])
                    );
                    this._updateScaleLine(this._scaleLineMetric, maxMeters);
                };

                this._eventHandlers.graphicScaleUpdate = updateScale;
                this._map.on('zoomend moveend', updateScale);
                updateScale();

                Log.info("[GeoLeaf.ScaleControl] Échelle graphique ajoutée");
            },

            /**
             * Met à jour la ligne d'échelle graphique
             * @param {HTMLElement} scaleLine - Élément de la ligne d'échelle
             * @param {number} maxMeters - Distance maximale en mètres
             * @private
             */
            _updateScaleLine(scaleLine, maxMeters) {
                const maxKm = maxMeters / 1000;
                let scale, ratio;

                if (maxKm > 1) {
                    const maxNiceKm = this._getRoundNum(maxKm);
                    ratio = maxNiceKm / maxKm;
                    scale = maxNiceKm + ' km';
                } else {
                    const maxNiceM = this._getRoundNum(maxMeters);
                    ratio = maxNiceM / maxMeters;
                    scale = maxNiceM + ' m';
                }

                scaleLine.style.width = Math.round(150 * ratio) + 'px';
                scaleLine.textContent = scale;
            },

            /**
             * Arrondit un nombre à une valeur "propre" (1, 2, 5, 10, 20, 50, etc.)
             * @param {number} num - Nombre à arrondir
             * @returns {number} Nombre arrondi
             * @private
             */
            _getRoundNum(num) {
                const pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
                let d = num / pow10;

                d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

                return pow10 * d;
            },

            /**
             * Crée le bloc personnalisé (échelle numérique + niveau de zoom)
             * @param {HTMLElement} parentContainer - Conteneur parent
             * @private
             */
            _createCustomScaleBlock(parentContainer) {
                // Créer le conteneur - disposition horizontale
                this._container = L.DomUtil.create('div', 'gl-scale-control', parentContainer);

                // Échelle numérique
                if (this._config.scaleNumeric) {
                    if (this._config.scaleNumericEditable) {
                        this._createEditableScale();
                    } else {
                        this._createReadOnlyScale();
                    }
                }

                // Niveau de zoom
                if (this._config.scaleNivel) {
                    this._createZoomLevel();
                }

                // Événements de mise à jour
                const updateHandler = () => this._updateScale();
                this._eventHandlers.numericScaleUpdate = updateHandler;
                this._map.on('zoomend moveend', updateHandler);
                this._updateScale(); // Mise à jour initiale

                Log.info("[GeoLeaf.ScaleControl] Bloc personnalisé ajouté");
            },

            /**
             * Crée l'échelle numérique en lecture seule
             * @private
             */
            _createReadOnlyScale() {
                this._numericElement = L.DomUtil.create('div', 'gl-scale-numeric', this._container);
            },

            /**
             * Crée l'échelle numérique éditable avec input
             * @private
             */
            _createEditableScale() {
                // Créer un conteneur pour l'échelle éditable
                const wrapper = L.DomUtil.create('div', 'gl-scale-numeric-editable', this._container);

                // Créer le préfixe "1:" (toujours visible)
                this._scalePrefix = L.DomUtil.create('span', 'gl-scale-prefix', wrapper);
                this._scalePrefix.textContent = '1:';

                // Créer le span affiché initialement (souligné et cliquable) - contient uniquement le dénominateur
                this._numericElement = L.DomUtil.create('span', 'gl-scale-numeric-clickable', wrapper);
                this._numericElement.textContent = '0';

                // Créer l'input (caché initialement) - contient uniquement le dénominateur
                this._inputElement = L.DomUtil.create('input', 'gl-scale-numeric-input', wrapper);
                this._inputElement.type = 'text';
                this._inputElement.placeholder = '250000';
                this._inputElement.style.display = 'none';

                // Empêcher les interactions de la carte lors de l'édition
                L.DomEvent.disableClickPropagation(wrapper);
                L.DomEvent.disableScrollPropagation(wrapper);

                // Clic sur le span : passer en mode édition
                this._numericElement.addEventListener('click', () => {
                    this._switchToEditMode();
                });

                // Validation avec Enter
                this._inputElement.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this._onScaleInputChange();
                        this._switchToDisplayMode();
                    }
                });

                // Validation en cliquant à l'extérieur (blur)
                this._inputElement.addEventListener('blur', () => {
                    this._onScaleInputChange();
                    this._switchToDisplayMode();
                });
            },

            /**
             * Crée l'affichage du niveau de zoom
             * @private
             */
            _createZoomLevel() {
                this._zoomElement = L.DomUtil.create('div', 'gl-scale-zoom', this._container);
            },

            /**
             * Bascule en mode édition (affiche l'input)
             * @private
             */
            _switchToEditMode() {
                if (!this._numericElement || !this._inputElement) return;

                // Copier la valeur actuelle dans l'input
                this._inputElement.value = this._numericElement.textContent;

                // Cacher le span, afficher l'input
                this._numericElement.style.display = 'none';
                this._inputElement.style.display = 'inline-block';

                // Focus et sélection du texte
                this._inputElement.focus();
                this._inputElement.select();
            },

            /**
             * Bascule en mode affichage (affiche le span)
             * @private
             */
            _switchToDisplayMode() {
                if (!this._numericElement || !this._inputElement) return;

                // Cacher l'input, afficher le span
                this._inputElement.style.display = 'none';
                this._numericElement.style.display = 'inline';
            },

            /**
             * Met à jour l'affichage de l'échelle et du zoom
             * @private
             */
            _updateScale() {
                const zoom = this._map.getZoom();
                const scale = this._calculateScale(zoom);

                // Mettre à jour l'échelle numérique
                if (this._numericElement) {
                    if (this._config.scaleNumericEditable) {
                        // Mettre à jour uniquement le dénominateur (sans '1:')
                        if (this._inputElement.style.display === 'none') {
                            this._numericElement.textContent = this._formatNumber(scale);
                        }
                    } else {
                        // Mode non éditable : afficher "1:" + dénominateur
                        this._numericElement.textContent = `1:${this._formatNumber(scale)}`;
                    }
                }

                // Mettre à jour le niveau de zoom
                if (this._zoomElement) {
                    this._zoomElement.textContent = `Zoom: ${Number(zoom).toFixed(2)}`;
                }
            },

            /**
             * Calcule l'échelle approximative en fonction du niveau de zoom
             * @param {number} zoom - Niveau de zoom Leaflet
             * @param {number} [lat] - Latitude optionnelle (utilise le centre de la carte si non fournie)
             * @returns {number} Échelle (ex: 250000 pour 1:250000)
             * @private
             */
            _calculateScale(zoom, lat) {
                // Utiliser la latitude fournie ou celle du centre de la carte
                const latitude = lat !== undefined ? lat : this._map.getCenter().lat;
                // Formule approximative basée sur la taille des tuiles Web Mercator
                const metersPerPixel = 156543.03392 * Math.cos(latitude * Math.PI / 180) / Math.pow(2, zoom);
                const scale = metersPerPixel * 96 / 0.0254; // 96 DPI
                return Math.round(scale);
            },

            /**
             * Formate un nombre avec des espaces comme séparateurs de milliers
             * @param {number} num - Nombre à formater
             * @returns {string} Nombre formaté
             * @private
             */
            _formatNumber(num) {
                return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            },

            /**
             * Gère le changement manuel de l'échelle
             * @private
             */
            _onScaleInputChange() {
                if (!this._inputElement) return;

                const input = this._inputElement.value.trim();
                // Parser uniquement le dénominateur (nombre avec espaces optionnels)
                const cleanedInput = input.replace(/\s/g, '');
                const targetScale = parseInt(cleanedInput, 10);

                if (!isNaN(targetScale) && targetScale > 0) {
                    const targetZoom = this._calculateZoomFromScale(targetScale);
                    // Utiliser setView avec zoomSnap: 0 pour permettre les zooms fractionnaires
                    this._map.setView(this._map.getCenter(), targetZoom, {
                        animate: true,
                        zoomSnap: 0
                    });
                    Log.info(`[GeoLeaf.ScaleControl] Zoom ajusté à ${targetZoom} pour échelle 1:${targetScale}`);
                } else {
                    Log.warn("[GeoLeaf.ScaleControl] Format d'échelle invalide:", input);
                    this._updateScale(); // Réinitialiser la valeur
                }
            },

            /**
             * Calcule le niveau de zoom pour atteindre une échelle donnée
             * @param {number} targetScale - Échelle cible (ex: 250000)
             * @returns {number} Niveau de zoom (peut être décimal pour plus de précision)
             * @private
             */
            _calculateZoomFromScale(targetScale) {
                const lat = this._map.getCenter().lat;
                const metersPerPixel = targetScale * 0.0254 / 96;
                let zoom = Math.log2(156543.03392 * Math.cos(lat * Math.PI / 180) / metersPerPixel);

                // Affiner le zoom par itération pour obtenir l'échelle exacte
                // Utiliser une méthode de convergence précise
                for (let i = 0; i < 20; i++) {
                    const currentScale = this._calculateScale(zoom, lat); // Passer lat pour éviter recalcul
                    const diff = targetScale - currentScale;

                    // Si l'erreur est inférieure à 1 (pratiquement identique), on arrête
                    if (Math.abs(diff) < 1) {
                        break;
                    }

                    // Ajuster le zoom proportionnellement à l'erreur
                    // Plus l'échelle est grande, plus on doit dézoomer (zoom plus petit)
                    const adjustment = Math.log2(targetScale / currentScale);
                    zoom -= adjustment * 0.95; // Facteur d'amortissement pour éviter les oscillations
                }

                // Arrondir à 4 décimales pour une précision maximale
                const preciseZoom = Math.round(zoom * 10000) / 10000;
                return Math.max(0, Math.min(22, preciseZoom));
            },

            /**
             * Détruit le contrôle et nettoie les ressources
             */
            destroy() {
                // Retirer les event listeners de la carte
                if (this._map && this._eventHandlers) {
                    if (this._eventHandlers.graphicScaleUpdate) {
                        this._map.off('zoomend moveend', this._eventHandlers.graphicScaleUpdate);
                    }
                    if (this._eventHandlers.numericScaleUpdate) {
                        this._map.off('zoomend moveend', this._eventHandlers.numericScaleUpdate);
                    }
                }

                // Supprimer le conteneur principal du DOM
                if (this._mainWrapper && this._mainWrapper.parentNode) {
                    this._mainWrapper.parentNode.removeChild(this._mainWrapper);
                }

                // Nettoyer toutes les références
                this._map = null;
                this._config = null;
                this._container = null;
                this._scaleLineMetric = null;
                this._numericElement = null;
                this._zoomElement = null;
                this._inputElement = null;
                this._scalePrefix = null;
                this._mainWrapper = null;
                this._eventHandlers = {};

                Log.info("[GeoLeaf.ScaleControl] Contrôle détruit et ressources nettoyées");
            }
        };

        // Exposer le module (removed: migrated to globals.js in B3)

        /**
         * Initialise automatiquement le contrôle d'échelle si la configuration est présente
         */
        function initScaleControl(map) {
            if (!map) {
                Log.warn("[GeoLeaf.ScaleControl] Impossible d'initialiser : carte non fournie");
                return;
            }

            const config = _gl$1.GeoLeaf && _gl$1.GeoLeaf.Config && typeof _gl$1.GeoLeaf.Config.get === 'function'
                ? _gl$1.GeoLeaf.Config.get('scaleConfig')
                : null;

            if (config && (config.scaleGraphic || config.scaleNumeric || config.scaleNivel)) {
                ScaleControl$1.init(map, config);
            }
        }

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /**
     * Logger unifié
     */

    /**
     * Module DataConverter
     *
     * Responsabilités :
     * - Convertir les données brutes (Array de POI, Array de routes) vers GeoJSON FeatureCollection
     * - Normaliser les géométries
     * - Gérer les différents formats : POI, LineString, Polygon
     *
     * Utilisé par GeoLeaf.GeoJSON lors du chargement depuis profile.json
     */
    const DataConverterModule = {
        /**
         * Convertit un array de POI en GeoJSON FeatureCollection.
         *
         * Chaque POI doit avoir :
         * - id (string)
         * - latlng (array [lat, lng])
         * - title (string)
         * - attributes (object)
         *
         * @param {Array} poiArray - Array de POI
         * @returns {Object} FeatureCollection GeoJSON
         */
        convertPoiArrayToGeoJSON(poiArray) {
            if (!Array.isArray(poiArray)) {
                Log.warn("[DataConverter.convertPoiArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            const features = poiArray
                .map((poi) => {
                    if (!poi || typeof poi !== "object") {
                        return null;
                    }

                    if (!poi.id) {
                        Log.warn("[DataConverter.convertPoiArrayToGeoJSON] POI sans ID, ignoré", poi);
                        return null;
                    }

                    // Valider latlng
                    let coordinates = null;
                    if (Array.isArray(poi.latlng) && poi.latlng.length === 2) {
                        // GeoJSON utilise [lon, lat], mais les données utilisent [lat, lon]
                        coordinates = [poi.latlng[1], poi.latlng[0]];
                    } else if (
                        poi.location &&
                        typeof poi.location.lat === "number" &&
                        typeof poi.location.lng === "number"
                    ) {
                        coordinates = [poi.location.lng, poi.location.lat];
                    } else {
                        Log.warn(
                            "[DataConverter.convertPoiArrayToGeoJSON] POI sans coordonnées valides, ignoré",
                            { id: poi.id }
                        );
                        return null;
                    }

                    // Construire la feature GeoJSON
                    const feature = {
                        type: "Feature",
                        id: poi.id,
                        geometry: {
                            type: "Point",
                            coordinates: coordinates
                        },
                        properties: {
                            id: poi.id,
                            title: poi.title || "Sans titre",
                            description: poi.description || "",
                            ...poi.attributes // Fusionner les attributs
                        }
                    };

                    return feature;
                })
                .filter((f) => f !== null);

            Log.debug("[DataConverter.convertPoiArrayToGeoJSON] Converti", {
                input: poiArray.length,
                output: features.length
            });

            return {
                type: "FeatureCollection",
                features: features
            };
        },

        /**
         * Convertit un array de routes (LineString) en GeoJSON FeatureCollection.
         *
         * Chaque route doit avoir :
         * - id (string)
         * - geometry avec type: "LineString" et coordinates
         * - attributes (object optionnel)
         *
         * @param {Array} routeArray - Array de routes
         * @returns {Object} FeatureCollection GeoJSON
         */
        convertRouteArrayToGeoJSON(routeArray) {
            if (!Array.isArray(routeArray)) {
                Log.warn("[DataConverter.convertRouteArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            const features = routeArray
                .map((route) => {
                    if (!route || typeof route !== "object") {
                        return null;
                    }

                    if (!route.id) {
                        Log.warn("[DataConverter.convertRouteArrayToGeoJSON] Route sans ID, ignorée", route);
                        return null;
                    }

                    // Valider la géométrie
                    if (!route.geometry || route.geometry.type !== "LineString" || !Array.isArray(route.geometry.coordinates)) {
                        Log.warn(
                            "[DataConverter.convertRouteArrayToGeoJSON] Route sans géométrie LineString valide, ignorée",
                            { id: route.id }
                        );
                        return null;
                    }

                    // Construire la feature GeoJSON
                    const feature = {
                        type: "Feature",
                        id: route.id,
                        geometry: {
                            type: "LineString",
                            coordinates: route.geometry.coordinates
                        },
                        properties: {
                            id: route.id,
                            title: route.title || "Sans titre",
                            description: route.description || "",
                            categoryId: route.categoryId,
                            subCategoryId: route.subCategoryId,
                            ...route.attributes // Fusionner les attributs
                        }
                    };

                    return feature;
                })
                .filter((f) => f !== null);

            Log.debug("[DataConverter.convertRouteArrayToGeoJSON] Converti", {
                input: routeArray.length,
                output: features.length
            });

            return {
                type: "FeatureCollection",
                features: features
            };
        },

        /**
         * Convertit un array de zones (Polygon) en GeoJSON FeatureCollection.
         *
         * Chaque zone doit avoir :
         * - id (string)
         * - geometry avec type: "Polygon" et coordinates
         * - attributes (object optionnel)
         *
         * @param {Array} zoneArray - Array de zones
         * @returns {Object} FeatureCollection GeoJSON
         */
        convertZoneArrayToGeoJSON(zoneArray) {
            if (!Array.isArray(zoneArray)) {
                Log.warn("[DataConverter.convertZoneArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            const features = zoneArray
                .map((zone) => {
                    if (!zone || typeof zone !== "object") {
                        return null;
                    }

                    if (!zone.id) {
                        Log.warn("[DataConverter.convertZoneArrayToGeoJSON] Zone sans ID, ignorée", zone);
                        return null;
                    }

                    // Valider la géométrie
                    if (!zone.geometry || zone.geometry.type !== "Polygon" || !Array.isArray(zone.geometry.coordinates)) {
                        Log.warn(
                            "[DataConverter.convertZoneArrayToGeoJSON] Zone sans géométrie Polygon valide, ignorée",
                            { id: zone.id }
                        );
                        return null;
                    }

                    // Construire la feature GeoJSON
                    const feature = {
                        type: "Feature",
                        id: zone.id,
                        geometry: {
                            type: "Polygon",
                            coordinates: zone.geometry.coordinates
                        },
                        properties: {
                            id: zone.id,
                            title: zone.title || zone.siteName || "Sans titre",
                            description: zone.description || "",
                            ...zone.attributes // Fusionner les attributs
                        }
                    };

                    return feature;
                })
                .filter((f) => f !== null);

            Log.debug("[DataConverter.convertZoneArrayToGeoJSON] Converti", {
                input: zoneArray.length,
                output: features.length
            });

            return {
                type: "FeatureCollection",
                features: features
            };
        },

        /**
         * Convertit un string GPX en GeoJSON FeatureCollection.
         *
         * Parse les éléments waypoints et tracks, crée des Points ou LineStrings.
         *
         * @param {string} gpxString - Contenu XML du fichier GPX
         * @returns {Object} FeatureCollection GeoJSON
         */
        convertGpxToGeoJSON(gpxString) {
            if (!gpxString || typeof gpxString !== "string") {
                Log.warn("[DataConverter.convertGpxToGeoJSON] GPX string invalide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            try {
                // Parser le XML
                const parser = new DOMParser();
                const gpxDoc = parser.parseFromString(gpxString, "text/xml");

                const parseErrors = gpxDoc.getElementsByTagName("parsererror");
                if (parseErrors.length > 0) {
                    Log.error("[DataConverter.convertGpxToGeoJSON] Erreur parsing XML:", parseErrors[0].textContent);
                    return {
                        type: "FeatureCollection",
                        features: []
                    };
                }

                const features = [];

                // 1. Parser les waypoints (wpt)
                const waypoints = gpxDoc.getElementsByTagName("wpt");
                for (let i = 0; i < waypoints.length; i++) {
                    const wpt = waypoints[i];
                    const lat = parseFloat(wpt.getAttribute("lat"));
                    const lon = parseFloat(wpt.getAttribute("lon"));

                    if (!isNaN(lat) && !isNaN(lon)) {
                        const nameElem = wpt.getElementsByTagName("name")[0];
                        const descElem = wpt.getElementsByTagName("desc")[0];
                        const symElem = wpt.getElementsByTagName("sym")[0];

                        // Extraire les extensions GeoLeaf si présentes
                        const geoLeafExt = {};
                        const tagsList = []; // Accumulateur pour les tags multiples
                        const extensions = wpt.getElementsByTagName("extensions");
                        if (extensions.length > 0) {
                            const ext = extensions[0];
                            // Utiliser childNodes pour être sûr d'avoir tous les éléments
                            for (let j = 0; j < ext.childNodes.length; j++) {
                                const child = ext.childNodes[j];
                                // Ignorer les nœuds texte
                                if (child.nodeType !== 1) continue;

                                // Récupérer le nom du tag (gère les namespaces)
                                const tagName = child.tagName || child.nodeName || '';
                                const localName = child.localName || tagName.split(':').pop();

                                // Vérifier si c'est une extension GeoLeaf
                                const isGeoLeaf = tagName.toLowerCase().startsWith("geoleaf:") ||
                                    (child.namespaceURI && child.namespaceURI.includes("geoleaf"));

                                if (isGeoLeaf || tagName.includes(':')) {
                                    // Utiliser localName comme clé (sans préfixe)
                                    const key = localName || tagName.replace(/^[^:]+:/, '');
                                    const value = child.textContent || '';

                                    // Cas spécial : les tags sont accumulés dans un tableau
                                    if (key === 'tag' || key === 'tags') {
                                        if (value) tagsList.push(value);
                                    } else {
                                        geoLeafExt[key] = value;
                                    }
                                }
                            }
                        }

                        // Ajouter les tags comme tableau si présents
                        if (tagsList.length > 0) {
                            geoLeafExt.tags = tagsList;
                        }

                        const feature = {
                            type: "Feature",
                            id: geoLeafExt.id || (nameElem ? nameElem.textContent : `wpt-${i}`),
                            geometry: {
                                type: "Point",
                                coordinates: [lon, lat]
                            },
                            properties: {
                                id: geoLeafExt.id || (nameElem ? nameElem.textContent : `wpt-${i}`),
                                title: nameElem ? nameElem.textContent : `Waypoint ${i + 1}`,
                                description: descElem ? descElem.textContent : "",
                                symbol: symElem ? symElem.textContent : "",
                                ...geoLeafExt // Inclure les extensions GeoLeaf
                            }
                        };

                        features.push(feature);
                    }
                }

                // 2. Parser les tracks (trk)
                const tracks = gpxDoc.getElementsByTagName("trk");
                for (let i = 0; i < tracks.length; i++) {
                    const trk = tracks[i];
                    const nameElem = trk.getElementsByTagName("name")[0];
                    const descElem = trk.getElementsByTagName("desc")[0];

                    // Extraire les extensions GeoLeaf pour le track
                    const trkGeoLeafExt = {};
                    const trkTagsList = []; // Accumulateur pour les tags multiples
                    const trkExtensions = trk.getElementsByTagName("extensions");
                    if (trkExtensions.length > 0) {
                        const ext = trkExtensions[0];
                        for (let m = 0; m < ext.childNodes.length; m++) {
                            const child = ext.childNodes[m];
                            if (child.nodeType !== 1) continue;

                            const tagName = child.tagName || child.nodeName || '';
                            const localName = child.localName || tagName.split(':').pop();

                            const isGeoLeaf = tagName.toLowerCase().startsWith("geoleaf:") ||
                                (child.namespaceURI && child.namespaceURI.includes("geoleaf"));

                            if (isGeoLeaf || tagName.includes(':')) {
                                const key = localName || tagName.replace(/^[^:]+:/, '');
                                const value = child.textContent || '';

                                // Cas spécial : les tags sont accumulés dans un tableau
                                if (key === 'tag' || key === 'tags') {
                                    if (value) trkTagsList.push(value);
                                } else {
                                    trkGeoLeafExt[key] = value;
                                }
                            }
                        }
                    }

                    // Ajouter les tags comme tableau si présents
                    if (trkTagsList.length > 0) {
                        trkGeoLeafExt.tags = trkTagsList;
                    }

                    const segments = trk.getElementsByTagName("trkseg");
                    for (let j = 0; j < segments.length; j++) {
                        const segment = segments[j];
                        const trkpts = segment.getElementsByTagName("trkpt");

                        const coordinates = [];
                        for (let k = 0; k < trkpts.length; k++) {
                            const trkpt = trkpts[k];
                            const lat = parseFloat(trkpt.getAttribute("lat"));
                            const lon = parseFloat(trkpt.getAttribute("lon"));

                            if (!isNaN(lat) && !isNaN(lon)) {
                                coordinates.push([lon, lat]);
                            }
                        }

                        if (coordinates.length > 0) {
                            const feature = {
                                type: "Feature",
                                id: nameElem ? `${nameElem.textContent}-${j}` : `trk-${i}-${j}`,
                                geometry: {
                                    type: "LineString",
                                    coordinates: coordinates
                                },
                                properties: {
                                    id: nameElem ? `${nameElem.textContent}-${j}` : `trk-${i}-${j}`,
                                    title: nameElem ? nameElem.textContent : `Track ${i + 1}`,
                                    description: descElem ? descElem.textContent : "",
                                    segmentIndex: j,
                                    pointCount: coordinates.length,
                                    ...trkGeoLeafExt // Inclure les extensions GeoLeaf du track
                                }
                            };

                            features.push(feature);
                        }
                    }
                }

                Log.debug("[DataConverter.convertGpxToGeoJSON] Converti", {
                    waypoints: waypoints.length,
                    tracks: tracks.length,
                    features: features.length
                });

                return {
                    type: "FeatureCollection",
                    features: features
                };
            } catch (err) {
                Log.error("[DataConverter.convertGpxToGeoJSON] Erreur lors du parsing GPX:", err);
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }
        },

        /**
         * Détecte automatiquement le type de données et les convertit en GeoJSON.
         *
         * Stratégie de détection :
         * 1. Si déjà GeoJSON (type: "FeatureCollection"), retourner tel quel
         * 2. Si array : analyser le premier élément
         *    - S'il a "latlng" ou "location" → POI
         *    - S'il a "geometry.type === 'LineString'" → Route
         *    - S'il a "geometry.type === 'Polygon'" → Zone
         * 3. Sinon : retourner vide
         *
         * @param {*} data - Données à convertir
         * @returns {Object} FeatureCollection GeoJSON
         */
        autoConvert(data) {
            if (!data) {
                Log.warn("[DataConverter.autoConvert] Données nulles, retour FeatureCollection vide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            // Cas 1 : Déjà GeoJSON
            if (data.type === "FeatureCollection" && Array.isArray(data.features)) {
                Log.debug("[DataConverter.autoConvert] Données déjà en GeoJSON, passage direct");
                return data;
            }

            if (data.type === "Feature" && data.geometry) {
                Log.debug("[DataConverter.autoConvert] Feature unique, conversion en FeatureCollection");
                return {
                    type: "FeatureCollection",
                    features: [data]
                };
            }

            // Cas 2 : Array
            if (!Array.isArray(data) || data.length === 0) {
                Log.warn("[DataConverter.autoConvert] Données ne sont pas un array ou array vide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            const firstItem = data[0];

            if (!firstItem || typeof firstItem !== "object") {
                Log.warn("[DataConverter.autoConvert] Premier élément invalide");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            // Analyser le type
            if (firstItem.latlng || (firstItem.location && typeof firstItem.location.lat === "number")) {
                // POI
                Log.debug("[DataConverter.autoConvert] Détecté comme array de POI");
                return this.convertPoiArrayToGeoJSON(data);
            } else if (
                firstItem.geometry &&
                firstItem.geometry.type === "LineString" &&
                Array.isArray(firstItem.geometry.coordinates)
            ) {
                // Route
                Log.debug("[DataConverter.autoConvert] Détecté comme array de routes");
                return this.convertRouteArrayToGeoJSON(data);
            } else if (
                firstItem.geometry &&
                firstItem.geometry.type === "Polygon" &&
                Array.isArray(firstItem.geometry.coordinates)
            ) {
                // Zone
                Log.debug("[DataConverter.autoConvert] Détecté comme array de zones");
                return this.convertZoneArrayToGeoJSON(data);
            } else {
                Log.warn("[DataConverter.autoConvert] Type de données non reconnu");
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }
        }
    };

    // Exposition de l'API
    const DataConverter = DataConverterModule;

    /*!
     * GeoLeaf Core – Config / Loaders
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /**
     * Charge une configuration depuis une URL JSON et la fusionne.
     *
     * @param {string} url - URL du fichier JSON
     * @param {Object} [options] - Options de chargement
     * @param {Object} [options.headers] - Headers HTTP personnalisés (ex: CSRF token)
     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type
     * @returns {Promise<Object>}
     * @example
     * Config.loadUrl('/api/config.json', {
     *     headers: { 'X-CSRF-Token': '...' },
     *     strictContentType: true
     * })
     */
    Config.loadUrl = function (url, options = {}) {
        const Loader = ProfileLoader$1;
        if (!Loader) {
            Log.error("[GeoLeaf.Config] Module Loader non disponible.");
            return Promise.reject(new Error("Loader module not available"));
        }

        return Loader.loadUrl(url, options)
            .then((jsonCfg) => {
                // perf 5.5+5.6 : utiliser _applyConfig() pour éviter la duplication de
                // _validateConfig() et _initSubModules() (appels doubles supprimés)
                this._applyConfig(jsonCfg, "url");

                this._maybeFireLoadedEvent();

                return this._config;
            })
            .catch((err) => {
                Log.error("[GeoLeaf.Config] Erreur lors du chargement JSON :", err);
                return this._config;
            });
    };

    /**
     * Charge un fichier de taxonomie (mapping catégories / sous-catégories)
     * et le fusionne dans la configuration existante.
     *
     * @param {string} [url] - URL du fichier de mapping (depuis le profil)
     * @param {Object} [options]
     * @param {Object} [options.headers]
     * @param {boolean} [options.strictContentType=true]
     * @returns {Promise<Object>} - Objet categories consolidé
     */
    Config.loadTaxonomy = function (url = null, options = {}) {
        const Taxonomy = TaxonomyManager;
        if (!Taxonomy) {
            Log.error("[GeoLeaf.Config] Module Taxonomy non disponible.");
            return Promise.reject(new Error("Taxonomy module not available"));
        }

        return Taxonomy.loadTaxonomy(url, options);
    };

    /**
     * Charge les ressources liées au profil actif :
     * - profile.json
     * - poi.json
     * - mapping.json
     * - routes.json
     *
     * @param {Object} [options]
     * @param {Object} [options.headers] - Headers HTTP optionnels.
     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
     * @returns {Promise<Object>} Configuration consolidée incluant les données du profil.
     */
    Config.loadActiveProfileResources = function (options = {}) {
        const Profile = ProfileManager;
        if (!Profile) {
            Log.error("[GeoLeaf.Config] Module Profile non disponible.");
            return Promise.reject(new Error("Profile module not available"));
        }

        return Profile.loadActiveProfileResources(options);
    };

    /*!
     * GeoLeaf Core – Config / Accessors
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /* ------------------------------------------------------------------ */
    /*  Storage accessors                                                  */
    /* ------------------------------------------------------------------ */

    /**
     * Retourne la configuration complète (objet).
     *
     * @returns {Object}
     */
    Config.getAll = function () {
        // S'assurer que les sous-modules sont initialisés
        if (!this._isLoaded) {
            this._initSubModules();
        }

        const Storage = StorageHelper;
        return Storage && typeof Storage.getAll === "function"
            ? Storage.getAll()
            : this._config;
    };

    /**
     * Récupère une valeur via un chemin de type "map.center" ou "basemaps.street.url".
     *
     * @param {string} path - Chemin avec des points.
     * @param {*} [defaultValue] - Valeur renvoyée si le chemin n'existe pas.
     * @returns {*}
     */
    Config.get = function (path, defaultValue) {
        // S'assurer que les sous-modules sont initialisés
        if (!this._isLoaded) {
            this._initSubModules();
        }

        const Storage = StorageHelper;
        return Storage && typeof Storage.get === "function"
            ? Storage.get(path, defaultValue)
            : defaultValue;
    };

    /**
     * Définit une valeur via un chemin de type "map.center" ou "basemaps.street.url".
     * Crée les objets intermédiaires si nécessaire.
     *
     * @param {string} path
     * @param {*} value
     */
    Config.set = function (path, value) {
        const Storage = StorageHelper;
        if (Storage && typeof Storage.set === "function") {
            Storage.set(path, value);
        } else {
            Log.warn("[GeoLeaf.Config] Module Storage non disponible pour set().");
        }
    };

    /**
     * Retourne une section de configuration (ex : "basemaps", "map").
     *
     * @param {string} sectionName
     * @param {Object} [defaultValue]
     * @returns {Object|*}
     */
    Config.getSection = function (sectionName, defaultValue) {
        const Storage = StorageHelper;
        return Storage && typeof Storage.getSection === "function"
            ? Storage.getSection(sectionName, defaultValue)
            : defaultValue;
    };

    /* ------------------------------------------------------------------ */
    /*  Taxonomy accessors                                                 */
    /* ------------------------------------------------------------------ */

    /**
     * Retourne l'objet complet des catégories (mapping interne).
     *
     * @returns {Object} - { [categoryId]: { label, icon, colorFill, colorStroke, subcategories? } }
     */
    Config.getCategories = function () {
        // S'assurer que les sous-modules sont initialisés
        if (!this._isLoaded) {
            this._initSubModules();
        }

        const Taxonomy = TaxonomyManager;
        return Taxonomy && typeof Taxonomy.getCategories === "function"
            ? Taxonomy.getCategories()
            : {};
    };

    /**
     * Retourne une catégorie à partir de son identifiant.
     *
     * @param {string} categoryId
     * @returns {Object|undefined}
     */
    Config.getCategory = function (categoryId) {
        const Taxonomy = TaxonomyManager;
        return Taxonomy && typeof Taxonomy.getCategory === "function"
            ? Taxonomy.getCategory(categoryId)
            : undefined;
    };

    /**
     * Retourne une sous-catégorie à partir de son identifiant et de celui
     * de la catégorie parente.
     *
     * @param {string} categoryId
     * @param {string} subCategoryId
     * @returns {Object|undefined}
     */
    Config.getSubcategory = function (categoryId, subCategoryId) {
        const Taxonomy = TaxonomyManager;
        return Taxonomy && typeof Taxonomy.getSubcategory === "function"
            ? Taxonomy.getSubcategory(categoryId, subCategoryId)
            : undefined;
    };

    /* ------------------------------------------------------------------ */
    /*  Profile accessors                                                  */
    /* ------------------------------------------------------------------ */

    /**
     * Retourne l'identifiant du profil actuellement chargé (ou null).
     *
     * @returns {string|null}
     */
    Config.getActiveProfileId = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getActiveProfileId === "function"
            ? Profile.getActiveProfileId()
            : null;
    };

    /**
     * Retourne l'objet profile.json du profil actif (ou null).
     *
     * @returns {Object|null}
     */
    Config.getActiveProfile = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getActiveProfile === "function"
            ? Profile.getActiveProfile()
            : null;
    };

    /**
     * Retourne le tableau de POI normalisés du profil actif.
     *
     * @returns {Array}
     */
    Config.getActiveProfilePoi = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getActiveProfilePoi === "function"
            ? Profile.getActiveProfilePoi()
            : [];
    };

    /**
     * Retourne le tableau de routes du profil actif.
     *
     * @returns {Array}
     */
    Config.getActiveProfileRoutes = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getActiveProfileRoutes === "function"
            ? Profile.getActiveProfileRoutes()
            : [];
    };

    /**
     * Retourne l'objet de mapping du profil actif (mapping.json).
     *
     * @returns {Object|null}
     */
    Config.getActiveProfileMapping = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getActiveProfileMapping === "function"
            ? Profile.getActiveProfileMapping()
            : null;
    };

    /**
     * Retourne la configuration des icônes depuis la taxonomie du profil actif.
     *
     * @returns {Object|null}
     */
    Config.getIconsConfig = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.getIconsConfig === "function"
            ? Profile.getIconsConfig()
            : null;
    };

    /**
     * Indique si l'usage de mapping.json pour normaliser les POI de profil est activé.
     *
     * @returns {boolean} true si le mapping doit être utilisé, false sinon.
     */
    Config.isProfilePoiMappingEnabled = function () {
        const Profile = ProfileManager;
        return Profile && typeof Profile.isProfilePoiMappingEnabled === "function"
            ? Profile.isProfilePoiMappingEnabled()
            : true;
    };

    /*!
     * GeoLeaf Core – Config / Validation
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */



    /**
     * Valide la structure du JSON de configuration.
     * Lance une erreur si les données critiques sont invalides.
     *
     * @param {Object} cfg - Configuration à valider
     * @throws {Error} Si la structure est invalide
     * @private
     */
    Config._validateConfig = function (cfg) {
        if (!cfg || typeof cfg !== "object") {
            return; // Pas de validation si vide
        }

        // Validation de map.center
        if (cfg.map && cfg.map.center !== undefined) {
            if (
                !Array.isArray(cfg.map.center) ||
                cfg.map.center.length !== 2 ||
                typeof cfg.map.center[0] !== "number" ||
                typeof cfg.map.center[1] !== "number"
            ) {
                throw new Error(
                    "[GeoLeaf.Config] map.center doit être un tableau de 2 nombres [lat, lng]."
                );
            }
        }

        // Validation de map.zoom
        if (cfg.map && cfg.map.zoom !== undefined) {
            if (typeof cfg.map.zoom !== "number" || cfg.map.zoom < 0 || cfg.map.zoom > 20) {
                throw new Error(
                    "[GeoLeaf.Config] map.zoom doit être un nombre entre 0 et 20."
                );
            }
        }

        // Validation de map.positionFixed
        if (cfg.map && cfg.map.positionFixed !== undefined) {
            if (typeof cfg.map.positionFixed !== "boolean") {
                throw new Error(
                    "[GeoLeaf.Config] map.positionFixed doit être un booléen (true/false)."
                );
            }
        }

        // Validation de map.initialMaxZoom
        if (cfg.map && cfg.map.initialMaxZoom !== undefined) {
            if (typeof cfg.map.initialMaxZoom !== "number" || cfg.map.initialMaxZoom < 1 || cfg.map.initialMaxZoom > 20) {
                throw new Error(
                    "[GeoLeaf.Config] map.initialMaxZoom doit être un nombre entre 1 et 20."
                );
            }
        }

        // Validation de map.boundsMargin
        if (cfg.map && cfg.map.boundsMargin !== undefined) {
            if (typeof cfg.map.boundsMargin !== "number" || cfg.map.boundsMargin < 0 || cfg.map.boundsMargin > 1) {
                throw new Error(
                    "[GeoLeaf.Config] map.boundsMargin doit être un nombre entre 0 et 1 (ex: 0.3 = 30% de marge)."
                );
            }
        }

        // Validation de basemaps
        if (cfg.basemaps !== undefined) {
            if (typeof cfg.basemaps !== "object" || cfg.basemaps === null) {
                throw new Error(
                    "[GeoLeaf.Config] basemaps doit être un objet."
                );
            }
        }

        // Validation de poi
        if (cfg.poi !== undefined) {
            if (!Array.isArray(cfg.poi)) {
                throw new Error(
                    "[GeoLeaf.Config] poi doit être un tableau."
                );
            }
        }

        // Validation de geojson
        if (cfg.geojson !== undefined) {
            if (!Array.isArray(cfg.geojson)) {
                throw new Error(
                    "[GeoLeaf.Config] geojson doit être un tableau."
                );
            }
        }

        // Validation de categories
        if (cfg.categories !== undefined) {
            if (
                typeof cfg.categories !== "object" ||
                cfg.categories === null ||
                Array.isArray(cfg.categories)
            ) {
                throw new Error(
                    "[GeoLeaf.Config] categories doit être un objet."
                );
            }

            // Valider chaque catégorie
            Object.entries(cfg.categories).forEach(([catId, catData]) => {
                if (!catData || typeof catData !== "object") {
                    Log.warn(
                        `[GeoLeaf.Config] Catégorie '${catId}' invalide (doit être un objet).`
                    );
                    return;
                }

                if (!catData.label || typeof catData.label !== "string") {
                    Log.warn(
                        `[GeoLeaf.Config] Catégorie '${catId}' : le champ 'label' est manquant ou invalide.`
                    );
                }

                // Validation couleurs : accepter soit 'color' (ancien format), soit 'colorFill'/'colorStroke' (nouveau format)
                const hasOldFormat = catData.color && typeof catData.color === "string";
                const hasNewFormat =
                    (catData.colorFill && typeof catData.colorFill === "string") ||
                    (catData.colorStroke && typeof catData.colorStroke === "string");

                if (!hasOldFormat && !hasNewFormat) {
                    Log.warn(
                        `[GeoLeaf.Config] Catégorie '${catId}' : aucune couleur définie (ni 'color', ni 'colorFill'/'colorStroke').`
                    );
                }

                // Valider les sous-catégories
                if (catData.subcategories !== undefined) {
                    if (
                        typeof catData.subcategories !== "object" ||
                        catData.subcategories === null ||
                        Array.isArray(catData.subcategories)
                    ) {
                        Log.warn(
                            `[GeoLeaf.Config] Catégorie '${catId}' : subcategories doit être un objet.`
                        );
                        return;
                    }

                    Object.entries(catData.subcategories).forEach(([subId, subData]) => {
                        if (!subData || typeof subData !== "object") {
                            Log.warn(
                                `[GeoLeaf.Config] Sous-catégorie '${subId}' dans '${catId}' invalide (doit être un objet).`
                            );
                            return;
                        }

                        if (!subData.label || typeof subData.label !== "string") {
                            Log.warn(
                                `[GeoLeaf.Config] Sous-catégorie '${subId}' dans '${catId}' : le champ 'label' est manquant ou invalide.`
                            );
                        }

                        const hasOldFormatSub =
                            subData.color && typeof subData.color === "string";
                        const hasNewFormatSub =
                            (subData.colorFill && typeof subData.colorFill === "string") ||
                            (subData.colorStroke && typeof subData.colorStroke === "string");

                        if (!hasOldFormatSub && !hasNewFormatSub) {
                            Log.warn(
                                `[GeoLeaf.Config] Sous-catégorie '${subId}' dans '${catId}' : aucune couleur définie (ni 'color', ni 'colorFill'/'colorStroke').`
                            );
                        }
                    });
                }
            });
        }

        Log.debug("[GeoLeaf.Config] Validation de la structure réussie.");
    };

    /**
     * globals.config.js — Bridge UMD/ESM : B3 + B4 — helpers, validators, renderers, data, loaders, config
     *
     * @see globals.js (orchestrateur)
     */


    const _g$D = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};

    _g$D.GeoLeaf = _g$D.GeoLeaf || {};

    // ── B3 assignations ──────────────────────────────────────────────────────────
    if (!_g$D.GeoLeaf.Helpers) _g$D.GeoLeaf.Helpers = {};
    _g$D.GeoLeaf.Helpers.StyleResolver = StyleResolver;
    _g$D.GeoLeaf.Helpers.getColorsFromLayerStyle = getColorsFromLayerStyle;
    _g$D.GeoLeaf.Helpers.resolvePoiColors = resolvePoiColors;
    if (!_g$D.GeoLeaf._Validators) _g$D.GeoLeaf._Validators = {};
    _g$D.GeoLeaf._StyleValidator = StyleValidator;
    _g$D.GeoLeaf._Validators.StyleValidator = StyleValidator;
    _g$D.GeoLeaf._StyleValidatorRules = StyleValidatorRules;
    _g$D.GeoLeaf._Validators.StyleValidatorRules = StyleValidatorRules;
    if (!_g$D.GeoLeaf._Renderers) _g$D.GeoLeaf._Renderers = {};
    _g$D.GeoLeaf._Renderers.AbstractRenderer = AbstractRenderer;
    _g$D.GeoLeaf._Renderers.SimpleTextRenderer = SimpleTextRenderer;
    _g$D.GeoLeaf._Normalizer = DataNormalizer;
    _g$D.GeoLeaf._StyleLoader = StyleLoader;
    _g$D.GeoLeaf.ScaleControl = ScaleControl$1;
    _g$D.GeoLeaf.initScaleControl = initScaleControl;

    // ── B4 assignations ──────────────────────────────────────────────────────────
    if (!_g$D.GeoLeaf.Config) _g$D.GeoLeaf.Config = Config;
    Object.assign(_g$D.GeoLeaf.Config, Config);
    _g$D.GeoLeaf._DataConverter = DataConverter;
    _g$D.GeoLeaf._ConfigLoader = ProfileLoader$1;
    _g$D.GeoLeaf._ConfigNormalization = ConfigNormalizer;
    _g$D.GeoLeaf._ProfileLoader = ProfileLoader;
    _g$D.GeoLeaf._ConfigProfile = ProfileManager;
    _g$D.GeoLeaf._ConfigStorage = StorageHelper;
    _g$D.GeoLeaf._ConfigTaxonomy = TaxonomyManager;

    /**
     * GeoLeaf GeoJSON Module - Shared State & Constants
     * État partagé et constantes pour le module GeoJSON
     *
     * @module geojson/shared
     */

    const _g$C =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    /**
     * État partagé du module GeoJSON
     * Accessible via GeoJSONShared.state
     */
    const GeoJSONShared = {};

    /**
     * État interne partagé entre les sous-modules
     */
    GeoJSONShared.state = {
        /**
         * Référence vers la carte Leaflet.
         * @type {L.Map|null}
         */
        map: null,

        /**
         * Groupe contenant toutes les couches GeoJSON (conteneur parent).
         * @type {L.LayerGroup|null}
         */
        layerGroup: null,

        /**
         * LEGACY: Couche L.GeoJSON principale (pour compatibilité descendante).
         * @deprecated depuis v4.0.0 — utiliser `layers` (Map). Suppression prévue en v4.1.0.
         * Migration : remplacer `state.geoJsonLayer` par `state.layers.get(layerId)?.layer`.
         * @type {L.GeoJSON|null}
         */
        geoJsonLayer: null,

        /**
         * Map des couches individuelles par ID.
         * Structure: Map<layerId, {id, label, layer, visible, config, clusterGroup}>
         * Remplace le champ `geoJsonLayer` (désormais @deprecated).
         * Migration : remplacer `state.geoJsonLayer` par `state.layers.get(layerId)?.layer`.
         * @type {Map<string, Object>}
         */
        layers: new Map(),

        /**
         * Compteur pour générer des IDs uniques si non fourni.
         * @type {number}
         */
        layerIdCounter: 0,

        // featureCache removed (Sprint 1) — features accessed via state.layers

        /**
         * Options par défaut du module GeoJSON.
         */
        options: {
            /**
             * Style par défaut des géométries (polygones / lignes).
             * Neutral transparent fallback — real style loaded from JSON before layer creation.
             */
            defaultStyle: {
                color: "#999999",
                weight: 2,
                opacity: 0.9,
                fillColor: "#cccccc",
                fillOpacity: 0.15,
            },
            /**
             * Style des points (circleMarker).
             */
            defaultPointStyle: {
                radius: 6,
                color: "#999999",
                weight: 2,
                fillColor: "#cccccc",
                fillOpacity: 0.9,
            },
            /**
             * Fonction de rappel pour chaque feature.
             * @param {Object} feature
             * @param {L.Layer} layer
             */
            onEachFeature: null,
            /**
             * Fonction pointToLayer personnalisée (si fournie).
             * @param {Object} feature
             * @param {L.LatLng} latlng
             * @returns {L.Layer}
             */
            pointToLayer: null,
            /**
             * Adapter automatiquement la vue sur les données chargées.
             */
            fitBoundsOnLoad: true,
            /**
             * ZOOM max lors du fitBounds (facultatif).
             */
            maxZoomOnFit:
                _g$C.GeoLeaf && _g$C.GeoLeaf.CONSTANTS ? _g$C.GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18,
        },
    };

    /**
     * Configuration des panes Leaflet pour le z-ordering des couches.
     */
    GeoJSONShared.PANE_CONFIG = {
        BASEMAP_NAME: "geoleaf-basemap",
        BASEMAP_ZINDEX: 200,
        LAYER_PREFIX: "geoleaf-layer-",
        LAYER_BASE_ZINDEX: 400,
        MIN_LAYER_ZINDEX: 0,
        MAX_LAYER_ZINDEX: 99,
    };

    /**
     * Helpers pour la gestion des panes
     */
    GeoJSONShared.PaneHelpers = {
        /**
         * Génère le nom du pane pour un zIndex donné
         * @param {number} zIndex - zIndex de la couche (0-99)
         * @returns {string} Nom du pane
         */
        getPaneName(zIndex) {
            const config = GeoJSONShared.PANE_CONFIG;
            return `${config.LAYER_PREFIX}${zIndex || 0}`;
        },

        /**
         * Valide et clamp un zIndex dans la plage autorisée
         * @param {number} zIndex - zIndex à valider
         * @returns {number} zIndex valide (0-99)
         */
        validateZIndex(zIndex) {
            const config = GeoJSONShared.PANE_CONFIG;
            return Math.max(
                config.MIN_LAYER_ZINDEX,
                Math.min(config.MAX_LAYER_ZINDEX, Math.floor(zIndex))
            );
        },

        /**
         * Applique le pane à un layer ou marker
         * @param {L.Layer} layer - Layer Leaflet
         * @param {number} zIndex - zIndex de la couche
         */
        applyPaneToLayer(layer, zIndex) {
            if (layer && layer.options) {
                layer.options.pane = this.getPaneName(zIndex);
            }
        },
    };

    /**
     * Map des opérateurs de comparaison pour styleRules.
     * Supporte : >, >=, <, <=, ==, ===, eq (alias ==), !=, !==, contains, startsWith, endsWith, in, notIn, between
     */
    GeoJSONShared.STYLE_OPERATORS = {
        ">": (a, b) => Number(a) > Number(b),
        ">=": (a, b) => Number(a) >= Number(b),
        "<": (a, b) => Number(a) < Number(b),
        "<=": (a, b) => Number(a) <= Number(b),
        "==": (a, b) => a == b,
        "===": (a, b) => a === b,
        eq: (a, b) => a == b, // Alias pour ==
        "!=": (a, b) => a != b,
        "!==": (a, b) => a !== b,
        neq: (a, b) => a != b, // Alias pour !=
        contains: (a, b) => String(a).toLowerCase().includes(String(b).toLowerCase()),
        startsWith: (a, b) => String(a).toLowerCase().startsWith(String(b).toLowerCase()),
        endsWith: (a, b) => String(a).toLowerCase().endsWith(String(b).toLowerCase()),
        in: (a, b) => Array.isArray(b) && b.includes(a),
        notIn: (a, b) => Array.isArray(b) && !b.includes(a),
        between: (a, b) => {
            if (!Array.isArray(b) || b.length !== 2) return false;
            const num = Number(a);
            const min = Number(b[0]);
            const max = Number(b[1]);
            return num >= min && num <= max;
        },
    };

    /**
     * Réinitialise l'état partagé (utile pour les tests)
     */
    GeoJSONShared.reset = function () {
        const state = GeoJSONShared.state;
        state.map = null;
        state.layerGroup = null;
        state.geoJsonLayer = null;
        state.layers = new Map();
        state.layerIdCounter = 0;
        // featureCache removed (Sprint 1)
        // Réinitialiser les options par défaut
        state.options = {
            defaultStyle: {
                color: "#999999",
                weight: 2,
                opacity: 0.9,
                fillColor: "#cccccc",
                fillOpacity: 0.15,
            },
            defaultPointStyle: {
                radius: 6,
                color: "#999999",
                weight: 2,
                fillColor: "#cccccc",
                fillOpacity: 0.9,
            },
            onEachFeature: null,
            pointToLayer: null,
            fitBoundsOnLoad: true,
            maxZoomOnFit:
                _g$C.GeoLeaf && _g$C.GeoLeaf.CONSTANTS ? _g$C.GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18,
        };
    };

    /**
     * Getter pour le Log (lazy loading)
     */
    GeoJSONShared.getLog = function () {
        return _g$C.GeoLeaf && _g$C.GeoLeaf.Log ? _g$C.GeoLeaf.Log : console;
    };

    // ── Getters publics (8.3.2) ─────────────────────────────────────────────────

    /**
     * @public Retourne la Map des couches GeoJSON actives.
     * @returns {Map<string, Object>}
     */
    GeoJSONShared.getLayers = function () {
        return GeoJSONShared.state.layers;
    };

    /**
     * @public Retourne les données d'une couche par son ID.
     * @param {string} layerId
     * @returns {Object|undefined}
     */
    GeoJSONShared.getLayerById = function (layerId) {
        return GeoJSONShared.state.layers.get(layerId);
    };

    /**
     * GeoLeaf GeoJSON Module - Clustering
     * Gestion des stratégies de clustering (unified, by-source, etc.)
     *
     * @module geojson/clustering
     */

    const _g$B = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});


    // Dépendances lazy

    const GeoJSONClustering = {};

    /**
     * Récupère la configuration POI globale.
     *
     * @returns {Object}
     */
    GeoJSONClustering.getPoiConfig = function () {
        const Config = _g$B.GeoLeaf && _g$B.GeoLeaf.Config;
        if (Config && typeof Config.get === "function") {
            return Config.get("poiConfig") || {};
        }
        return {};
    };

    /**
     * Récupère le cluster partagé du module POI s'il existe.
     *
     * @returns {L.MarkerClusterGroup|null}
     */
    GeoJSONClustering.getSharedPOICluster = function () {
        const Log = getLog();


        try {
            const POI = _g$B.GeoLeaf && _g$B.GeoLeaf.POI;
            if (!POI || typeof POI.getLayer !== "function") {
                Log.debug("[GeoLeaf.GeoJSON] Module POI non disponible ou getLayer() manquant");
                return null;
            }

            const poiLayer = POI.getLayer();

            if (!poiLayer) {
                Log.debug("[GeoLeaf.GeoJSON] POI.getLayer() retourne null/undefined");
                return null;
            }

            Log.debug("[GeoLeaf.GeoJSON] POI.getLayer() retourné:", {
                hasAddLayer: typeof poiLayer.addLayer === "function",
                hasRemoveLayer: typeof poiLayer.removeLayer === "function",
                hasFeatureGroup: poiLayer._featureGroup !== undefined,
                hasGroup: poiLayer._group !== undefined,
                hasClusterGroup: poiLayer._markerCluster !== undefined,
                isMarkerClusterGroup: poiLayer.constructor && poiLayer.constructor.name === 'MarkerClusterGroup',
                constructor: poiLayer.constructor ? poiLayer.constructor.name : 'unknown'
            });

            // Vérifier si c'est un markerClusterGroup ou LayerGroup valide
            // Accepter tout layer avec addLayer/removeLayer (plus permissif)
            if (poiLayer &&
                typeof poiLayer.addLayer === "function" &&
                typeof poiLayer.removeLayer === "function") {
                Log.debug("[GeoLeaf.GeoJSON] Cluster/Layer POI récupéré avec succès");
                return poiLayer;
            }

            Log.warn("[GeoLeaf.GeoJSON] POI.getLayer() ne retourne pas un layer valide (checks failed)");
        } catch (e) {
            Log.error("[GeoLeaf.GeoJSON] Impossible de récupérer le cluster POI :", e);
        }
        return null;
    };

    /**
     * Détermine la stratégie de clustering pour une couche.
     *
     * @param {Object} def - Définition de la couche
     * @param {Object} geojsonData - Données GeoJSON
     * @returns {Object} - { shouldCluster: boolean, useSharedCluster: boolean }
     */
    GeoJSONClustering.getClusteringStrategy = function (def, geojsonData) {
        const Log = getLog();
        const poiConfig = GeoJSONClustering.getPoiConfig();

        // Normaliser def.clustering: peut être boolean ou object
        const clusteringConfig = typeof def.clustering === 'object' ? def.clustering : { enabled: def.clustering };
        const isClusteringEnabled = clusteringConfig.enabled === true;
        const isClusteringDisabled = clusteringConfig.enabled === false;

        // Override explicite dans la couche: clustering.enabled: false (priorité absolue)
        if (isClusteringDisabled) {
            return { shouldCluster: false, useSharedCluster: false };
        }

        // Si clustering désactivé globalement ET pas d'override dans la couche
        if (!poiConfig.clustering && !isClusteringEnabled) {
            return { shouldCluster: false, useSharedCluster: false };
        }

        // Vérifier si la couche contient des Points
        const hasPoints = geojsonData.features && geojsonData.features.some(f =>
            f.geometry && f.geometry.type && f.geometry.type.includes("Point")
        );

        if (!hasPoints) {
            return { shouldCluster: false, useSharedCluster: false };
        }

        // Override explicite dans la couche: clustering.enabled: true
        if (isClusteringEnabled) {
            // Si la couche a des paramètres de clustering spécifiques, créer un cluster indépendant
            const clusterRadius = clusteringConfig.maxClusterRadius || (typeof def.clusterRadius === "number" ? def.clusterRadius : null);
            const disableAtZoom = clusteringConfig.disableClusteringAtZoom || (typeof def.disableClusteringAtZoom === "number" ? def.disableClusteringAtZoom : null);

            const hasCustomClusterParams =
                (clusterRadius !== null && clusterRadius !== (poiConfig.clusterRadius || 80)) ||
                (disableAtZoom !== null && disableAtZoom !== (poiConfig.disableClusteringAtZoom || 18));

            if (hasCustomClusterParams) {
                return {
                    shouldCluster: true,
                    useSharedCluster: false  // Cluster indépendant avec paramètres personnalisés
                };
            }

            // Sinon, respecter la stratégie globale
            const strategy = poiConfig.clusterStrategy || "unified";
            return {
                shouldCluster: true,
                useSharedCluster: strategy === "unified"
            };
        }

        // Lire la stratégie configurée
        const strategy = poiConfig.clusterStrategy || "unified";

        switch (strategy) {
            case "unified":
                // Un seul cluster partagé pour tous
                return { shouldCluster: true, useSharedCluster: true };

            case "by-layer":
                // Cluster indépendant par couche: respecte clustering.enabled: true/false en config
                // Par défaut, pas de cluster SAUF si clustering.enabled === true
                return {
                    shouldCluster: isClusteringEnabled,
                    useSharedCluster: false  // Chaque couche a son propre cluster
                };

            case "by-source":
                // Cluster séparé par source
                const sourceConfig = poiConfig.clusterStrategies?.["by-source"]?.sources || {};
                const shouldClusterGeoJSON = sourceConfig.geojson !== false;
                return {
                    shouldCluster: shouldClusterGeoJSON,
                    useSharedCluster: false
                };

            case "json-only":
                // Cluster uniquement pour JSON, pas GeoJSON
                const jsonOnlyConfig = poiConfig.clusterStrategies?.["json-only"] || {};
                return {
                    shouldCluster: jsonOnlyConfig.geojsonClustering === true,
                    useSharedCluster: false
                };

            default:
                // Par défaut : comportement unifié (rétrocompatibilité)
                Log.warn("[GeoLeaf.GeoJSON] Stratégie de clustering inconnue: " + strategy + ". Utilisation de 'unified'.");
                return { shouldCluster: true, useSharedCluster: true };
        }
    };

    /**
     * Crée un cluster indépendant avec les options spécifiées.
     *
     * @param {Object} options - Options de clustering
     * @returns {L.MarkerClusterGroup|null}
     */
    GeoJSONClustering.createIndependentCluster = function (options = {}) {
        if (!_g$B.L || !_g$B.L.markerClusterGroup) {
            return null;
        }

        return _g$B.L.markerClusterGroup({
            maxClusterRadius: options.clusterRadius || 80,
            disableClusteringAtZoom: options.disableClusteringAtZoom || 18,
            animate: options.animate !== undefined ? options.animate : false,
            spiderfyOnMaxZoom: options.spiderfyOnMaxZoom !== undefined ? options.spiderfyOnMaxZoom : false,
            showCoverageOnHover: options.showCoverageOnHover !== undefined ? options.showCoverageOnHover : false,
            zoomToBoundsOnClick: options.zoomToBoundsOnClick !== undefined ? options.zoomToBoundsOnClick : true
        });
    };

    /**
     * GeoLeaf GeoJSON Module - Feature Validator
     * Validation stricte des features GeoJSON selon schéma centralisé
     *
     * @module geojson/feature-validator
     */


    // Dépendances lazy

    const FeatureValidator = {};

    /**
     * Valide une FeatureCollection entière et retourne les features valides
     *
     * @param {Object} collection - FeatureCollection GeoJSON
     * @returns {Object} { validFeatures: Array, errors: Array }
     */
    FeatureValidator.validateFeatureCollection = function (collection) {
        const Log = getLog();
        const errors = [];
        const validFeatures = [];

        if (!collection || typeof collection !== "object") {
            Log.warn("[GeoLeaf.GeoJSON.Validator] Collection non valide : type invalide");
            return { validFeatures: [], errors: [{ message: "Collection non valide" }] };
        }

        // Accepter les FeatureCollections ou les arrays de features
        const features = collection.type === "FeatureCollection"
            ? collection.features
            : Array.isArray(collection)
                ? collection
                : [collection];


        if (!Array.isArray(features)) {
            Log.warn("[GeoLeaf.GeoJSON.Validator] Pas de features à valider");
            return { validFeatures: [], errors: [] };
        }

        features.forEach((feature, index) => {
            const result = FeatureValidator.validateFeature(feature, index);
            if (result.valid) {
                validFeatures.push(feature);
            } else {
                errors.push(...result.errors);
            }
        });

        return { validFeatures, errors };
    };

    /**
     * Valide une single feature
     *
     * @param {Object} feature - Feature GeoJSON
     * @param {number} [index] - Index dans la collection (pour logging)
     * @returns {Object} { valid: Boolean, errors: Array }
     */
    FeatureValidator.validateFeature = function (feature, index) {
        const Log = getLog();
        const errors = [];
        const featureId = feature?.properties?.id || feature?.id || index || "unknown";

        // Type feature
        if (!feature || feature.type !== "Feature") {
            errors.push({
                featureId,
                field: "type",
                message: "Feature doit avoir type='Feature'",
                severity: "error"
            });
            Log.warn(`[GeoLeaf.GeoJSON.Validator] Feature ${featureId}: type invalide`);
            return { valid: false, errors };
        }

        // Géométrie
        const geomResult = FeatureValidator.validateGeometry(
            feature.geometry,
            featureId
        );
        if (!geomResult.valid) {
            errors.push(...geomResult.errors);
        }

        // Propriétés
        const propsResult = FeatureValidator.validateProperties(
            feature.properties,
            featureId
        );
        if (!propsResult.valid) {
            errors.push(...propsResult.errors);
        }

        if (errors.length > 0) {
            Log.warn(
                `[GeoLeaf.GeoJSON.Validator] Feature ${featureId} rejetée : ${errors.map(e => e.message).join("; ")}`
            );
            return { valid: false, errors };
        }

        return { valid: true, errors: [] };
    };

    /**
     * Valide la géométrie d'une feature
     *
     * @param {Object} geometry - Geometry GeoJSON
     * @param {string|number} featureId - Feature identifier (for logging)
     * @returns {Object} { valid: Boolean, errors: Array }
     */
    FeatureValidator.validateGeometry = function (geometry, featureId) {
        const errors = [];
        const validTypes = ["Point", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];

        if (!geometry || typeof geometry !== "object") {
            errors.push({
                featureId,
                field: "geometry",
                message: "geometry requis et doit être un objet",
                severity: "error"
            });
            return { valid: false, errors };
        }

        if (!geometry.type) {
            errors.push({
                featureId,
                field: "geometry.type",
                message: "geometry.type requis",
                severity: "error"
            });
            return { valid: false, errors };
        }

        if (!validTypes.includes(geometry.type)) {
            errors.push({
                featureId,
                field: "geometry.type",
                message: `Type de géométrie invalide '${geometry.type}'. Doit être : ${validTypes.join(", ")}`,
                severity: "error"
            });
            return { valid: false, errors };
        }

        if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length === 0) {
            errors.push({
                featureId,
                field: "geometry.coordinates",
                message: "geometry.coordinates doit être un array non-vide",
                severity: "error"
            });
            return { valid: false, errors };
        }

        return { valid: errors.length === 0, errors };
    };

    /**
     * Valide les propriétés d'une feature
     *
     * @param {Object} properties - Feature properties
     * @param {string|number} featureId - Feature identifier (for logging)
     * @returns {Object} { valid: Boolean, errors: Array }
     */
    FeatureValidator.validateProperties = function (properties, featureId) {
        const errors = [];

        if (!properties || typeof properties !== "object") {
            errors.push({
                featureId,
                field: "properties",
                message: "properties requis et doit être un objet",
                severity: "error"
            });
            return { valid: false, errors };
        }

        // Au moins un nom (name, title, ou autre identifier)
        const hasName = properties.name || properties.title || properties.label;
        if (!hasName) {
            errors.push({
                featureId,
                field: "properties.name",
                message: "properties doit contenir au moins name, title ou label",
                severity: "error"
            });
        }

        // Validation des types numériques
        if (typeof properties.distance_km !== "undefined" && typeof properties.distance_km !== "number") {
            errors.push({
                featureId,
                field: "properties.distance_km",
                message: "distance_km doit être un nombre",
                severity: "warning"
            });
        }

        if (typeof properties.distance_km === "number" && properties.distance_km < 0) {
            errors.push({
                featureId,
                field: "properties.distance_km",
                message: "distance_km doit être >= 0",
                severity: "warning"
            });
        }

        if (typeof properties.duration_min !== "undefined" && typeof properties.duration_min !== "number") {
            errors.push({
                featureId,
                field: "properties.duration_min",
                message: "duration_min doit être un nombre",
                severity: "warning"
            });
        }

        if (typeof properties.duration_min === "number" && properties.duration_min < 0) {
            errors.push({
                featureId,
                field: "properties.duration_min",
                message: "duration_min doit être >= 0",
                severity: "warning"
            });
        }

        if (typeof properties.rating !== "undefined") {
            if (typeof properties.rating !== "number") {
                errors.push({
                    featureId,
                    field: "properties.rating",
                    message: "rating doit être un nombre",
                    severity: "warning"
                });
            } else if (properties.rating < 0 || properties.rating > 5) {
                errors.push({
                    featureId,
                    field: "properties.rating",
                    message: "rating doit être entre 0 et 5",
                    severity: "warning"
                });
            }
        }

        // Validation des couleurs hex
        if (typeof properties.color !== "undefined" && typeof properties.color === "string") {
            if (!/^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(properties.color)) {
                errors.push({
                    featureId,
                    field: "properties.color",
                    message: `color invalide '${properties.color}'. Format: #RGB ou #RRGGBB`,
                    severity: "warning"
                });
            }
        }

        // Validation des opacity
        if (typeof properties.opacity !== "undefined") {
            if (typeof properties.opacity !== "number") {
                errors.push({
                    featureId,
                    field: "properties.opacity",
                    message: "opacity doit être un nombre",
                    severity: "warning"
                });
            } else if (properties.opacity < 0 || properties.opacity > 1) {
                errors.push({
                    featureId,
                    field: "properties.opacity",
                    message: "opacity doit être entre 0 et 1",
                    severity: "warning"
                });
            }
        }

        // Validation des weight
        if (typeof properties.weight !== "undefined") {
            if (typeof properties.weight !== "number") {
                errors.push({
                    featureId,
                    field: "properties.weight",
                    message: "weight doit être un nombre",
                    severity: "warning"
                });
            } else if (properties.weight < 0) {
                errors.push({
                    featureId,
                    field: "properties.weight",
                    message: "weight doit être >= 0",
                    severity: "warning"
                });
            }
        }

        // Validation des URLs
        const urlFields = ["link", "photo", "url"];
        urlFields.forEach(field => {
            if (typeof properties[field] !== "undefined" && typeof properties[field] === "string") {
                if (!FeatureValidator.isValidUrl(properties[field])) {
                    errors.push({
                        featureId,
                        field: `properties.${field}`,
                        message: `${field} n'est pas une URL valide`,
                        severity: "warning"
                    });
                }
            }
        });

        // Validation email
        if (typeof properties.email !== "undefined" && typeof properties.email === "string") {
            if (!FeatureValidator.isValidEmail(properties.email)) {
                errors.push({
                    featureId,
                    field: "properties.email",
                    message: "email invalide",
                    severity: "warning"
                });
            }
        }

        // Validation tags (doit être array de strings)
        if (typeof properties.tags !== "undefined") {
            if (!Array.isArray(properties.tags)) {
                errors.push({
                    featureId,
                    field: "properties.tags",
                    message: "tags doit être un array",
                    severity: "warning"
                });
            } else {
                properties.tags.forEach((tag, idx) => {
                    if (typeof tag !== "string") {
                        errors.push({
                            featureId,
                            field: `properties.tags[${idx}]`,
                            message: "tag doit être une string",
                            severity: "warning"
                        });
                    }
                });
            }
        }

        // Vérifier que properties ne contient pas d'objets imbriqués (à plat obligatoirement)
        Object.entries(properties).forEach(([key, value]) => {
            if (value !== null && typeof value === "object" && !Array.isArray(value)) {
                errors.push({
                    featureId,
                    field: `properties.${key}`,
                    message: `Propriété imbriquée détectée. Les propriétés doivent être plates (strings, nombres, arrays). Objet trouvé: ${JSON.stringify(value)}`,
                    severity: "error"
                });
            }
        });

        // Les erreurs "error" invalident la feature, pas les "warning"
        const hasErrors = errors.some(e => e.severity === "error");
        return { valid: !hasErrors, errors };
    };

    /**
     * Valide qu'une string est une URL valide
     *
     * @param {string} url - URL à valider
     * @returns {Boolean}
     */
    FeatureValidator.isValidUrl = function (url) {
        if (typeof url !== "string") return false;
        try {
            new URL(url);
            return true;
        } catch {
            // Accepter aussi les URLs relatives
            return /^(https?:\/\/|\/|\.\.?\/)/.test(url);
        }
    };

    /**
     * Valide qu'une string est un email valide
     *
     * @param {string} email - Email à valider
     * @returns {Boolean}
     */
    FeatureValidator.isValidEmail = function (email) {
        if (typeof email !== "string") return false;
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    };

    /**
     * GeoLeaf GeoJSON - Style Utilities
     * Shared style normalization helpers (Phase 4 dedup — extracted from style.js + vector-tiles.js)
     *
     * @module geojson/style-utils
     * @version 1.0.0
     */

    const _g$A = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    /**
     * Normalise a GeoLeaf style object (fill/stroke nested format) into
     * flat Leaflet Path options.
     *
     * Handles:
     * - Nested fill/stroke → flat Leaflet props
     * - Already-flat passthrough
     * - fillOpacity default (0.4 when unspecified)
     *
     * Does NOT handle hatch patterns or casing — those are layered on by the
     * caller (layer-manager/style.js) when a layerId is available.
     *
     * @param {Object} style - Style in GeoLeaf format
     * @param {Object} [options={}] - Extra options
     * @param {boolean} [options.setFillFlag=false] - Set `fill: true` when fill block present
     * @returns {Object} Flat Leaflet Path options
     */
    function normalizeStyleToLeaflet(style, options = {}) {
        if (!style || typeof style !== 'object') return {};

        const normalized = {};

        if (style.fill || style.stroke) {
            // Fill (remplissage)
            if (style.fill) {
                if (style.fill.color) normalized.fillColor = style.fill.color;
                normalized.fillOpacity = typeof style.fill.opacity === 'number'
                    ? style.fill.opacity
                    : 0.4;
                if (style.fill.pattern) normalized.fillPattern = style.fill.pattern;
                if (options.setFillFlag) normalized.fill = true;
            }

            // Stroke (contour)
            if (style.stroke) {
                if (style.stroke.color) normalized.color = style.stroke.color;
                if (typeof style.stroke.opacity === 'number') normalized.opacity = style.stroke.opacity;
                if (typeof style.stroke.widthPx === 'number') normalized.weight = style.stroke.widthPx;
                if (style.stroke.dashArray) normalized.dashArray = style.stroke.dashArray;
                if (style.stroke.lineCap) normalized.lineCap = style.stroke.lineCap;
                if (style.stroke.lineJoin) normalized.lineJoin = style.stroke.lineJoin;
            }

            // Shape & size (common)
            if (style.shape) normalized.shape = style.shape;
            if (typeof style.sizePx === 'number') {
                normalized.radius = style.sizePx;
                normalized.sizePx = style.sizePx;
            }
        } else {
            // Already flat Leaflet format — passthrough
            Object.assign(normalized, style);
        }

        return normalized;
    }

    // ── Backward compat ──
    if (!_g$A.GeoLeaf) _g$A.GeoLeaf = {};
    _g$A.GeoLeaf._StyleUtils = { normalizeStyleToLeaflet };

    /**
     * GeoLeaf GeoJSON Module - Style Resolver
     * Évaluation des règles de style dynamiques (styleRules)
     *
     * @module geojson/style-resolver
     */

    const _g$z = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});


    const GeoJSONStyleResolver = {};

    /**
     * Résout une valeur imbriquée dans un objet via un chemin (ex: "properties.name").
     * @param {Object} obj - Objet source
     * @param {string} path - Chemin (dot notation)
     * @returns {*} Valeur trouvée ou null
     */
    GeoJSONStyleResolver.getNestedValue = function (obj, path) {
        if (!obj || !path) return null;
        return path.split('.').reduce((current, prop) =>
            current && current[prop] !== undefined ? current[prop] : null, obj);
    };


    /**
     * Évalue une condition simple contre une feature GeoJSON.
     * @param {Object} feature - Feature GeoJSON
     * @param {Object} condition - {field, operator, value}
     * @param {Object} STYLE_OPERATORS - Opérateurs de comparaison
     * @param {Object} Log - Logger
     * @returns {boolean} true si la condition est remplie
     */
    GeoJSONStyleResolver.evaluateCondition = function (feature, condition, STYLE_OPERATORS, Log) {
        const { field, operator, value } = condition;
        if (!field || !operator) return false;

        // Résoudre la valeur du champ depuis la feature
        const fieldValue = GeoJSONStyleResolver.getNestedValue(feature, field);

        // Si le champ n'existe pas, la condition n'est pas remplie
        if (fieldValue === null || fieldValue === undefined) return false;

        // Obtenir la fonction de comparaison
        const compareFn = STYLE_OPERATORS[operator];
        if (!compareFn) {
            Log.warn && Log.warn('[GeoJSON] Opérateur styleRules inconnu:', operator);
            return false;
        }

        // Évaluer la condition
        try {
            return compareFn(fieldValue, value);
        } catch (e) {
            Log.warn && Log.warn('[GeoJSON] Erreur évaluation condition:', e.message);
            return false;
        }
    };

    /**
     * Évalue les règles de style (styleRules) contre une feature GeoJSON.
     * Retourne le style de la PREMIÈRE règle correspondante (ordre du tableau).
     * Supporte les formats:
     * - Simple: {when: {field, operator, value}, style: {...}}
     * - Composé: {when: {all: [{field, operator, value}, ...]}, style: {...}}
     *
     * @param {Object} feature - Feature GeoJSON
     * @param {Array} styleRules - Tableau de règles
     * @returns {Object|null} Style de la première règle correspondante, ou null
     */
    GeoJSONStyleResolver.evaluateStyleRules = function (feature, styleRules) {
        if (!Array.isArray(styleRules) || styleRules.length === 0) {
            return null;
        }

        const shared = GeoJSONShared;
        const Log = getLog();
        const STYLE_OPERATORS = shared.STYLE_OPERATORS;

        for (const rule of styleRules) {
            if (!rule || !rule.when || !rule.style) continue;

            // Support du format composé avec "all": [conditions]
            if (rule.when.all && Array.isArray(rule.when.all)) {
                // Vérifier que TOUTES les conditions sont remplies
                const allConditionsMet = rule.when.all.every(condition =>
                    GeoJSONStyleResolver.evaluateCondition(feature, condition, STYLE_OPERATORS, Log)
                );

                if (allConditionsMet) {
                    return rule.style;
                }
            }
            // Format simple avec field, operator, value
            else if (rule.when.field && rule.when.operator) {
                const conditionMet = GeoJSONStyleResolver.evaluateCondition(
                    feature,
                    rule.when,
                    STYLE_OPERATORS,
                    Log
                );

                if (conditionMet) {
                    return rule.style;
                }
            }
        }

        return null;
    };

    /**
     * Construit les options Leaflet pour L.geoJSON à partir des options GeoLeaf.
     *
     * @param {Object} options - Options GeoLeaf
     * @returns {Object} - Options Leaflet
     */
    GeoJSONStyleResolver.buildLeafletOptions = function (options) {
        const evaluateStyleRules = GeoJSONStyleResolver.evaluateStyleRules;

        const normalizeStyle = (style) => {
            if (!style || typeof style !== 'object') {
                return {};
            }

            const normalized = {};

            // Format imbriqué fill/stroke
            if (style.fill || style.stroke) {
                if (style.fill) {
                    if (style.fill.color) normalized.fillColor = style.fill.color;
                    if (typeof style.fill.opacity === 'number') {
                        normalized.fillOpacity = style.fill.opacity;
                    } else {
                        normalized.fillOpacity = 1.0;
                    }
                }

                if (style.stroke) {
                    if (style.stroke.color) normalized.color = style.stroke.color;
                    if (typeof style.stroke.opacity === 'number') normalized.opacity = style.stroke.opacity;
                    if (typeof style.stroke.widthPx === 'number') normalized.weight = style.stroke.widthPx;
                    if (style.stroke.dashArray) normalized.dashArray = style.stroke.dashArray;
                    if (style.stroke.lineCap) normalized.lineCap = style.stroke.lineCap;
                    if (style.stroke.lineJoin) normalized.lineJoin = style.stroke.lineJoin;
                }

                // Hatch (hachurage) — copier la structure pour que setLayerStyle
                // puisse la traiter plus tard.
                // Pour renderMode 'pattern_only' : on met fillColor='transparent'
                // et fillOpacity=1. Transparent évite le flash blanc, et fillOpacity=1
                // garantit que le pattern SVG sera visible dès son injection par
                // _applyHatchToLayer (plus besoin de changer fill-opacity après coup).
                if (style.hatch && style.hatch.enabled) {
                    normalized.hatch = Object.assign({}, style.hatch);
                    if (style.hatch.renderMode === 'pattern_only') {
                        normalized.fillColor = 'transparent';
                        normalized.fillOpacity = 1;
                    }
                }

                // Propriétés communes
                if (style.shape) normalized.shape = style.shape;
                if (typeof style.sizePx === 'number') {
                    normalized.radius = style.sizePx;
                    normalized.sizePx = style.sizePx;
                }
            } else {
                Object.assign(normalized, style);
                if (typeof normalized.fillOpacity !== 'number') {
                    normalized.fillOpacity = 1.0;
                }
            }

            return normalized;
        };

        const leafletOptions = {
            /**
             * Style pour polygones / lignes.
             * Priorité : defaultStyle < styleRules (première correspondante) < feature.properties.style
             */
            style(feature) {
                // 1. Commencer avec le style par défaut
                let finalStyle = Object.assign({}, normalizeStyle(options.defaultStyle));

                // 2. Appliquer les styleRules (première règle correspondante gagne)
                if (options.styleRules && Array.isArray(options.styleRules)) {
                    const matchedStyle = evaluateStyleRules(feature, options.styleRules);
                    if (matchedStyle) {
                        finalStyle = Object.assign({}, finalStyle, normalizeStyle(matchedStyle));
                    }
                }

                // 3. Mode interactif
                const interactiveShapes = typeof options.interactiveShape === "boolean"
                    ? options.interactiveShape
                    : (_g$z.GeoLeaf && _g$z.GeoLeaf.Config && _g$z.GeoLeaf.Config.get ? _g$z.GeoLeaf.Config.get('ui.interactiveShapes', false) : false);
                finalStyle.interactive = interactiveShapes;

                return finalStyle;
            },

            /**
             * Gestion des points (Point / MultiPoint).
             */
            pointToLayer: options.pointToLayer
                ? function (feature, latlng) {
                      return options.pointToLayer(feature, latlng);
                  }
                : function (feature, latlng) {
                      // Utiliser le paramètre interactiveShape défini pour cette couche
                      const interactiveShapes = typeof options.interactiveShape === "boolean"
                          ? options.interactiveShape
                          : (_g$z.GeoLeaf && _g$z.GeoLeaf.Config && _g$z.GeoLeaf.Config.get ? _g$z.GeoLeaf.Config.get('ui.interactiveShapes', false) : false);
                      const pointStyle = _g$z.GeoLeaf && _g$z.GeoLeaf.Utils && _g$z.GeoLeaf.Utils.mergeOptions
                          ? _g$z.GeoLeaf.Utils.mergeOptions(options.defaultPointStyle, { interactive: interactiveShapes })
                          : Object.assign({}, options.defaultPointStyle, { interactive: interactiveShapes });
                      return _g$z.L.circleMarker(latlng, pointStyle);
                  },

            /**
             * Callback pour chaque entité.
             */
            onEachFeature: function (feature, layer) {
                // Popup simple par défaut si popupContent fourni
                if (
                    feature &&
                    feature.properties &&
                    typeof feature.properties.popupContent === "string"
                ) {
                    layer.bindPopup(feature.properties.popupContent);
                }

                // Callback custom utilisateur
                if (typeof options.onEachFeature === "function") {
                    options.onEachFeature(feature, layer);
                }
            }
        };

        return leafletOptions;
    };

    // Exposer aussi via _StyleRules pour compatibilité avec le module Themes
    if (!_g$z.GeoLeaf) _g$z.GeoLeaf = {};
    _g$z.GeoLeaf._StyleRules = {
        evaluate: GeoJSONStyleResolver.evaluateStyleRules,
        operators: GeoJSONShared ? GeoJSONShared.STYLE_OPERATORS : {},
        getNestedValue: GeoJSONStyleResolver.getNestedValue
    };

    /**
     * GeoLeaf GeoJSON Module — Vector Tiles
     * Support for protobuf vector tiles via Leaflet.VectorGrid
     *
     * Sprint 8: Replace heavy GeoJSON polygon/line layers with pre-generated
     * vector tiles for near-zero memory consumption. Tiles are served as
     * static PBF files ({z}/{x}/{y}.pbf) — no tile server required.
     *
     * Requires: leaflet.vectorgrid (optional peer dependency)
     *   <script src="https://unpkg.com/leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.min.js"></script>
     *
     * Fallback: if VectorGrid is not available, the layer falls back to
     * standard GeoJSON loading (single-layer.js pipeline).
     *
     * @module geojson/vector-tiles
     */

    const _g$y = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$b = () => GeoJSONShared.state;

    /**
     * VectorTiles module — manages VT layer creation, style mapping, and interactions.
     * Exposed as GeoLeaf._VectorTiles on the global namespace.
     */
    const VectorTiles = {

        // ════════════════════════════════════════════════════════════════
        //   DETECTION
        // ════════════════════════════════════════════════════════════════

        /**
         * Check whether Leaflet.VectorGrid is loaded and usable.
         * @returns {boolean}
         */
        isAvailable() {
            return !!(
                _g$y.L &&
                _g$y.L.vectorGrid &&
                typeof _g$y.L.vectorGrid.protobuf === 'function'
            );
        },

        /**
         * Determine if a layer definition should use vector tiles.
         * Returns true only when:
         * 1. The layer has a vectorTiles config with enabled !== false
         * 2. Leaflet.VectorGrid is loaded
         * 3. The layer's default style does NOT use SVG hatch patterns
         *    (VectorGrid uses Canvas tiles — SVG patterns are incompatible)
         *
         * @param {Object} def - Normalised layer definition
         * @returns {boolean}
         */
        shouldUseVectorTiles(def) {
            const vtConfig = this._getVTConfig(def);
            if (!vtConfig || vtConfig.enabled === false) return false;
            if (!this.isAvailable()) return false;

            // Layers requiring SVG hatch patterns cannot use VectorGrid (Canvas-based).
            // Check the inline style definition for hatch config.
            if (def.style && def.style.hatch && def.style.hatch.enabled) {
                const Log = getLog();
                Log.info(`[VectorTiles] Layer "${def.id}" has hatch patterns → falling back to GeoJSON/SVG renderer`);
                return false;
            }

            return true;
        },

        // ════════════════════════════════════════════════════════════════
        //   CONFIG HELPERS
        // ════════════════════════════════════════════════════════════════

        /**
         * Extract the vectorTiles config block from a layer definition.
         * Supports both `def.vectorTiles` and `def.data.vectorTiles`.
         *
         * @param {Object} def
         * @returns {Object|null}
         * @private
         */
        _getVTConfig(def) {
            if (!def) return null;
            if (def.vectorTiles && typeof def.vectorTiles === 'object') {
                return def.vectorTiles;
            }
            if (def.data && def.data.vectorTiles && typeof def.data.vectorTiles === 'object') {
                return def.data.vectorTiles;
            }
            return null;
        },

        /**
         * Resolve the full tile URL template from the layer definition.
         * If the config provides an absolute URL, returns it as-is.
         * Otherwise builds a relative path: `{profilesBasePath}/{profileId}/{layerDir}/{tilesDir}/{z}/{x}/{y}.pbf`
         *
         * @param {Object} def - Layer definition (must contain _profileId + _layerDirectory)
         * @param {Object} vtConfig - The vectorTiles config block
         * @returns {string|null}
         * @private
         */
        _resolveTileUrl(def, vtConfig) {
            // Absolute URL or explicit template
            if (vtConfig.url) {
                if (vtConfig.url.startsWith('http') || vtConfig.url.startsWith('//') || vtConfig.url.startsWith('/')) {
                    return vtConfig.url;
                }
            }

            const Config = _g$y.GeoLeaf && _g$y.GeoLeaf.Config;
            const dataCfg = Config && Config.get ? Config.get('data') : null;
            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || 'profiles';
            const profileId = def._profileId;
            const layerDir = def._layerDirectory;

            if (!profileId || !layerDir) {
                // Cannot resolve relative → try raw url fallback
                return vtConfig.url || null;
            }

            const tilesDir = vtConfig.tilesDirectory || 'tiles';
            return `${profilesBasePath}/${profileId}/${layerDir}/${tilesDir}/{z}/{x}/{y}.pbf`;
        },

        // ════════════════════════════════════════════════════════════════
        //   STYLE CONVERSION
        // ════════════════════════════════════════════════════════════════

        /**
         * Normalise a GeoLeaf style object into flat Leaflet Path options.
         * Phase 4 dedup: delegates to shared style-utils.
         * @private
         */
        _normalizeStyle(style) {
            return normalizeStyleToLeaflet(style, { setFillFlag: true });
        },

        /**
         * Convert a full GeoLeaf style definition (defaultStyle + styleRules)
         * into a VectorGrid-compatible style value.
         *
         * If styleRules are present, returns a **function(properties, zoom)**
         * that evaluates rules per-feature (called by VectorGrid for each tile feature).
         *
         * If only a static defaultStyle is present, returns a flat style object.
         *
         * @param {Object|null} styleData - Loaded style JSON ({defaultStyle, styleRules, ...})
         * @param {Object|null} fallbackStyle - Fallback default style (GeoLeaf defaults)
         * @returns {Object|Function} VectorGrid style value
         */
        convertStyleToVT(styleData, fallbackStyle) {
            const self = this;
            const base = this._normalizeStyle(fallbackStyle || {});

            if (!styleData) return base;

            // Merge defaultStyle from loaded style JSON
            const merged = Object.assign({}, base, this._normalizeStyle(styleData.defaultStyle));

            // If styleRules are present, return a function for per-feature evaluation
            if (styleData.styleRules && Array.isArray(styleData.styleRules) && styleData.styleRules.length > 0) {
                const rules = styleData.styleRules;

                return function vtStyleFunction(properties, zoom) {
                    // Build a pseudo-feature for evaluateStyleRules
                    const feature = { properties: properties || {} };

                    const StyleResolver = _g$y.GeoLeaf && _g$y.GeoLeaf._GeoJSONStyleResolver;
                    if (StyleResolver && typeof StyleResolver.evaluateStyleRules === 'function') {
                        const matched = StyleResolver.evaluateStyleRules(feature, rules);
                        if (matched) {
                            return Object.assign({}, merged, self._normalizeStyle(matched));
                        }
                    }
                    return merged;
                };
            }

            return merged;
        },

        // ════════════════════════════════════════════════════════════════
        //   LAYER CREATION
        // ════════════════════════════════════════════════════════════════

        /**
         * Create and return a L.vectorGrid.protobuf layer for a VT-enabled definition.
         * This is the main entry point called from single-layer.js.
         *
         * @param {string} layerId - Unique layer ID
         * @param {string} layerLabel - Display label
         * @param {Object} def - Normalised layer definition (must include vectorTiles block)
         * @param {Object} baseOptions - Base options from GeoJSON module
         * @returns {Promise<Object>} Layer metadata (id, label, featureCount, isVectorTile)
         */
        async loadVectorTileLayer(layerId, layerLabel, def, baseOptions) {
            const Log = getLog();
            const state = getState$b();
            const vtConfig = this._getVTConfig(def);

            if (!vtConfig) {
                throw new Error(`[VectorTiles] No vectorTiles config for ${layerId}`);
            }

            // 1. Resolve tile URL
            const tileUrl = this._resolveTileUrl(def, vtConfig);
            if (!tileUrl) {
                throw new Error(`[VectorTiles] Cannot resolve tile URL for ${layerId}`);
            }

            // 2. Load default style (same mechanism as GeoJSON layers)
            let styleData = null;
            try {
                if (def.styles && def.styles.default) {
                    styleData = await (_g$y.GeoLeaf && _g$y.GeoLeaf._GeoJSONLayerConfig && _g$y.GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle(layerId, def));
                }
            } catch (err) {
                Log.warn(`[VectorTiles] Could not load default style for ${layerId}:`, err.message);
            }

            // 3. Convert style
            const fallbackStyle = state.options.defaultStyle;
            const vtStyle = this.convertStyleToVT(styleData, fallbackStyle);

            // 4. Layer name in the vector tile (configured or defaults to layer id)
            const vtLayerName = vtConfig.layerName || def.id;

            // 5. Resolve pane
            const PaneHelpers = GeoJSONShared.PaneHelpers;
            const PaneConfig = GeoJSONShared.PANE_CONFIG;

            let zIndex = def.zIndex;
            if (typeof zIndex !== 'number') {
                const allLayerIds = Array.from(state.layers.keys());
                zIndex = Math.max(PaneConfig.MIN_LAYER_ZINDEX, PaneConfig.MAX_LAYER_ZINDEX - allLayerIds.length);
            } else {
                zIndex = PaneHelpers.validateZIndex(zIndex);
            }
            def.zIndex = zIndex;

            const paneName = PaneHelpers.getOrCreatePane
                ? PaneHelpers.getOrCreatePane(zIndex, state.map)
                : PaneHelpers.getPaneName(zIndex);

            // 6. Build VectorGrid options
            const vtOptions = {
                vectorTileLayerStyles: {},
                interactive: vtConfig.interactive !== false,
                maxNativeZoom: vtConfig.maxNativeZoom || 14,
                maxZoom: vtConfig.maxZoom || (state.options.maxZoomOnFit || 18),
                minZoom: vtConfig.minZoom || 0,
                pane: paneName,
                rendererFactory: _g$y.L && _g$y.L.canvas ? _g$y.L.canvas.tile : undefined,
                tolerance: vtConfig.tolerance || 3,
            };

            // Feature ID accessor (for setFeatureStyle)
            if (vtConfig.featureIdProperty) {
                vtOptions.getFeatureId = function (feature) {
                    return feature.properties[vtConfig.featureIdProperty] || feature.id;
                };
            }

            vtOptions.vectorTileLayerStyles[vtLayerName] = vtStyle;

            Log.info(`[GeoLeaf.VectorTiles] ⬡ Creating VT layer: ${layerId} (tile layer: ${vtLayerName})`);
            Log.debug(`[GeoLeaf.VectorTiles] URL template: ${tileUrl}`);

            // 7. Create the VectorGrid layer
            const vtLayer = _g$y.L.vectorGrid.protobuf(tileUrl, vtOptions);

            // 8. Bind interactions (popup, tooltip)
            if (vtConfig.interactive !== false) {
                this._bindInteractions(vtLayer, def);
            }

            // 9. Store in state.layers (same structure as GeoJSON layers for LayerManager compat)
            const Config = _g$y.GeoLeaf && _g$y.GeoLeaf.Config;
            const dataCfg = Config && Config.get ? Config.get('data') : null;
            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || 'profiles';
            const layerBasePath = `${profilesBasePath}/${def._profileId}/${def._layerDirectory}`;

            const layerData = {
                id: layerId,
                label: layerLabel,
                layer: vtLayer,
                visible: true,
                config: def,
                clusterGroup: null,
                legendsConfig: def.legends,
                basePath: layerBasePath,
                useSharedCluster: false,
                features: [],  // VT layers don't expose raw features
                geometryType: def.geometry || def.geometryType || 'polygon',
                // Sprint 8: VT-specific metadata
                isVectorTile: true,
                vtLayerName: vtLayerName,
                vtTileUrl: tileUrl,
                currentStyle: styleData
            };

            // Visibility metadata (same as GeoJSON layers)
            layerData._visibility = {
                current: false,
                logicalState: false,
                source: 'system',
                userOverride: false,
                themeOverride: false,
                themeDesired: null,
                zoomConstrained: false
            };

            state.layers.set(layerId, layerData);

            // VT layers do NOT go into ThemeCache (nothing to cache — tiles are streamed)

            // Apply zoom visibility if LayerManager is available
            if (_g$y.GeoLeaf && _g$y.GeoLeaf._GeoJSONLayerManager) {
                _g$y.GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom();
            }

            // Don't auto-add to map — themes control visibility
            layerData.visible = false;

            Log.info(`[GeoLeaf.VectorTiles] ✅ VT layer loaded: ${layerId}`);

            return {
                id: layerId,
                label: layerLabel,
                featureCount: 0,  // VT: feature count unknown until tiles are rendered
                isVectorTile: true
            };
        },

        // ════════════════════════════════════════════════════════════════
        //   INTERACTIONS (POPUP / TOOLTIP)
        // ════════════════════════════════════════════════════════════════

        /**
         * Bind popup and tooltip interactions to a VectorGrid layer.
         * VectorGrid fires click/mouseover on individual tile features,
         * providing `e.layer.properties` from the PBF data.
         *
         * @param {L.VectorGrid} vtLayer - The VectorGrid layer
         * @param {Object} def - Layer definition (popup/tooltip config)
         * @private
         */
        _bindInteractions(vtLayer, def) {
            const PopupTooltip = _g$y.GeoLeaf && _g$y.GeoLeaf._GeoJSONPopupTooltip;

            // ── Click → popup ──
            if (def.popup && def.popup.enabled !== false) {
                vtLayer.on('click', function (e) {
                    if (!e.layer || !e.layer.properties) return;

                    const feature = {
                        type: 'Feature',
                        properties: e.layer.properties,
                        geometry: null  // Geometry not available from VT click events
                    };

                    // Build popup content the same way as GeoJSON layers
                    if (PopupTooltip && typeof PopupTooltip._buildPopupContent === 'function') {
                        const content = PopupTooltip._buildPopupContent(feature, def);
                        if (content) {
                            _g$y.L.popup()
                                .setLatLng(e.latlng)
                                .setContent(content)
                                .openOn(getState$b().map);
                        }
                    } else {
                        // Fallback: simple properties dump
                        const props = feature.properties;
                        const lines = Object.keys(props)
                            .filter(k => props[k] !== null && props[k] !== undefined)
                            .slice(0, 10)
                            .map(k => `<b>${k}:</b> ${props[k]}`);
                        if (lines.length > 0) {
                            _g$y.L.popup()
                                .setLatLng(e.latlng)
                                .setContent(lines.join('<br>'))
                                .openOn(getState$b().map);
                        }
                    }
                });
            }

            // ── Hover → tooltip ──
            if (def.tooltip && def.tooltip.enabled !== false) {
                let tooltipLayer = null;

                vtLayer.on('mouseover', function (e) {
                    if (!e.layer || !e.layer.properties) return;

                    const fields = def.tooltip.fields;
                    if (!fields || !Array.isArray(fields) || fields.length === 0) return;

                    // Extract the first text field for tooltip
                    const firstField = fields[0];
                    const fieldPath = firstField.field || '';
                    const propValue = _resolvePropertyPath(e.layer.properties, fieldPath);

                    if (propValue) {
                        tooltipLayer = _g$y.L.tooltip({ sticky: true })
                            .setLatLng(e.latlng)
                            .setContent(String(propValue));
                        getState$b().map.addLayer(tooltipLayer);
                    }
                });

                vtLayer.on('mouseout', function () {
                    if (tooltipLayer) {
                        getState$b().map.removeLayer(tooltipLayer);
                        tooltipLayer = null;
                    }
                });
            }
        },

        // ════════════════════════════════════════════════════════════════
        //   STYLE UPDATES (for theme changes)
        // ════════════════════════════════════════════════════════════════

        /**
         * Update the style of an existing VT layer.
         * Called by the LayerManager / Themes when the active style changes.
         *
         * @param {string} layerId - Layer ID
         * @param {Object} styleData - New style JSON ({defaultStyle, styleRules, ...})
         */
        updateLayerStyle(layerId, styleData) {
            const Log = getLog();
            const state = getState$b();
            const layerData = state.layers.get(layerId);

            if (!layerData || !layerData.isVectorTile) return;

            const vtLayerName = layerData.vtLayerName;
            const vtLayer = layerData.layer;

            if (!vtLayer || !vtLayer.options) return;

            const fallbackStyle = state.options.defaultStyle;
            const newStyle = this.convertStyleToVT(styleData, fallbackStyle);

            vtLayer.options.vectorTileLayerStyles[vtLayerName] = newStyle;

            // Force redraw to apply new styles
            if (typeof vtLayer.redraw === 'function') {
                vtLayer.redraw();
            }

            layerData.currentStyle = styleData;
            Log.debug(`[GeoLeaf.VectorTiles] Style updated for ${layerId}`);
        }
    };


    // ════════════════════════════════════════════════════════════════
    //   PRIVATE HELPERS
    // ════════════════════════════════════════════════════════════════

    /**
     * Resolve a dot-notation property path against a flat properties object.
     * Handles "properties.Name" → looks up "Name" (strips "properties." prefix).
     *
     * @param {Object} props - Flat properties from vector tile feature
     * @param {string} path - Dot-notation path (e.g. "properties.Name")
     * @returns {*} Resolved value or null
     * @private
     */
    function _resolvePropertyPath(props, path) {
        if (!props || !path) return null;

        // Strip leading "properties." since VT features already provide flat properties
        const cleanPath = path.startsWith('properties.')
            ? path.substring('properties.'.length)
            : path;

        // Simple dot-notation resolution
        const parts = cleanPath.split('.');
        let current = props;
        for (const part of parts) {
            if (current === null || current === undefined) return null;
            current = current[part];
        }
        return current !== undefined ? current : null;
    }

    /**
     * GeoLeaf GeoJSON Module - Visibility Manager
     * Gestionnaire centralisé de visibilité des couches avec gestion des priorités
     *
     * Gère trois sources de modification de visibilité :
     * - 'user': Action manuelle de l'utilisateur (toggle, show/hide explicite)
     * - 'theme': Modification par application d'un thème
     * - 'zoom': Modification automatique selon le niveau de zoom
     *
     * Règles de priorité :
     * 1. user > theme > zoom (l'utilisateur a toujours le dernier mot)
     * 2. Une action 'user' annule les flags 'theme' et 'zoom'
     * 3. Une action 'theme' peut override 'zoom' mais pas 'user'
     * 4. Une action 'zoom' ne change jamais l'état si 'user' ou 'theme' est actif
     *
     * @module geojson/visibility-manager
     */

    const _g$x = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});



    // Dépendances lazy

    const getState$a = () => GeoJSONShared.state;

    const VisibilityManager = {};


    /**
     * États de visibilité possibles
     * @private
     */
    const VisibilitySource = {
        USER: 'user',
        THEME: 'theme',
        ZOOM: 'zoom',
        SYSTEM: 'system'  // Chargement initial, etc.
    };

    /**
     * Initialise les métadonnées de visibilité pour une couche
     * @param {Object} layerData - Données de la couche
     * @private
     */
    function initVisibilityMetadata(layerData) {
        if (!layerData._visibility) {
            layerData._visibility = {
                current: false,           // État actuel physique sur la carte (true/false)
                logicalState: false,      // État logique (bouton ON/OFF, indépendant du zoom)
                source: VisibilitySource.SYSTEM,  // Dernière source de modification
                userOverride: false,      // L'utilisateur a forcé un état
                themeOverride: false,     // Un thème a forcé un état
                themeDesired: null,       // Visibilité voulue par le thème (true/false)
                zoomConstrained: false    // La couche est limitée par le zoom
            };
        }
    }

    /**
     * Définit la visibilité d'une couche avec gestion de priorité
     *
     * @param {string} layerId - ID de la couche
     * @param {boolean} visible - État de visibilité souhaité
     * @param {string} source - Source de la modification ('user' | 'theme' | 'zoom' | 'system')
     * @returns {boolean} - true si la visibilité a été modifiée, false sinon
     */
    VisibilityManager.setVisibility = function (layerId, visible, source) {
        const state = getState$a();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[VisibilityManager] Couche introuvable:", layerId);
            return false;
        }

        // Initialiser les métadonnées si nécessaire
        initVisibilityMetadata(layerData);

        const meta = layerData._visibility;
        const oldVisible = meta.current;
        const oldSource = meta.source;

        // Appliquer les règles de priorité
        const canChange = this._canChangeVisibility(meta, source, visible);

        if (!canChange) {
            Log.debug(
                `[VisibilityManager] Changement refusé pour ${layerId}: ` +
                `source=${source}, userOverride=${meta.userOverride}, themeOverride=${meta.themeOverride}`
            );
            return false;
        }

        // Mettre à jour les flags selon la source
        this._updateVisibilityFlags(meta, source, visible);

        // Appliquer le changement effectif
        const changed = this._applyVisibilityChange(layerId, layerData, visible);

        if (changed) {
            meta.current = visible;
            meta.source = source;

            Log.debug(
                `[VisibilityManager] ${layerId}: ${oldVisible} → ${visible} ` +
                `(source: ${oldSource} → ${source})`
            );

            // Mettre à jour les anciens flags pour compatibilité
            layerData.visible = visible;
            layerData.userDisabled = meta.userOverride && !visible;
            layerData.themeHidden = meta.themeOverride && !visible;

            // Notifier la légende
            this._notifyLegend(layerId, visible);

            // Émettre l'événement
            this._fireVisibilityEvent(layerId, visible, source);
        }

        return changed;
    };

    /**
     * Vérifie si la visibilité peut être modifiée selon les règles de priorité
     * @param {Object} meta - Métadonnées de visibilité
     * @param {string} source - Source de la modification
     * @returns {boolean}
     * @private
     */
    VisibilityManager._canChangeVisibility = function (meta, source, desiredVisible) {
        // L'utilisateur peut toujours modifier
        if (source === VisibilitySource.USER) {
            return true;
        }

        // IMPORTANT: Le zoom DOIT TOUJOURS pouvoir modifier l'affichage physique (current)
        // même si userOverride est true. Cela permet d'afficher/masquer selon les seuils de zoom
        // tout en gardant logicalState indépendant.
        if (source === VisibilitySource.ZOOM) {
            return true;
        }

        // Si l'utilisateur a défini un override, seul l'utilisateur peut changer l'état logique
        if (meta.userOverride) {
            return false;
        }

        // Ne jamais réactiver ce qu'un thème a explicitement masqué
        if (source === VisibilitySource.ZOOM && meta.themeOverride && meta.themeDesired === false && desiredVisible === true) {
            return false;
        }

        // Les thèmes peuvent override le zoom mais pas l'utilisateur
        if (source === VisibilitySource.THEME) {
            return true;
        }

        // Par défaut, autoriser (pour 'system' et autres)
        return true;
    };

    /**
     * Met à jour les flags de visibilité selon la source
     * @param {Object} meta - Métadonnées de visibilité
     * @param {string} source - Source de la modification
     * @param {boolean} visible - État de visibilité
     * @private
     */
    VisibilityManager._updateVisibilityFlags = function (meta, source, visible) {
        switch (source) {
            case VisibilitySource.USER:
                meta.userOverride = true;
                meta.themeOverride = false;  // Reset theme override
                meta.zoomConstrained = false;
                meta.logicalState = visible; // Mettre à jour l'état logique
                break;

            case VisibilitySource.THEME:
                // Ne pas override userOverride si déjà présent
                if (!meta.userOverride) {
                    meta.themeOverride = true;
                    meta.themeDesired = visible;
                    meta.zoomConstrained = false;
                    meta.logicalState = visible; // Mettre à jour l'état logique
                }
                break;

            case VisibilitySource.ZOOM:
                // Marquer la contrainte zoom (sauf override utilisateur)
                // NE PAS modifier logicalState - le zoom n'affecte pas l'état logique
                if (!meta.userOverride) {
                    meta.zoomConstrained = true;
                }
                break;

            case VisibilitySource.SYSTEM:
                // Reset tous les overrides pour un chargement propre
                meta.userOverride = false;
                meta.themeOverride = false;
                meta.themeDesired = null;
                meta.zoomConstrained = false;
                meta.logicalState = visible; // Initialiser l'état logique
                break;
        }
    };

    /**
     * Applique physiquement le changement de visibilité (add/remove layer)
     * @param {string} layerId - ID de la couche
     * @param {Object} layerData - Données de la couche
     * @param {boolean} visible - État de visibilité souhaité
     * @returns {boolean} - true si un changement a été effectué
     * @private
     */
    VisibilityManager._applyVisibilityChange = function (layerId, layerData, visible) {
        const state = getState$a();
        const Log = getLog();

        if (!layerData.layer) {
            Log.warn("[VisibilityManager] Layer Leaflet manquant pour:", layerId);
            return false;
        }

        // Déterminer quelle couche gérer (cluster ou layer)
        const layerToManage = layerData.clusterGroup || layerData.layer;
        const isCurrentlyOnMap = state.map && state.map.hasLayer(layerToManage);

        // Si déjà dans l'état souhaité, ne rien faire
        if (visible && isCurrentlyOnMap) {
            return false;
        }
        if (!visible && !isCurrentlyOnMap) {
            return false;
        }

        try {
            if (visible) {
                // Cas 1 : Cluster partagé avec POI
                if (layerData.useSharedCluster && layerData.clusterGroup) {
                    layerData.clusterGroup.addLayer(layerData.layer);
                }
                // Cas 2 : Cluster indépendant
                else if (layerData.clusterGroup) {
                    state.map.addLayer(layerData.clusterGroup);
                    if (layerData.clusterGroup.refreshClusters) {
                        layerData.clusterGroup.refreshClusters();
                    }
                }
                // Cas 3 : Pas de cluster - ajouter directement à la map pour respecter le pane
                else {
                    state.map.addLayer(layerData.layer);
                }
            } else {
                // Cas 1 : Cluster partagé avec POI
                if (layerData.useSharedCluster && layerData.clusterGroup) {
                    layerData.clusterGroup.removeLayer(layerData.layer);
                }
                // Cas 2 : Cluster indépendant
                else if (layerData.clusterGroup) {
                    state.map.removeLayer(layerData.clusterGroup);
                }
                // Cas 3 : Pas de cluster - retirer directement de la map
                else {
                    state.map.removeLayer(layerData.layer);
                }
            }

            // Synchroniser l'UI du Layer Manager et le bouton labels après changement réussi
            // Utilise le refresh debounced pour grouper les changements multiples (ex: zoom)
            if (_g$x.GeoLeaf && _g$x.GeoLeaf.LayerManager && typeof _g$x.GeoLeaf.LayerManager.refresh === 'function') {
                _g$x.GeoLeaf.LayerManager.refresh(); // Debounced par défaut (100ms)
            }

            if (_g$x.GeoLeaf && _g$x.GeoLeaf._LabelButtonManager && typeof _g$x.GeoLeaf._LabelButtonManager.syncImmediate === 'function') {
                _g$x.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
            }

            return true;

        } catch (err) {
            Log.error(`[VisibilityManager] Erreur lors du changement de visibilité de ${layerId}:`, err);
            return false;
        }
    };

    /**
     * Notifie le module Legend d'un changement de visibilité
     * @param {string} layerId - ID de la couche
     * @param {boolean} visible - État de visibilité
     * @private
     */
    VisibilityManager._notifyLegend = function (layerId, visible) {
        if (_g$x.GeoLeaf && _g$x.GeoLeaf.Legend && typeof _g$x.GeoLeaf.Legend.setLayerVisibility === "function") {
            _g$x.GeoLeaf.Legend.setLayerVisibility(layerId, visible);
        }

        // Notifier aussi le module Labels pour masquer/afficher les étiquettes
        if (_g$x.GeoLeaf && _g$x.GeoLeaf.Labels) {
            if (visible) {
                // Si la couche devient visible, vérifier si les labels doivent être affichés
                // refreshLabels ne fait rien si les labels ne sont pas enabled
                if (typeof _g$x.GeoLeaf.Labels.refreshLabels === "function") {
                    _g$x.GeoLeaf.Labels.refreshLabels(layerId);
                }
            } else {
                // Si la couche devient invisible, masquer les labels (sans changer enabled)
                if (typeof _g$x.GeoLeaf.Labels._hideLabelsForLayer === "function") {
                    _g$x.GeoLeaf.Labels._hideLabelsForLayer(layerId);
                }
            }
        }

        // Synchroniser le bouton de label pour refléter la visibilité de la couche
        if (_g$x.GeoLeaf && _g$x.GeoLeaf._LabelButtonManager && typeof _g$x.GeoLeaf._LabelButtonManager.syncImmediate === "function") {
            _g$x.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
        }
    };

    /**
     * Émet un événement de changement de visibilité
     * @param {string} layerId - ID de la couche
     * @param {boolean} visible - État de visibilité
     * @param {string} source - Source du changement
     * @private
     */
    VisibilityManager._fireVisibilityEvent = function (layerId, visible, source) {
        const state = getState$a();
        if (!state.map) return;

        try {
            state.map.fire("geoleaf:geojson:visibility-changed", {
                layerId: layerId,
                visible: visible,
                source: source
            });
        } catch (e) {
            // Silencieux
        }
    };

    /**
     * Réinitialise les overrides utilisateur pour une couche
     * Utilisé par les thèmes pour reprendre le contrôle
     *
     * @param {string} layerId - ID de la couche
     */
    VisibilityManager.resetUserOverride = function (layerId) {
        const state = getState$a();
        const layerData = state.layers.get(layerId);

        if (layerData && layerData._visibility) {
            layerData._visibility.userOverride = false;
            getLog().debug(`[VisibilityManager] User override réinitialisé pour ${layerId}`);
        }
    };

    /**
     * Réinitialise tous les overrides utilisateur
     * Utilisé par les thèmes lors d'un changement complet de thème
     */
    VisibilityManager.resetAllUserOverrides = function () {
        const state = getState$a();
        let count = 0;

        state.layers.forEach((layerData, layerId) => {
            if (layerData._visibility && layerData._visibility.userOverride) {
                layerData._visibility.userOverride = false;
                count++;
            }
        });

        if (count > 0) {
            getLog().debug(`[VisibilityManager] ${count} user override(s) réinitialisé(s)`);
        }
    };

    /**
     * Obtient l'état de visibilité complet d'une couche
     * @param {string} layerId - ID de la couche
     * @returns {Object|null} - Métadonnées de visibilité ou null
     */
    VisibilityManager.getVisibilityState = function (layerId) {
        const state = getState$a();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            return null;
        }

        initVisibilityMetadata(layerData);

        return {
            current: layerData._visibility.current,
            source: layerData._visibility.source,
            userOverride: layerData._visibility.userOverride,
            themeOverride: layerData._visibility.themeOverride,
            zoomConstrained: layerData._visibility.zoomConstrained
        };
    };

    /**
     * Exporte les constantes pour utilisation externe
     */
    VisibilityManager.VisibilitySource = VisibilitySource;

    getLog().info("[GeoLeaf._LayerVisibilityManager] Module chargé");

    /**
     * GeoLeaf GeoJSON Worker Manager
     * Orchestre le cycle de vie du Web Worker GeoJSON.
     *
     * Fonctionnalités :
     *   - Création lazy d'un Worker unique (singleton)
     *   - Communication postMessage / onmessage
     *   - Fallback transparent vers fetch main-thread si Worker indisponible
     *   - Nettoyage automatique du Worker après un délai d'inactivité
     *
     * @module geojson/worker-manager
     */

    /** Délai avant terminaison du Worker inactif (ms) */
    const IDLE_TIMEOUT = 30000;

    /** Chunk size envoyé au Worker */
    const DEFAULT_CHUNK_SIZE = 500;

    /** Nom du fichier worker */
    const WORKER_FILENAME = "geojson-worker.js";

    /**
     * Détecte le répertoire de base du bundle GeoLeaf en scannant les balises <script>.
     * Permet de résoudre l'URL du Worker relativement au bundle, pas à la page HTML.
     *
     * @returns {string} Base URL se terminant par '/' (ex. "../dist/" ou "/assets/js/")
     * @private
     */
    function _detectScriptBase() {
        // Méthode 1 : document.currentScript (disponible uniquement pendant l'exécution synchrone du script)
        if (typeof document !== "undefined" && document.currentScript && document.currentScript.src) {
            return document.currentScript.src.substring(0, document.currentScript.src.lastIndexOf("/") + 1);
        }

        // Méthode 2 : scanner les <script> pour trouver geoleaf*.js
        if (typeof document !== "undefined") {
            var scripts = document.getElementsByTagName("script");
            for (var i = scripts.length - 1; i >= 0; i--) {
                var src = scripts[i].src || "";
                if (/geoleaf[\w.-]*\.js/i.test(src)) {
                    return src.substring(0, src.lastIndexOf("/") + 1);
                }
            }
        }

        // Méthode 3 : fallback — même répertoire que la page
        return "";
    }

    /** Base URL capturée au chargement du module */
    const _scriptBase = _detectScriptBase();

    /**
     * État interne du manager.
     * @private
     */
    const _state$2 = {
        /** @type {Worker|null} */
        worker: null,
        /** @type {boolean} */
        workerAvailable: true,
        /** @type {Map<string, Object>} layerId → { resolve, reject, features, onChunk } */
        pending: new Map(),
        /** @type {number|null} */
        idleTimer: null
    };

    // ─── Helpers ────────────────────────────────────────────────────

    /**
     * Tente de créer le Worker. Renvoie null si impossible.
     * @returns {Worker|null}
     * @private
     */
    function _createWorker() {
        if (!_state$2.workerAvailable) return null;
        if (_state$2.worker) return _state$2.worker;

        try {
            // Résoudre l'URL du Worker relativement au script GeoLeaf (pas à la page HTML)
            const workerUrl = _scriptBase + WORKER_FILENAME;
            const worker = new Worker(workerUrl);

            worker.onmessage = _onMessage;
            worker.onerror = _onError;

            _state$2.worker = worker;
            getLog().debug("[WorkerManager] Web Worker GeoJSON créé :", workerUrl);
            return worker;
        } catch (err) {
            getLog().warn("[WorkerManager] Impossible de créer le Web Worker, fallback main-thread :", err.message);
            _state$2.workerAvailable = false;
            return null;
        }
    }

    /**
     * Réinitialise le timer d'inactivité.
     * @private
     */
    function _resetIdleTimer() {
        if (_state$2.idleTimer) clearTimeout(_state$2.idleTimer);
        _state$2.idleTimer = setTimeout(() => {
            if (_state$2.pending.size === 0 && _state$2.worker) {
                _state$2.worker.terminate();
                _state$2.worker = null;
                getLog().debug("[WorkerManager] Worker terminé après inactivité");
            }
        }, IDLE_TIMEOUT);
    }

    // ─── Worker message handlers ────────────────────────────────────

    /**
     * Gestionnaire des messages reçus du Worker.
     * @param {MessageEvent} event
     * @private
     */
    function _onMessage(event) {
        const msg = event.data;
        if (!msg || !msg.type) return;

        const entry = msg.layerId ? _state$2.pending.get(msg.layerId) : null;

        switch (msg.type) {
            case "chunk":
                if (entry) {
                    // Accumuler les features
                    if (msg.features && msg.features.length) {
                        entry.features.push(...msg.features);
                    }
                    // Callback optionnel par chunk (pour rendu progressif)
                    if (typeof entry.onChunk === "function") {
                        entry.onChunk(msg.features, msg.index, msg.total);
                    }
                }
                break;

            case "done":
                if (entry) {
                    _state$2.pending.delete(msg.layerId);
                    entry.resolve({
                        type: "FeatureCollection",
                        features: entry.features
                    });
                    _resetIdleTimer();
                }
                break;

            case "text-done":
                // Perf 6.3.1: GPX text fetch completed in Worker
                if (entry) {
                    _state$2.pending.delete(msg.layerId);
                    entry.resolve(msg.text || '');
                    _resetIdleTimer();
                }
                break;

            case "error":
                if (entry) {
                    _state$2.pending.delete(msg.layerId);
                    entry.reject(new Error(msg.message));
                    _resetIdleTimer();
                } else {
                    getLog().warn("[WorkerManager] Erreur Worker sans layerId :", msg.message);
                }
                break;

            case "pong":
                getLog().debug("[WorkerManager] Worker pong reçu");
                break;
        }
    }

    /**
     * Gestionnaire d'erreur globale du Worker.
     * @param {ErrorEvent} err
     * @private
     */
    function _onError(err) {
        var details = err.message || err.filename || "unknown (possible 404 on " + _scriptBase + WORKER_FILENAME + ")";
        getLog().error("[WorkerManager] Erreur Worker :", details);
        // Rejeter toutes les requêtes en cours → fallback main-thread
        _state$2.pending.forEach(function (entry) {
            entry.reject(new Error("Worker error: " + details));
        });
        _state$2.pending.clear();
        // Marquer le Worker comme indisponible → prochains appels utiliseront le fallback
        _state$2.workerAvailable = false;
        if (_state$2.worker) {
            _state$2.worker.terminate();
            _state$2.worker = null;
        }
    }

    // ─── Fallback main-thread ───────────────────────────────────────

    /**
     * Fallback : fetch + parse sur le thread principal.
     *
     * @param {string} url
     * @param {string} layerId
     * @returns {Promise<Object>} FeatureCollection
     * @private
     */
    function _mainThreadFetch(url, layerId) {
        const Log = getLog();
        Log.debug("[WorkerManager] Fallback main-thread pour :", layerId);

        return fetch(url)
            .then(function (response) {
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + " pour " + url);
                }
                return response.json();
            })
            .then(function (data) {
                // Normaliser
                if (data && data.type === "FeatureCollection") return data;
                if (data && data.type === "Feature") {
                    return { type: "FeatureCollection", features: [data] };
                }
                if (Array.isArray(data)) {
                    return { type: "FeatureCollection", features: data };
                }
                return data;
            });
    }

    // ─── API publique ───────────────────────────────────────────────

    const WorkerManager = {

        /**
         * Récupère et parse un GeoJSON via le Web Worker (ou fallback main-thread).
         *
         * @param {string} url - URL du GeoJSON
         * @param {string} layerId - Identifiant unique de la couche
         * @param {Object} [options={}]
         * @param {number} [options.chunkSize=500] - Nombre de features par chunk
         * @param {Function} [options.onChunk] - Callback(features[], chunkIndex, totalFeatures)
         * @returns {Promise<Object>} - Résolu avec un FeatureCollection complet
         */
        fetchGeoJSON: function (url, layerId, options) {
            options = options || {};

            // Resolve relative URLs to absolute before sending to the Worker.
            // The Worker resolves relative paths against its own location (dist/),
            // not the page URL — so we must pass an absolute URL.
            var absoluteUrl = url;
            if (typeof location !== "undefined" && url && !url.includes("://")) {
                try {
                    absoluteUrl = new URL(url, location.href).href;
                } catch (_) {
                    // keep original url if resolution fails
                }
            }

            var worker = _createWorker();

            if (!worker) {
                return _mainThreadFetch(absoluteUrl, layerId);
            }

            return new Promise(function (resolve, reject) {
                _state$2.pending.set(layerId, {
                    resolve: resolve,
                    reject: reject,
                    features: [],
                    onChunk: options.onChunk || null
                });

                worker.postMessage({
                    type: "fetch",
                    url: absoluteUrl,
                    layerId: layerId,
                    chunkSize: options.chunkSize || DEFAULT_CHUNK_SIZE
                });

                _resetIdleTimer();
            });
        },

        /**
         * Récupère le texte brut d'une URL via le Web Worker (ou fallback main-thread).
         * Perf 6.3.1: Utilisé pour les fichiers GPX afin de décharger le réseau du thread principal.
         * Note: le parsing DOMParser reste sur le main thread car non disponible dans tous les Workers.
         *
         * @param {string} url - URL du fichier texte
         * @param {string} layerId - Identifiant unique de la couche
         * @returns {Promise<string>} - Résolu avec le texte brut
         */
        fetchText: function (url, layerId) {
            // Resolve relative URLs to absolute (same reason as fetchGeoJSON)
            var absoluteUrl = url;
            if (typeof location !== "undefined" && url && !url.includes("://")) {
                try {
                    absoluteUrl = new URL(url, location.href).href;
                } catch (_) {}
            }

            var worker = _createWorker();

            if (!worker) {
                // Fallback main-thread
                return fetch(absoluteUrl).then(function (response) {
                    if (!response.ok) throw new Error('HTTP ' + response.status + ' pour ' + absoluteUrl);
                    return response.text();
                });
            }

            return new Promise(function (resolve, reject) {
                _state$2.pending.set(layerId, {
                    resolve: resolve,
                    reject: reject,
                    features: [], // unused for text, kept for consistency
                    onChunk: null
                });

                worker.postMessage({
                    type: 'fetch-text',
                    url: absoluteUrl,
                    layerId: layerId
                });

                _resetIdleTimer();
            });
        },

        /**
         * Vérifie si le Web Worker est disponible.
         * @returns {boolean}
         */
        isAvailable: function () {
            return _state$2.workerAvailable && typeof Worker !== "undefined";
        },

        /**
         * Termine le Worker et nettoie l'état.
         * Appelé lors du teardown de l'application.
         */
        dispose: function () {
            if (_state$2.idleTimer) clearTimeout(_state$2.idleTimer);
            _state$2.pending.forEach(function (entry) {
                entry.reject(new Error("WorkerManager disposed"));
            });
            _state$2.pending.clear();
            if (_state$2.worker) {
                _state$2.worker.terminate();
                _state$2.worker = null;
            }
            getLog().debug("[WorkerManager] Disposed");
        }
    };

    /**
     * GeoLeaf GeoJSON Module - Layer Configuration Manager
     * Gestion de la configuration et des options des couches
     *
     * @module geojson/layer-config-manager
     */

    const _g$w = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    // Dépendances lazy
    const getState$9 = () => GeoJSONShared.state;

    const LayerConfigManager = {};

    /**
     * Résout le chemin absolu d'un fichier de données
     *
     * @param {string} dataFile - Nom du fichier de données
     * @param {Object} profile - Profil actif
     * @param {string} [layerDirectory] - Dossier de la couche
     * @returns {string} Chemin absolu résolu
     */
    LayerConfigManager.resolveDataFilePath = function (dataFile, profile, layerDirectory) {
        const Config = _g$w.GeoLeaf && _g$w.GeoLeaf.Config;
        const dataCfg = Config && Config.get ? Config.get('data') : null;
        const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
        const profileId = (dataCfg && dataCfg.activeProfile) || profile.id;

        // Si dataFile commence par ../, on résout relativement au dossier du profil
        if (dataFile.startsWith('../')) {
            // dataFile = "../raw/file.json" -> "profiles/tourism/raw/file.json"
            const relativePath = dataFile.replace('../', '');
            return `${profilesBasePath}/${profileId}/${relativePath}`;
        }


        // Si dataFile commence par /, c'est un chemin absolu
        if (dataFile.startsWith('/')) {
            return dataFile;
        }

        // Sinon, relatif au dossier de la couche (layers/tourism_poi_all/data/file.json)
        if (layerDirectory) {
            return `${profilesBasePath}/${profileId}/${layerDirectory}/${dataFile}`;
        }

        // Fallback: relatif au dossier du profil
        return `${profilesBasePath}/${profileId}/${dataFile}`;
    };

    /**
     * Infère le type de géométrie d'une couche
     *
     * @param {Object} def - Définition de la couche
     * @param {Object} geojsonData - Données GeoJSON
     * @returns {string} Type de géométrie ('point', 'line', 'polygon', 'unknown')
     */
    LayerConfigManager.inferGeometryType = function (def, geojsonData) {
        if (def && typeof def.geometryType === "string") return def.geometryType;
        const features = geojsonData && Array.isArray(geojsonData.features)
            ? geojsonData.features
            : [];
        const first = features.find(f => f && f.geometry && f.geometry.type);
        if (!first) return "unknown";
        const geometryType = first.geometry.type.toLowerCase();
        if (geometryType.includes("point")) return "point";
        if (geometryType.includes("line")) return "line";
        if (geometryType.includes("polygon")) return "polygon";
        return "unknown";
    };

    /**
     * Construit les options Leaflet pour une couche spécifique
     * Configure pointToLayer, onEachFeature, styles, popups, tooltips et panes
     *
     * @param {Object} def - Définition de la couche depuis profile.json
     * @param {string} def.id - ID unique de la couche
     * @param {number} [def.zIndex] - Index z pour le positionnement
     * @param {Object} [def.style] - Style par défaut de la couche
     * @param {Array} [def.styleRules] - Règles de style conditionnelles
     * @param {boolean} [def.interactiveShape=false] - Rendre les formes interactives
     * @param {boolean} [def.showIconsOnMap=false] - Afficher icônes SVG pour les points
     * @param {Object} baseOptions - Options de base du module GeoJSON
     * @returns {Object} Options Leaflet configurées (pointToLayer, onEachFeature, style, etc.)
     * @example
     * const options = GeoLeaf._GeoJSONLayerConfig.buildLayerOptions(
     *   { id: 'poi_tourism', zIndex: 100, showIconsOnMap: true },
     *   { defaultPointStyle: { radius: 8 } }
     * );
     */
    LayerConfigManager.buildLayerOptions = function (def, baseOptions) {
        const state = getState$9();
        const mergedOptions = Object.assign({}, state.options, baseOptions);

        // Style des polygones / lignes
        if (def.style && typeof def.style === "object") {
            mergedOptions.defaultStyle = Object.assign(
                {},
                mergedOptions.defaultStyle,
                def.style
            );
        }

        // Règles de style dynamiques (styleRules)
        if (Array.isArray(def.styleRules) && def.styleRules.length > 0) {
            mergedOptions.styleRules = def.styleRules;
        }

        // Déterminer le paramètre interactiveShape pour cette couche
        mergedOptions.interactiveShape = typeof def.interactiveShape === "boolean"
            ? def.interactiveShape
            : (_g$w.GeoLeaf && _g$w.GeoLeaf.Config && _g$w.GeoLeaf.Config.get ? _g$w.GeoLeaf.Config.get('ui.interactiveShapes', false) : false);

        // Vérifier si on doit afficher les icônes SVG sur la carte
        const showIconsOnMap = typeof def.showIconsOnMap === 'boolean' ? def.showIconsOnMap : false;

        // Déterminer le pane à utiliser pour cette couche
        const PaneHelpers = GeoJSONShared.PaneHelpers;
        const paneName = PaneHelpers.getPaneName(def.zIndex);

        // Style des points
        if (showIconsOnMap) {
            // Mode ICÔNE : utiliser les icônes SVG du profil
            mergedOptions.pointToLayer = function (feature, latlng) {
                // Convertir la feature en POI pour obtenir les infos de catégorie
                const PopupTooltip = _g$w.GeoLeaf && _g$w.GeoLeaf._GeoJSONPopupTooltip;
                const poiData = PopupTooltip ? PopupTooltip.convertFeatureToPOI(feature, def) : null;

                if (poiData) {
                    // Convertir le format ancien 'fields' au nouveau 'detailPopup'
                    const popupConfig = def.popup || {};
                    const convertedPopup = {
                        enabled: popupConfig.enabled,
                        // Format ancien: { fields: [...] } → Format nouveau: { detailPopup: [...] }
                        detailPopup: popupConfig.detailPopup || popupConfig.fields || [],
                        // Aussi supporter l'ancien format de tooltip
                        detailTooltip: popupConfig.detailTooltip || (popupConfig.tooltip && popupConfig.tooltip.fields) || []
                    };

                    // Passer toute la configuration de la couche au POI
                    poiData._layerConfig = {
                        style: mergedOptions.defaultStyle || {},
                        popup: convertedPopup,
                        tooltip: def.tooltip || {},
                        sidepanelConfig: def.sidepanelConfig || {}
                    };
                }

                // Utiliser le système de markers POI pour créer l'icône
                const markers = _g$w.GeoLeaf && _g$w.GeoLeaf._POIMarkers;
                if (markers && typeof markers.createMarker === 'function' && poiData) {
                    const attachEvents = mergedOptions.interactiveShape !== false;
                    const marker = markers.createMarker(poiData, { attachEvents, pane: paneName });
                    // S'assurer que le pane est défini sur le marker
                    if (marker && marker.options) {
                        marker.options.pane = paneName;
                    }
                    return marker;
                }

                // Fallback sur circleMarker avec pane
                const pointStyle = Object.assign(
                    {},
                    mergedOptions.defaultPointStyle,
                    def.pointStyle,
                    { interactive: mergedOptions.interactiveShape, pane: paneName }
                );
                return _g$w.L.circleMarker(latlng, pointStyle);
            };
        } else if (def.pointStyle && typeof def.pointStyle === "object") {
            // Mode CIRCLE : utiliser circleMarker classique avec pane
            const pointStyle = Object.assign(
                {},
                mergedOptions.defaultPointStyle,
                def.pointStyle,
                { interactive: mergedOptions.interactiveShape, pane: paneName }
            );
            mergedOptions.pointToLayer = function (feature, latlng) {
                return _g$w.L.circleMarker(latlng, pointStyle);
            };
        }

        // Callback onEachFeature : intégration popups + side panel + tooltips
        const originalOnEachFeature = typeof def.onEachFeature === "function" ? def.onEachFeature : null;

        mergedOptions.onEachFeature = function (feature, layer) {
            // Popup unifié
            const PopupTooltip = _g$w.GeoLeaf && _g$w.GeoLeaf._GeoJSONPopupTooltip;
            if (PopupTooltip) {
                PopupTooltip.bindUnifiedPopup(feature, layer, def);
                PopupTooltip.bindUnifiedTooltip(feature, layer, def);
            }

            // Callback custom si fourni
            if (originalOnEachFeature) {
                originalOnEachFeature(feature, layer);
            }
        };

        // Ajouter le pane aux defaultPointStyle pour que le style-resolver l'utilise dans son fallback
        if (mergedOptions.defaultPointStyle) {
            mergedOptions.defaultPointStyle = Object.assign({}, mergedOptions.defaultPointStyle, { pane: paneName });
        } else {
            mergedOptions.defaultPointStyle = { pane: paneName };
        }

        // Utiliser le StyleResolver pour construire les options Leaflet finales
        if (_g$w.GeoLeaf && _g$w.GeoLeaf._GeoJSONStyleResolver && _g$w.GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions) {
            return _g$w.GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions(mergedOptions);
        }

        return mergedOptions;
    };

    /**
     * Charge la légende d'une couche depuis son fichier legends/*.json
     * Résout automatiquement le chemin selon le style actif et la config du profil
     *
     * @param {Object} profile - Profil contenant la configuration
     * @param {string} profile.id - ID du profil (ex: 'tourism')
     * @param {string} [profile.basePath] - Chemin de base du profil
     * @param {Object} layerDef - Définition de la couche depuis profile.json
     * @param {string} layerDef.id - ID de la couche
     * @param {string} [layerDef.style='default'] - Style actif de la couche
     * @param {Object} [layerDef.legends] - Configuration des légendes
     * @param {string} [layerDef.legends.directory='legends'] - Dossier des légendes
     * @param {string} [layerDef.legends.default] - Fichier légende par défaut
     * @returns {void} Charge et affiche la légende via GeoLeaf.Legend.loadLegend()
     * @example
     * GeoLeaf._GeoJSONLayerConfig.loadLayerLegend(
     *   { id: 'tourism', basePath: '../profiles/tourism' },
     *   { id: 'poi_all', style: 'par_categorie', legends: { directory: 'legends' } }
     * );
     */
    LayerConfigManager.loadLayerLegend = function (profile, layerDef) {
        const Log = getLog();

        if (!layerDef) {
            if (Log) Log.debug("[GeoLeaf.GeoJSON] Pas de définition de couche");
            return;
        }

        // Pour v3.0, la config de la couche est déjà dans layerDef (enrichie par profile.js)
        const layerConfig = layerDef.legends ? layerDef : null;

        if (!layerConfig || !layerConfig.legends) {
            if (Log) Log.debug("[GeoLeaf.GeoJSON] Pas de config legends pour cette couche");
            return;
        }

        const legendsConfig = layerConfig.legends;
        const legendDirectory = legendsConfig.directory || "legends";

        // Déterminer le style actif de la couche
        const activeStyle = layerDef.style || "default";

        // Construire le nom de fichier de la légende
        let legendFile;
        if (activeStyle === "default" && legendsConfig.default) {
            legendFile = legendsConfig.default;
        } else {
            legendFile = `${activeStyle}.legend.json`;
        }

        // Construire le chemin de la légende
        const profileBasePath = profile.basePath || "./profiles/" + profile.id;
        const layerDirectory = layerDef._layerDirectory || "layers/" + layerDef.id;
        const legendPath = `${profileBasePath}/${layerDirectory}/${legendDirectory}/${legendFile}`;

        if (Log) Log.debug(`[GeoLeaf.GeoJSON] Chargement légende pour style "${activeStyle}": ${legendPath}`);

        // Charger et afficher la légende directement
        if (_g$w.GeoLeaf && _g$w.GeoLeaf.Legend && typeof _g$w.GeoLeaf.Legend.loadLayerLegend === "function") {
            try {
                _g$w.GeoLeaf.Legend.loadLayerLegend(layerDef.id, activeStyle, layerDef);
                if (Log) Log.info(`[GeoLeaf.GeoJSON] Légende affichée pour ${layerDef.id} (style: ${activeStyle})`);
            } catch (error) {
                if (Log) Log.warn(`[GeoLeaf.GeoJSON] Erreur chargement légende: ${error.message}`);
            }
        } else {
            if (Log) Log.warn("[GeoLeaf.GeoJSON] Module Legend non disponible");
        }
    };

    /**
     * Charge le style par défaut d'une couche depuis son fichier styles/*.style.json
     * Fonction asynchrone utilisant fetch() pour charger le JSON
     *
     * @async
     * @param {string} layerId - ID de la couche (utilisé pour le logging)
     * @param {Object} layerDef - Définition de la couche
     * @param {Object} layerDef.styles - Configuration des styles
     * @param {string} layerDef.styles.default - Nom du fichier de style par défaut
     * @param {string} [layerDef.styles.directory='styles'] - Dossier des styles
     * @param {string} layerDef._profileId - ID du profil (métadonnée interne)
     * @param {string} layerDef._layerDirectory - Dossier de la couche (métadonnée interne)
     * @returns {Promise<Object>} Style chargé (objet JSON parsé)
     * @throws {Error} "Pas de style par défaut défini" si styles.default manquant
     * @throws {Error} "Métadonnées manquantes" si _profileId ou _layerDirectory absent
     * @throws {Error} "HTTP {status}" si le fetch échoue
     * @example
     * try {
     *   const style = await GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle(
     *     'provincia_ar',
     *     { styles: { default: 'défaut.json' }, _profileId: 'tourism', _layerDirectory: 'layers/provincia_ar' }
     *   );
     *   console.log('Style chargé:', style);
     * } catch (err) {
     *   console.error('Erreur chargement style:', err);
     * }
     */
    LayerConfigManager.loadDefaultStyle = async function (layerId, layerDef) {
        const Log = getLog();

        if (!layerDef.styles || !layerDef.styles.default) {
            throw new Error("Pas de style par défaut défini");
        }

        const profileId = layerDef._profileId;
        const layerDirectory = layerDef._layerDirectory;

        if (!profileId || !layerDirectory) {
            throw new Error("Métadonnées manquantes (profileId ou layerDirectory)");
        }

        const Config = _g$w.GeoLeaf && _g$w.GeoLeaf.Config;
        const dataCfg = Config && Config.get ? Config.get('data') : null;
        const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";

        const styleDirectory = layerDef.styles.directory || "styles";
        const styleFile = layerDef.styles.default;
        const stylePath = `${profilesBasePath}/${profileId}/${layerDirectory}/${styleDirectory}/${styleFile}`;

        Log.debug("[GeoLeaf.GeoJSON] Chargement style par défaut:", stylePath);

        const response = await fetch(stylePath);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const styleData = await response.json();
        Log.debug("[GeoLeaf.GeoJSON] Style chargé:", styleData);
        return styleData;
    };

    /**
     * GeoLeaf GeoJSON Module - Popup & Tooltip
     * Gestion des popups et tooltips unifiés
     *
     * @module geojson/popup-tooltip
     */

    const _g$v = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    // Dépendances lazy
    const getState$8 = () => GeoJSONShared.state;

    const PopupTooltip = {};

    /**
     * Convertit une feature GeoJSON en format POI pour le side panel.
     * Utilise _Normalizer si disponible, sinon crée un POI par défaut.
     * Enrichissement centralisé pour tous les POIs.
     *
     * @param {Object} feature - Feature GeoJSON
     * @param {Object} def - Définition de la couche
     * @returns {Object} - Objet POI formaté
     */
    PopupTooltip.convertFeatureToPOI = function (feature, def) {
        let poi;

        // Utiliser le Normalizer centralisé si disponible
        const Normalizer = _g$v.GeoLeaf && _g$v.GeoLeaf._Normalizer;
        if (Normalizer && typeof Normalizer.normalizeFromGeoJSON === 'function') {
            poi = Normalizer.normalizeFromGeoJSON(feature, def);
        } else {
            // Fallback: logique locale
            const props = feature.properties || {};


            poi = {
                id: props.id || ("geojson-feature-" + Math.random().toString(36).substr(2, 9)),
                // Résolution case-insensitive du titre (28 janvier 2026)
                title: props.NAME || props.Name || props.name ||
                       props.TITLE || props.Title || props.title ||
                       props.LABEL || props.Label || props.label || "Sans titre",
                description: props.description || props.desc || "",
                // Conserver properties pour compatibilité avec les configs qui utilisent "properties.field"
                properties: { ...props },
                attributes: {
                    source: "geojson",
                    layerId: def.id,
                    layerLabel: def.label,
                    ...props
                }
            };

            // Ajouter les coordonnées dans tous les formats supportés
            if (feature.geometry && feature.geometry.coordinates) {
                // Format latlng array [lat, lng] pour compatibilité POI
                poi.latlng = [
                    feature.geometry.coordinates[1], // lat
                    feature.geometry.coordinates[0]  // lng
                ];
                // Format geometry pour compatibilité GeoJSON
                poi.geometry = feature.geometry;
                // Format location pour compatibilité legacy
                poi.location = {
                    lat: feature.geometry.coordinates[1],
                    lng: feature.geometry.coordinates[0]
                };
            }
        }

        // Enrichissement centralisé pour tous les POIs
        if (poi) {
            poi.attributes = poi.attributes || {};
            poi.attributes.source = "geojson";
            poi.attributes.layerId = def.id;
            poi.attributes.layerLabel = def.label;

            // Attacher la configuration de la couche
            poi._layerConfig = def;

            // Utiliser getSidepanelConfig pour la normalisation correcte
            const Loader = _g$v.GeoLeaf && _g$v.GeoLeaf._GeoJSONLoader;
            const sidepanelLayout = Loader && Loader.getSidepanelConfig ? Loader.getSidepanelConfig(def) : null;
            if (sidepanelLayout) {
                poi._sidepanelConfig = {
                    detailLayout: sidepanelLayout
                };
            }
        }

        return poi;
    };

    /**
     * Attache un popup unifié compatible avec le système POI.
     *
     * @param {Object} feature - Feature GeoJSON
     * @param {L.Layer} layer - Couche Leaflet
     * @param {Object} def - Définition de la couche
     */
    PopupTooltip.bindUnifiedPopup = function (feature, layer, def) {
        const Log = getLog();

        if (!feature.properties) return;

        // Si interactiveShape est false, ne rien attacher (la couche est non-cliquable)
        if (def.interactiveShape === false) {
            return;
        }

        // Vérifier le paramètre showPopup de la couche (défaut: true)
        const showPopup = typeof def.showPopup === 'boolean' ? def.showPopup : true;

        // Si showPopup est false, mode DIRECT: toggle du panneau latéral au clic (sans popup)
        if (!showPopup) {
            layer.on("click", (e) => {
                if (e && e.originalEvent) e.originalEvent.stopPropagation();

                // Masquer le tooltip si présent
                if (layer.getTooltip && layer.getTooltip()) {
                    try {
                        if (typeof layer.closeTooltip === 'function') layer.closeTooltip();
                        else layer.unbindTooltip();
                    } catch (err) { /* ignore */ }
                }

                if (_g$v.GeoLeaf && _g$v.GeoLeaf.POI && typeof _g$v.GeoLeaf.POI.showPoiDetails === "function") {
                    const poiData = PopupTooltip.convertFeatureToPOI(feature, def);
                    const shared = _g$v.GeoLeaf._POIShared && _g$v.GeoLeaf._POIShared.state;
                    const current = shared ? shared.currentPoiInPanel : null;

                    // Toggle: si le même POI est ouvert, fermer le panneau, sinon l'ouvrir
                    if (current && poiData && current.id && poiData.id && current.id === poiData.id) {
                        if (_g$v.GeoLeaf.POI && typeof _g$v.GeoLeaf.POI.hideSidePanel === 'function') {
                            _g$v.GeoLeaf.POI.hideSidePanel();
                        }
                    } else {
                        _g$v.GeoLeaf.POI.showPoiDetails(poiData);
                    }
                }
            });
            return;
        }

        // Si un popup existe déjà (créé par POI Markers), le conserver
        if (layer.getPopup()) {
            return;
        }

        // Convertir la feature en POI normalisé
        const poiData = PopupTooltip.convertFeatureToPOI(feature, def);

        // Utiliser ContentBuilder.Assemblers si disponible
        const ContentBuilder = _g$v.GeoLeaf && _g$v.GeoLeaf._ContentBuilder?.Assemblers || null;
        // Utiliser le helper pour récupérer la config popup (28 janvier 2026)
        const Loader = _g$v.GeoLeaf && _g$v.GeoLeaf._GeoJSONLoader;

        let popupConfig = null;
        try {
            popupConfig = Loader && Loader.getPopupConfig ? Loader.getPopupConfig(def) : null;
        } catch (e) {
            // ...log supprimé ([DEBUG] bindUnifiedPopup - ERREUR getPopupConfig)...
        }

        // ...logs supprimés ([POPUP] bindUnifiedPopup)...
        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === 'function') {
            const markersModule = _g$v.GeoLeaf && _g$v.GeoLeaf._POIMarkers;
            const resolveCategoryDisplay = markersModule && typeof markersModule.resolveCategoryDisplay === 'function'
                ? markersModule.resolveCategoryDisplay
                : null;

            const popupContent = ContentBuilder.buildPopupHTML(poiData, popupConfig, {
                resolveCategoryDisplay: resolveCategoryDisplay
            });

            if (popupContent) {
                layer.bindPopup(popupContent);
            }
        } else {
            // Fallback: utiliser POIPopup module
            const popupModule = _g$v.GeoLeaf && _g$v.GeoLeaf._POIPopup;
            if (popupModule && typeof popupModule.buildQuickPopupContent === 'function') {
                const markersModule = _g$v.GeoLeaf && _g$v.GeoLeaf._POIMarkers;
                const resolveCategoryDisplay = markersModule && typeof markersModule.resolveCategoryDisplay === 'function'
                    ? markersModule.resolveCategoryDisplay
                    : null;

                const popupContent = popupModule.buildQuickPopupContent(poiData, resolveCategoryDisplay);
                if (popupContent) {
                    layer.bindPopup(popupContent);
                }
            } else {
                // Fallback minimal sans modules
                const Security = _g$v.GeoLeaf && _g$v.GeoLeaf.Security || {
                    escapeHtml: (str) => {
                        if (!str) return "";
                        const div = document.createElement("div");
                        div.textContent = String(str);
                        return div.innerHTML;
                    }
                };

                const props = feature.properties;
                const name = props.name || props.label || props.title || "Sans titre";
                const description = props.description || props.desc || "";

                let popupHtml = '<div class="gl-geojson-popup">';
                popupHtml += '<h3 class="gl-popup-title">' + Security.escapeHtml(name) + '</h3>';

                if (description) {
                    popupHtml += '<p class="gl-popup-description">' + Security.escapeHtml(description) + '</p>';
                }

                if (_g$v.GeoLeaf && _g$v.GeoLeaf.POI && typeof _g$v.GeoLeaf.POI.showPoiDetails === "function") {
                    popupHtml += '<a href="#" class="gl-poi-popup__link" data-layer-id="' + def.id + '" data-feature-id="' + (props.id || '') + '">Voir détails →</a>';
                }

                popupHtml += '</div>';
                layer.bindPopup(popupHtml);
            }
        }

        // Flag pour tracker l'état du popup
        layer._geoleafPopupActive = false;

        // Fermer le tooltip quand le popup s'ouvre
        layer.on('popupopen', () => {
            layer._geoleafPopupActive = true;

            // Fermer le tooltip si présent
            if (layer.getTooltip && layer.getTooltip()) {
                try {
                    if (typeof layer.closeTooltip === 'function') {
                        layer.closeTooltip();
                    }
                } catch (err) {
                    Log.warn('[GeoJSON] Erreur fermeture tooltip:', err);
                }
            }

            // Délégation d'événement pour le lien "Voir détails"
            const popup = layer.getPopup();
            if (!popup) return;

            const popupEl = popup.getElement();
            if (!popupEl) return;

            const link = popupEl.querySelector('.gl-poi-popup__link');
            if (link && !link._geoleafClickBound) {
                link._geoleafClickBound = true;
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (_g$v.GeoLeaf && _g$v.GeoLeaf.POI && typeof _g$v.GeoLeaf.POI.showPoiDetails === "function") {
                        const poiData = PopupTooltip.convertFeatureToPOI(feature, def);
                        _g$v.GeoLeaf.POI.showPoiDetails(poiData);
                    }
                });
            }
        });

        // Réactiver le tooltip quand le popup se ferme
        layer.on('popupclose', () => {
            layer._geoleafPopupActive = false;

            // Réouvrir le tooltip s'il est permanent (mode "always")
            if (layer.getTooltip() && layer.getTooltip().options.permanent) {
                setTimeout(() => {
                    if (layer.openTooltip && !layer._geoleafPopupActive) {
                        layer.openTooltip();
                    }
                }, 50);
            }
        });
    };

    /**
     * Attache un tooltip unifié à une couche selon sa configuration.
     *
     * @param {Object} feature - Feature GeoJSON
     * @param {L.Layer} layer - Couche Leaflet
     * @param {Object} def - Définition de la couche
     */
    PopupTooltip.bindUnifiedTooltip = function (feature, layer, def) {
        const state = getState$8();

        if (!feature.properties || !layer) return;

        // Récupérer les paramètres de tooltip de la couche
        const tooltipMode = def.tooltipMode || "hover"; // "always", "never", "hover"
        const tooltipMinZoom = typeof def.tooltipMinZoom === "number" ? def.tooltipMinZoom : 0;

        // Si mode "never", ne rien faire
        if (tooltipMode === "never") {
            return;
        }

        // Construire le texte du tooltip par défaut (fallback case-insensitive)
        const props = feature.properties;
        const tooltipText = props.NAME || props.Name || props.name ||
                            props.TITLE || props.Title || props.title ||
                            props.LABEL || props.Label || props.label ||
                            props.id || "Sans titre";

        // Utiliser le helper pour récupérer la config tooltip (28 janvier 2026)
        const Loader = _g$v.GeoLeaf && _g$v.GeoLeaf._GeoJSONLoader;
        const tooltipConfig = Loader && Loader.getTooltipConfig ? Loader.getTooltipConfig(def) : null;

        // Convertir la feature en POI pour avoir access aux champs via attributes.*
        const featureAsPoi = PopupTooltip.convertFeatureToPOI(feature, def);

        // Fonction pour construire le contenu du tooltip
        const buildTooltipContent = () => {
            // Utiliser ContentBuilder.Assemblers si disponible
            const ContentBuilder = _g$v.GeoLeaf && _g$v.GeoLeaf._ContentBuilder?.Assemblers || null;
            if (ContentBuilder && typeof ContentBuilder.buildTooltipHTML === 'function') {
                const content = ContentBuilder.buildTooltipHTML(featureAsPoi, tooltipConfig);
                return content || tooltipText;
            }

            // Fallback: utiliser POIPopup module
            const POIPopup = _g$v.GeoLeaf && _g$v.GeoLeaf._POIPopup;
            if (POIPopup && typeof POIPopup.buildTooltipContent === 'function') {
                const content = POIPopup.buildTooltipContent(featureAsPoi);
                return content || tooltipText;
            }

            // Fallback minimal
            return tooltipText;
        };

        // Fonction pour gérer l'affichage du tooltip selon le zoom
        const updateTooltipVisibility = () => {
            if (!state.map) return;

            // Ne pas afficher le tooltip si un popup est actif sur cette couche
            if (layer._geoleafPopupActive) return;

            const currentZoom = state.map.getZoom();
            const shouldShow = currentZoom >= tooltipMinZoom;

            const content = buildTooltipContent();

            if (shouldShow) {
                if (!layer.getTooltip()) {
                    const opts = {
                        direction: 'top',
                        offset: [0, -10],
                        opacity: 0.9,
                        className: 'gl-geojson-tooltip',
                        permanent: tooltipMode === 'always'
                    };
                    layer.bindTooltip(content, opts);
                    if (tooltipMode === 'always' && layer.openTooltip) {
                        layer.openTooltip();
                    }
                } else {
                    // update existing tooltip content
                    const tooltip = layer.getTooltip();
                    if (tooltip && tooltip.setContent) tooltip.setContent(content);
                }
            } else {
                if (layer.getTooltip()) {
                    try {
                        if (typeof layer.closeTooltip === 'function') {
                            layer.closeTooltip();
                        } else {
                            layer.unbindTooltip();
                        }
                    } catch (err) {
                        /* ignore */
                    }
                }
            }
        };

        // Stocker la référence pour le nettoyage
        layer._geoleafTooltipUpdate = updateTooltipVisibility;

        // Bloquer l'ouverture du tooltip pendant que le popup est actif
        layer.on('tooltipopen', (e) => {
            if (layer._geoleafPopupActive) {
                layer.closeTooltip();
            }
        });

        // Attendre que la couche soit ajoutée à la map avant d'initialiser
        layer.on('add', () => {
            // Initialiser le tooltip
            updateTooltipVisibility();

            // Ajouter le listener sur le zoom
            if (state.map) {
                state.map.on('zoomend', updateTooltipVisibility);
            }
        });

        // Nettoyer le listener quand la couche est retirée
        layer.on('remove', () => {
            if (state.map && layer._geoleafTooltipUpdate) {
                state.map.off('zoomend', layer._geoleafTooltipUpdate);
            }
        });
    };

    /**
     * GeoLeaf GeoJSON Layer Manager - Store
     * Layer CRUD operations: get, query, remove, z-index
     *
     * @module geojson/layer-manager/store
     */

    const _g$u = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$7 = () => GeoJSONShared.state;

    const LayerManager$4 = {};

    /**
     * Récupère une couche spécifique par son ID.
     *
     * @param {string} layerId - ID de la couche
     * @returns {Object|null} - { id, label, layer, visible, config, clusterGroup } ou null
     */
    LayerManager$4.getLayerById = function (layerId) {
        const state = getState$7();
        return state.layers.get(layerId) || null;
    };

    /**
     * Récupère les données d'une couche (geojson, geometryType, config).
     * Utilisé par le module Themes pour appliquer les styles.
     *
     * @param {string} layerId - ID de la couche
     * @returns {Object|null} - { geojson, geometryType, config } ou null
     */
    LayerManager$4.getLayerData = function (layerId) {
        const state = getState$7();
        const layerData = state.layers.get(layerId);
        if (!layerData) return null;

        return {
            geojson: layerData.geojson || null,
            features: layerData.features || [],
            geometryType: layerData.geometryType || 'unknown',
            config: layerData.config || {},
            layer: layerData.layer
        };
    };

    /**
     * Récupère toutes les couches chargées.
     *
     * @returns {Array<Object>} - Tableau de { id, label, visible, type, featureCount }
     *
     * Note: 'visible' retourne l'état LOGIQUE de la couche (activée/désactivée par l'utilisateur ou le thème),
     * pas l'état physique sur la carte (qui peut être masquée par le zoom).
     * C'est l'état qui doit être reflété par le bouton ON/OFF du gestionnaire de couches.
     */
    LayerManager$4.getAllLayers = function () {
        const state = getState$7();
        const layers = [];
        state.layers.forEach((layerData, id) => {
            // Utiliser logicalState qui est indépendant du zoom
            const meta = layerData._visibility;
            const logicalVisible = meta && typeof meta.logicalState === 'boolean'
                ? meta.logicalState
                : (layerData.visible || false);

            layers.push({
                id: id,
                label: layerData.label,
                visible: logicalVisible,
                // Perf 6.1.2: Use cached geometryType instead of O(n) detectLayerType() per call
                type: layerData.geometryType || LayerManager$4.detectLayerType(layerData.layer),
                featureCount: layerData.features ? layerData.features.length : (layerData.layer ? layerData.layer.getLayers().length : 0)
            });
        });
        return layers;
    };

    /**
     * Détecte le type de géométrie dominant d'une couche.
     *
     * @param {L.GeoJSON} layer
     * @returns {string} - "poi", "route", "area", ou "mixed"
     */
    LayerManager$4.detectLayerType = function (layer) {
        if (!layer || typeof layer.eachLayer !== 'function') return "mixed";

        const types = { Point: 0, LineString: 0, Polygon: 0 };

        layer.eachLayer((l) => {
            if (l.feature && l.feature.geometry) {
                const geomType = l.feature.geometry.type;
                if (geomType.includes("Point")) types.Point++;
                else if (geomType.includes("LineString")) types.LineString++;
                else if (geomType.includes("Polygon")) types.Polygon++;
            }
        });

        const max = Math.max(types.Point, types.LineString, types.Polygon);
        if (max === 0) return "mixed";
        if (types.Point === max) return "poi";
        if (types.LineString === max) return "route";
        if (types.Polygon === max) return "area";
        return "mixed";
    };

    /**
     * Supprime une couche.
     *
     * @param {string} layerId - ID de la couche
     */
    LayerManager$4.removeLayer = function (layerId) {
        const state = getState$7();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] removeLayer: couche introuvable :", layerId);
            return;
        }

        // Retirer de la carte
        if (layerData.visible) {
            LayerManager$4.hideLayer(layerId);
        }

        // Détruire les objets Leaflet
        if (layerData.clusterGroup) {
            layerData.clusterGroup.clearLayers();
        }
        if (layerData.layer) {
            layerData.layer.clearLayers();
        }

        // Retirer de la Map
        state.layers.delete(layerId);
        // featureCache removed (Sprint 1)

        Log.debug("[GeoLeaf.GeoJSON] Couche supprimée :", layerId);
    };

    /**
     * Met à jour le zIndex d'une couche (ordre d'empilement sur la carte).
     * Recréée la couche avec le nouveau pane si elle est visible.
     *
     * @param {string} layerId - ID de la couche
     * @param {number} newZIndex - Nouveau zIndex (0-99)
     * @returns {boolean} - true si la mise à jour a réussi
     */
    LayerManager$4.updateLayerZIndex = function (layerId, newZIndex) {
        const state = getState$7();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] updateLayerZIndex: couche introuvable :", layerId);
            return false;
        }

        // Validation et clamping 0-99
        const PaneHelpers = GeoJSONShared.PaneHelpers;
        newZIndex = PaneHelpers.validateZIndex(newZIndex);

        const oldZIndex = layerData.config.zIndex || 0;
        if (oldZIndex === newZIndex) {
            Log.debug("[GeoLeaf.GeoJSON] updateLayerZIndex: zIndex identique, aucun changement :", layerId);
            return true;
        }

        Log.info(`[GeoLeaf.GeoJSON] Changement zIndex pour ${layerId}: ${oldZIndex} → ${newZIndex}`);

        // Mettre à jour la config
        layerData.config.zIndex = newZIndex;

        // Si la couche n'est pas visible, juste mettre à jour la config
        const VisibilityManager = _g$u.GeoLeaf && _g$u.GeoLeaf._LayerVisibilityManager;
        const visState = VisibilityManager ? VisibilityManager.getVisibilityState(layerId) : null;
        const isVisible = visState ? visState.current : layerData.visible;

        if (!isVisible) {
            Log.debug("[GeoLeaf.GeoJSON] Couche non visible, zIndex mis à jour dans config uniquement");
            return true;
        }

        // Couche visible : besoin de changer le pane
        const newPaneName = PaneHelpers.getPaneName(newZIndex);
        const newPane = state.map.getPane(newPaneName);

        if (!newPane) {
            Log.error(`[GeoLeaf.GeoJSON] Pane ${newPaneName} introuvable`);
            return false;
        }

        try {
            // Retirer temporairement de la carte
            if (layerData.clusterGroup) {
                state.map.removeLayer(layerData.clusterGroup);
            } else {
                state.map.removeLayer(layerData.layer);
            }

            // Changer le pane du layer Leaflet
            if (layerData.layer && layerData.layer.options) {
                layerData.layer.options.pane = newPaneName;

                // Mettre à jour chaque feature/layer individuelle
                layerData.layer.eachLayer(function(subLayer) {
                    if (subLayer.options) {
                        subLayer.options.pane = newPaneName;
                    }
                    // Forcer le re-rendu en changeant le pane du path SVG
                    if (subLayer._path && subLayer._path.parentNode) {
                        const newPaneElement = state.map.getPane(newPaneName);
                        if (newPaneElement) {
                            newPaneElement.appendChild(subLayer._path);
                        }
                    }
                });
            }

            // Changer le pane du clusterGroup si présent
            if (layerData.clusterGroup && layerData.clusterGroup.options) {
                layerData.clusterGroup.options.pane = newPaneName;
            }

            // Remettre sur la carte directement
            if (layerData.clusterGroup) {
                state.map.addLayer(layerData.clusterGroup);
            } else {
                state.map.addLayer(layerData.layer);
            }

            Log.debug(`[GeoLeaf.GeoJSON] Couche ${layerId} déplacée vers pane ${newPaneName}`);

            // Déclencher événement de changement
            if (state.map) {
                state.map.fire("geoleaf:geojson:zindex-changed", {
                    layerId: layerId,
                    oldZIndex: oldZIndex,
                    newZIndex: newZIndex
                });
            }

            return true;
        } catch (error) {
            Log.error(`[GeoLeaf.GeoJSON] Erreur lors du changement de zIndex pour ${layerId}:`, error);
            return false;
        }
    };

    /**
     * GeoLeaf GeoJSON Layer Manager - Visibility
     * Show/hide/toggle layers, zoom-based visibility
     *
     * @module geojson/layer-manager/visibility
     */

    const _g$t = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$6 = () => GeoJSONShared.state;
    const ScaleUtils$1 = { calculateMapScale, isScaleInRange };

    const LayerManager$3 = {};

    /**
     * Affiche une couche (rend visible).
     *
     * @param {string} layerId - ID de la couche
     */
    LayerManager$3.showLayer = function (layerId) {
        const state = getState$6();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] showLayer: couche introuvable :", layerId);
            return;
        }

        // Utiliser le gestionnaire de visibilité centralisé
        const VisibilityManager = _g$t.GeoLeaf && _g$t.GeoLeaf._LayerVisibilityManager;
        if (!VisibilityManager) {
            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
            return;
        }

        const changed = VisibilityManager.setVisibility(
            layerId,
            true,
            VisibilityManager.VisibilitySource.USER
        );

        // IMPORTANT: Recalculer la visibilité physique en fonction du zoom
        // setVisibility met à jour logicalState (bouton), mais il faut aussi recalculer current
        LayerManager$3.updateLayerVisibilityByZoom();

        // Charger la légende si disponible (uniquement si changement effectué)
        if (changed) {
            LayerManager$3._loadLayerLegend(layerId, layerData);

            // Gérer les labels au moment de l'activation
            if (_g$t.GeoLeaf && _g$t.GeoLeaf.Labels && _g$t.GeoLeaf.Labels.hasLabelConfig(layerId)) {
                // Vérifier si visibleByDefault est true pour les labels
                const visibleByDefault = layerData.currentStyle?.label?.visibleByDefault === true;

                if (visibleByDefault) {
                    // Activer et afficher les labels immédiatement
                    _g$t.GeoLeaf.Labels.enableLabels(layerId, {}, true);
                } else if (_g$t.GeoLeaf.Labels.areLabelsEnabled(layerId)) {
                    // Sinon, juste rafraîchir si déjà activés
                    _g$t.GeoLeaf.Labels.refreshLabels(layerId);
                }
            }
            if (_g$t.GeoLeaf && _g$t.GeoLeaf._LabelButtonManager) {
                _g$t.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
            }

            Log.debug("[GeoLeaf.GeoJSON] Couche affichée :", layerId);
        }
    };

    /**
     * Masque une couche (rend invisible).
     *
     * @param {string} layerId - ID de la couche
     */
    LayerManager$3.hideLayer = function (layerId) {
        const state = getState$6();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] hideLayer: couche introuvable :", layerId);
            return;
        }

        // Utiliser le gestionnaire de visibilité centralisé
        const VisibilityManager = _g$t.GeoLeaf && _g$t.GeoLeaf._LayerVisibilityManager;
        if (!VisibilityManager) {
            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
            return;
        }

        const changed = VisibilityManager.setVisibility(
            layerId,
            false,
            VisibilityManager.VisibilitySource.USER
        );

        // IMPORTANT: Recalculer la visibilité physique (even on hide, to ensure consistency)
        LayerManager$3.updateLayerVisibilityByZoom();

        if (changed) {
            // Masquer les labels et mettre à jour le bouton
            if (_g$t.GeoLeaf && _g$t.GeoLeaf.Labels) {
                _g$t.GeoLeaf.Labels.disableLabels(layerId);
            }
            if (_g$t.GeoLeaf && _g$t.GeoLeaf._LabelButtonManager) {
                _g$t.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
            }

            Log.debug("[GeoLeaf.GeoJSON] Couche masquée :", layerId);
        }
    };

    /**
     * Toggle la visibilité d'une couche.
     *
     * @param {string} layerId - ID de la couche
     */
    LayerManager$3.toggleLayer = function (layerId) {
        const state = getState$6();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] toggleLayer: couche introuvable :", layerId);
            return;
        }

        // Obtenir l'état actuel via le gestionnaire de visibilité
        const VisibilityManager = _g$t.GeoLeaf && _g$t.GeoLeaf._LayerVisibilityManager;
        if (!VisibilityManager) {
            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
            return;
        }

        const visState = VisibilityManager.getVisibilityState(layerId);
        const currentlyVisible = visState ? visState.current : layerData.visible;

        // Toggle
        if (currentlyVisible) {
            LayerManager$3.hideLayer(layerId);
        } else {
            LayerManager$3.showLayer(layerId);
        }
    };

    /**
     * Met à jour la visibilité des couches en fonction de layerScale du style actif.
     * Respecte les préférences utilisateur (désactivation manuelle ou par thème).
     * Utilise le gestionnaire de visibilité centralisé avec source 'zoom'.
     * Exécution immédiate pour réactivité pendant le zoom (le debounce LayerManager.refresh évite les saccades d'UI).
     */
    LayerManager$3.updateLayerVisibilityByZoom = function () {
        const state = getState$6();
        const Log = getLog();
        if (!state.map) return;

        const VisibilityManager = _g$t.GeoLeaf && _g$t.GeoLeaf._LayerVisibilityManager;
        if (!VisibilityManager) {
            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
            return;
        }

        const currentScale = (ScaleUtils$1 && typeof ScaleUtils$1.calculateMapScale === "function")
            ? ScaleUtils$1.calculateMapScale(state.map, { logger: Log })
            : 0;

        const normalizeScaleValue = (value) => {
            if (typeof value !== "number") return null;
            return value <= 0 ? null : value;
        };

        state.layers.forEach((layerData, layerId) => {
            const config = layerData.config;
            if (!config) return;

            const hasCurrentStyle = !!layerData.currentStyle;
            const styleScale = hasCurrentStyle ? layerData.currentStyle.layerScale : null;
            if (!styleScale && hasCurrentStyle) {
                if (Log && typeof Log.warn === "function") {
                    Log.warn(`[GeoLeaf.GeoJSON] layerScale manquant pour ${layerId}, couche laissée visible par défaut`);
                }
            }

            const minScale = normalizeScaleValue(styleScale && styleScale.minScale);
            const maxScale = normalizeScaleValue(styleScale && styleScale.maxScale);

            const shouldBeVisibleByScale = (ScaleUtils$1 && typeof ScaleUtils$1.isScaleInRange === "function")
                ? ScaleUtils$1.isScaleInRange(currentScale, minScale, maxScale, Log)
                : true;

            // Base visibility: user override > theme intent > config default
            const meta = layerData._visibility;
            let baseVisible;
            if (meta && meta.userOverride) {
                // IMPORTANT: Pour userOverride, utiliser logicalState (état bouton), pas current (état zoom)
                baseVisible = meta.logicalState;
            } else if (meta && meta.themeOverride) {
                baseVisible = meta.themeDesired;
            } else {
                // visibility.active parameter is deprecated - now managed by layerScale in style files
                baseVisible = true;
            }

            // RÈGLE CRITIQUE :
            // - L'AFFICHAGE sur la carte RESPECTE TOUJOURS les seuils de zoom
            // - Le BOUTON (via logicalState) reste indépendant du zoom
            // - Utilisateur voit : bouton ON, mais couche cachée si hors zoom
            const shouldBeVisible = baseVisible && shouldBeVisibleByScale;

            VisibilityManager.setVisibility(
                layerId,
                shouldBeVisible,
                VisibilityManager.VisibilitySource.ZOOM
            );
        });
    };

    /**
     * Émet un événement de changement de visibilité.
     *
     * @param {string} layerId
     * @param {boolean} visible
     * @private
     */
    LayerManager$3._fireLayerVisibilityEvent = function (layerId, visible) {
        const state = getState$6();
        if (!state.map) return;

        try {
            state.map.fire("geoleaf:geojson:visibility-changed", {
                layerId: layerId,
                visible: visible
            });
        } catch (e) {
            // Silencieux
        }
    };

    /**
     * GeoLeaf GeoJSON - Hatch Pattern Utilities
     * SVG hatch pattern creation and application for polygon fills.
     * Extracted from layer-manager/style.js (Phase 8.2.1)
     *
     * @module geojson/layer-manager/hatch-pattern
     */

    /**
     * Crée un pattern SVG pour le hachurage.
     * Retourne l'ID (string) du pattern, à passer à `_applyHatchToLayer`.
     * Les patterns sont réellement injectés dans le DOM dans `_applyHatchToLayer`.
     *
     * @param {string} layerId - ID de la couche (pour l'unicité du pattern)
     * @param {Object} hatchConfig - Configuration du hachurage
     * @returns {string|null} patternId, ou null si hachurage désactivé
     */
    function _createHatchPattern(layerId, hatchConfig) {
        if (!hatchConfig || !hatchConfig.enabled) {
            return null;
        }

        // Créer un ID unique basé sur les paramètres du hatch
        const type = hatchConfig.type || 'diagonal';
        const angle = hatchConfig.angleDeg || 0;
        const spacing = hatchConfig.spacingPx || 10;
        const strokeColor = (hatchConfig.stroke?.color || '#000000').replace('#', '');
        const strokeWidth = hatchConfig.stroke?.widthPx || 1;
        const strokeOpacity = hatchConfig.stroke?.opacity || 1;

        // Hash des paramètres pour créer un ID unique
        const configHash = `${type}-${angle}-${spacing}-${strokeColor}-${strokeWidth}-${strokeOpacity}`;
        const patternId = `hatch-${layerId}-${configHash}`;

        // Si le pattern existe déjà, le réutiliser
        const existingPattern = document.getElementById(patternId);
        if (existingPattern) {
            return patternId;
        }

        // Créer le pattern SVG
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', patternId);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('width', spacing);
        pattern.setAttribute('height', spacing);

        // Créer les lignes selon le type
        if (type === 'dot') {
            // Pattern de points (stipple)
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', spacing / 2);
            circle.setAttribute('cy', spacing / 2);
            circle.setAttribute('r', Math.max(0.5, strokeWidth / 2));
            circle.setAttribute('fill', `#${strokeColor}`);
            circle.setAttribute('fill-opacity', strokeOpacity);
            pattern.appendChild(circle);
        } else if (type === 'cross') {
            // Croix (horizontal + vertical)
            const lineH = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineH.setAttribute('x1', '0');
            lineH.setAttribute('y1', spacing / 2);
            lineH.setAttribute('x2', spacing);
            lineH.setAttribute('y2', spacing / 2);
            lineH.setAttribute('stroke', `#${strokeColor}`);
            lineH.setAttribute('stroke-width', strokeWidth);
            lineH.setAttribute('stroke-opacity', strokeOpacity);
            pattern.appendChild(lineH);

            const lineV = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineV.setAttribute('x1', spacing / 2);
            lineV.setAttribute('y1', '0');
            lineV.setAttribute('x2', spacing / 2);
            lineV.setAttribute('y2', spacing);
            lineV.setAttribute('stroke', `#${strokeColor}`);
            lineV.setAttribute('stroke-width', strokeWidth);
            lineV.setAttribute('stroke-opacity', strokeOpacity);
            pattern.appendChild(lineV);
        } else if (type === 'x') {
            // Croix diagonale (45° + 135°)
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', '0');
            line1.setAttribute('y1', '0');
            line1.setAttribute('x2', spacing);
            line1.setAttribute('y2', spacing);
            line1.setAttribute('stroke', `#${strokeColor}`);
            line1.setAttribute('stroke-width', strokeWidth);
            line1.setAttribute('stroke-opacity', strokeOpacity);
            pattern.appendChild(line1);

            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', spacing);
            line2.setAttribute('y1', '0');
            line2.setAttribute('x2', '0');
            line2.setAttribute('y2', spacing);
            line2.setAttribute('stroke', `#${strokeColor}`);
            line2.setAttribute('stroke-width', strokeWidth);
            line2.setAttribute('stroke-opacity', strokeOpacity);
            pattern.appendChild(line2);
        } else {
            // Simple ligne (diagonal, horizontal, vertical)
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

            if (type === 'horizontal' || angle === 0) {
                line.setAttribute('x1', '0');
                line.setAttribute('y1', spacing / 2);
                line.setAttribute('x2', spacing);
                line.setAttribute('y2', spacing / 2);
            } else if (type === 'vertical' || angle === 90) {
                line.setAttribute('x1', spacing / 2);
                line.setAttribute('y1', '0');
                line.setAttribute('x2', spacing / 2);
                line.setAttribute('y2', spacing);
            } else {
                // Diagonal avec angle - créer une vraie diagonale
                line.setAttribute('x1', '0');
                line.setAttribute('y1', '0');
                line.setAttribute('x2', spacing);
                line.setAttribute('y2', spacing);
                // Appliquer la rotation depuis le centre du pattern
                if (angle != null && angle !== 45) {
                    const centerX = spacing / 2;
                    const centerY = spacing / 2;
                    pattern.setAttribute('patternTransform', `rotate(${angle} ${centerX} ${centerY})`);
                }
            }

            line.setAttribute('stroke', `#${strokeColor}`);
            line.setAttribute('stroke-width', strokeWidth);
            line.setAttribute('stroke-opacity', strokeOpacity);
            pattern.appendChild(line);
        }

        // Retourner juste l'ID du pattern.
        // Les patterns seront injectés dans le SVG Leaflet dans _applyHatchToLayer.
        return patternId;
    }

    /**
     * Trouve l'élément SVG contenant les paths d'un layer Leaflet.
     * Les layers sur des panes custom (geoleaf-layer-XX) ont leur propre SVG.
     *
     * @param {L.Layer} layer - Layer Leaflet
     * @returns {SVGSVGElement|null}
     */
    function _findLayerSvg(layer) {
        // 1. Chercher via le path du layer lui-même
        if (layer._path && layer._path.ownerSVGElement) {
            return layer._path.ownerSVGElement;
        }

        // 2. Pour les groupes, chercher via le premier sublayer avec un path
        if (typeof layer.eachLayer === 'function') {
            let found = null;
            layer.eachLayer(sublayer => {
                if (!found && sublayer._path && sublayer._path.ownerSVGElement) {
                    found = sublayer._path.ownerSVGElement;
                }
            });
            if (found) return found;
        }

        // 3. Chercher via le renderer du layer (Leaflet stocke le renderer)
        const renderer = layer._renderer || layer._map?._renderer;
        if (renderer && renderer._container && renderer._container.tagName === 'svg') {
            return renderer._container;
        }

        // 4. Fallback: chercher dans tous les panes (pas seulement overlay-pane)
        const svgs = document.querySelectorAll('.leaflet-pane svg');
        if (svgs.length === 1) return svgs[0];

        // 5. Dernier fallback: overlay-pane
        return document.querySelector('.leaflet-overlay-pane svg');
    }

    /**
     * Applique le hachurage SVG à un layer Leaflet.
     * Injecte le pattern dans le `<defs>` du SVG Leaflet et pose un MutationObserver
     * pour que le `fill` reste sur le pattern même après un re-render Leaflet.
     *
     * @param {L.Layer} layer - Layer Leaflet
     * @param {string} patternId - ID du pattern SVG
     * @param {Object} hatchConfig - Configuration du hachurage
     */
    function _applyHatchToLayer(layer, patternId, hatchConfig) {
        if (!layer || !patternId) return;

        // Trouver le SVG correct pour ce layer (pane custom ou overlay-pane)
        let mapSvg = _findLayerSvg(layer);
        if (!mapSvg) {
            // Retry avec délai si SVG n'existe pas encore
            const retryCount = 5;
            const retryDelay = 100; // ms
            let attempts = 0;
            const tryApplyHatch = () => {
                mapSvg = _findLayerSvg(layer);
                if (mapSvg) {
                    _applyHatchToLayer(layer, patternId, hatchConfig);
                    return;
                }
                attempts++;
                if (attempts < retryCount) {
                    setTimeout(tryApplyHatch, retryDelay);
                }
            };
            setTimeout(tryApplyHatch, retryDelay);
            return;
        }

        // Vérifier si le pattern existe déjà
        let pattern = mapSvg.querySelector(`#${patternId}`);
        if (!pattern && hatchConfig) {
            // Créer le pattern maintenant
            const spacing = hatchConfig.spacingPx || 10;
            const type = hatchConfig.type || 'diagonal';
            const angle = hatchConfig.angleDeg;
            const strokeColor = hatchConfig.stroke?.color || '#000000';
            const strokeWidth = hatchConfig.stroke?.widthPx || 1;
            const strokeOpacity = hatchConfig.stroke?.opacity || 1;

            // Assurer que la couleur a toujours le # pour les attributs SVG
            const colorWithHash = strokeColor.startsWith('#') ? strokeColor : `#${strokeColor}`;

            pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.setAttribute('id', patternId);
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            pattern.setAttribute('width', spacing);
            pattern.setAttribute('height', spacing);

            // Créer le contenu selon le type
            if (type === 'dot') {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', spacing / 2);
                circle.setAttribute('cy', spacing / 2);
                // Rayon proportionnel au spacing:
                // Plus petit spacing (plus dense) = points plus petits
                // Plus grand spacing (moins dense) = points plus gros pour compenser
                // spacing 6px → r=0.42, spacing 12px → r=0.84
                circle.setAttribute('r', Math.max(0.3, spacing * 0.07));
                circle.setAttribute('fill', colorWithHash);
                circle.setAttribute('fill-opacity', strokeOpacity);
                pattern.appendChild(circle);
            } else if (type === 'diagonal') {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', '0');
                line.setAttribute('x2', spacing);
                line.setAttribute('y2', spacing);
                line.setAttribute('stroke', colorWithHash);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-opacity', strokeOpacity);
                if (angle != null && angle !== 45) {
                    const centerX = spacing / 2;
                    const centerY = spacing / 2;
                    pattern.setAttribute('patternTransform', `rotate(${angle} ${centerX} ${centerY})`);
                }
                pattern.appendChild(line);
            } else if (type === 'cross') {
                // Ligne horizontale
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', '0');
                hLine.setAttribute('y1', spacing / 2);
                hLine.setAttribute('x2', spacing);
                hLine.setAttribute('y2', spacing / 2);
                hLine.setAttribute('stroke', colorWithHash);
                hLine.setAttribute('stroke-width', strokeWidth);
                hLine.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(hLine);
                // Ligne verticale
                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', spacing / 2);
                vLine.setAttribute('y1', '0');
                vLine.setAttribute('x2', spacing / 2);
                vLine.setAttribute('y2', spacing);
                vLine.setAttribute('stroke', colorWithHash);
                vLine.setAttribute('stroke-width', strokeWidth);
                vLine.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(vLine);
            } else if (type === 'x') {
                // Diagonale principal (TL to BR)
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', '0');
                line1.setAttribute('y1', '0');
                line1.setAttribute('x2', spacing);
                line1.setAttribute('y2', spacing);
                line1.setAttribute('stroke', colorWithHash);
                line1.setAttribute('stroke-width', strokeWidth);
                line1.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(line1);
                // Diagonale secondaire (TR to BL)
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', spacing);
                line2.setAttribute('y1', '0');
                line2.setAttribute('x2', '0');
                line2.setAttribute('y2', spacing);
                line2.setAttribute('stroke', colorWithHash);
                line2.setAttribute('stroke-width', strokeWidth);
                line2.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(line2);
            } else if (type === 'horizontal') {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', spacing / 2);
                line.setAttribute('x2', spacing);
                line.setAttribute('y2', spacing / 2);
                line.setAttribute('stroke', colorWithHash);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(line);
            } else if (type === 'vertical') {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', spacing / 2);
                line.setAttribute('y1', '0');
                line.setAttribute('x2', spacing / 2);
                line.setAttribute('y2', spacing);
                line.setAttribute('stroke', colorWithHash);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-opacity', strokeOpacity);
                pattern.appendChild(line);
            }

            // Ajouter au defs du SVG
            let defs = mapSvg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                mapSvg.insertBefore(defs, mapSvg.firstChild);
            }
            defs.appendChild(pattern);
        }

        // Fonction pour appliquer le pattern à un élément path
        const applyToPath = (path) => {
            if (path && path.setAttribute) {
                const fillUrl = `url(#${patternId})`;
                const currentFill = path.getAttribute('fill');

                // N'appliquer que si différent (évite boucle infinie)
                if (currentFill !== fillUrl) {
                    path.setAttribute('fill', fillUrl);
                }

                // S'assurer que l'opacité de remplissage est visible pour les patterns
                if (hatchConfig && hatchConfig.renderMode === 'pattern_only') {
                    // Toujours forcer fill-opacity=1 quand le pattern est appliqué.
                    // C'est ici (et uniquement ici) qu'on rend le fill visible,
                    // car le pattern SVG est déjà injecté — pas de flash blanc.
                    path.setAttribute('fill-opacity', '1');
                }

                // Observer les changements pour réappliquer le pattern
                if (!path._hatchObserver) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'fill') {
                                const newFill = path.getAttribute('fill');
                                // Ne réappliquer que si vraiment différent
                                if (newFill !== fillUrl && !newFill.includes(patternId)) {
                                    path.setAttribute('fill', fillUrl);
                                }
                            }
                        });
                    });
                    observer.observe(path, { attributes: true, attributeFilter: ['fill'] });
                    path._hatchObserver = observer;
                }
            }
        };

        // Pour les layers individuels
        if (layer._path) {
            applyToPath(layer._path);
        }

        // Pour les groupes de layers (L.geoJSON, FeatureGroup, MultiPolygon)
        // Récursif : gère les FeatureGroups imbriqués (ex: MultiPolygon dans L.geoJSON)
        if (typeof layer.eachLayer === 'function') {
            layer.eachLayer(sublayer => {
                if (sublayer._path) {
                    applyToPath(sublayer._path);
                } else if (typeof sublayer.eachLayer === 'function') {
                    // Recurse into nested groups (MultiPolygon → individual Polygons)
                    sublayer.eachLayer(sub => {
                        if (sub._path) {
                            applyToPath(sub._path);
                        }
                    });
                }
            });
        }

        // Phase 1 fix L1: disconnect MutationObservers on layer remove to prevent memory leaks
        if (!layer._disconnectHatchObservers) {
            layer._disconnectHatchObservers = function() {
                const disconnectPath = (p) => {
                    if (p._hatchObserver) {
                        p._hatchObserver.disconnect();
                        p._hatchObserver = null;
                    }
                };
                if (this._path) disconnectPath(this._path);
                if (typeof this.eachLayer === 'function') {
                    this.eachLayer(sub => {
                        if (sub._path) disconnectPath(sub._path);
                        if (typeof sub.eachLayer === 'function') {
                            sub.eachLayer(inner => {
                                if (inner._path) disconnectPath(inner._path);
                            });
                        }
                    });
                }
            };
            layer.on('remove', function() { this._disconnectHatchObservers(); });
        }
    }

    /**
     * GeoLeaf GeoJSON Layer Manager - Style
     * Style normalization, hatch patterns, style application
     *
     * @module geojson/layer-manager/style
     */

    const _g$s = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$5 = () => GeoJSONShared.state;

    const LayerManager$2 = {};

    /**
     * Normalise le format de style vers le format Leaflet
     * Phase 4 dedup: delegates base fill/stroke to shared normalizeStyleToLeaflet,
     * then layers on hatch patterns and casing extensions.
     * @private
     * @param {Object} style - Style source (format imbriqué ou plat)
     * @param {string} layerId - ID de la couche (pour les patterns SVG)
     * @returns {Object} - Style normalisé au format Leaflet
     */
    function _normalizeStyleToLeaflet(style, layerId) {
        if (!style || typeof style !== 'object') {
            return {};
        }

        // Base normalization (fill/stroke → flat Leaflet props)
        const normalized = normalizeStyleToLeaflet(style);

        // ── Extended: hatch pattern_only override ──
        if (style.fill || style.stroke) {
            if (style.hatch && style.hatch.enabled && style.hatch.renderMode === 'pattern_only') {
                normalized.fillColor = 'transparent';
                normalized.fillOpacity = 1;
            }

            // ── Extended: Casing (bordure/contour pour polylines) ──
            if (style.casing && style.casing.enabled) {
                normalized._casing = {
                    enabled: true,
                    color: style.casing.color || '#000000',
                    opacity: typeof style.casing.opacity === 'number' ? style.casing.opacity : 1.0,
                    weight: typeof style.casing.widthPx === 'number' ? style.casing.widthPx : 1.0,
                    dashArray: style.casing.dashArray || null,
                    lineCap: style.casing.lineCap || null,
                    lineJoin: style.casing.lineJoin || null
                };
            }

            // ── Extended: Hatch normalization + SVG pattern creation ──
            if (style.hatch) {
                normalized.hatch = { ...style.hatch };
                if (style.hatch.stroke) {
                    const hatchStroke = {};
                    if (style.hatch.stroke.color) hatchStroke.color = style.hatch.stroke.color;
                    if (typeof style.hatch.stroke.opacity === 'number') hatchStroke.opacity = style.hatch.stroke.opacity;
                    if (typeof style.hatch.stroke.widthPx === 'number') hatchStroke.widthPx = style.hatch.stroke.widthPx;
                    normalized.hatch.stroke = hatchStroke;
                }

                if (style.hatch.enabled && layerId) {
                    const patternId = _createHatchPattern(layerId, style.hatch);
                    if (patternId) {
                        normalized._hatchPatternId = patternId;
                        if (style.hatch.renderMode === 'pattern_only') {
                            normalized.fillColor = 'transparent';
                            normalized.fillOpacity = 1;
                        }
                    }
                }
            }
        }

        return normalized;
    }

    /**
     * Applique un nouveau style à une couche existante.
     * Utilisé par le module Themes pour changer dynamiquement l'apparence.
     *
     * @param {string} layerId - ID de la couche
     * @param {Object} styleConfig - Configuration du style { style, styleRules }
     * @returns {boolean} - true si le style a été appliqué avec succès
     */
    LayerManager$2.setLayerStyle = function (layerId, styleConfig) {
        const state = getState$5();
        const Log = getLog();
        const layerData = state.layers.get(layerId);

        if (!layerData) {
            Log.warn("[GeoLeaf.GeoJSON] setLayerStyle: couche introuvable :", layerId);
            return false;
        }

        // Sprint 8: VT layers — delegate to VectorTiles module
        if (layerData.isVectorTile && _g$s.GeoLeaf && _g$s.GeoLeaf._VectorTiles) {
            _g$s.GeoLeaf._VectorTiles.updateLayerStyle(layerId, styleConfig);
            return true;
        }

        const leafletLayer = layerData.layer;
        if (!leafletLayer || typeof leafletLayer.setStyle !== 'function') {
            Log.warn("[GeoLeaf.GeoJSON] setLayerStyle: couche sans méthode setStyle :", layerId);
            return false;
        }

        // Préparer le style par défaut (ne pas utiliser defaultStyle qui peut contenir les anciennes valeurs)
        const baseStyle = {
            color: '#999999',
            weight: 2,
            opacity: 0.9,
            fillColor: '#cccccc',
            fillOpacity: 0.15
        };

        // Normaliser le style (defaultStyle ou style) vers format Leaflet
        const rawStyle = styleConfig.defaultStyle || styleConfig.style || {};
        const normalizedStyle = _normalizeStyleToLeaflet(rawStyle, layerId);
        const defaultStyle = Object.assign({}, baseStyle, normalizedStyle);

        // Préparer les styleRules
        const styleRules = Array.isArray(styleConfig.styleRules) ? styleConfig.styleRules : [];

        // Fonction de style dynamique
        const styleFn = (feature) => {
            // 1. Commencer avec le style par défaut
            let finalStyle = Object.assign({}, defaultStyle);

            // 2. Appliquer les styleRules (première règle correspondante gagne)
            if (styleRules.length > 0 && _g$s.GeoLeaf && _g$s.GeoLeaf._GeoJSONStyleResolver) {
                    const matchedStyle = _g$s.GeoLeaf._GeoJSONStyleResolver.evaluateStyleRules(feature, styleRules);
                if (matchedStyle) {
                    // Normaliser le style de la règle vers format Leaflet
                    const normalizedRuleStyle = _normalizeStyleToLeaflet(matchedStyle, layerId);
                    finalStyle = Object.assign({}, finalStyle, normalizedRuleStyle);
                }
            }

            // 3. NE PAS appliquer properties.style ou properties.color pour permettre aux règles de s'appliquer
            // Commenté car cela écrase les règles de style
            // const featureStyle = feature && feature.properties && feature.properties.style
            //     ? feature.properties.style
            //     : null;
            // if (featureStyle) {
            //     finalStyle = Object.assign({}, finalStyle, featureStyle);
            // }

            return finalStyle;
        };

        // Appliquer le style à toutes les features de la couche
        try {
            let styled = 0;
            let markersRecreated = 0;
            const layersToRecreate = [];

            // Première passe : identifier et styler ou marquer pour recréation
            leafletLayer.eachLayer(function(layer) {
                if (!layer.feature) {
                    return;
                }

                const style = styleFn(layer.feature);

                // Cas 1: Layers avec setStyle (Path, CircleMarker, Polyline, etc.)
                if (layer.setStyle && typeof layer.setStyle === 'function') {
                    layer.setStyle(style);

                    // Préserver/restaurer l'état interactive depuis la config de la couche.
                    // setStyle() de Leaflet ne touche pas 'interactive', mais certaines
                    // recréations de path peuvent le perdre.
                    const isInteractive = typeof layerData.config.interactiveShape === 'boolean'
                        ? layerData.config.interactiveShape
                        : (_g$s.GeoLeaf && _g$s.GeoLeaf.Config && _g$s.GeoLeaf.Config.get
                            ? _g$s.GeoLeaf.Config.get('ui.interactiveShapes', false)
                            : false);
                    if (layer.options) {
                        layer.options.interactive = isInteractive;
                    }
                    // S'assurer que le path SVG a le bon pointer-events
                    if (layer._path) {
                        layer._path.style.pointerEvents = isInteractive ? 'auto' : 'none';
                    }
                    // Pour les layers Canvas : forcer Leaflet à recalculer le
                    // hit-area en cas de changement d'interactive. Canvas n'a pas
                    // de _path mais utilise _renderer pour le hit-testing.
                    if (!layer._path && layer._renderer && typeof layer.redraw === 'function') {
                        layer.redraw();
                    }

                    styled++;

                    // Gérer le casing (bordure pour polylines)
                    if (style._casing && style._casing.enabled && layer instanceof _g$s.L.Polyline && !(layer instanceof _g$s.L.Polygon)) {
                        const casingConfig = style._casing;

                        // Créer ou mettre à jour la polyline de casing (dessous, plus large)
                        if (!layer._casingLayer) {
                            // Créer une nouvelle couche de casing
                            const casingStyle = {
                                color: casingConfig.color,
                                opacity: casingConfig.opacity,
                                weight: casingConfig.weight,
                                dashArray: casingConfig.dashArray,
                                lineCap: casingConfig.lineCap || 'butt',
                                lineJoin: casingConfig.lineJoin || 'miter',
                                fill: false
                            };

                            layer._casingLayer = _g$s.L.polyline(layer.getLatLngs(), casingStyle);
                            // Ajouter la couche de casing au même parent (group ou map)
                            if (leafletLayer && leafletLayer.addLayer) {
                                leafletLayer.addLayer(layer._casingLayer);
                            } else if (layer._map) {
                                layer._map.addLayer(layer._casingLayer);
                            }
                            // Mettre la couche de casing derrière la couche principale
                            if (layer._casingLayer.setZIndex) {
                                layer._casingLayer.setZIndex((layer.options.zIndex || 0) - 1);
                            }
                        } else {
                            // Mettre à jour le style existant
                            layer._casingLayer.setStyle({
                                color: casingConfig.color,
                                opacity: casingConfig.opacity,
                                weight: casingConfig.weight,
                                dashArray: casingConfig.dashArray,
                                lineCap: casingConfig.lineCap || 'butt',
                                lineJoin: casingConfig.lineJoin || 'miter'
                            });
                        }
                    } else if (!style._casing || !style._casing.enabled) {
                        // Supprimer la couche de casing si elle existe mais n'est plus nécessaire
                        if (layer._casingLayer && leafletLayer && leafletLayer.removeLayer) {
                            leafletLayer.removeLayer(layer._casingLayer);
                            layer._casingLayer = null;
                        }
                    }

                    // Appliquer le hachurage si présent dans ce style
                    if (style._hatchPatternId && style.hatch) {
                        const patternId = style._hatchPatternId;
                        const hatchConfig = style.hatch;

                        // Appliquer immédiatement : fonctionne pour les layers avec _path
                        // ET pour les FeatureGroups (MultiPolygon) via eachLayer récursif.
                        setTimeout(() => {
                            _applyHatchToLayer(layer, patternId, hatchConfig);
                        }, 0);

                        // Ajouter aussi un listener pour quand le layer est ajouté/re-ajouté
                        if (!layer._hatchPatternId || layer._hatchPatternId !== patternId) {
                            layer._hatchPatternId = patternId;

                            // Supprimer l'ancien listener s'il existe
                            if (layer._hatchListener) {
                                layer.off('add', layer._hatchListener);
                            }

                            // Créer le nouveau listener
                            // Ne PAS garder 'if (this._path)' : pour les FeatureGroups
                            // (MultiPolygon), _path est null mais _applyHatchToLayer
                            // gère les groupes via eachLayer.
                            layer._hatchListener = function() {
                                _applyHatchToLayer(this, patternId, hatchConfig);
                            };

                            layer.on('add', layer._hatchListener);

                            // Phase 1 fix L2: cleanup hatch listener on remove to prevent leaks
                            if (!layer._hatchCleanupBound) {
                                layer._hatchCleanupBound = true;
                                layer.on('remove', function() {
                                    if (this._hatchListener) {
                                        this.off('add', this._hatchListener);
                                        this._hatchListener = null;
                                    }
                                });
                            }
                        }
                    }
                }
                // Cas 2: Markers avec icônes - besoin de recréer avec nouvelle icône
                else if (_g$s.L && layer instanceof _g$s.L.Marker) {
                    layersToRecreate.push({ layer, feature: layer.feature, style });
                } else ;
            });

            // Seconde passe : recréer les markers avec les nouvelles couleurs
            if (layersToRecreate.length > 0) {
                const POIMarkers = _g$s.GeoLeaf && _g$s.GeoLeaf._POIMarkers;

                layersToRecreate.forEach(({ layer, feature, style }) => {
                    const latlng = layer.getLatLng();

                    // Utiliser le système POI pour créer une nouvelle icône colorée
                    if (POIMarkers && typeof POIMarkers.buildMarkerIcon === 'function') {
                        const poiData = {
                            ...feature.properties,
                            latlng: [latlng.lat, latlng.lng],
                            attributes: feature.properties.attributes || {},
                            _layerConfig: { style: style } // Passer le style pour resolveCategoryColors
                        };

                        let displayConfig = {};
                        if (typeof POIMarkers.resolveCategoryDisplay === 'function') {
                            displayConfig = POIMarkers.resolveCategoryDisplay(poiData);
                        }

                        // Override avec tous les paramètres du style
                        if (style.fillColor) {
                            displayConfig.colorFill = style.fillColor;
                        }
                        if (style.color) {
                            displayConfig.colorStroke = style.color;
                        }
                        if (typeof style.radius === 'number') {
                            displayConfig.radius = style.radius;
                        }
                        if (typeof style.weight === 'number') {
                            displayConfig.weight = style.weight;
                        }
                        if (typeof style.fillOpacity === 'number') {
                            displayConfig.fillOpacity = style.fillOpacity;
                        }
                        if (typeof style.opacity === 'number') {
                            displayConfig.opacity = style.opacity;
                        }

                        const newIcon = POIMarkers.buildMarkerIcon(displayConfig);
                        layer.setIcon(newIcon);
                        markersRecreated++;
                    } else {
                        // Fallback: remplacer par un CircleMarker
                        const newMarker = _g$s.L.circleMarker(latlng, style);
                        newMarker.feature = feature;
                        leafletLayer.removeLayer(layer);
                        leafletLayer.addLayer(newMarker);
                        markersRecreated++;
                    }
                });
            }

            Log.debug(`[GeoLeaf.GeoJSON] Style appliqué: ${styled + markersRecreated} features (${styled} setStyle, ${markersRecreated} markers)`);

            // Appliquer le hachurage global uniquement si pas de styleRules avec hatch
            const hasHatchInRules = styleRules.some(rule => rule.style?.hatch?.enabled);

            if (defaultStyle._hatchPatternId && !hasHatchInRules) {
                const patternId = defaultStyle._hatchPatternId;
                const hatchConfig = defaultStyle.hatch;

                // Appliquer immédiatement (avec hatchConfig pour fill-opacity)
                _applyHatchToLayer(leafletLayer, patternId, hatchConfig);

                // Log résumé au lieu de logs individuels
                Log.debug(`[GeoLeaf.GeoJSON] Hachures appliquées: pattern=${patternId}, features=${styled}`);

                // Supprimer les anciens listeners pour éviter les doublons
                if (layerData._hatchListeners) {
                    leafletLayer.off('add', layerData._hatchListeners.onAdd);
                    if (_g$s.L && _g$s.L.DomEvent) {
                        leafletLayer.eachLayer(layer => {
                            if (layer._path) {
                                layer.off('add', layerData._hatchListeners.onLayerAdd);
                            }
                        });
                    }
                }

                // Créer les listeners pour réappliquer le hachurage après les redraws
                const onAdd = () => {
                    setTimeout(() => _applyHatchToLayer(leafletLayer, patternId, hatchConfig), 0);
                };

                const onLayerAdd = function() {
                    _applyHatchToLayer(this, patternId, hatchConfig);
                };

                // Ajouter les listeners
                leafletLayer.on('add', onAdd);
                leafletLayer.eachLayer(layer => {
                    if (layer._path) {
                        layer.on('add', onLayerAdd);
                    }
                });

                // Stocker les listeners pour nettoyage futur
                layerData._hatchListeners = { onAdd, onLayerAdd };
                layerData._hatchPatternId = patternId;
            }

            // Mettre à jour la config stockée pour que les futures évaluations utilisent le nouveau style
            layerData.config = Object.assign({}, layerData.config, {
                style: styleConfig.defaultStyle || styleConfig.style,
                styleRules: styleRules
            });

            // Stocker currentStyle pour les labels
            layerData.currentStyle = styleConfig;

            // Mettre à jour l'état du bouton des labels immédiatement
            if (_g$s.GeoLeaf && _g$s.GeoLeaf._LabelButtonManager) {
                _g$s.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
            }

            // Réévaluer la visibilité après application du style (layerScale)
            if (_g$s.GeoLeaf && _g$s.GeoLeaf._GeoJSONLayerManager && typeof _g$s.GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom === "function") {
                _g$s.GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom();
            }

            Log.debug("[GeoLeaf.GeoJSON] Style appliqué avec succès :", layerId);
            return true;
        } catch (err) {
            Log.error("[GeoLeaf.GeoJSON] Erreur setLayerStyle :", layerId, err.message);
            return false;
        }
    };

    /**
     * GeoLeaf GeoJSON Layer Manager - Integration
     * Layer Manager UI registration, legend loading, populate with all configs
     *
     * @module geojson/layer-manager/integration
     */

    const _g$r = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$4 = () => GeoJSONShared.state;

    const LayerManager$1 = {};

    /**
     * Enregistre les couches dans le module LayerManager.
     */
    LayerManager$1.registerWithLayerManager = function () {
        const state = getState$4();
        const Log = getLog();
        const LMgr = _g$r.GeoLeaf && _g$r.GeoLeaf.LayerManager;

        Log.info(`[GeoLeaf.GeoJSON] registerWithLayerManager() appelé avec ${state.layers.size} couche(s)`);

        if (!LMgr || typeof LMgr._registerGeoJsonLayer !== "function") {
            Log.warn("[GeoLeaf.GeoJSON] Module LayerManager non disponible, pas d'intégration gestionnaire de couches");
            return;
        }

        // Grouper les layers par idSection
        const sectionMap = new Map();

        state.layers.forEach((layerData, id) => {
            // Log pour debug - VOIR TOUTES LES COUCHES
            // Utiliser layerManagerId défini dans layer.json
            const sectionId = layerData.config.layerManagerId || "geojson-default";

            if (!sectionMap.has(sectionId)) {
                sectionMap.set(sectionId, {
                    id: sectionId,
                    order: 99,
                    items: []
                });
            }

            const type = LayerManager$1.detectLayerType(layerData.layer);
            let legendType = "fill";
            if (type === "poi") legendType = "circle";
            else if (type === "route") legendType = "line";
            else if (type === "area") legendType = "fill";

            let color = "#3388ff";
            if (layerData.config.style) {
                color = layerData.config.style.fillColor || layerData.config.style.color || color;
            } else if (layerData.config.pointStyle) {
                color = layerData.config.pointStyle.fillColor || color;
            }

            // Détecter si la couche a des labels (dans la config OU dans le style courant)
            let hasLabels = false;
            let labelsConfig = null;

            // Vérifier d'abord dans la config de la couche
            if (layerData.config.labels && layerData.config.labels.enabled) {
                hasLabels = true;
                labelsConfig = layerData.config.labels;
            }

            // Vérifier ensuite dans le style actuel (currentStyle)
            if (!hasLabels && layerData.currentStyle && layerData.currentStyle.label && layerData.currentStyle.label.enabled) {
                hasLabels = true;
                // Créer une config de labels minimale basée sur le style
                labelsConfig = { enabled: true };
            }

            // Log pour TOUTES les couches pour comprendre le problème
            if (Log) {
                Log.info(`[GeoJSON LayerManager] 🔍 Préparation item ${id}:`, {
                    hasConfig: !!layerData.config,
                    hasStyles: !!(layerData.config && layerData.config.styles),
                    styles: layerData.config ? layerData.config.styles : 'NO CONFIG',
                    configKeys: layerData.config ? Object.keys(layerData.config).sort() : []
                });
            }

            sectionMap.get(sectionId).items.push({
                id: id,
                label: layerData.label,
                type: legendType,
                color: color,
                visible: layerData.visible,
                toggleable: true,
                order: 0,
                zIndex: layerData.config.zIndex || 0,
                themes: layerData.config.themes || null,
                labels: hasLabels ? labelsConfig : null,
                styles: layerData.config.styles || null
            });
        });

        // Ajouter chaque section au gestionnaire de couches
        sectionMap.forEach((section) => {
            // Trier les items par zIndex décroissant (zIndex élevé = en haut = affiché au-dessus)
            section.items.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));

            // Enregistrer chaque couche dans le LayerManager
            section.items.forEach((item) => {
                Log.debug(`[GeoLeaf.GeoJSON] Enregistrement couche "${item.id}" dans section "${section.id}"`);
                LMgr._registerGeoJsonLayer(item.id, {
                    layerManagerId: section.id,
                    label: item.label,
                    themes: item.themes,
                    styles: item.styles,
                    labels: item.labels
                });
            });

            Log.debug("[GeoLeaf.GeoJSON] Section couche '" + section.id + "' créée avec " + section.items.length + " couche(s)");
        });
    };

    /**
     * Charge la légende d'une couche si disponible
     * @param {string} layerId - ID de la couche
     * @param {Object} layerData - Données de la couche
     * @private
     */
    LayerManager$1._loadLayerLegend = function (layerId, layerData) {

        const config = layerData.config || {};

        // Nouveau flux : générer la légende depuis le style JSON
        if (_g$r.GeoLeaf && _g$r.GeoLeaf.Legend && typeof _g$r.GeoLeaf.Legend.loadLayerLegend === "function") {
            // Déterminer le style courant
            const styleSelector = _g$r.GeoLeaf._LayerManagerStyleSelector;
            let styleId = null;

            if (styleSelector && typeof styleSelector.getCurrentStyle === "function") {
                styleId = styleSelector.getCurrentStyle(layerId) || null;
            }

            // Fallback depuis metadata éventuelle
            if (!styleId && layerData.currentStyleMetadata && layerData.currentStyleMetadata.id) {
                styleId = layerData.currentStyleMetadata.id;
            }

            // Fallback depuis la config de styles
            if (!styleId && config.styles && Array.isArray(config.styles.available)) {
                const available = config.styles.available;
                // Essayer de trouver l'ID correspondant au fichier default
                const defaultFile = config.styles.default;
                const defaultByFile = defaultFile ? available.find(s => s.file === defaultFile) : null;
                styleId = (defaultByFile && defaultByFile.id) || (available[0] && available[0].id) || "default";
            }

            if (!styleId) {
                styleId = "default";
            }

            _g$r.GeoLeaf.Legend.loadLayerLegend(layerId, styleId, config);
            return;
        }
    };

    /**
     * Peuple le LayerManager avec TOUTES les configurations de couches disponibles.
     * Contrairement à registerWithLayerManager() qui ne montre que les couches chargées (thème actif),
     * cette fonction affiche TOUTES les couches et met à jour l'état coché selon le thème actif.
     *
     * @param {Object} activeThemeConfig - Configuration du thème actif (contient liste des layers visibles)
     * @returns {void}
     */
    LayerManager$1.populateLayerManagerWithAllConfigs = function(activeThemeConfig) {
            // ...logs nettoyés...
        const Log = getLog();
        const LMgr = _g$r.GeoLeaf && _g$r.GeoLeaf.LayerManager;

        if (!LMgr || typeof LMgr._registerGeoJsonLayer !== "function") {
            Log.warn("[GeoLeaf.GeoJSON] populateLayerManagerWithAllConfigs: Module LayerManager non disponible");
            return;
        }

        if (!_g$r.GeoLeaf || !_g$r.GeoLeaf._allLayerConfigs || !Array.isArray(_g$r.GeoLeaf._allLayerConfigs)) {
            Log.warn("[GeoLeaf.GeoJSON] populateLayerManagerWithAllConfigs: GeoLeaf._allLayerConfigs non disponible");
            return;
        }

        Log.info(`[GeoLeaf.GeoJSON] Peuplement LayerManager avec ${_g$r.GeoLeaf._allLayerConfigs.length} configs de couches...`);
        // ...log debug supprimé...

        // Obtenir la liste des couches actives du thème
        // Les layers peuvent être des objets {id, visible, style} ou des strings simples
        let activeThemeLayers = [];
        if (activeThemeConfig && Array.isArray(activeThemeConfig.layers)) {
            activeThemeLayers = activeThemeConfig.layers.map(l => l.id || l);
        }
        Log.debug(`[GeoLeaf.GeoJSON] Couches actives du thème: ${activeThemeLayers.join(', ')}`);

        // Grouper les configs par sectionId (layerManagerId)
        const sectionMap = new Map();

        _g$r.GeoLeaf._allLayerConfigs.forEach(config => {
            const sectionId = config.layerManagerId || "geojson-default";

            if (!sectionMap.has(sectionId)) {
                sectionMap.set(sectionId, {
                    id: sectionId,
                    items: []
                });
            }

            // Déterminer si la couche est active dans le thème courant
            const isActive = activeThemeLayers.includes(config.id);

            // Log pour debug - VOIR CE QUI EST DANS config POUR TOUTES LES COUCHES
            // ...logs supprimés ([GeoJSON LayerManager] config debug)...

            sectionMap.get(sectionId).items.push({
                id: config.id,
                label: config.label,
                layerManagerId: sectionId,
                themes: config.themes || null,
                isActive: isActive,
                zIndex: config.zIndex || 0,
                styles: config.styles || null,
                labels: config.labels || null
            });
        });

        // Enregistrer chaque couche avec le LayerManager
        sectionMap.forEach((section) => {
            // Trier par zIndex décroissant
            section.items.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));

            section.items.forEach((item) => {
                Log.debug(`[GeoLeaf.GeoJSON] Enregistrement couche "${item.id}" dans section "${section.id}" (actif: ${item.isActive})`);
                LMgr._registerGeoJsonLayer(item.id, {
                    layerManagerId: section.id,
                    label: item.label,
                    themes: item.themes,
                    checked: item.isActive,
                    styles: item.styles,
                    labels: item.labels
                });
            });

            Log.debug(`[GeoLeaf.GeoJSON] Section "${section.id}" peuplée avec ${section.items.length} couche(s)`);
        });

        Log.info(`[GeoLeaf.GeoJSON] LayerManager peuplé avec succès`);

        // Mettre à jour l'UI du LayerManager si nécessaire
        if (LMgr._updateUI && typeof LMgr._updateUI === "function") {
            Log.debug("[GeoLeaf.GeoJSON] Appel LayerManager._updateUI()");
            LMgr._updateUI();
        }
    };

    /**
     * GeoLeaf GeoJSON Loader - Config Helpers
     * Accesseurs de configuration normalisée pour popup, tooltip et sidepanel.
     * Utilisé par popup-tooltip.js via l'import ESM de GeoJSONLoader.
     *
     * @module geojson/loader/config-helpers
     */

    const Loader$3 = {};

    /**
     * Récupère la configuration des champs popup d'une couche.
     *
     * @param {Object} def - Définition de la couche (normalisée ou originale)
     * @returns {Array|null} - Array de configurations de champs ou null
     */
    Loader$3.getPopupConfig = function(def) {
        if (!def) return null;

        // Structure normalisée (après passage dans loadProfile)
        if (def.popupFields && Array.isArray(def.popupFields)) {
            return def.popupFields;
        }

        // Structure originale (depuis config JSON)
        if (def.popup && def.popup.fields && Array.isArray(def.popup.fields)) {
            return def.popup.fields;
        }

        return null;
    };

    /**
     * Récupère la configuration des champs tooltip d'une couche.
     *
     * @param {Object} def - Définition de la couche (normalisée ou originale)
     * @returns {Array|null} - Array de configurations de champs ou null
     */
    Loader$3.getTooltipConfig = function(def) {
        if (!def) return null;

        // Structure normalisée (après passage dans loadProfile)
        if (def.tooltipFields && Array.isArray(def.tooltipFields)) {
            return def.tooltipFields;
        }

        // Structure originale (depuis config JSON)
        if (def.tooltip && def.tooltip.fields && Array.isArray(def.tooltip.fields)) {
            return def.tooltip.fields;
        }

        return null;
    };

    /**
     * Récupère la configuration des champs sidepanel d'une couche.
     *
     * @param {Object} def - Définition de la couche (normalisée ou originale)
     * @returns {Array|null} - Array de configurations de champs ou null
     */
    Loader$3.getSidepanelConfig = function(def) {
        if (!def) return null;

        // Structure normalisée (après passage dans loadProfile)
        if (def.sidepanelFields && Array.isArray(def.sidepanelFields)) {
            return def.sidepanelFields;
        }

        // Structure originale (depuis config JSON)
        if (def.sidepanel && def.sidepanel.detailLayout && Array.isArray(def.sidepanel.detailLayout)) {
            return def.sidepanel.detailLayout;
        }

        return null;
    };

    /**
     * GeoLeaf GeoJSON Loader - Data
     * Chargement direct de données GeoJSON (URL ou objet JS)
     *
     * @module geojson/loader/data
     */

    const _g$q = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$3 = () => GeoJSONShared.state;

    const Loader$2 = {};

    /**
     * Charge un fichier GeoJSON via une URL.
     *
     * @param {string} url - URL du fichier GeoJSON.
     * @param {Object} [options] - Options additionnelles, fusionnées avec celles du module.
     * @returns {Promise<L.GeoJSON|null>}
     */
    Loader$2.loadUrl = async function (url, options = {}) {
        const state = getState$3();
        const Log = getLog();

        if (!url) {
            Log.warn("[GeoLeaf.GeoJSON] URL GeoJSON manquante.");
            return state.geoJsonLayer;
        }

        if (!state.map) {
            Log.error("[GeoLeaf.GeoJSON] Module non initialisé. Appelle GeoLeaf.GeoJSON.init() avant loadUrl().");
            return null;
        }

        const mergedOptions = _g$q.GeoLeaf && _g$q.GeoLeaf.Utils && _g$q.GeoLeaf.Utils.mergeOptions
            ? _g$q.GeoLeaf.Utils.mergeOptions(state.options, options)
            : Object.assign({}, state.options, options);

        try {
            // Sprint 3.3: Use unified FetchHelper for GeoJSON loading
            const FetchHelper = _g$q.GeoLeaf && _g$q.GeoLeaf.Utils?.FetchHelper;

            let data;
            if (FetchHelper) {
                data = await FetchHelper.get(url, {
                    timeout: 20000, // GeoJSON files can be large
                    retries: 2
                });
            } else {
                // Fallback to raw fetch
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + " pour " + url);
                }
                data = await response.json();
            }

            _g$q.GeoLeaf && Loader$2.addData(data, mergedOptions);
            return state.geoJsonLayer;
        } catch (err) {
            Log.error("[GeoLeaf.GeoJSON] Erreur lors du chargement GeoJSON :", err);
            return state.geoJsonLayer;
        }
    };

    /**
     * Ajoute des données GeoJSON passées directement en objet JS.
     * Valide les features selon le schéma strict avant ajout.
     *
     * @param {Object} geojsonData - Objet GeoJSON valide.
     * @param {Object} [options] - Options additionnelles, fusionnées avec celles du module.
     */
    Loader$2.addData = function (geojsonData, options = {}) {
        const state = getState$3();
        const Log = getLog();

        if (!geojsonData) {
            Log.warn("[GeoLeaf.GeoJSON] Aucune donnée GeoJSON fournie à addData().");
            return;
        }

        if (!state.map || !state.geoJsonLayer) {
            Log.error("[GeoLeaf.GeoJSON] Module non initialisé. Appelle GeoLeaf.GeoJSON.init() avant addData().");
            return;
        }

        const mergedOptions = _g$q.GeoLeaf && _g$q.GeoLeaf.Utils && _g$q.GeoLeaf.Utils.mergeOptions
            ? _g$q.GeoLeaf.Utils.mergeOptions(state.options, options)
            : Object.assign({}, state.options, options);

        // Met à jour les options de la couche si besoin
        if (_g$q.GeoLeaf && _g$q.GeoLeaf._GeoJSONStyleResolver && _g$q.GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions) {
            state.geoJsonLayer.options = _g$q.GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions(mergedOptions);
        }

        // Validation stricte des features GeoJSON
        let dataToAdd = geojsonData;
        if (_g$q.GeoLeaf && _g$q.GeoLeaf._GeoJSONFeatureValidator && typeof _g$q.GeoLeaf._GeoJSONFeatureValidator.validateFeatureCollection === "function") {
            const validationResult = _g$q.GeoLeaf._GeoJSONFeatureValidator.validateFeatureCollection(geojsonData);

            if (validationResult.errors.length > 0) {
                Log.warn(
                    `[GeoLeaf.GeoJSON] Validation: ${validationResult.errors.length} feature(s) rejetée(s), ${validationResult.validFeatures.length} acceptée(s)`
                );
            }

            // Ajouter uniquement les features valides
            if (validationResult.validFeatures.length > 0) {
                if (geojsonData.type === "FeatureCollection") {
                    dataToAdd = {
                        type: "FeatureCollection",
                        features: validationResult.validFeatures
                    };
                } else {
                    dataToAdd = validationResult.validFeatures.length === 1
                        ? validationResult.validFeatures[0]
                        : { type: "FeatureCollection", features: validationResult.validFeatures };
                }
            } else {
                Log.warn("[GeoLeaf.GeoJSON] Aucune feature valide à ajouter après validation");
                return;
            }
        }

        // Ajoute les données validées
        state.geoJsonLayer.addData(dataToAdd);

        // Adapter la vue sur les données si demandé
        if (mergedOptions.fitBoundsOnLoad && state.layerGroup) {
            const bounds = state.layerGroup.getBounds();
            if (bounds.isValid()) {
                const fitOptions = {};
                if (typeof mergedOptions.maxZoomOnFit === "number") {
                    fitOptions.maxZoom = mergedOptions.maxZoomOnFit;
                }
                state.map.fitBounds(bounds, fitOptions);
            }
        }

        // Événement custom pour l'écosystème GeoLeaf
        try {
            state.map.fire("geoleaf:geojson:loaded", {
                data: geojsonData,
                layer: state.geoJsonLayer
            });
        } catch (e) {
            // On ne bloque jamais si fire échoue
        }
    };

    /**
     * GeoLeaf GeoJSON Loader - Profile
     * Orchestration du chargement par profil, batch loading, LayerManager population
     *
     * @module geojson/loader/profile
     */

    const _g$p = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$2 = () => GeoJSONShared.state;

    const Loader$1 = {};

    /**
     * Charge automatiquement les couches GeoJSON déclarées dans le profil actif.
     *
     * @param {Object} [options] - Options supplémentaires globales appliquées à toutes les couches.
     * @returns {Promise<Array<Object>>} - Tableau des couches effectivement chargées avec métadonnées.
     */
    Loader$1.loadFromActiveProfile = function (options = {}) {
        const state = getState$2();
        const Log = getLog();
        const Config = _g$p.GeoLeaf && _g$p.GeoLeaf.Config;



        if (!Config || typeof Config.getActiveProfile !== "function") {

            Log.warn(
                "[GeoLeaf.GeoJSON] Module Config ou Config.getActiveProfile() non disponible ; chargement GeoJSON par profil impossible."
            );
            return Promise.resolve([]);
        }

        const profile = Config.getActiveProfile();


        if (!profile || typeof profile !== "object") {

            Log.warn("[GeoLeaf.GeoJSON] Aucun profil actif ou profil invalide ; aucun GeoJSON chargé.");
            return Promise.resolve([]);
        }

        let layersDef = [];

        // Format 1 : profil.geojsonLayers = [...]
        if (Array.isArray(profile.geojsonLayers)) {
            layersDef = profile.geojsonLayers;
        }
        // Format 2 : profil.geojson.layers = [...]
        else if (profile.geojson && Array.isArray(profile.geojson.layers)) {
            layersDef = profile.geojson.layers;
        }
        // Format 3 : profil.layers = [...] (nouveau modèle Full Layer)
        else if (Array.isArray(profile.layers)) {
            layersDef = profile.layers;
        }
        // Format 4 : v3.0 avec Config.getActiveProfileLayersConfig() (nouvelles couches modulaires)
        else if (Config.Profile && typeof Config.Profile.getActiveProfileLayersConfig === "function") {
            const layersConfig = Config.Profile.getActiveProfileLayersConfig();
            if (Array.isArray(layersConfig)) {
                layersDef = layersConfig;
                Log.info("[GeoLeaf.GeoJSON] Utilisation du système v3.0 - " + layersConfig.length + " couches détectées");
            }
        }

        if (!layersDef.length) {
            Log.info(
                "[GeoLeaf.GeoJSON] Aucun bloc geojsonLayers / geojson.layers / layers défini dans le profil actif ; rien à charger."
            );
            return Promise.resolve([]);
        }

        // Limite de sécurité : max 50 couches (augmentée pour profils riches)
        if (layersDef.length > 50) {
            Log.warn(
                "[GeoLeaf.GeoJSON] Beaucoup de couches GeoJSON détectées (" + layersDef.length + "). Cela peut affecter les performances."
            );
        } else if (layersDef.length > 20) {
            Log.info(
                "[GeoLeaf.GeoJSON] " + layersDef.length + " couches GeoJSON détectées. Profil riche détecté."
            );
        }

        const baseOptions = options || {};
        const batchSize = 3;
        const batchDelay = 200;
        const self = this;

        const tasks = layersDef.map((def, index) => async () => {
            if (!def || typeof def !== "object") {
                Log.warn("[GeoLeaf.GeoJSON] Descripteur GeoJSON de profil invalide, ignoré :", { index, def });
                return null;
            }

            if (typeof def.active === "boolean" && def.active === false) {
                Log.debug("[GeoLeaf.GeoJSON] Couche désactivée (active: false), ignorée :", def.id || "(sans ID)");
                return null;
            }

            const layerDirectory = def._layerDirectory || null;
            const layerUrl = def.url || (def.dataFile ? self._resolveDataFilePath(def.dataFile, profile, layerDirectory) : null);

            if (!layerUrl) {
                Log.warn("[GeoLeaf.GeoJSON] Descripteur GeoJSON sans URL ou dataFile, ignoré :", {
                    index,
                    id: def.id,
                    label: def.label
                });
                return null;
            }

            const normalizedDef = { ...def, url: layerUrl };
            normalizedDef._profileId = profile.id;
            normalizedDef._layerDirectory = layerDirectory;

            // Normalisation unifiée des configurations
            if (def.popup && typeof def.popup === 'object') {
                normalizedDef.showPopup = def.popup.enabled !== false;
                if (def.popup.fields && Array.isArray(def.popup.fields)) {
                    normalizedDef.popupFields = def.popup.fields;
                }
                normalizedDef.popup = def.popup;
            }

            if (def.tooltip && typeof def.tooltip === 'object') {
                normalizedDef.showTooltip = def.tooltip.enabled !== false;
                if (def.tooltip.fields && Array.isArray(def.tooltip.fields)) {
                    normalizedDef.tooltipFields = def.tooltip.fields;
                }
                if (def.tooltip.mode) {
                    normalizedDef.tooltipMode = def.tooltip.mode;
                }
                normalizedDef.tooltip = def.tooltip;
            }

            if (def.sidepanel && typeof def.sidepanel === 'object') {
                if (def.sidepanel.detailLayout && Array.isArray(def.sidepanel.detailLayout)) {
                    normalizedDef.sidepanelFields = def.sidepanel.detailLayout;
                }
                normalizedDef.sidepanel = def.sidepanel;
            }

            if (def.clustering && typeof def.clustering === 'object') {
                normalizedDef.clustering = def.clustering.enabled !== false;
                if (typeof def.clustering.maxClusterRadius === 'number') {
                    normalizedDef.maxClusterRadius = def.clustering.maxClusterRadius;
                    normalizedDef.clusterRadius = def.clustering.maxClusterRadius;
                }
                if (typeof def.clustering.disableClusteringAtZoom === 'number') {
                    normalizedDef.disableClusteringAtZoom = def.clustering.disableClusteringAtZoom;
                }
            }

            if (def.search && typeof def.search === 'object') {
                normalizedDef.search = def.search;
            }

            if (def.table && typeof def.table === 'object') {
                normalizedDef.table = def.table;
            }

            // Sprint 8: propagate vectorTiles config
            if (def.data && def.data.vectorTiles && typeof def.data.vectorTiles === 'object') {
                normalizedDef.vectorTiles = def.data.vectorTiles;
            }
            if (def.vectorTiles && typeof def.vectorTiles === 'object') {
                normalizedDef.vectorTiles = def.vectorTiles;
            }

            const layerId = def.id || ("geojson-layer-" + (state.layerIdCounter++));
            const layerLabel = def.label || layerId;

            Log.debug("[GeoLeaf.GeoJSON] Chargement couche GeoJSON :", {
                profileId: profile.id || "(inconnu)",
                layerId: layerId,
                url: layerUrl
            });

            try {
                return await _g$p.GeoLeaf._GeoJSONLoader._loadSingleLayer(layerId, layerLabel, normalizedDef, baseOptions);
            } catch (err) {
                Log.error("[GeoLeaf.GeoJSON] Échec chargement couche :", {
                    layerId: layerId,
                    url: layerUrl,
                    error: err
                });
                return null;
            }
        });

        // ── Sprint 5 : Smart loading — immediate (default theme) + deferred ──
        const defaultThemeLayerIds = self._getDefaultThemeLayerIds(profile);
        const immediateTasks = [];
        const deferredTasks = [];

        layersDef.forEach((def, index) => {
            if (def && def.id && defaultThemeLayerIds.has(def.id)) {
                immediateTasks.push(tasks[index]);
            } else {
                deferredTasks.push(tasks[index]);
            }
        });

        Log.info(
            `[GeoLeaf.GeoJSON] Smart loading: ${immediateTasks.length} immédiate(s) (thème par défaut), ${deferredTasks.length} différée(s)`
        );

        // Phase 1 : charger les couches du thème par défaut
        return this._loadLayersByBatch(immediateTasks, batchSize, batchDelay).then((layers) => {
            const loadedLayers = layers.filter(Boolean);

            Log.info("[GeoLeaf.GeoJSON] Phase 1 : " + loadedLayers.length + " couche(s) du thème par défaut chargée(s)");

            // Intégration avec LayerManager si disponible
            if (loadedLayers.length > 0 && _g$p.GeoLeaf && _g$p.GeoLeaf._GeoJSONLayerManager) {
                _g$p.GeoLeaf._GeoJSONLayerManager.registerWithLayerManager();
            }

            // Fit bounds sur l'ensemble des couches chargées
            if (baseOptions.fitBoundsOnLoad !== false && state.map && state.layerGroup) {
                const bounds = state.layerGroup.getBounds();
                if (bounds.isValid()) {
                    const fitOptions = {};
                    if (typeof baseOptions.maxZoomOnFit === "number") {
                        fitOptions.maxZoom = baseOptions.maxZoomOnFit;
                    }
                    state.map.fitBounds(bounds, fitOptions);
                    Log.debug("[GeoLeaf.GeoJSON] Carte ajustée sur l'emprise des couches GeoJSON");

                    const onMoveEnd = function() {
                        state.map.off('moveend', onMoveEnd);
                        try {
                            const event = new CustomEvent('geoleaf:fitbounds:complete', { detail: { bounds: bounds } });
                            document.dispatchEvent(event);
                        } catch (e) {
                            // fallback si CustomEvent n'est pas dispo
                        }
                    };
                    state.map.on('moveend', onMoveEnd);
                }
            }

            // Événement : couches initiales prêtes
            try {
                state.map.fire("geoleaf:geojson:layers-loaded", {
                    count: loadedLayers.length,
                    layers: loadedLayers.map(l => ({ id: l.id, label: l.label }))
                });
            } catch (e) {
                // Silencieux
            }

            try {
                document.dispatchEvent(new CustomEvent('geoleaf:layers:initial-loaded', {
                    detail: { count: loadedLayers.length, deferred: deferredTasks.length }
                }));
            } catch (e) {
                // Silencieux
            }

            // Phase 2 : charger le reste en arrière-plan (idle)
            if (deferredTasks.length > 0) {
                self._loadLayersInIdle(deferredTasks).then((deferredLayers) => {
                    const loadedDeferred = deferredLayers.filter(Boolean);
                    Log.info(
                        "[GeoLeaf.GeoJSON] Phase 2 : " + loadedDeferred.length + " couche(s) différée(s) chargée(s) en arrière-plan"
                    );

                    // Re-register with LayerManager to include deferred layers
                    if (loadedDeferred.length > 0 && _g$p.GeoLeaf && _g$p.GeoLeaf._GeoJSONLayerManager) {
                        _g$p.GeoLeaf._GeoJSONLayerManager.registerWithLayerManager();
                    }

                    try {
                        state.map.fire("geoleaf:geojson:deferred-layers-loaded", {
                            count: loadedDeferred.length,
                            layers: loadedDeferred.map(l => ({ id: l.id, label: l.label }))
                        });
                    } catch (e) {
                        // Silencieux
                    }
                }).catch((err) => {
                    Log.error("[GeoLeaf.GeoJSON] Erreur chargement couches différées :", err);
                });
            }

            return loadedLayers;
        });
    };

    /**
     * Exécute un tableau de tâches async par lots.
     *
     * @param {Array<Function>} tasks - Fonctions async à exécuter
     * @param {number} [batchSize=3] - Taille des lots
     * @param {number} [delayMs=200] - Délai entre les lots (non utilisé actuellement)
     * @returns {Promise<Array>}
     * @private
     */
    Loader$1._loadLayersByBatch = async function (tasks, batchSize = 3, delayMs = 200) {
        const results = [];

        for (let i = 0; i < tasks.length; i += batchSize) {
            const batch = tasks.slice(i, i + batchSize);
            const batchStart = Date.now();
            const batchResults = await Promise.all(batch.map(fn => fn()));
            results.push(...batchResults);

            const batchDuration = Date.now() - batchStart;
            const Log = getLog();
            Log.info(`[GeoLeaf.GeoJSON] Lot ${Math.floor(i / batchSize) + 1}/${Math.ceil(tasks.length / batchSize)} chargé en ${batchDuration} ms`);

            // Yield to the main thread between batches to avoid long tasks
            if (i + batchSize < tasks.length && delayMs > 0) {
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }
        }

        return results;
    };

    /**
     * Retourne un Set d'IDs de couches appartenant au thème par défaut.
     * Utilisé pour le chargement prioritaire (Sprint 5).
     *
     * @param {Object} profile - Profil actif enrichi
     * @returns {Set<string>} - IDs des couches du thème initial
     * @private
     */
    Loader$1._getDefaultThemeLayerIds = function (profile) {
        try {
            if (!profile || !profile.themes) return new Set();

            const themesData = profile.themes;
            // Support "defautTheme" (FR) et "defaultTheme" (EN)
            const defaultThemeId =
                (themesData.config && themesData.config.defautTheme) ||
                themesData.defaultTheme ||
                null;

            if (!defaultThemeId || !Array.isArray(themesData.themes)) return new Set();

            const defaultTheme = themesData.themes.find((t) => t.id === defaultThemeId);
            if (!defaultTheme || !Array.isArray(defaultTheme.layers)) return new Set();

            return new Set(
                defaultTheme.layers
                    .filter((l) => l.visible !== false)
                    .map((l) => l.id)
            );
        } catch (e) {
            return new Set();
        }
    };

    /**
     * Charge des tâches de couches en arrière-plan via requestIdleCallback.
     * Chaque lot est planifié quand le navigateur est inactif.
     *
     * @param {Array<Function>} tasks - Fonctions async à exécuter
     * @param {number} [batchSize=2] - Taille des lots idle
     * @returns {Promise<Array>}
     * @private
     */
    Loader$1._loadLayersInIdle = function (tasks, batchSize = 2) {
        const Log = getLog();

        return new Promise((resolve) => {
            const results = [];
            let index = 0;

            const schedule =
                typeof requestIdleCallback === 'function'
                    ? (cb) => requestIdleCallback(cb, { timeout: 3000 })
                    : (cb) => setTimeout(cb, 60);

            const processNext = () => {
                if (index >= tasks.length) {
                    resolve(results);
                    return;
                }

                schedule(async () => {
                    const batch = tasks.slice(index, index + batchSize);
                    const batchResults = await Promise.all(batch.map((fn) => fn()));
                    results.push(...batchResults);

                    Log.debug(
                        `[GeoLeaf.GeoJSON] Idle: lot ${Math.floor(index / batchSize) + 1}/${Math.ceil(tasks.length / batchSize)} ` +
                        `(${results.length}/${tasks.length} traitées)`
                    );

                    index += batchSize;
                    processNext();
                });
            };

            processNext();
        });
    };

    /**
     * Prépare les configurations de TOUTES les couches pour le LayerManager.
     * Utilise les configs déjà chargées par ProfileLoader et y ajoute les layerManagerId.
     *
     * @param {Object} profile - Profil actif enrichi par ProfileLoader
     * @returns {Promise<Array>} - Promise résolvant en array des infos de couches
     */
    Loader$1.loadAllLayersConfigsForLayerManager = async function(profile) {
        const Log = getLog();

        if (!profile || !profile.layers || !Array.isArray(profile.layers)) {
            Log.warn("[GeoLeaf.GeoJSON] loadAllLayersConfigsForLayerManager: Pas de couches dans le profil");
            return [];
        }

        Log.info(`[GeoLeaf.GeoJSON] Préparation de ${profile.layers.length} configurations de couches pour LayerManager...`);

        // Les configs sont déjà chargées par ProfileLoader, il suffit d'enrichir avec layerManagerId
        const allConfigs = profile.layers.map(layer => {
            let styles = null;
            let labels = null;
            if (layer.config && layer.config.styles) {
                styles = layer.config.styles;
            } else if (layer.styles) {
                styles = layer.styles;
            }
            if (layer.config && layer.config.labels) {
                labels = layer.config.labels;
            } else if (layer.labels) {
                labels = layer.labels;
            }
            return {
                id: layer.id,
                label: layer.label,
                layerManagerId: layer.layerManagerId || "geojson-default",
                configFile: layer.configFile,
                zIndex: (layer.config && layer.config.zIndex) || 0,
                themes: (layer.config && layer.config.themes) || null,
                styles: styles,
                labels: labels
            };
        });

        Log.info(`[GeoLeaf.GeoJSON] ${allConfigs.length} configurations prêtes pour LayerManager`);

        // Stocker les configs pour utilisation par LayerManager
        _g$p.GeoLeaf._allLayerConfigs = allConfigs;

        return allConfigs;
    };

    /**
     * GeoLeaf GeoJSON Loader - Single Layer
     * Pipeline complet de chargement d'une couche individuelle
     *
     * Sprint 7 : Web Worker fetch+parse + chunked addData via requestIdleCallback
     * Sprint 8 : Vector tiles — early-exit to VectorTiles module when configured
     *
     * @module geojson/loader/single-layer
     */

    const _g$o = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});

    const getState$1 = () => GeoJSONShared.state;
    const getVectorTiles = () => _g$o.GeoLeaf && _g$o.GeoLeaf._VectorTiles;

    /**
     * Détermine si un style chargé nécessite un post-processing via setLayerStyle
     * (hatch patterns ou casing). Les styles simples (couleurs, opacités) sont
     * déjà injectés dans buildLayerOptions et ne nécessitent pas de passe supplémentaire.
     *
     * @param {Object} styleData - Données de style JSON chargées
     * @returns {boolean} true si setLayerStyle est nécessaire
     * @private
     */
    function _styleNeedsPostProcess(styleData) {
        if (!styleData) return false;

        // Check default style for hatch
        const defStyle = styleData.defaultStyle || styleData.style || {};
        if (defStyle.hatch && defStyle.hatch.enabled) return true;
        if (defStyle.casing && defStyle.casing.enabled) return true;

        // Check styleRules for hatch/casing
        const rules = Array.isArray(styleData.styleRules) ? styleData.styleRules : [];
        for (const rule of rules) {
            const s = rule.style || {};
            if (s.hatch && s.hatch.enabled) return true;
            if (s.casing && s.casing.enabled) return true;
        }

        return false;
    }

    const Loader = {};

    /** Nombre de features injectées par tick idle */
    const CHUNK_ADD_SIZE = 200;

    /**
     * Ajoute des features à un layer Leaflet par chunks via requestIdleCallback.
     * Évite de bloquer le thread principal lors de gros jeux de données.
     *
     * @param {L.GeoJSON} leafletLayer - Layer Leaflet cible (créé vide)
     * @param {Array} features - Tableau des features GeoJSON
     * @param {number} [chunkSize=200] - Nombre de features par tick
     * @returns {Promise<void>} Résolu quand toutes les features sont ajoutées
     * @private
     */
    function _addFeaturesChunked(leafletLayer, features, chunkSize) {
        chunkSize = chunkSize || CHUNK_ADD_SIZE;
        var total = features.length;

        // Petit jeu de données → ajout direct (pas de surcoût scheduling)
        if (total <= chunkSize) {
            leafletLayer.addData({ type: "FeatureCollection", features: features });
            return Promise.resolve();
        }

        var Log = getLog();
        var _ric = typeof requestIdleCallback === "function"
            ? requestIdleCallback
            : function (cb) { return setTimeout(cb, 4); };

        return new Promise(function (resolve) {
            var offset = 0;

            function processChunk() {
                var end = Math.min(offset + chunkSize, total);
                var slice = features.slice(offset, end);

                leafletLayer.addData({ type: "FeatureCollection", features: slice });
                offset = end;

                if (offset < total) {
                    _ric(processChunk);
                } else {
                    Log.debug("[GeoLeaf.GeoJSON] Chunked addData terminé :", total, "features");
                    resolve();
                }
            }

            _ric(processChunk);
        });
    }

    /**
     * Charge une couche GeoJSON individuelle.
     *
     * @param {string} layerId - ID unique de la couche
     * @param {string} layerLabel - Libellé de la couche
     * @param {Object} def - Définition de la couche depuis le profil
     * @param {Object} baseOptions - Options de base
     * @returns {Promise<Object>} - Métadonnées de la couche chargée
     * @private
     */
    Loader._loadSingleLayer = function (layerId, layerLabel, def, baseOptions) {
        const state = getState$1();
        const Log = getLog();

        // ── Sprint 8: Vector tiles — early-exit ──────────────────────
        // If the layer has a vectorTiles config AND VectorGrid is available,
        // delegate entirely to the VT module (no GeoJSON fetch/parse).
        const VT = getVectorTiles();
        if (VT && VT.shouldUseVectorTiles(def)) {
            Log.info(`[GeoLeaf.GeoJSON] ⬡ Layer "${layerId}" → vector tiles (Sprint 8)`);
            return VT.loadVectorTileLayer(layerId, layerLabel, def, baseOptions);
        }

        const fromCache = !!def._cachedData;
        const isGpx = def.type === "gpx" || (def.url && def.url.endsWith(".gpx"));

        // Sprint 7 : utiliser le Web Worker pour le fetch+parse JSON (pas cache)
        // Perf 6.3.1: étendre le Worker au fetch GPX text (parse DOMParser reste main thread)
        const WorkerMgr = _g$o.GeoLeaf && _g$o.GeoLeaf._WorkerManager;
        const useWorker = !fromCache && WorkerMgr && WorkerMgr.isAvailable();

        const dataPromise = fromCache
            ? Promise.resolve(def._cachedData)
            : useWorker
                ? (isGpx
                    ? WorkerMgr.fetchText(def.url, layerId)
                    : WorkerMgr.fetchGeoJSON(def.url, layerId))
                : fetch(def.url).then((response) => {
                    if (!response.ok) {
                        throw new Error("HTTP " + response.status + " pour " + def.url);
                    }

                    if (isGpx) {
                        return response.text();
                    }

                    return response.json();
                });

        return dataPromise
            .then(async (rawData) => {
                if (fromCache) {
                    delete def._cachedData;
                }

                const DataConverter = _g$o.GeoLeaf && _g$o.GeoLeaf._DataConverter;
                let geojsonData;

                if (isGpx) {
                    if (typeof rawData === "string") {
                        geojsonData = DataConverter && typeof DataConverter.convertGpxToGeoJSON === "function"
                            ? DataConverter.convertGpxToGeoJSON(rawData)
                            : { type: "FeatureCollection", features: [] };
                    } else {
                        Log.warn("[GeoLeaf.GeoJSON._loadSingleLayer] GPX n'est pas un string", layerId);
                        geojsonData = { type: "FeatureCollection", features: [] };
                    }
                } else {
                    geojsonData = DataConverter ? DataConverter.autoConvert(rawData) : rawData;
                }

                Log.debug("[GeoLeaf.GeoJSON._loadSingleLayer] Données converties", {
                    layerId: layerId,
                    type: def.type,
                    features: geojsonData.features ? geojsonData.features.length : 0,
                    source: fromCache ? "cache" : "network"
                });

                const PaneHelpers = GeoJSONShared.PaneHelpers;
                const PaneConfig = GeoJSONShared.PANE_CONFIG;

                // ── Style pre-loading: charger le JSON AVANT de créer le layer ──
                let preloadedStyleData = null;
                if (def.styles && def.styles.default) {
                    try {
                        preloadedStyleData = await _g$o.GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle(layerId, def);
                        if (preloadedStyleData) {
                            // Injecter le style résolu dans def pour que buildLayerOptions l'utilise
                            const resolvedDefault = preloadedStyleData.defaultStyle || preloadedStyleData.style;
                            if (resolvedDefault) {
                                def.style = Object.assign({}, def.style || {}, resolvedDefault);
                            }
                            if (Array.isArray(preloadedStyleData.styleRules) && preloadedStyleData.styleRules.length) {
                                def.styleRules = preloadedStyleData.styleRules;
                            }
                            Log.debug("[GeoLeaf.GeoJSON] Style pré-chargé pour:", layerId);
                        }
                    } catch (err) {
                        Log.warn("[GeoLeaf.GeoJSON] Échec pré-chargement style pour:", layerId, err.message);
                        // Notification toast si le système est disponible
                        if (_g$o.GeoLeaf && _g$o.GeoLeaf.Notifications && typeof _g$o.GeoLeaf.Notifications.warning === 'function') {
                            _g$o.GeoLeaf.Notifications.warning(
                                `Style par défaut introuvable pour « ${layerLabel} ». Affichage avec style neutre.`
                            );
                        }
                    }
                }

                const layerOptions = _g$o.GeoLeaf._GeoJSONLayerConfig.buildLayerOptions(def, baseOptions);
                // Use lazy pane factory if available, fallback to getPaneName
                layerOptions.pane = PaneHelpers.getOrCreatePane
                    ? PaneHelpers.getOrCreatePane(def.zIndex, state.map)
                    : PaneHelpers.getPaneName(def.zIndex);

                // ── NE PAS appeler enablePaneInteraction ici ──────────────────
                // Mettre pointer-events: auto sur le pane <div> est DESTRUCTIF :
                // le <div> couvre tout le viewport et intercepte TOUS les clics,
                // bloquant les panes à z-index inférieur. Avec les panes par couche,
                // plusieurs panes interactifs se superposent (ex: z454 au-dessus de
                // z453), et pointer-events: auto sur z454 empêche tout clic sur z453.
                //
                // Tous les panes restent à pointer-events: none. L'interactivité
                // est gérée au niveau des éléments enfants :
                //  - SVG <path> : Leaflet CSS `.leaflet-pane > svg path.leaflet-interactive`
                //    donne pointer-events: auto (fonctionne malgré le parent none)
                //  - Markers <div> : Leaflet CSS `.leaflet-marker-icon.leaflet-interactive`
                //    donne pointer-events: auto
                //  - Canvas : les couches non-interactives restent muettes (voulu)

                // ── Choix du renderer : SVG vs Canvas ──────────────────────────
                // Avec preferCanvas: true (défaut Sprint 7), Leaflet crée un <canvas>
                // par pane. Contrairement aux éléments SVG <path> (qui ne captent les
                // clics que sur leur tracé réel), un <canvas> est un rectangle opaque
                // pour les événements DOM : il intercepte TOUS les clics dans ses
                // limites, même sur les zones transparentes. Résultat : les panes
                // Canvas superposés plus haut en z-index bloquent les clics vers les
                // couches interactives en-dessous.
                //
                // Solution : forcer L.svg() pour toute couche interactive polygon/
                // polyline (pas les points, qui utilisent le markerPane ou les
                // clusters). Cela garantit que chaque polygone interactif est un
                // <path> SVG avec son propre pointer-events, tandis que les couches
                // non-interactives restent en Canvas pour la performance.
                const isInteractiveShape = def.interactiveShape === true;
                const isPolygonOrLine = def.geometry === 'polygon' || def.geometry === 'polyline' || def.geometry === 'line';
                const needsSvgRenderer = _styleNeedsPostProcess(preloadedStyleData) || (isInteractiveShape && isPolygonOrLine);

                if (needsSvgRenderer && _g$o.L && _g$o.L.svg) {
                    layerOptions.renderer = _g$o.L.svg({ pane: layerOptions.pane });
                    if (_styleNeedsPostProcess(preloadedStyleData)) {
                        Log.debug("[GeoLeaf.GeoJSON] SVG renderer forcé (hatch/casing) pour:", layerId);
                    } else {
                        Log.debug("[GeoLeaf.GeoJSON] SVG renderer forcé (interactive polygon/line + preferCanvas) pour:", layerId);
                    }
                }

                // ── Propager interactive au niveau du FeatureGroup L.geoJSON ──
                // Le style() callback définit interactive par feature, mais le
                // FeatureGroup parent doit aussi être marqué interactive pour que
                // Leaflet enregistre les event handlers sur le renderer.
                if (isInteractiveShape) {
                    layerOptions.interactive = true;
                }

                // Sprint 7 : créer le layer vide puis injecter les features par chunks
                const features = Array.isArray(geojsonData.features) ? geojsonData.features : [];
                const leafletLayer = _g$o.L.geoJSON(null, layerOptions);

                // Déterminer la stratégie de clustering AVANT d'ajouter les features
                // pour savoir si on doit attendre la fin de l'injection (cas cluster).
                const ClusteringModule = _g$o.GeoLeaf && _g$o.GeoLeaf._GeoJSONClustering;
                const clusterStrategy = ClusteringModule
                    ? ClusteringModule.getClusteringStrategy(def, geojsonData)
                    : { shouldCluster: false, useSharedCluster: false };

                // Normaliser les paramètres de clustering depuis l'objet clustering si présents
                // (le thème applier ne fait pas cette normalisation contrairement à profile.js)
                if (def.clustering && typeof def.clustering === 'object') {
                    if (typeof def.clusterRadius !== 'number' && typeof def.clustering.maxClusterRadius === 'number') {
                        def.clusterRadius = def.clustering.maxClusterRadius;
                    }
                    if (typeof def.disableClusteringAtZoom !== 'number' && typeof def.clustering.disableClusteringAtZoom === 'number') {
                        def.disableClusteringAtZoom = def.clustering.disableClusteringAtZoom;
                    }
                }

                // Sprint 7+8 : addData chunked — ATTENDRE la fin si clustering actif
                // ou si le style nécessite un post-processing (hatch/casing).
                // MarkerClusterGroup.addLayer(featureGroup) prend un instantané des enfants ;
                // les features ajoutées après ne sont PAS visibles dans le cluster.
                // Pour hatch/casing, setLayerStyle doit itérer TOUTES les features
                // pour attacher les listeners 'add' → il faut que les features soient présentes.
                const needsAwaitFeatures = clusterStrategy.shouldCluster || _styleNeedsPostProcess(preloadedStyleData);
                if (needsAwaitFeatures) {
                    await _addFeaturesChunked(leafletLayer, features, CHUNK_ADD_SIZE);
                } else {
                    // Sans clustering ni hatch, on peut continuer sans attendre — Leaflet affiche
                    // les features au fur et à mesure lorsque la couche est déjà sur la map.
                    _addFeaturesChunked(leafletLayer, features, CHUNK_ADD_SIZE);
                }

                let clusterGroup = null;
                let useSharedCluster = false;

                if (clusterStrategy.shouldCluster) {
                    if (clusterStrategy.useSharedCluster) {
                        // Utiliser le cluster POI partagé
                        Log.info("[GeoLeaf.GeoJSON] 🔄 Tentative récupération cluster POI partagé pour:", layerId);
                        let poiCluster = ClusteringModule ? ClusteringModule.getSharedPOICluster() : null;

                        if (poiCluster) {
                            clusterGroup = poiCluster;
                            clusterGroup.addLayer(leafletLayer);
                            useSharedCluster = true;
                            Log.info("[GeoLeaf.GeoJSON] ✅ Couche ajoutée au cluster POI partagé (stratégie: unified) :", layerId);
                        } else {
                            // Le cluster POI n'est pas encore créé, attendre un peu et réessayer
                            Log.debug("[GeoLeaf.GeoJSON] Cluster POI non disponible immédiatement, tentative après délai :", layerId);

                            // Stocker temporairement sans cluster
                            const tempLayerData = {
                                id: layerId,
                                label: layerLabel,
                                layer: leafletLayer,
                                visible: true,
                                config: def,
                                clusterGroup: null,
                                useSharedCluster: false,
                                pendingSharedCluster: true
                            };

                            state.layers.set(layerId, tempLayerData);

                            // Réessayer après un court délai
                            setTimeout(() => {
                                poiCluster = ClusteringModule ? ClusteringModule.getSharedPOICluster() : null;

                                if (poiCluster) {
                                    poiCluster.addLayer(leafletLayer);
                                    tempLayerData.clusterGroup = poiCluster;
                                    tempLayerData.useSharedCluster = true;
                                    tempLayerData.pendingSharedCluster = false;
                                    Log.debug("[GeoLeaf.GeoJSON] Couche ajoutée au cluster POI partagé (après délai) :", layerId);
                                } else {
                                    Log.warn("[GeoLeaf.GeoJSON] Cluster POI toujours non disponible, création cluster indépendant :", layerId);
                                    if (_g$o.L && _g$o.L.markerClusterGroup) {
                                        const independentCluster = _g$o.L.markerClusterGroup({
                                            maxClusterRadius: def.clusterRadius || 80,
                                            disableClusteringAtZoom: def.disableClusteringAtZoom || 18,
                                            animate: false,
                                            showCoverageOnHover: false
                                        });

                                        // Forcer le pane sur tous les markers du cluster
                                        independentCluster.on('layeradd', function(e) {
                                            PaneHelpers.applyPaneToLayer(e.layer, def.zIndex || 0);
                                        });

                                        independentCluster.addLayer(leafletLayer);
                                        tempLayerData.clusterGroup = independentCluster;
                                        tempLayerData.useSharedCluster = false;
                                        tempLayerData.pendingSharedCluster = false;

                                        if (tempLayerData.visible) {
                                            state.map.addLayer(independentCluster);
                                        }
                                    }
                                }
                            }, 500);

                            return {
                                id: layerId,
                                label: layerLabel,
                                featureCount: features.length
                            };
                        }
                    } else {
                        // Créer un cluster indépendant (by-source)
                        if (_g$o.L && _g$o.L.markerClusterGroup) {
                            clusterGroup = _g$o.L.markerClusterGroup({
                                maxClusterRadius: def.clusterRadius || 80,
                                disableClusteringAtZoom: def.disableClusteringAtZoom || 18,
                                animate: false,
                                spiderfyOnMaxZoom: false,
                                showCoverageOnHover: false,
                                zoomToBoundsOnClick: true
                            });

                            // Forcer le pane sur tous les markers du cluster
                            PaneHelpers.getPaneName(def.zIndex);
                            clusterGroup.on('layeradd', function(e) {
                                PaneHelpers.applyPaneToLayer(e.layer, def.zIndex || 0);
                            });

                            clusterGroup.addLayer(leafletLayer);
                            Log.debug("[GeoLeaf.GeoJSON] Couche avec cluster indépendant (stratégie: by-source) :", layerId);
                        }
                    }
                } else {
                    Log.debug("[GeoLeaf.GeoJSON] Couche sans clustering :", layerId);
                }

                // Stocker la couche
                const inferredGeometry = _g$o.GeoLeaf._GeoJSONLayerConfig.inferGeometryType(def, geojsonData);

                // Calculer le zIndex si non défini
                let zIndex = def.zIndex;
                if (typeof zIndex !== 'number') {
                    // Calculer automatiquement basé sur l'ordre d'apparition
                    const allLayerIds = Array.from(state.layers.keys());
                    zIndex = Math.max(PaneConfig.MIN_LAYER_ZINDEX, PaneConfig.MAX_LAYER_ZINDEX - allLayerIds.length);
                    Log.debug(`[GeoLeaf.GeoJSON] zIndex auto-assigné pour ${layerId}: ${zIndex}`);
                } else {
                    // Validation et clamping 0-99
                    const validatedZIndex = PaneHelpers.validateZIndex(zIndex);
                    if (validatedZIndex !== def.zIndex) {
                        Log.warn(`[GeoLeaf.GeoJSON] zIndex ${def.zIndex} clamped to ${validatedZIndex} pour ${layerId}`);
                    }
                    zIndex = validatedZIndex;
                }
                def.zIndex = zIndex;

                const Config = _g$o.GeoLeaf && _g$o.GeoLeaf.Config;
                const dataCfg = Config && Config.get ? Config.get('data') : null;
                const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
                const layerBasePath = `${profilesBasePath}/${def._profileId}/${def._layerDirectory}`;

                const layerData = {
                    id: layerId,
                    label: layerLabel,
                    layer: leafletLayer,
                    visible: true,
                    config: def,
                    clusterGroup: clusterGroup,
                    legendsConfig: def.legends,
                    basePath: layerBasePath,
                    useSharedCluster: useSharedCluster,
                    // geojson raw data removed (Sprint 1) — saves ~243 MB on large profiles
                    features: features,
                    geometryType: def.geometryType || inferredGeometry
                };

                // Initialiser les métadonnées de visibilité AVANT d'ajouter à la map
                layerData._visibility = {
                    current: false,
                    logicalState: false,
                    source: 'system',
                    userOverride: false,
                    themeOverride: false,
                    themeDesired: null,
                    zoomConstrained: false
                };

                state.layers.set(layerId, layerData);

                // featureCache removed (Sprint 1) — UI reads features directly from state.layers

                // Mettre en cache les données GeoJSON pour les chargements suivants
                if (_g$o.GeoLeaf && _g$o.GeoLeaf.ThemeCache && typeof _g$o.GeoLeaf.ThemeCache.store === 'function') {
                    const profileId = def._profileId || (_g$o.GeoLeaf.Config && _g$o.GeoLeaf.Config.getActiveProfileId ? _g$o.GeoLeaf.Config.getActiveProfileId() : null);
                    _g$o.GeoLeaf.ThemeCache.store(layerId, profileId, geojsonData, { contentLength: def.contentLength });
                }

                // Appliquer immédiatement les seuils de zoom pour cette couche
                if (_g$o.GeoLeaf && _g$o.GeoLeaf._GeoJSONLayerManager) {
                    _g$o.GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom();
                }

                // NE PAS ajouter automatiquement à la carte au chargement
                // Les thèmes contrôleront la visibilité des couches
                layerData.visible = false;

                // FitBounds UNIQUEMENT si pas de système de thèmes
                const shouldFitBounds = def.fitBoundsOnLoad && !(_g$o.GeoLeaf && _g$o.GeoLeaf.ThemeSelector);
                if (shouldFitBounds && leafletLayer.getBounds().isValid()) {
                    const fitOptions = {};
                    if (typeof def.maxZoomOnFit === "number") {
                        fitOptions.maxZoom = def.maxZoomOnFit;
                    }
                    state.map.fitBounds(leafletLayer.getBounds(), fitOptions);
                }

                // ── Post-processing: appliquer setLayerStyle uniquement si hatch/casing ──
                if (preloadedStyleData) {
                    // Stocker currentStyle dans layerData pour les labels
                    const layerDataForStyle = state.layers.get(layerId);
                    if (layerDataForStyle) {
                        layerDataForStyle.currentStyle = preloadedStyleData;
                    }

                    const needsPostProcess = _styleNeedsPostProcess(preloadedStyleData);
                    if (needsPostProcess && _g$o.GeoLeaf && _g$o.GeoLeaf._GeoJSONLayerManager) {
                        Log.debug("[GeoLeaf.GeoJSON] Post-process setLayerStyle (hatch/casing) pour:", layerId);
                        _g$o.GeoLeaf._GeoJSONLayerManager.setLayerStyle(layerId, preloadedStyleData);
                    } else {
                        Log.debug("[GeoLeaf.GeoJSON] Style simple pré-injecté, setLayerStyle ignoré pour:", layerId);
                    }

                    // Initialiser les labels selon le style
                    if (_g$o.GeoLeaf && _g$o.GeoLeaf.Labels && typeof _g$o.GeoLeaf.Labels.initializeLayerLabels === 'function') {
                        _g$o.GeoLeaf.Labels.initializeLayerLabels(layerId);
                    }

                    // Synchroniser le bouton de label
                    if (_g$o.GeoLeaf && _g$o.GeoLeaf._LabelButtonManager) {
                        _g$o.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
                    }
                } else {
                    // Pas de style par défaut: initialiser les labels depuis la config legacy si présents
                    if (def.labels && def.labels.enabled && _g$o.GeoLeaf && _g$o.GeoLeaf.Labels && typeof _g$o.GeoLeaf.Labels.initializeLayerLabels === 'function') {
                        _g$o.GeoLeaf.Labels.initializeLayerLabels(layerId);
                    }

                    // Synchroniser le bouton de label
                    if (_g$o.GeoLeaf && _g$o.GeoLeaf._LabelButtonManager) {
                        _g$o.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
                    }
                }
                Log.debug("[GeoLeaf.GeoJSON] Couche chargée avec succès :", layerId, "(" + features.length + " features)");

                return {
                    id: layerId,
                    label: layerLabel,
                    featureCount: features.length
                };
            });
    };

    /**
     * GeoLeaf GeoJSON Module - Aggregator
     * Module principal qui délègue aux sous-modules spécialisés
     *
     * Architecture Phase 3.5:
     * - geojson/shared.js        : État partagé, constantes, STYLE_OPERATORS
     * - geojson/style-resolver.js: Évaluation styleRules, buildLeafletOptions
     * - geojson/layer-manager.js : Gestion couches (show/hide/toggle/remove)
     * - geojson/loader.js        : Chargement (loadUrl, loadFromActiveProfile)
     * - geojson/popup-tooltip.js : Popups et tooltips unifiés
     * - geojson/clustering.js    : Stratégies de clustering
     *
     * @module geoleaf.geojson
     */

    const _g$n = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});



    // ========================================
    //   GETTERS LAZY POUR SOUS-MODULES
    // ========================================


    const getState = () => GeoJSONShared.state;

    const getLayerManager = () => _g$n.GeoLeaf && _g$n.GeoLeaf._GeoJSONLayerManager;
    const getLoader = () => _g$n.GeoLeaf && _g$n.GeoLeaf._GeoJSONLoader;



    // ========================================
    //   MODULE GEOJSON (AGRÉGATEUR)
    // ========================================


    const GeoJSONModule = {
        /**
         * Getters pour accès direct à l'état (compatibilité)
         */
        get _map() { return getState() ? getState().map : null; },
        get _layerGroup() { return getState() ? getState().layerGroup : null; },
        get _geoJsonLayer() { return getState() ? getState().geoJsonLayer : null; },
        get _layers() { return getState() ? getState().layers : new Map(); },
        get _options() { return getState() ? getState().options : {}; },

        /**
         * Valide les options passées à init()
         * @param {Object} options
         * @private
         */
        _validateOptions(options) {
            if (options.map && typeof options.map.addLayer !== 'function') {
                Log.warn("[GeoLeaf.GeoJSON] options.map ne semble pas être une carte Leaflet valide.");
            }

            if (options.defaultStyle && typeof options.defaultStyle !== 'object') {
                Log.warn("[GeoLeaf.GeoJSON] options.defaultStyle doit être un objet.");
                delete options.defaultStyle;
            }

            if (options.onEachFeature && typeof options.onEachFeature !== 'function') {
                Log.warn("[GeoLeaf.GeoJSON] options.onEachFeature doit être une fonction.");
                delete options.onEachFeature;
            }

            if (options.pointToLayer && typeof options.pointToLayer !== 'function') {
                Log.warn("[GeoLeaf.GeoJSON] options.pointToLayer doit être une fonction.");
                delete options.pointToLayer;
            }

            if (options.maxZoomOnFit !== undefined &&
                (typeof options.maxZoomOnFit !== 'number' || options.maxZoomOnFit < 1 || options.maxZoomOnFit > 20)) {
                Log.warn("[GeoLeaf.GeoJSON] options.maxZoomOnFit doit être un nombre entre 1 et 20.");
                options.maxZoomOnFit = _g$n.GeoLeaf && _g$n.GeoLeaf.CONSTANTS ? _g$n.GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18;
            }

            return options;
        },

        /**
         * Initialise le module GeoJSON.
         *
         * @param {Object} options
         * @param {L.Map} [options.map] - Carte Leaflet. Si absent, tentative via GeoLeaf.Core.getMap().
         * @param {Object} [options.defaultStyle]
         * @param {Object} [options.defaultPointStyle]
         * @param {Function} [options.onEachFeature]
         * @param {Function} [options.pointToLayer]
         * @param {boolean} [options.fitBoundsOnLoad]
         * @param {number} [options.maxZoomOnFit]
         * @returns {L.GeoJSON|null} - La couche GeoJSON ou null si échec.
         */
        init(options = {}) {
            const state = getState();
            if (!state) {
                Log.error("[GeoLeaf.GeoJSON] Module shared.js non chargé.");
                return null;
            }

            // Validation
            options = this._validateOptions(options);

            if (typeof _g$n.L === "undefined" || !_g$n.L || typeof _g$n.L.geoJSON !== "function") {
                Log.error("[GeoLeaf.GeoJSON] Leaflet (L) est requis mais introuvable.");
                return null;
            }

            // Utiliser l'helper partagé
            const map = _g$n.GeoLeaf && _g$n.GeoLeaf.Utils ? _g$n.GeoLeaf.Utils.ensureMap(options.map) : (options.map || null);

            if (!map) {
                Log.error(
                    "[GeoLeaf.GeoJSON] Aucune carte Leaflet disponible. Passe une instance de carte dans init({ map })."
                );
                return null;
            }

            state.map = map;

            // Fusionner les options
            state.options = _g$n.GeoLeaf && _g$n.GeoLeaf.Utils && _g$n.GeoLeaf.Utils.mergeOptions
                ? _g$n.GeoLeaf.Utils.mergeOptions(state.options, options)
                : Object.assign({}, state.options, options);

            // Créer les panes pour contrôler le z-index des couches
            const PaneConfig = GeoJSONShared.PANE_CONFIG;
            const PaneHelpers = GeoJSONShared.PaneHelpers;

            // Basemap: z-index 200 (toujours en dessous)
            const basemapPane = state.map.createPane(PaneConfig.BASEMAP_NAME);
            basemapPane.style.zIndex = PaneConfig.BASEMAP_ZINDEX;

            // Lazy pane factory — panes are created on demand instead of 100 upfront
            const _createdPanes = new Set();
            const _origGetPaneName = PaneHelpers.getPaneName.bind(PaneHelpers);
            /**
             * Returns a Leaflet pane name for the given zIndex,
             * creating the DOM pane lazily on first use.
             */
            PaneHelpers.getOrCreatePane = function (zIndex, map) {
                const paneName = _origGetPaneName(zIndex);
                if (!_createdPanes.has(paneName)) {
                    const pane = map.createPane(paneName);
                    pane.style.zIndex = PaneConfig.LAYER_BASE_ZINDEX + zIndex;
                    // TOUS les panes restent à pointer-events: none DÉFINITIVEMENT.
                    // NE JAMAIS passer un pane à pointer-events: auto car le <div>
                    // couvre tout le viewport et bloquerait les clics des panes en-
                    // dessous (plusieurs panes interactifs se superposent).
                    //
                    // L'interactivité fonctionne via les éléments enfants qui
                    // surchargent pointer-events individuellement (CSS spec : un
                    // enfant avec pointer-events: auto REÇOIT les événements même
                    // si son parent a pointer-events: none) :
                    //
                    //  - SVG <path class="leaflet-interactive"> :
                    //    Leaflet CSS `.leaflet-pane > svg path.leaflet-interactive`
                    //    → pointer-events: auto (polygones/polylines interactifs)
                    //  - Marker <div class="leaflet-marker-icon leaflet-interactive"> :
                    //    Leaflet CSS `.leaflet-marker-icon.leaflet-interactive`
                    //    → pointer-events: auto (marqueurs de points)
                    //  - Canvas <canvas> : hérite none → ne capte rien (voulu pour
                    //    les couches non-interactives : températures, pluvio, etc.)
                    pane.style.pointerEvents = 'none';
                    _createdPanes.add(paneName);
                }
                return paneName;
            };

            /**
             * Active la capture des événements pointeur sur un pane existant.
             * Appelé lorsqu'on y ajoute une couche interactive (interactiveShape: true).
             */
            PaneHelpers.enablePaneInteraction = function (zIndex, map) {
                const paneName = _origGetPaneName(zIndex);
                const pane = map.getPane(paneName);
                if (pane) {
                    pane.style.pointerEvents = 'auto';
                }
            };

            Log.info(`[GeoLeaf.GeoJSON] Pane basemap créé : ${PaneConfig.BASEMAP_NAME} (z:${PaneConfig.BASEMAP_ZINDEX}). Couches GeoJSON: panes créés à la demande.`);

            // Créer un groupe pour encapsuler TOUTES les couches GeoJSON
            state.layerGroup = _g$n.L.featureGroup().addTo(state.map);

            // Initialiser la Map des couches
            state.layers = new Map();

            // Ajouter un écouteur pour gérer les seuils de zoom
            const LayerManager = getLayerManager();
            if (LayerManager) {
                state.map.on('zoomend', () => {
                    LayerManager.updateLayerVisibilityByZoom();
                });
            }

            // LEGACY: Créer la couche GeoJSON vide (pour compatibilité)
            const StyleResolver = GeoJSONStyleResolver;
            const leafletOptions = StyleResolver
                ? StyleResolver.buildLeafletOptions(state.options)
                : {};

            state.geoJsonLayer = _g$n.L.geoJSON(null, leafletOptions);
            state.geoJsonLayer.addTo(state.layerGroup);

            Log.info("[GeoLeaf.GeoJSON] Module initialisé en mode multi-couches");

            return state.geoJsonLayer;
        },

        /**
         * Retourne la couche GeoJSON principale (LEGACY).
         * @returns {L.GeoJSON|null}
         */
        getLayer() {
            const state = getState();
            return state ? state.geoJsonLayer : null;
        },

        // ========================================
        //   DÉLÉGATION VERS LAYER MANAGER
        // ========================================

        getLayerById(layerId) {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.getLayerById(layerId) : null;
        },

        getLayerData(layerId) {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.getLayerData(layerId) : null;
        },

        getAllLayers() {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.getAllLayers() : [];
        },

        showLayer(layerId) {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.showLayer(layerId);
        },

        hideLayer(layerId) {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.hideLayer(layerId);
        },

        toggleLayer(layerId) {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.toggleLayer(layerId);
        },

        removeLayer(layerId) {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.removeLayer(layerId);
        },

        updateLayerZIndex(layerId, newZIndex) {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.updateLayerZIndex(layerId, newZIndex) : false;
        },

        setLayerStyle(layerId, styleConfig) {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.setLayerStyle(layerId, styleConfig) : false;
        },

        // ========================================
        //   DÉLÉGATION VERS LOADER
        // ========================================

        loadUrl(url, options = {}) {
            const Loader = getLoader();
            return Loader ? Loader.loadUrl(url, options) : Promise.resolve(null);
        },

        addData(geojsonData, options = {}) {
            const Loader = getLoader();
            if (Loader) Loader.addData(geojsonData, options);
        },

        loadFromActiveProfile(options = {}) {
            const Loader = getLoader();
            return Loader ? Loader.loadFromActiveProfile(options) : Promise.resolve([]);
        },

        // ========================================
        //   FILTRAGE DES FEATURES
        // ========================================

        /**
         * Filtre les features de toutes les couches GeoJSON.
         * Montre uniquement les features qui passent le prédicat.
         *
         * @param {Function} filterFn - Fonction (feature, layerId) => boolean
         * @param {Object} [options] - Options supplémentaires
         * @returns {Object} - { filtered: number, total: number, visible: number }
         */
        filterFeatures(filterFn, options = {}) {
            const state = getState();
            if (typeof filterFn !== 'function') {
                Log.warn("[GeoLeaf.GeoJSON] filterFeatures: filterFn doit être une fonction");
                return { filtered: 0, total: 0, visible: 0 };
            }

            const stats = { filtered: 0, total: 0, visible: 0 };

            // Déterminer les couches à filtrer
            let layerIds = [];
            if (options.layerIds) {
                layerIds = Array.isArray(options.layerIds) ? options.layerIds : [options.layerIds];
            } else {
                layerIds = Array.from(state.layers.keys());
            }

            // Filtrer par type de géométrie si spécifié (avec aliases)
            if (options.geometryType) {
                const geoType = options.geometryType.toLowerCase();
                const typeAliases = {
                    'poi': 'point',
                    'route': 'line',
                    'linestring': 'line',
                    'area': 'polygon'
                };
                const normalizedType = typeAliases[geoType] || geoType;

                layerIds = layerIds.filter(id => {
                    const data = state.layers.get(id);
                    if (!data) return false;
                    const layerGeoType = (data.geometryType || '').toLowerCase();
                    const normalizedLayerType = typeAliases[layerGeoType] || layerGeoType;
                    return normalizedLayerType === normalizedType;
                });
            }

            layerIds.forEach(layerId => {
                const layerData = state.layers.get(layerId);
                if (!layerData || !layerData.layer) return;

                // Si search.enabled === false, la couche n'est pas concernée par le filtrage
                const bypassFilter = layerData.config?.search?.enabled === false;

                // Initialiser le Set des layers filtrées si pas encore fait
                if (!layerData._filteredOutLayers) {
                    layerData._filteredOutLayers = new Set();
                }

                const toShow = [];
                const toHide = [];

                // Itérer sur chaque feature
                layerData.layer.eachLayer(leafletLayer => {
                    if (!leafletLayer.feature) return;

                    stats.total++;

                    const shouldShow = bypassFilter || filterFn(leafletLayer.feature, layerId);

                    if (shouldShow) {
                        toShow.push(leafletLayer);
                        stats.visible++;
                    } else {
                        toHide.push(leafletLayer);
                        stats.filtered++;
                    }
                });

                // Appliquer les changements de visibilité
                const clusterGroup = layerData.clusterGroup;

                toHide.forEach(leafletLayer => {
                    leafletLayer._geoleafFiltered = true;

                    if (clusterGroup) {
                        if (!layerData._filteredOutLayers.has(leafletLayer)) {
                            clusterGroup.removeLayer(leafletLayer);
                            layerData._filteredOutLayers.add(leafletLayer);
                        }
                    } else {
                        if (leafletLayer.getElement) {
                            const layerElement = leafletLayer.getElement();
                            if (layerElement) layerElement.style.display = 'none';
                        } else if (leafletLayer.setStyle) {
                            if (leafletLayer.options._originalOpacity === undefined) {
                                leafletLayer.options._originalOpacity = leafletLayer.options.opacity;
                                leafletLayer.options._originalFillOpacity = leafletLayer.options.fillOpacity;
                            }
                            leafletLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                        }
                    }
                });

                toShow.forEach(leafletLayer => {
                    leafletLayer._geoleafFiltered = false;

                    if (clusterGroup) {
                        if (layerData._filteredOutLayers.has(leafletLayer)) {
                            clusterGroup.addLayer(leafletLayer);
                            layerData._filteredOutLayers.delete(leafletLayer);
                        }
                    } else {
                        if (leafletLayer.getElement) {
                            const layerElement = leafletLayer.getElement();
                            if (layerElement) layerElement.style.display = '';
                        } else if (leafletLayer.setStyle) {
                            leafletLayer.setStyle({
                                opacity: leafletLayer.options._originalOpacity !== undefined
                                    ? leafletLayer.options._originalOpacity : 1,
                                fillOpacity: leafletLayer.options._originalFillOpacity !== undefined
                                    ? leafletLayer.options._originalFillOpacity : 0.4
                            });
                        }
                    }
                });
            });

            Log.debug(`[GeoLeaf.GeoJSON] filterFeatures: ${stats.visible}/${stats.total} features visibles`);
            return stats;
        },

        /**
         * Réinitialise le filtre sur les features (montre tout).
         *
         * @param {Object} [options] - Mêmes options que filterFeatures
         */
        clearFeatureFilter(options = {}) {
            return this.filterFeatures(() => true, options);
        },

        /**
         * Retourne toutes les features chargées.
         * Reads directly from state.layers (featureCache removed in Sprint 1).
         * @param {Object} [options]
         * @returns {Array<Object>} features GeoJSON enrichies de { _layerId }
         */
        getFeatures(options = {}) {
            const state = getState();
            if (!state) return [];

            const geometrySet = Array.isArray(options.geometryTypes)
                ? new Set(options.geometryTypes.map(t => t.toLowerCase()))
                : null;
            const layerSet = Array.isArray(options.layerIds) ? new Set(options.layerIds) : null;

            const result = [];
            state.layers.forEach((layerData, layerId) => {
                if (layerSet && !layerSet.has(layerId)) return;
                const geoType = (layerData.geometryType || "").toLowerCase();
                if (geometrySet && !geometrySet.has(geoType)) return;

                (layerData.features || []).forEach((f) => {
                    if (f && typeof f === "object") {
                        // Shallow tag with _layerId instead of full Object.assign clone
                        f._layerId = layerId;
                        result.push(f);
                    }
                });
            });
            return result;
        },

        /**
         * Supprime toutes les entités GeoJSON de la couche legacy.
         */
        clear() {
            const state = getState();
            if (state && state.geoJsonLayer) {
                state.geoJsonLayer.clearLayers();
            }
        },

        // ========================================
        //   MÉTHODES INTERNES EXPOSÉES
        // ========================================

        _updateLayerVisibilityByZoom() {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.updateLayerVisibilityByZoom();
        },

        _registerWithLayerManager() {
            const LayerManager = getLayerManager();
            if (LayerManager) LayerManager.registerWithLayerManager();
        },

        _convertFeatureToPOI(feature, def) {
            const pt = _g$n.GeoLeaf && _g$n.GeoLeaf._GeoJSONPopupTooltip;
            return pt ? pt.convertFeatureToPOI(feature, def) : null;
        },

        _getClusteringStrategy(def, geojsonData) {
            const Clustering = GeoJSONClustering;
            return Clustering
                ? Clustering.getClusteringStrategy(def, geojsonData)
                : { shouldCluster: false, useSharedCluster: false };
        },

        _getSharedPOICluster() {
            const Clustering = GeoJSONClustering;
            return Clustering ? Clustering.getSharedPOICluster() : null;
        },

        _getPoiConfig() {
            const Clustering = GeoJSONClustering;
            return Clustering ? Clustering.getPoiConfig() : {};
        },

        _detectLayerType(layer) {
            const LayerManager = getLayerManager();
            return LayerManager ? LayerManager.detectLayerType(layer) : "mixed";
        },

        _buildLeafletOptions(options) {
            const StyleResolver = GeoJSONStyleResolver;
            return StyleResolver ? StyleResolver.buildLeafletOptions(options) : {};
        }
    };

    // Exposer _StyleRules pour compatibilité avec le module Themes
    // (déjà fait dans style-resolver.js, mais on s'assure que c'est accessible)
    if (_g$n.GeoLeaf && !_g$n.GeoLeaf._StyleRules && GeoJSONStyleResolver) {
        _g$n.GeoLeaf._StyleRules = {
            evaluate: GeoJSONStyleResolver.evaluateStyleRules,
            operators: GeoJSONShared ? GeoJSONShared.STYLE_OPERATORS : {},
            getNestedValue: GeoJSONStyleResolver.getNestedValue
        };
    }

    const GeoJSONCore = GeoJSONModule;

    /**
     * GeoLeaf Route Layer Manager Module
     * Gestion des layers Leaflet pour les itinéraires
     */

    const _g$m = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});


    const RouteLayerManager = {};

    /**
     * Appliquer un itinéraire complet (remplacement)
     * @param {Object} context - Context object with map, layerGroup, routeLayer, options
     * @param {number[][]} coords - Coordinates array
     * @param {Function} clearCallback - Callback to clear existing routes
     * @param {Function} fireEventsCallback - Callback to fire route loaded events
     */
    RouteLayerManager.applyRoute = function (context, coords, clearCallback, fireEventsCallback) {
        if (!Array.isArray(coords)) {
            coords = [];
        }

        if (typeof clearCallback === "function") {
            clearCallback();
        }

        if (!context.routeLayer && context.layerGroup && context.map) {
            // Applique le paramètre interactiveShapes de la config
            const interactiveShapes = _g$m.GeoLeaf.Config.get('ui.interactiveShapes', false);
            const lineStyle = Object.assign({}, context.options.lineStyle, { interactive: interactiveShapes });
            context.routeLayer = _g$m.L.polyline([], lineStyle).addTo(
                context.layerGroup
            );
        }


        if (context.routeLayer) {
            context.routeLayer.setLatLngs(coords);
        }

        if (context.options.fitBoundsOnLoad && coords.length > 1 && context.map) {
            const bounds = context.routeLayer.getBounds();
            const fitOpt = {};
            if (context.options.maxZoomOnFit) {
                fitOpt.maxZoom = context.options.maxZoomOnFit;
            }
            context.map.fitBounds(bounds, fitOpt);
        }

        if (typeof fireEventsCallback === "function") {
            fireEventsCallback(coords);
        }
    };

    /**
     * Ajouter un waypoint manuel
     * @param {L.LayerGroup} layerGroup - Layer group
     * @param {number[]} latlng - Coordinates [lat, lng]
     * @param {Object} waypointStyle - Waypoint style
     */
    RouteLayerManager.addWaypoint = function (layerGroup, latlng, waypointStyle) {
        if (!layerGroup) return;
        const interactiveShapes = _g$m.GeoLeaf.Config.get('ui.interactiveShapes', false);
        const style = Object.assign({}, waypointStyle, { interactive: interactiveShapes });
        _g$m.L.circleMarker(latlng, style).addTo(layerGroup);
    };

    /**
     * Ajouter un segment manuel
     * @param {L.Polyline} routeLayer - Route polyline
     * @param {number[][]} coords - Coordinates to add
     */
    RouteLayerManager.addSegment = function (routeLayer, coords) {
        if (!routeLayer) return;
        const current = routeLayer.getLatLngs();
        routeLayer.setLatLngs([...current, ...coords]);
    };

    /**
     * Émet les événements "geoleaf:route:loaded" (Leaflet + DOM)
     * @param {L.Map} map - Leaflet map
     * @param {L.Polyline} routeLayer - Route polyline
     * @param {number[][]} coords - Coordinates
     */
    RouteLayerManager.fireRouteLoadedEvents = function (map, routeLayer, coords) {
        // Événement Leaflet sur la carte
        try {
            if (map && typeof map.fire === "function") {
                map.fire("geoleaf:route:loaded", {
                    coords,
                    layer: routeLayer,
                    source: "geoleaf.route"
                });
            }
        } catch (e) {
            Log.warn(
                "[GeoLeaf.Route] Impossible d'émettre l'événement Leaflet geoleaf:route:loaded.",
                e
            );
        }

        // CustomEvent DOM
        if (typeof document !== "undefined" && typeof document.dispatchEvent === "function") {
            const detail = {
                coords: Array.isArray(coords) ? coords.slice() : [],
                map: map,
                layer: routeLayer,
                source: "geoleaf.route"
            };

            try {
                if (typeof CustomEvent === "function") {
                    const event = new CustomEvent("geoleaf:route:loaded", { detail });
                    document.dispatchEvent(event);
                } else {
                    const legacyEvent = document.createEvent("CustomEvent");
                    legacyEvent.initCustomEvent(
                        "geoleaf:route:loaded",
                        true,
                        true,
                        detail
                    );
                    document.dispatchEvent(legacyEvent);
                }
            } catch (err) {
                Log.warn(
                    "[GeoLeaf.Route] Impossible d'émettre le CustomEvent geoleaf:route:loaded.",
                    err
                );
            }
        }
    };

    /**
     * GeoLeaf Route Loaders Module
     * Chargement d'itinéraires depuis différentes sources (GPX, GeoJSON, Config)
     */


    const RouteLoaders = {};

    /**
     * Charger un itinéraire GeoJSON (LineString)
     * @param {Object} geojson - Objet GeoJSON
     * @param {Function} applyRouteCallback - Callback pour appliquer les coordonnées
     */
    RouteLoaders.loadGeoJSON = function (geojson, applyRouteCallback) {
        if (!geojson || !geojson.type) {
            Log.error("[GeoLeaf.Route] GeoJSON invalide.");
            return;
        }

        let coords = [];

        if (geojson.type === "Feature" && geojson.geometry.type === "LineString") {
            coords = geojson.geometry.coordinates.map((c) => [c[1], c[0]]);
        } else if (geojson.type === "LineString") {
            coords = geojson.coordinates.map((c) => [c[1], c[0]]);
        } else {
            Log.warn("[GeoLeaf.Route] Format GeoJSON non géré.");
        }

        if (typeof applyRouteCallback === "function") {
            applyRouteCallback(coords);
        }
    };

    /**
     * Extraire un tableau de [lat, lng] à partir d'un item de cfg.routes.
     * @param {Object} route - Route data
     * @returns {number[][]} Coordinates array
     */
    RouteLoaders.extractCoordsFromRouteItem = function (route) {
        // Cas 1 : tableau direct de [lat, lng]
        if (Array.isArray(route.geometry) && route.geometry.length > 0) {
            if (
                Array.isArray(route.geometry[0]) &&
                typeof route.geometry[0][0] === "number" &&
                typeof route.geometry[0][1] === "number"
            ) {
                return route.geometry.map((pair) => [pair[0], pair[1]]);
            }

            // Cas 2 : GeoJSON-like dans un tableau
            if (
                route.geometry[0] &&
                typeof route.geometry[0] === "object" &&
                route.geometry[0].type === "LineString" &&
                Array.isArray(route.geometry[0].coordinates)
            ) {
                return route.geometry[0].coordinates.map((c) => [c[1], c[0]]);
            }
        }

        // Cas 3 : objet GeoJSON LineString
        if (
            route.geometry &&
            typeof route.geometry === "object" &&
            route.geometry.type === "LineString" &&
            Array.isArray(route.geometry.coordinates) &&
            route.geometry.coordinates.length > 0
        ) {
            return route.geometry.coordinates.map((c) => [c[1], c[0]]);
        }

        // Cas 4 : objet GeoJSON MultiLineString - fusionner tous les segments
        if (
            route.geometry &&
            typeof route.geometry === "object" &&
            route.geometry.type === "MultiLineString" &&
            Array.isArray(route.geometry.coordinates) &&
            route.geometry.coordinates.length > 0
        ) {
            // Prendre le premier segment (linéaire le plus long) ou fusionner tous
            const allCoords = route.geometry.coordinates.reduce((acc, segment) => {
                if (Array.isArray(segment) && segment.length > 0) {
                    return acc.concat(segment.map((c) => [c[1], c[0]]));
                }
                return acc;
            }, []);

            if (allCoords.length > 0) {
                return allCoords;
            }
        }

        // Aucune géométrie valide trouvée - DEBUG au lieu de WARN
        // car il peut y avoir des features sans coordonnées valides
        return [];
    };

    /**
     * GeoLeaf Route Popup Builder Module
     * Construction des popups/tooltips et panneau latéral pour les itinéraires.
     * Délègue le rendu au module _ContentBuilder centralisé.
     *
     * @module route/popup-builder
     * @version 2.0.0
     */

    const _g$l =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    const RoutePopupBuilder = {};

    // Perf 6.1.6: Module-level cache for taxonomy lookups (invalidated on profile change)
    const _taxonomyCache = { profileId: null, categories: null, icons: null };

    /**
     * Retourne le cache taxonomy, rafraîchi si le profil a changé
     * @returns {{ categories: Object, icons: Object }}
     * @private
     */
    function _getTaxonomyCache() {
        const Config = _g$l.GeoLeaf.Config;
        if (!Config || typeof Config.getActiveProfile !== "function") {
            return { categories: {}, icons: {} };
        }
        const profile = Config.getActiveProfile() || {};
        const profileId = profile.id || null;
        if (_taxonomyCache.profileId !== profileId) {
            _taxonomyCache.profileId = profileId;
            _taxonomyCache.categories = profile?.taxonomy?.categories || {};
            _taxonomyCache.icons = profile?.icons || {};
        }
        return _taxonomyCache;
    }

    // ========================================
    //   UTILITAIRES
    // ========================================

    /**
     * Récupère le ContentBuilder (Assemblers).
     * Les fonctions buildPopupHTML / buildTooltipHTML sont sur le sous-module Assemblers.
     * @returns {Object|null}
     */
    function getContentBuilder$1() {
        return _g$l.GeoLeaf._ContentBuilder?.Assemblers || null;
    }

    /**
     * Récupère le Normalizer
     * @returns {Object|null}
     */
    function getNormalizer() {
        return _g$l.GeoLeaf._Normalizer || null;
    }

    // escapeHtml imported directly from security/index.js (A3 — DEAD-01)

    /**
     * Convertit une route en POI normalisé
     * @param {Object} route - Données de la route
     * @returns {Object} POI normalisé
     */
    function convertRouteToPOI(route) {
        const Normalizer = getNormalizer();
        if (Normalizer && typeof Normalizer.normalizeFromRoute === "function") {
            return Normalizer.normalizeFromRoute(route);
        }

        // Fallback: conversion manuelle
        const attrs = route.attributes || {};
        return {
            id: route.id,
            sourceType: "route",
            geometryType: "LineString",
            title: route.label || route.name || "Itinéraire",
            description: attrs.description || route.description || "",
            lat: null,
            lng: null,
            categoryId: attrs.categoryId || null,
            subCategoryId: attrs.subCategoryId || null,
            attributes: {
                ...attrs,
                label: route.label || route.name,
                photo: attrs.photo,
                distance_km: attrs.distance_km,
                duration_min: attrs.duration_min,
                difficulty: attrs.difficulty,
                tags: attrs.tags,
            },
            rawData: route,
        };
    }

    // ========================================
    //   CONFIGURATION
    // ========================================

    /**
     * Récupère la configuration de popup pour les routes
     * @returns {Array|null}
     */
    function getRoutePopupConfig() {
        const Config = _g$l.GeoLeaf.Config;
        if (Config && typeof Config.getActiveProfile === "function") {
            const profile = Config.getActiveProfile();
            if (profile?.panels?.route?.popup?.detailPopup) {
                return profile.panels.route.popup.detailPopup;
            }
        }
        return null;
    }

    /**
     * Récupère la configuration du layout pour le side panel des routes
     * @returns {Array|null}
     */
    function getRouteLayoutConfig() {
        const Config = _g$l.GeoLeaf.Config;
        if (Config && typeof Config.getActiveProfile === "function") {
            const profile = Config.getActiveProfile();
            if (profile?.panels?.route?.layout) {
                return profile.panels.route.layout;
            }
        }
        return null;
    }

    // ========================================
    //   TOOLTIP
    // ========================================

    /**
     * Ajoute un tooltip à une polyline d'itinéraire
     * @param {L.Polyline} polyline - Polyline Leaflet
     * @param {Object} route - Données de l'itinéraire
     */
    RoutePopupBuilder.addRouteTooltip = function (polyline, route) {
        const label = route.label || route.name || "Itinéraire";

        polyline.bindTooltip(escapeHtml(label), {
            sticky: true,
            className: "gl-route-tooltip",
        });
    };

    // ========================================
    //   POPUP
    // ========================================

    /**
     * Ajoute un popup à une polyline d'itinéraire
     * @param {L.Polyline} polyline - Polyline Leaflet
     * @param {Object} route - Données de l'itinéraire
     * @param {Object} _routeModule - Référence au module GeoLeaf.Route (réservé pour usage futur)
     */
    RoutePopupBuilder.addRoutePopup = function (polyline, route, _routeModule) {
        const popupContent = RoutePopupBuilder.buildRoutePopupContent(route);
        polyline.bindPopup(popupContent, { maxWidth: 300 });

        // Attacher le handler pour le bouton "Voir plus"
        polyline.on("popupopen", () => {
            Log.info && Log.info("[Route Popup] Popup opened for route:", route.id);
            setTimeout(() => {
                const selector = '.gl-poi-popup__link[data-route-id="' + route.id + '"]';
                const linkEl = document.querySelector(selector);
                if (linkEl && !linkEl._geoleafClickBound) {
                    linkEl._geoleafClickBound = true;
                    linkEl.addEventListener("click", (e) => {
                        e.preventDefault();
                        RoutePopupBuilder.openRouteSidePanel(route);
                    });
                }
            }, 50);
        });
    };

    /**
     * Construit le contenu HTML d'un popup pour une route
     * @param {Object} route - Données de l'itinéraire
     * @returns {string} Contenu HTML
     */
    RoutePopupBuilder.buildRoutePopupContent = function (route) {
        const ContentBuilder = getContentBuilder$1();
        const config = getRoutePopupConfig();
        const routeAsPoi = convertRouteToPOI(route);

        // Utiliser ContentBuilder si disponible et configuré
        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === "function" && config) {
            return ContentBuilder.buildPopupHTML(routeAsPoi, config, {
                resolveCategoryDisplay: null,
            });
        }

        // Fallback: construction manuelle du popup
        return buildFallbackRoutePopup(route);
    };

    /**
     * Construit un popup de route par défaut (fallback)
     * @param {Object} route - Données de l'itinéraire
     * @returns {string} HTML du popup
     */
    function buildFallbackRoutePopup(route) {
        const attrs = route.attributes || {};
        const label = escapeHtml(route.label || route.name || "Itinéraire");
        const description = escapeHtml(attrs.description || route.description || "");
        const photo = attrs.photo || route.photo || null;
        const routeId = escapeHtml(String(route.id || ""));

        // Résolution des icônes depuis la taxonomie (Perf 6.1.6: cache module-level)
        const categoryId = attrs.categoryId || null;
        const subCategoryId = attrs.subCategoryId || null;

        const taxCache = _getTaxonomyCache();
        const categories = taxCache.categories;
        const iconsConfig = taxCache.icons;
        const catData = categoryId ? categories[categoryId] : null;
        const subCatData = catData && subCategoryId ? catData.subcategories?.[subCategoryId] : null;

        const iconId =
            subCatData?.icon || catData?.icon || iconsConfig.defaultIcon || "activity-generic";
        const colorFill = subCatData?.colorFill || catData?.colorFill || "#666666";
        const colorStroke = subCatData?.colorStroke || catData?.colorStroke || "#222222";

        // Construction de l'icône
        let iconHtml = "";
        {
            const iconPrefix = iconsConfig.symbolPrefix || "gl-poi-cat-";
            const iconIdNormalized = String(iconId).trim().toLowerCase().replace(/\s+/g, "-");
            const symbolId = iconPrefix + iconIdNormalized;

            iconHtml =
                '<svg class="gl-poi-popup__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24">' +
                '<circle cx="12" cy="12" r="10" fill="' +
                colorFill +
                '" stroke="' +
                colorStroke +
                '" stroke-width="1.5"/>' +
                '<svg x="4" y="4" width="16" height="16"><use href="#' +
                symbolId +
                '" style="color: #ffffff"/></svg>' +
                "</svg>";
        }

        // Métadonnées (distance, durée, difficulté)
        let metaText = "";
        const metaItems = [];
        if (attrs.distance_km) {
            metaItems.push("📏 " + attrs.distance_km + " km");
        }
        if (attrs.duration_min) {
            metaItems.push("⏱️ " + attrs.duration_min + " min");
        }
        if (attrs.difficulty) {
            const diffLabels = { easy: "Facile", medium: "Moyen", hard: "Difficile" };
            metaItems.push("⚡ " + (diffLabels[attrs.difficulty] || attrs.difficulty));
        }
        if (metaItems.length > 0) {
            metaText = '<p class="gl-poi-popup__meta-text">' + metaItems.join(" • ") + "</p>";
        }

        // Tags
        const tagBadges = [];
        if (Array.isArray(attrs.tags)) {
            attrs.tags.forEach((tag) => {
                if (tag && typeof tag === "string") {
                    tagBadges.push(
                        '<span class="gl-poi-badge gl-poi-badge--tag">' + escapeHtml(tag) + "</span>"
                    );
                }
            });
        }

        // Construction du popup
        return (
            '<div class="gl-poi-popup">' +
            (photo
                ? '<div class="gl-poi-popup__photo"><img src="' +
                  photo +
                  '" alt="' +
                  label +
                  '" /></div>'
                : "") +
            '<div class="gl-poi-popup__body">' +
            '<div class="gl-poi-popup__title-wrapper">' +
            '<h3 class="gl-poi-popup__title">' +
            iconHtml +
            '<span class="gl-poi-popup__title-text">' +
            label +
            "</span></h3>" +
            "</div>" +
            (description ? '<p class="gl-poi-popup__desc">' + description + "</p>" : "") +
            metaText +
            (tagBadges.length
                ? '<div class="gl-poi-popup__badges">' + tagBadges.join("") + "</div>"
                : "") +
            '<a class="gl-poi-popup__link" href="#" data-route-id="' +
            routeId +
            '">Voir plus >>></a>' +
            "</div>" +
            "</div>"
        );
    }

    // ========================================
    //   SIDE PANEL
    // ========================================

    /**
     * Ouvre le panneau latéral avec les détails d'un itinéraire
     * @param {Object} route - Données de l'itinéraire
     */
    RoutePopupBuilder.openRouteSidePanel = function (route) {
        // Vérifier que le module POI est disponible
        if (!_g$l.GeoLeaf.POI || typeof _g$l.GeoLeaf.POI.openSidePanelWithLayout !== "function") {
            Log.warn &&
                Log.warn(
                    "[Route Popup] Cannot open side panel: POI.openSidePanelWithLayout not available"
                );
            return;
        }

        const attrs = route.attributes || {};
        const layout = getRouteLayoutConfig();

        // Construire les métadonnées
        const metadata = [];
        if (attrs.distance_km) {
            metadata.push("📏 Distance : " + attrs.distance_km + " km");
        }
        if (attrs.duration_min) {
            metadata.push("⏱️ Durée : " + attrs.duration_min + " minutes");
        }
        if (attrs.difficulty) {
            const diffLabels = { easy: "Facile", medium: "Moyen", hard: "Difficile" };
            metadata.push("⚡ Difficulté : " + (diffLabels[attrs.difficulty] || attrs.difficulty));
        }

        // Transformer la route en structure POI pour le rendu
        const routeAsPoi = {
            id: route.id,
            label: route.label || route.name,
            title: route.label || route.name,
            name: route.label || route.name,
            description: attrs.description || route.description,
            attributes: {
                ...attrs,
                metadata: metadata.length > 0 ? metadata : null,
                photo: attrs.photo,
                mainImage: attrs.photo,
                description: attrs.description,
                shortDescription: attrs.description,
                description_long: attrs.description_long,
                longDescription: attrs.description_long,
                categoryId: attrs.categoryId,
                subCategoryId: attrs.subCategoryId,
                difficulty: attrs.difficulty,
                distance_km: attrs.distance_km,
                duration_min: attrs.duration_min,
                tags: attrs.tags,
                link: attrs.link,
            },
        };

        // Ouvrir le panneau latéral
        _g$l.GeoLeaf.POI.openSidePanelWithLayout(routeAsPoi, layout);
    };

    /**
     * GeoLeaf Route Style Resolver Module
     * Résolution des styles d'itinéraires (couleurs, endpoints)
     */


    const RouteStyleResolver = {};

    /**
     * Détermine la couleur d'un itinéraire selon la priorité :
     *  1. colorRoute de la sous-catégorie (si définie)
     *  2. colorRoute de la catégorie (si définie)
     *  3. couleur par défaut de routeConfig.default.color
     *
     * @param {Object} route - L'itinéraire
     * @param {Object} profile - Le profil actif
     * @param {Object} routeConfigDefault - La config par défaut (defaultSettings.routeConfig.default)
     * @returns {string|null} La couleur à utiliser ou null
     */
    RouteStyleResolver.getRouteColor = function (route, profile, routeConfigDefault) {
        if (!route || !route.attributes) {
            return routeConfigDefault?.color || null;
        }

        const attrs = route.attributes;
        const categoryId = attrs.categoryId;
        const subCategoryId = attrs.subCategoryId;

        // Récupérer la taxonomie du profil
        const taxonomy = profile?.taxonomy?.categories || {};


        // 1. Vérifier colorRoute de la sous-catégorie
        if (categoryId && subCategoryId) {
            const category = taxonomy[categoryId];
            if (category && category.subcategories) {
                const subCategory = category.subcategories[subCategoryId];
                if (subCategory && subCategory.colorRoute) {
                    return subCategory.colorRoute;
                }
            }
        }

        // 2. Vérifier colorRoute de la catégorie
        if (categoryId) {
            const category = taxonomy[categoryId];
            if (category && category.colorRoute) {
                return category.colorRoute;
            }
        }

        // 3. Couleur par défaut
        return routeConfigDefault?.color || null;
    };

    /**
     * Calcule le style final d'un itinéraire en combinant :
     *  - le style par défaut du module,
     *  - la config par défaut du profil (defaultSettings.routeConfig.default),
     *  - la couleur basée sur la taxonomie (colorRoute),
     *  - les surcharges au niveau de l'itinéraire (properties.*).
     *
     * @param {Object} route - L'itinéraire
     * @param {Object} activeProfile - Le profil actif
     * @param {Object} routeConfigDefault - Config par défaut du profil
     * @param {Object} defaultStyle - Style par défaut du module
     * @returns {Object} Style final résolu
     */
    RouteStyleResolver.resolveRouteStyle = function (route, activeProfile, routeConfigDefault, defaultStyle) {
        const finalStyle = Object.assign({}, defaultStyle || {});

        // 1) Appliquer le style par défaut du profil (routeConfig.default)
        if (routeConfigDefault && typeof routeConfigDefault === "object") {
            Object.assign(finalStyle, routeConfigDefault);
        }

        // 2) Couleur basée sur la taxonomie (subcategory > category > default)
        const taxonomyColor = RouteStyleResolver.getRouteColor(route, activeProfile, routeConfigDefault);
        if (taxonomyColor) {
            finalStyle.color = taxonomyColor;
        }

        // 3) Surcharges au niveau de la route (properties.*)
        if (route.properties && typeof route.properties === "object") {
            const p = route.properties;

            if (typeof p.color === "string" && p.color.trim() !== "") {
                finalStyle.color = p.color.trim();
            }
            if (typeof p.weight === "number") {
                finalStyle.weight = p.weight;
            }
            if (typeof p.opacity === "number") {
                finalStyle.opacity = p.opacity;
            }
            if (typeof p.dashArray === "string" && p.dashArray.trim() !== "") {
                finalStyle.dashArray = p.dashArray.trim();
            }
        }

        return finalStyle;
    };

    /**
     * Calcule la configuration d'affichage des points départ / arrivée
     * en combinant :
     *  - les options par défaut du module (_options),
     *  - les endpoints définis dans le profil actif (defaultSettings.routeConfig.endpoints),
     *  - les surcharges éventuelles au niveau de l'itinéraire
     *    (properties.showStart, properties.showEnd, startStyle, endStyle).
     *
     * @param {Object} route - L'itinéraire
     * @param {Object} profileEndpoints - Config endpoints du profil
     * @param {Object} moduleOptions - Options du module Route
     * @returns {Object} Configuration des endpoints {showStart, showEnd, startStyle, endStyle}
     */
    RouteStyleResolver.resolveEndpointConfig = function (route, profileEndpoints, moduleOptions) {
        const opt = moduleOptions || {};

        const baseStartStyle =
            opt.startWaypointStyle || opt.waypointStyle || {
                radius: 6,
                color: "#ffffff",
                fillColor: "#2b7cff",
                fillOpacity: 1,
                weight: 2
            };

        const baseEndStyle =
            opt.endWaypointStyle || opt.waypointStyle || {
                radius: 6,
                color: "#ffffff",
                fillColor: "#ff7b32",
                fillOpacity: 1,
                weight: 2
            };

        const cfg = {
            showStart: typeof opt.showStart === "boolean" ? opt.showStart : true,
            showEnd: typeof opt.showEnd === "boolean" ? opt.showEnd : true,
            startStyle: Object.assign({}, baseStartStyle),
            endStyle: Object.assign({}, baseEndStyle)
        };

        // 1) Profil actif (defaultSettings.routeConfig.endpoints)
        if (profileEndpoints && typeof profileEndpoints === "object") {
            if (typeof profileEndpoints.showStart === "boolean") {
                cfg.showStart = profileEndpoints.showStart;
            }
            if (typeof profileEndpoints.showEnd === "boolean") {
                cfg.showEnd = profileEndpoints.showEnd;
            }
            if (
                profileEndpoints.start &&
                typeof profileEndpoints.start === "object"
            ) {
                Object.assign(cfg.startStyle, profileEndpoints.start);
            }
            if (profileEndpoints.end && typeof profileEndpoints.end === "object") {
                Object.assign(cfg.endStyle, profileEndpoints.end);
            }
        }

        // 2) Surcharges au niveau de l'itinéraire
        if (route && route.properties && typeof route.properties === "object") {
            const p = route.properties;

            if (typeof p.showStart === "boolean") {
                cfg.showStart = p.showStart;
            }
            if (typeof p.showEnd === "boolean") {
                cfg.showEnd = p.showEnd;
            }
            if (p.startStyle && typeof p.startStyle === "object") {
                Object.assign(cfg.startStyle, p.startStyle);
            }
            if (p.endStyle && typeof p.endStyle === "object") {
                Object.assign(cfg.endStyle, p.endStyle);
            }
        }

        return cfg;
    };

    /**
     * globals.geojson.js — Bridge UMD/ESM : B5 — geojson, route
     *
     * @see globals.js (orchestrateur)
     */


    const _g$k = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};

    _g$k.GeoLeaf = _g$k.GeoLeaf || {};

    // ── B5 assignations ──────────────────────────────────────────────────────────
    const _GeoJSONLayerManager = Object.assign({}, LayerManager$4, LayerManager$3, LayerManager$2, LayerManager$1);
    const _GeoJSONLoader = Object.assign({}, Loader$3, Loader$2, Loader$1, Loader);
    // Délégation manquante : _resolveDataFilePath n'est défini dans aucun sous-module du Loader.
    // LayerConfigManager.resolveDataFilePath résout le chemin d'un fichier de données GeoJSON.
    _GeoJSONLoader._resolveDataFilePath = LayerConfigManager.resolveDataFilePath.bind(LayerConfigManager);
    _g$k.GeoLeaf._GeoJSONShared = GeoJSONShared;
    _g$k.GeoLeaf._GeoJSONClustering = GeoJSONClustering;
    _g$k.GeoLeaf._GeoJSONFeatureValidator = FeatureValidator;
    _g$k.GeoLeaf._StyleUtils = { normalizeStyleToLeaflet };
    _g$k.GeoLeaf._GeoJSONStyleResolver = GeoJSONStyleResolver;
    _g$k.GeoLeaf._StyleRules = {
        evaluate: GeoJSONStyleResolver.evaluateStyleRules,
        operators: GeoJSONShared.STYLE_OPERATORS,
        getNestedValue: GeoJSONStyleResolver.getNestedValue
    };
    _g$k.GeoLeaf._VectorTiles = VectorTiles;
    _g$k.GeoLeaf._LayerVisibilityManager = VisibilityManager;
    _g$k.GeoLeaf._WorkerManager = WorkerManager;
    _g$k.GeoLeaf._GeoJSONLayerConfig = LayerConfigManager;
    _g$k.GeoLeaf._GeoJSONPopupTooltip = PopupTooltip;
    _g$k.GeoLeaf._GeoJSONLayerManager = _GeoJSONLayerManager;
    _g$k.GeoLeaf._GeoJSONLoader = _GeoJSONLoader;
    _g$k.GeoLeaf.GeoJSON = GeoJSONCore;
    _g$k.GeoLeaf._RouteLayerManager = RouteLayerManager;
    _g$k.GeoLeaf._RouteLoaders = RouteLoaders;
    _g$k.GeoLeaf._RoutePopupBuilder = RoutePopupBuilder;
    _g$k.GeoLeaf._RouteStyleResolver = RouteStyleResolver;

    /**
     * GeoLeaf UI Components - Module commun partagé
     * Composants d'interface réutilisables pour Legend et LayerManager
     *
     * Extrait le code commun entre:
     * - legend-renderer.js
     * - layer-manager/renderer.js
     *
     * DÉPENDANCES:
     * - Leaflet (L.DomUtil, L.DomEvent)
     * - Log (import ESM)
     *
     * EXPOSE:
     * - _UIComponents
     *
     * @module ui/components
     */


        /**
         * Module UI Components
         * @namespace _UIComponents
         * @private
         */
        const _UIComponents = {
            /**
             * Crée un accordéon
             * @param {HTMLElement} container - Conteneur parent
             * @param {Object} config - Configuration de l'accordéon
             * @param {string} config.layerId - ID de la couche
             * @param {string} config.label - Titre de l'accordéon
             * @param {boolean} config.collapsed - État initial
             * @param {boolean} config.visible - Couche visible ou non (pour grisage)
             * @param {Function} [config.onToggle] - Callback lors du toggle
             * @returns {Object} - { accordionEl, headerEl, bodyEl }
             */
            createAccordion(container, config) {
                const accordionEl = globalThis.L.DomUtil.create("div", "gl-legend__accordion", container);
                accordionEl.setAttribute("data-layer-id", config.layerId);

                if (config.collapsed) {
                    accordionEl.classList.add("gl-legend__accordion--collapsed");
                }

                // Ajouter classe inactive si la couche n'est pas visible
                if (config.visible === false) {
                    accordionEl.classList.add("gl-legend__accordion--inactive");
                }

                // Header de l'accordéon
                const headerEl = globalThis.L.DomUtil.create("div", "gl-legend__accordion-header", accordionEl);
                headerEl.setAttribute("role", "button");
                headerEl.setAttribute("tabindex", "0");
                headerEl.setAttribute("aria-expanded", !config.collapsed);

                const titleEl = globalThis.L.DomUtil.create("span", "gl-legend__accordion-title", headerEl);
                titleEl.textContent = config.label;

                const toggleEl = globalThis.L.DomUtil.create("button", "gl-legend__accordion-toggle", headerEl);
                toggleEl.type = "button";
                toggleEl.setAttribute("aria-label", "Basculer l'accordéon");
                toggleEl.textContent = config.collapsed ? "▶" : "▼";

                // Body de l'accordéon
                const bodyEl = globalThis.L.DomUtil.create("div", "gl-legend__accordion-body", accordionEl);

                // Gestionnaire de clic sur le header
                const onToggle = (ev) => {
                    // Ne rien faire si la couche est inactive
                    if (config.visible === false) {
                        if (globalThis.L && globalThis.L.DomEvent) {
                            globalThis.L.DomEvent.stopPropagation(ev);
                        }
                        ev.preventDefault();
                        return;
                    }

                    if (globalThis.L && globalThis.L.DomEvent) {
                        globalThis.L.DomEvent.stopPropagation(ev);
                    }
                    ev.preventDefault();

                    const isCollapsed = accordionEl.classList.toggle("gl-legend__accordion--collapsed");
                    toggleEl.textContent = isCollapsed ? "▶" : "▼";
                    headerEl.setAttribute("aria-expanded", !isCollapsed);

                    // Callback optionnel
                    if (typeof config.onToggle === "function") {
                        config.onToggle(config.layerId, !isCollapsed);
                    }
                };

                this.attachEventHandler(headerEl, "click", onToggle);

                return { accordionEl, headerEl, bodyEl, toggleEl };
            },

            /**
             * Rend un symbole cercle (POI/Marker)
             * @param {HTMLElement} container - Conteneur du symbole
             * @param {Object} config - Configuration du symbole
             * @returns {HTMLElement} - Élément créé
             */
            renderCircleSymbol(container, config) {
                const circleEl = globalThis.L.DomUtil.create("div", "gl-legend__circle", container);

                // Utiliser le radius transmis, sinon 24px par défaut (plus grand pour les légendes avec icônes)
                const radius = config.radius !== undefined ? config.radius : 24;
                const size = radius * 2;
                const fillColor = config.fillColor || config.color || "#3388ff";
                const strokeColor = config.color || config.borderColor || "rgba(0,0,0,0.2)";
                const strokeWidth = config.weight || 1;

                circleEl.style.width = size + "px";
                circleEl.style.height = size + "px";
                circleEl.style.backgroundColor = fillColor;
                circleEl.style.borderRadius = "50%";
                circleEl.style.border = strokeWidth + "px solid " + strokeColor;
                circleEl.style.position = "relative";
                circleEl.style.display = "flex";
                circleEl.style.alignItems = "center";
                circleEl.style.justifyContent = "center";

                if (config.fillOpacity !== undefined) {
                    circleEl.style.opacity = config.fillOpacity;
                }

                // Afficher l'icône sprite SVG si présente
                if (config.icon) {
                    // Validation de sécurité: L'ID d'icône doit être alphanumérique avec tirets/underscores seulement
                    const iconId = config.icon.startsWith('#') ? config.icon.substring(1) : config.icon;
                    if (!/^[a-zA-Z0-9_-]+$/.test(iconId)) {
                        if (Log) Log.error('[UIComponents] ID d\'icône invalide (caractères non autorisés):', config.icon);
                        return circleEl;
                    }

                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("viewBox", "0 0 24 24");
                    // Rendre l'icône à 85% du cercle pour qu'elle soit bien visible
                    svg.style.width = (size * 0.85) + "px";
                    svg.style.height = (size * 0.85) + "px";
                    svg.style.fill = config.iconColor || "currentColor";
                    svg.style.stroke = config.iconColor || "currentColor";
                    svg.style.color = "#ffffff"; // Définir la couleur de base pour currentColor
                    svg.style.pointerEvents = "none";
                    svg.style.position = "absolute";

                    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
                    // ID validé, construire le href sécurisé
                    const iconHref = '#' + iconId;
                    // Utiliser la syntaxe moderne href au lieu de xlink:href
                    use.setAttribute("href", iconHref);
                    svg.appendChild(use);
                    circleEl.appendChild(svg);

                    // Vérification d'erreur seulement si Log est disponible
                    if (Log) {
                        const spriteExists = document.querySelector('svg[data-geoleaf-sprite="profile"]');
                        if (!spriteExists) {
                            svg.setAttribute('data-sprite-missing', 'true');
                            Log.warn('[UIComponents] Icône', config.icon, 'référencée mais sprite non trouvé dans le DOM');
                        } else {
                            const symbolId = config.icon.startsWith('#') ? config.icon.substring(1) : config.icon;
                            const symbol = spriteExists.querySelector('#' + symbolId);
                            if (!symbol) {
                                svg.setAttribute('data-symbol-missing', config.icon);
                                Log.warn('[UIComponents] Symbole', config.icon, 'non trouvé dans le sprite SVG');
                            }
                        }
                    }
                }

                return circleEl;
            },

            /**
             * Rend un symbole ligne
             * @param {HTMLElement} container - Conteneur du symbole
             * @param {Object} config - Configuration du symbole
             * @returns {HTMLElement} - Élément créé
             */
            renderLineSymbol(container, config) {
                const width = config.width || 3;
                const color = config.color || "#3388ff";
                let style = config.style || "solid";
                const dashArray = config.dashArray || null;
                const outlineColor = config.outlineColor || null;
                const outlineWidth = config.outlineWidth || null;

                // Créer un SVG pour les lignes complexes (dashArray custom, tirets épais, ou avec outline)
                if (dashArray || width > 5 || (outlineColor && outlineWidth)) {
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("viewBox", "0 0 40 8");
                    svg.style.width = "40px";
                    const totalHeight = Math.max(width, 3) + (outlineWidth || 0) + 4;
                    svg.style.height = totalHeight + "px";

                    // Si outline existe, dessiner d'abord la ligne de contour
                    if (outlineColor && outlineWidth) {
                        const outlineLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        outlineLine.setAttribute("x1", "0");
                        outlineLine.setAttribute("y1", "4");
                        outlineLine.setAttribute("x2", "40");
                        outlineLine.setAttribute("y2", "4");
                        outlineLine.setAttribute("stroke", outlineColor);
                        outlineLine.setAttribute("stroke-width", width + (outlineWidth * 2));
                        outlineLine.setAttribute("stroke-linecap", "round");

                        if (config.outlineOpacity !== undefined) {
                            outlineLine.setAttribute("stroke-opacity", config.outlineOpacity);
                        }

                        svg.appendChild(outlineLine);
                    }

                    // Dessiner ensuite la ligne principale
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", "0");
                    line.setAttribute("y1", "4");
                    line.setAttribute("x2", "40");
                    line.setAttribute("y2", "4");
                    line.setAttribute("stroke", color);
                    line.setAttribute("stroke-width", width);
                    line.setAttribute("stroke-linecap", "round");

                    if (dashArray) {
                        line.setAttribute("stroke-dasharray", dashArray);
                    } else if (style === "dashed") {
                        line.setAttribute("stroke-dasharray", "8,4");
                    } else if (style === "dotted") {
                        line.setAttribute("stroke-dasharray", "2,3");
                    }

                    if (config.opacity !== undefined) {
                        line.setAttribute("stroke-opacity", config.opacity);
                    }

                    svg.appendChild(line);
                    container.appendChild(svg);
                    return svg;
                }

                // Fallback : DIV simple pour lignes basiques
                const lineEl = globalThis.L.DomUtil.create("div", "gl-legend__line", container);
                lineEl.style.width = "30px";
                lineEl.style.height = width + "px";
                lineEl.style.backgroundColor = color;

                if (style === "dashed") {
                    lineEl.style.backgroundImage = `linear-gradient(to right, ${color} 50%, transparent 50%)`;
                    lineEl.style.backgroundSize = "8px 100%";
                } else if (style === "dotted") {
                    lineEl.style.backgroundImage = `linear-gradient(to right, ${color} 30%, transparent 30%)`;
                    lineEl.style.backgroundSize = "4px 100%";
                }

                if (config.opacity !== undefined) {
                    lineEl.style.opacity = config.opacity;
                }

                return lineEl;
            },

            /**
             * Rend un symbole polygone/remplissage
             * @param {HTMLElement} container - Conteneur du symbole
             * @param {Object} config - Configuration du symbole
             * @returns {HTMLElement} - Élément créé
             */
            renderPolygonSymbol(container, config) {
                const color = config.fillColor || config.color || "#3388ff";
                const borderColor = config.borderColor || config.color || "#333";
                const borderWidth = config.weight || 1;
                const hasHatch = config.hatch && config.hatch.enabled;
                // Vérifier fillOpacity OU opacity (le generator peut utiliser l'un ou l'autre)
                let fillOpacity = config.fillOpacity !== undefined ? config.fillOpacity :
                                   (config.opacity !== undefined ? config.opacity : 1);

                // FIX: Si hatch avec renderMode="pattern_only", forcer fillOpacity=1.0
                // (même logique que layer-manager.js ligne 823-828 - doit rester synchronisé)
                if (hasHatch && config.hatch.renderMode === 'pattern_only') {
                    fillOpacity = 1.0;
                }

                // Utiliser SVG si hachures présentes OU si fillOpacity = 0 (contour seul)
                if (hasHatch || fillOpacity === 0) {
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("viewBox", "0 0 32 24");
                    svg.style.width = "32px";
                    svg.style.height = "24px";

                    // Créer le pattern de hachure SVG si nécessaire
                    if (hasHatch) {
                        const hatchCfg = config.hatch;
                        const type = hatchCfg.type || "diagonal";
                        const spacing = hatchCfg.spacingPx || 10;
                        const hatchColor = (hatchCfg.stroke && hatchCfg.stroke.color) || "#000000";
                        const hatchOpacity = (hatchCfg.stroke && hatchCfg.stroke.opacity) !== undefined ? hatchCfg.stroke.opacity : 1;
                        const hatchWidth = (hatchCfg.stroke && hatchCfg.stroke.widthPx) || 1;

                        const patternId = "hatch-legend-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
                        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                        const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");

                        pattern.setAttribute("id", patternId);
                        pattern.setAttribute("patternUnits", "userSpaceOnUse");
                        pattern.setAttribute("width", spacing);
                        pattern.setAttribute("height", spacing);

                        // Créer le contenu selon le type
                        if (type === "diagonal") {
                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", "0");
                            line.setAttribute("y1", "0");
                            line.setAttribute("x2", spacing);
                            line.setAttribute("y2", spacing);
                            line.setAttribute("stroke", hatchColor);
                            line.setAttribute("stroke-width", hatchWidth);
                            line.setAttribute("stroke-opacity", hatchOpacity);
                            pattern.appendChild(line);
                        } else if (type === "dot") {
                            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            circle.setAttribute("cx", spacing / 2);
                            circle.setAttribute("cy", spacing / 2);
                            circle.setAttribute("r", Math.max(0.3, spacing * 0.07));
                            circle.setAttribute("fill", hatchColor);
                            circle.setAttribute("fill-opacity", hatchOpacity);
                            pattern.appendChild(circle);
                        } else if (type === "cross") {
                            const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            hLine.setAttribute("x1", "0");
                            hLine.setAttribute("y1", spacing / 2);
                            hLine.setAttribute("x2", spacing);
                            hLine.setAttribute("y2", spacing / 2);
                            hLine.setAttribute("stroke", hatchColor);
                            hLine.setAttribute("stroke-width", hatchWidth);
                            hLine.setAttribute("stroke-opacity", hatchOpacity);
                            pattern.appendChild(hLine);

                            const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            vLine.setAttribute("x1", spacing / 2);
                            vLine.setAttribute("y1", "0");
                            vLine.setAttribute("x2", spacing / 2);
                            vLine.setAttribute("y2", spacing);
                            vLine.setAttribute("stroke", hatchColor);
                            vLine.setAttribute("stroke-width", hatchWidth);
                            vLine.setAttribute("stroke-opacity", hatchOpacity);
                            pattern.appendChild(vLine);
                        } else if (type === "x") {
                            const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line1.setAttribute("x1", "0");
                            line1.setAttribute("y1", "0");
                            line1.setAttribute("x2", spacing);
                            line1.setAttribute("y2", spacing);
                            line1.setAttribute("stroke", hatchColor);
                            line1.setAttribute("stroke-width", hatchWidth);
                            line1.setAttribute("stroke-opacity", hatchOpacity);
                            pattern.appendChild(line1);

                            const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line2.setAttribute("x1", spacing);
                            line2.setAttribute("y1", "0");
                            line2.setAttribute("x2", "0");
                            line2.setAttribute("y2", spacing);
                            line2.setAttribute("stroke", hatchColor);
                            line2.setAttribute("stroke-width", hatchWidth);
                            line2.setAttribute("stroke-opacity", hatchOpacity);
                            pattern.appendChild(line2);
                        }

                        defs.appendChild(pattern);
                        svg.appendChild(defs);

                        // Rectangle avec hachure
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", "1");
                        rect.setAttribute("y", "1");
                        rect.setAttribute("width", "30");
                        rect.setAttribute("height", "22");
                        rect.setAttribute("fill", `url(#${patternId})`);
                        rect.setAttribute("stroke", borderColor);
                        rect.setAttribute("stroke-width", borderWidth);
                        if (fillOpacity !== 1) {
                            rect.setAttribute("fill-opacity", fillOpacity);
                        }

                        svg.appendChild(rect);
                    } else {
                        // fillOpacity = 0 : rectangle transparent avec contour seulement
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", "1");
                        rect.setAttribute("y", "1");
                        rect.setAttribute("width", "30");
                        rect.setAttribute("height", "22");
                        rect.setAttribute("fill", "none");
                        rect.setAttribute("stroke", borderColor);
                        rect.setAttribute("stroke-width", borderWidth);

                        // Appliquer le dashArray si présent
                        if (config.dashArray) {
                            rect.setAttribute("stroke-dasharray", config.dashArray);
                        }

                        svg.appendChild(rect);
                    }

                    container.appendChild(svg);
                    return svg;
                }

                // Fallback : DIV simple avec remplissage
                const polygonEl = globalThis.L.DomUtil.create("div", "gl-legend__polygon", container);
                polygonEl.style.width = "24px";
                polygonEl.style.height = "16px";
                polygonEl.style.backgroundColor = color;
                polygonEl.style.border = borderWidth + "px solid " + borderColor;

                if (fillOpacity !== 1) {
                    polygonEl.style.opacity = fillOpacity;
                }

                return polygonEl;
            },

            /**
             * Rend un symbole étoile (rating)
             * @param {HTMLElement} container - Conteneur du symbole
             * @param {Object} config - Configuration du symbole
             * @returns {HTMLElement} - Élément créé
             */
            renderStarSymbol(container, config) {
                const starContainer = globalThis.L.DomUtil.create("div", "gl-legend__stars", container);

                const count = config.count || 5;
                const color = config.color || "#f1c40f";
                const size = config.size || 12;

                for (let i = 0; i < count; i++) {
                        const starEl = globalThis.L.DomUtil.create("span", "gl-legend__star", starContainer);
                    starEl.textContent = "★";
                    starEl.style.color = color;
                    starEl.style.fontSize = size + "px";
                }

                return starContainer;
            },

            /**
             * Rend un symbole selon son type
             * @param {HTMLElement} container - Conteneur du symbole
             * @param {Object} config - Configuration du symbole
             * @returns {HTMLElement} - Élément créé
             */
            renderSymbol(container, config) {
                // Support de la structure avec config.symbol ou directement config
                const symbolConfig = config.symbol || config;
                const symbolType = symbolConfig.type || config.type || "circle";

                switch (symbolType) {
                    case "marker":
                    case "circle":
                        return this.renderCircleSymbol(container, symbolConfig);

                    case "line":
                        return this.renderLineSymbol(container, symbolConfig);

                    case "polygon":
                    case "fill":
                        return this.renderPolygonSymbol(container, symbolConfig);

                    case "star":
                        return this.renderStarSymbol(container, symbolConfig);

                    case "icon":
                        // Icon avec URL d'image
                        if (symbolConfig.iconUrl) {
                            const imgEl = globalThis.L.DomUtil.create("img", "gl-legend__icon-img", container);
                            imgEl.src = symbolConfig.iconUrl;
                            if (symbolConfig.size) {
                                imgEl.style.width = symbolConfig.size + "px";
                                imgEl.style.height = symbolConfig.size + "px";
                            }
                            return imgEl;
                        }
                        // Icon avec sprite SVG - utiliser renderCircleSymbol qui gère déjà les sprites
                        if (symbolConfig.icon) {
                            return this.renderCircleSymbol(container, symbolConfig);
                        }
                        // Fallback vers circle
                        return this.renderCircleSymbol(container, symbolConfig);

                    default:
                        return this.renderCircleSymbol(container, symbolConfig);
                }
            },

            /**
             * Crée un bouton toggle (checkbox/switch)
             * @param {HTMLElement} container - Conteneur parent
             * @param {Object} config - Configuration du toggle
             * @param {string} [config.id] - ID du toggle
             * @param {boolean} config.isActive - État initial (alias: active)
             * @param {string} [config.className] - Classe CSS personnalisée
             * @param {string} [config.label] - Label du toggle
             * @param {string} [config.title] - Tooltip
             * @param {Function} [config.onToggle] - Callback lors du toggle
             * @returns {HTMLElement} - Élément bouton créé
             */
            createToggleButton(container, config) {
                // Support isActive ou active
                const isActive = config.isActive !== undefined ? config.isActive : config.active;
                const className = config.className || "gl-toggle-btn";

                const toggleBtn = globalThis.L.DomUtil.create(
                    "button",
                    className,
                    container
                );
                toggleBtn.type = "button";

                if (config.id) {
                    toggleBtn.setAttribute("data-toggle-id", config.id);
                }

                toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");

                if (config.title) {
                    toggleBtn.title = config.title;
                }

                if (isActive) {
                    toggleBtn.classList.add(className + "--on");
                }

                if (config.label) {
                    toggleBtn.textContent = config.label;
                }

                // Attacher le gestionnaire
                if (typeof config.onToggle === "function") {
                    const className = config.className || "gl-toggle-btn";
                    const onToggle = (ev) => {
                        if (globalThis.L && globalThis.L.DomEvent) {
                            globalThis.L.DomEvent.stopPropagation(ev);
                        }
                        ev.preventDefault();

                        const isActive = toggleBtn.classList.toggle(className + "--on");
                        toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");

                        config.onToggle(config.id, isActive, ev);
                    };

                    this.attachEventHandler(toggleBtn, "click", onToggle);
                }

                return toggleBtn;
            },

            /**
             * Attache un gestionnaire d'événements compatible Leaflet
             * @param {HTMLElement} element - Élément cible
             * @param {string} eventName - Nom de l'événement
             * @param {Function} handler - Gestionnaire
             */
            attachEventHandler(element, eventName, handler) {
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.on(element, eventName, handler);
                    if (eventName === "click") {
                        globalThis.L.DomEvent.disableClickPropagation(element);
                    }
                } else {
                    element.addEventListener(eventName, handler);
                }
            }
        };

    /**
     * Module Label Renderer pour GeoLeaf
     * Crée et gère les tooltips permanents Leaflet pour les étiquettes
     *
     * DÉPENDANCES:
     * - Leaflet (L.Tooltip, L.LatLng)
     * - GeoLeaf.Log (optionnel)
     *
     * EXPOSE:
     * - GeoLeaf._LabelRenderer
     */



    /**
     * Module Label Renderer
     * @namespace _LabelRenderer
     * @private
     */
    const _LabelRenderer = {
        /**
         * Crée les tooltips permanents pour toutes les features d'une couche
         * @param {string} layerId - ID de la couche
         * @param {L.LayerGroup} leafletLayer - Couche Leaflet (LayerGroup ou FeatureGroup)
         * @param {Object} labelConfig - Configuration des labels
         * @param {Object} style - Style des labels (extrait de currentStyle.label)
         * @param {Map} tooltipsMap - Map pour stocker les tooltips créés
         */
        createTooltipsForLayer(layerId, leafletLayer, labelConfig, style, tooltipsMap) {
            if (!leafletLayer || !labelConfig || !labelConfig.labelId) {
                if (Log) Log.warn("[LabelRenderer] Paramètres invalides pour createTooltipsForLayer", {
                    layerId,
                    hasLeafletLayer: !!leafletLayer,
                    hasLabelConfig: !!labelConfig,
                    labelId: labelConfig?.labelId,
                    labelConfigKeys: labelConfig ? Object.keys(labelConfig) : null
                });
                return;
            }

            const labelField = labelConfig.labelId;

            if (Log) Log.debug(`[LabelRenderer] Création tooltips pour ${layerId}, champ: ${labelField}`);

            // Parcourir toutes les features de la couche
            let featureCount = 0;

            leafletLayer.eachLayer((featureLayer) => {
                featureCount++;
                try {
                    this._createTooltipForFeature(
                        featureLayer,
                        labelField,
                        style,
                        tooltipsMap
                    );
                } catch (err) {
                    if (Log) Log.warn("[LabelRenderer] Erreur création tooltip:", err);
                }
            });

            if (Log) Log.debug(`[LabelRenderer] ${tooltipsMap.size} tooltips créés pour ${layerId} (${featureCount} features parcourues)`);
        },

        /**
         * Crée un marker texte (label) pour une feature
         * @private
         * @param {L.Layer} featureLayer - Layer Leaflet de la feature
         * @param {string} labelField - Nom du champ à afficher
         * @param {Object} style - Style du label
         * @param {Map} tooltipsMap - Map pour stocker le marker
         */
        _createTooltipForFeature(featureLayer, labelField, style, tooltipsMap) {
            // Récupérer les données GeoJSON de la feature
            const feature = featureLayer.feature;
            if (!feature || !feature.properties) {
                if (Log) Log.debug("[LabelRenderer] Feature ou properties manquant");
                return;
            }

            // Extraire la valeur du champ label
            const labelValue = this._extractFieldValue(feature.properties, labelField);
            if (!labelValue) {
                return;
            }

            // Récupérer la position (centre de la géométrie)
            let position = null;

            if (typeof featureLayer.getLatLng === "function") {
                // Pour les points
                position = featureLayer.getLatLng();
            } else if (typeof featureLayer.getBounds === "function") {
                // Pour les polygones (Polygon, MultiPolygon) - centre du bounding box
                // IMPORTANT: Vérifier getBounds AVANT getLatLngs car les polygones ont les deux!
                const bounds = featureLayer.getBounds();
                if (bounds && typeof bounds.getCenter === "function") {
                    position = bounds.getCenter();
                    if (Log) Log.info("[LabelRenderer] Position polygone calculée:", {
                        labelValue,
                        position: position,
                        positionType: typeof position,
                        hasLat: 'lat' in position,
                        hasLng: 'lng' in position,
                        latType: typeof position.lat,
                        lngType: typeof position.lng,
                        positionKeys: Object.keys(position)
                    });
                } else {
                    if (Log) Log.warn("[LabelRenderer] getBounds ne retourne pas getCenter pour:", labelValue);
                }
            } else if (typeof featureLayer.getLatLngs === "function") {
                // Pour les lignes - prendre le point du milieu de la ligne
                const latlngs = featureLayer.getLatLngs();
                if (latlngs && latlngs.length > 0) {
                    // Si c'est un MultiLineString ou une ligne complexe
                    const flatLatlngs = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
                    if (flatLatlngs && flatLatlngs.length > 0) {
                        const middleIndex = Math.floor(flatLatlngs.length / 2);
                        position = flatLatlngs[middleIndex];
                    }
                }
            }

            // Vérifier que position est valide
            // Note: Leaflet LatLng peut avoir lat/lng comme propriétés OU comme méthodes
            if (!position) {
                if (Log) Log.debug("[LabelRenderer] Position null pour feature, skipping label. Label:", labelValue);
                return;
            }

            const lat = typeof position.lat === 'function' ? position.lat() : position.lat;
            const lng = typeof position.lng === 'function' ? position.lng() : position.lng;

            if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                return;
            }

            // Créer un divIcon avec le texte du label
            const htmlContent = this._formatLabelContent(labelValue, style);

            const labelIcon = globalThis.L.divIcon({
                html: htmlContent,
                className: this._buildClassName(style),
                iconSize: null, // Auto-size
                iconAnchor: [0, 0] // Position relative au point
            });

            // Créer un marker avec cet icône texte
            const labelMarker = globalThis.L.marker([lat, lng], {
                icon: labelIcon,
                interactive: false, // Ne pas intercepter les clics
                keyboard: false
            });

            // Ajouter au map
            const map = Core && Core.getMap ? Core.getMap() : null;
            if (map) {
                labelMarker.addTo(map);

                // Stocker dans la map
                const featureId = feature.id || feature.properties.id || `feature_${Date.now()}_${Math.random()}`;
                tooltipsMap.set(featureId, labelMarker);
            } else {
                if (Log) Log.warn("[LabelRenderer] Carte non disponible pour", labelValue);
            }
        },

        /**
         * Extrait la valeur d'un champ depuis les propriétés
         * Supporte la notation pointée (ex: "attributes.name")
         * @private
         */
        _extractFieldValue(properties, fieldPath) {
            if (!properties || !fieldPath) return null;

            // Si pas de point, accès direct
            if (!fieldPath.includes(".")) {
                return properties[fieldPath];
            }

            // Notation pointée
            const parts = fieldPath.split(".");
            let value = properties;

            for (const part of parts) {
                if (value && typeof value === "object" && part in value) {
                    value = value[part];
                } else {
                    return null;
                }
            }

            return value;
        },

        /**
         * Parse l'offset depuis le style
         * @private
         */
        _parseOffset(offset) {
            if (!offset) return [0, 0];

            if (Array.isArray(offset) && offset.length === 2) {
                return [
                    typeof offset[0] === "number" ? offset[0] : 0,
                    typeof offset[1] === "number" ? offset[1] : 0
                ];
            }

            return [0, 0];
        },

        /**
         * Construit le nom de classe CSS pour le tooltip
         * @private
         */
        _buildClassName(style) {
            const classes = ["gl-label"];

            if (style) {
                if (style.className) {
                    classes.push(style.className);
                }

                // Ajouter des classes basées sur les propriétés de style
                if (style.variant) {
                    classes.push(`gl-label--${style.variant}`);
                }
            }

            return classes.join(" ");
        },

        /**
         * Formate le contenu du label
         * @private
         */
        _formatLabelContent(value, style) {
            if (!value) return "";

            let content = String(value);

            // Appliquer un préfixe/suffixe si défini
            if (style) {
                if (style.prefix) {
                    content = style.prefix + content;
                }
                if (style.suffix) {
                    content = content + style.suffix;
                }
            }

            // Créer le HTML du label
            const div = globalThis.document.createElement("div");
            div.className = "gl-label__content";
            div.textContent = content;

            // Appliquer les styles inline si définis
            if (style) {
                this._applyInlineStyles(div, style);
            }

            // Retourner le HTML string, pas l'élément DOM
            return div.outerHTML;
        },

        /**
         * Applique les styles inline au contenu du label
         * @private
         */
        _applyInlineStyles(element, style) {
            if (!element || !style) return;

            // Appliquer les styles de police et couleur avec setProperty + important pour forcer la priorité sur le CSS
            if (style.font) {
                if (style.font.family) {
                    // Ajouter un fallback pour assurer la lisibilité si la police demandée n'est pas disponible
                    const fontFamily = `"${style.font.family}", -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif`;
                    element.style.setProperty('font-family', fontFamily, 'important');
                }
                if (style.font.sizePt) {
                    element.style.setProperty('font-size', `${style.font.sizePt}pt`, 'important');
                }
                if (style.font.bold) {
                    element.style.setProperty('font-weight', 'bold', 'important');
                } else if (style.font.weight) {
                    // Pour améliorer la lisibilité, forcer un poids minimum de 500 si < 400
                    const weight = style.font.weight < 400 ? 500 : style.font.weight;
                    element.style.setProperty('font-weight', weight, 'important');
                }
                if (style.font.italic) {
                    element.style.setProperty('font-style', 'italic', 'important');
                }
            }

            // Appliquer la couleur du texte avec !important
            if (style.color) {
                element.style.setProperty('color', style.color, 'important');
            }

            // Appliquer l'opacité du texte
            if (style.opacity !== undefined) {
                element.style.setProperty('opacity', style.opacity, 'important');
            }

            // Appliquer le buffer (text-shadow pour contour) avec !important
            if (style.buffer && style.buffer.enabled) {
                const bufferColor = style.buffer.color || '#ffffff';
                const bufferOpacity = style.buffer.opacity !== undefined ? style.buffer.opacity : 1;
                const bufferSize = style.buffer.sizePx || 2;

                // Convertir la couleur hex + opacité en rgba
                const rgba = this._hexToRgba(bufferColor, bufferOpacity);

                // Créer un text-shadow multi-couches pour un contour plus net et visible
                const shadowParts = [];

                // Couche 1: Contour net avec de nombreux angles pour une couverture complète
                for (let angle = 0; angle < 360; angle += 30) {
                    const rad = angle * Math.PI / 180;
                    const x = Math.cos(rad) * bufferSize;
                    const y = Math.sin(rad) * bufferSize;
                    shadowParts.push(`${x.toFixed(2)}px ${y.toFixed(2)}px 0 ${rgba}`);
                }

                // Couche 2: Contour intermédiaire pour plus de densité (meilleure couverture)
                for (let angle = 15; angle < 360; angle += 30) {
                    const rad = angle * Math.PI / 180;
                    const x = Math.cos(rad) * bufferSize * 0.7;
                    const y = Math.sin(rad) * bufferSize * 0.7;
                    shadowParts.push(`${x.toFixed(2)}px ${y.toFixed(2)}px 0 ${rgba}`);
                }

                // Couche 3: Effet glow plus prononcé pour renforcer le contraste
                shadowParts.push(`0 0 ${bufferSize * 0.8}px ${rgba}`);
                shadowParts.push(`0 0 ${bufferSize * 1.5}px ${rgba}`);

                element.style.setProperty('text-shadow', shadowParts.join(', '), 'important');
            }

            // Appliquer textTransform
            if (style.textTransform) {
                element.style.setProperty('text-transform', style.textTransform, 'important');
            }
        },

        /**
         * Convertit une couleur hex en rgba
         * @private
         */
        _hexToRgba(hex, opacity) {
            if (!hex) return `rgba(0, 0, 0, ${opacity})`;

            // Enlever le # si présent
            hex = hex.replace('#', '');

            // Gérer les formats courts (#RGB) et longs (#RRGGBB)
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }

            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
    };

    /**
     * Module Labels pour GeoLeaf
     * Gestion des étiquettes flottantes sur les entités
     *
     * DÉPENDANCES:
     * - Leaflet (L.Tooltip, L.DomUtil)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf.GeoJSON (pour accéder aux layers)
     * - labels/label-renderer.js (pour le rendu des tooltips)
     * - loaders/style-loader.js (pour extraire les labels depuis les styles)
     *
     * EXPOSE:
     * - GeoLeaf.Labels
     *
     * MIGRATION V3:
     * - Les labels sont maintenant intégrés dans les fichiers style.json
     * - Plus de fichiers styleLabel.json séparés
     * - Les labels sont extraits depuis layerData.currentStyle.label
     */

    const ScaleUtils = { isScaleInRange: isScaleInRange, calculateMapScale: calculateMapScale };

    /**
     * État interne du module Labels
     * @private
     */
    const _state$1 = {
        // Map: layerId -> { enabled, config, tooltips }
        layers: new Map(),
        // Flag pour savoir si l'écouteur de zoom est attaché
        zoomListenerAttached: false
    };

    /**
     * Module Labels
     * @namespace Labels
     */
    const Labels = {
        /**
         * Initialise le système de labels
         * @param {Object} options - Options d'initialisation
         */
        init(options = {}) {
            if (Log) Log.debug("[Labels] Initialisation du module Labels");

            // Écouter les événements de chargement de couches
            this._attachLayerEvents();

            if (Log) Log.debug("[Labels] Module Labels initialisé");
        },

        /**
         * Initialise les labels pour une couche au chargement
         * Charge les labels UNIQUEMENT si:
         * - Le style contient label.enabled === true
         * - label.visibleByDefault === true
         * - La couche est visible
         *
         * POINT D'ENTRÉE UNIQUE pour l'initialisation au chargement
         * @param {string} layerId - ID de la couche
         */
        initializeLayerLabels(layerId) {
            if (!layerId) return;

            const layerData = this._getLayerData(layerId);
            if (!layerData) return;

            // D'ABORD masquer les labels existants pour réinitialiser lors du changement de style
            this._hideLabelsForLayer(layerId);

            // Réinitialiser l'état interne des labels pour cette couche
            _state$1.layers.delete(layerId);

            // Vérifier si le style a des labels activés
            if (layerData.currentStyle?.label?.enabled !== true) {
                if (Log) Log.debug("[Labels.initialize] Style sans labels ou labels désactivés pour", layerId);
                return;
            }

            // Vérifier visibleByDefault
            const visibleByDefault = layerData.currentStyle.label.visibleByDefault === true;

            if (!visibleByDefault) {
                if (Log) Log.debug("[Labels.initialize] Labels désactivés par défaut pour", layerId);
                // Toujours initialiser la config, mais sans les afficher
                return this.enableLabels(layerId, {}, false);
            }

            // Afficher les labels uniquement si couche visible ET visibleByDefault = true
            const isLayerVisible = layerData._visibility?.current === true;
            if (!isLayerVisible) {
                if (Log) Log.debug("[Labels.initialize] Labels configurés mais couche invisible pour", layerId);
                // Initialiser la config sans afficher
                return this.enableLabels(layerId, {}, false);
            }

            if (Log) Log.debug("[Labels.initialize] Initialisation labels visibles pour", layerId);
            return this.enableLabels(layerId, {}, true);
        },

        /**
         * Active les labels pour une couche
         * Les labels sont extraits depuis le style actuel de la couche (layerData.currentStyle.label)
         * @param {string} layerId - ID de la couche
         * @param {Object} labelConfig - Configuration des labels depuis layer.json (legacy, peut être vide)
         * @param {boolean} showImmediately - Si true, affiche les labels immédiatement (visibleByDefault)
         * @returns {Promise<void>}
         */
        async enableLabels(layerId, labelConfig = {}, showImmediately = true) {
            if (!layerId) {
                if (Log) Log.warn("[Labels] enableLabels: layerId manquant");
                return;
            }

            // VÉRIFICATION: Détecter les références obsolètes à styleFile
            if (labelConfig && labelConfig.styleFile) {
                const errorMessage =
                    `❌ CONFIGURATION OBSOLÈTE DÉTECTÉE\n` +
                    `═══════════════════════════════════════════════════════\n` +
                    `La couche "${layerId}" utilise une référence obsolète à un fichier\n` +
                    `de labels séparé via "labelConfig.styleFile".\n\n` +
                    `GeoLeaf ne supporte plus les fichiers de labels séparés (styleLabel.json).\n` +
                    `Les labels doivent être intégrés dans les fichiers de style.\n\n` +
                    `Valeur détectée: ${labelConfig.styleFile}\n` +
                    `Couche: ${layerId}\n\n` +
                    `Action requise:\n` +
                    `1. Supprimez la propriété "labels.styleFile" de la configuration\n` +
                    `2. Les labels sont maintenant extraits depuis layerData.currentStyle.label\n` +
                    `3. Consultez docs/STYLE_FORMAT_SPEC.md pour la syntaxe\n` +
                    `═══════════════════════════════════════════════════════`;

                console.error(errorMessage);
                throw new Error(`Configuration obsolète: labels.styleFile détecté dans la couche ${layerId}`);
            }

            if (Log) Log.debug("[Labels] Préparation labels pour", layerId, "showImmediately:", showImmediately);

            try {
                // Récupérer le style actuel de la couche pour extraire les labels intégrés
                const layerData = this._getLayerData(layerId);
                let labelStyleConfig = null;

                if (layerData && layerData.currentStyle && layerData.currentStyle.label) {
                    // Labels intégrés dans le style
                    const integratedLabel = layerData.currentStyle.label;

                    if (integratedLabel.enabled === true) {
                        labelStyleConfig = integratedLabel;

                        // IMPORTANT: Copier aussi labelScale depuis le style
                        if (layerData.currentStyle.labelScale) {
                            labelStyleConfig.labelScale = layerData.currentStyle.labelScale;
                        }

                        if (Log) {
                            Log.debug("[Labels] Labels intégrés détectés pour", layerId);
                            Log.debug("[Labels] labelScale:", labelStyleConfig.labelScale);
                        }
                    } else {
                        if (Log) Log.debug("[Labels] Labels intégrés désactivés (enabled=false) pour", layerId);
                        return;
                    }
                } else {
                    // Pas de labels intégrés dans le style - vérifier config legacy
                    if (labelConfig && labelConfig.enabled && labelConfig.labelId) {
                        // Utiliser la config legacy du fichier de config de la couche
                        labelStyleConfig = {
                            enabled: true,
                            field: labelConfig.labelId,
                            font: labelConfig.font || {
                                family: "Arial",
                                sizePt: 10,
                                weight: 50,
                                bold: false,
                                italic: false
                            },
                            color: labelConfig.color || "#000000",
                            opacity: labelConfig.opacity || 1.0,
                            buffer: labelConfig.buffer || { enabled: false },
                            background: labelConfig.background || { enabled: false },
                            offset: labelConfig.offset || { distancePx: 0 }
                        };
                        if (Log) Log.debug("[Labels] Utilisation config legacy pour", layerId);
                    } else {
                        // Pas de labels du tout
                        if (Log) Log.debug("[Labels] Aucun label configuré pour", layerId);
                        return;
                    }
                }

                // Stocker la configuration (enabled détermine si on affiche)
                // showImmediately est déterminé par visibleByDefault du style en priorité
                const effectiveShowImmediately = labelStyleConfig.visibleByDefault !== undefined
                    ? labelStyleConfig.visibleByDefault
                    : showImmediately;

                _state$1.layers.set(layerId, {
                    enabled: effectiveShowImmediately, // true si visibleByDefault, false sinon
                    config: labelConfig, // Configuration legacy (minZoom, maxZoom, etc.)
                    labelStyle: labelStyleConfig, // Configuration de style extraite du style
                    tooltips: new Map() // Map: featureId -> L.Marker
                });

                // Vérifier si la couche est visible avant de créer les labels
                let shouldShowLabels = effectiveShowImmediately;

                // Vérifier l'état de visibilité de la couche dans GeoJSON
                if (layerData) {
                    // Utiliser _visibility.current pour vérifier l'état réel
                    const isLayerVisible = layerData._visibility && layerData._visibility.current === true;
                    shouldShowLabels = effectiveShowImmediately && isLayerVisible;

                    if (effectiveShowImmediately && !isLayerVisible) {
                        if (Log) Log.debug("[Labels] Labels configurés pour affichage mais couche invisible:", layerId);
                    }
                }

                // Créer les markers seulement si la couche est visible ET showImmediately
                if (shouldShowLabels) {
                    await this._createLabelsForLayer(layerId);
                }

                // Attacher l'écouteur de zoom si ce n'est pas déjà fait
                this._ensureZoomListener();

                if (Log) Log.debug("[Labels] Config labels préparée pour", layerId, "visible:", showImmediately);
            } catch (err) {
                if (Log) Log.error("[Labels] Erreur préparation labels:", err);
                console.error("[Labels] Stack trace:", err.stack);
            }
        },

        /**
         * Désactive les labels pour une couche
         * @param {string} layerId - ID de la couche
         */
        disableLabels(layerId) {
            if (!layerId) return;

            const layerState = _state$1.layers.get(layerId);
            if (!layerState) return;

            if (Log) Log.debug("[Labels] Désactivation des labels pour", layerId);

            // Supprimer tous les tooltips
            if (layerState.tooltips) {
                layerState.tooltips.forEach(tooltip => {
                    try {
                        if (tooltip && tooltip.remove) {
                            tooltip.remove();
                        }
                    } catch (e) {
                        // Ignore
                    }
                });
                layerState.tooltips.clear();
            }

            // Marquer comme désactivé
            layerState.enabled = false;

            if (Log) Log.debug("[Labels] Labels désactivés pour", layerId);
        },

        /**
         * Cache temporairement les labels d'une couche sans changer l'état enabled
         * Utilisé quand la couche est désactivée mais qu'on veut garder la config
         * @param {string} layerId - ID de la couche
         * @private
         */
        _hideLabelsForLayer(layerId) {
            if (!layerId) return;

            const layerState = _state$1.layers.get(layerId);
            if (!layerState) return;

            if (Log) Log.debug("[Labels] Masquage temporaire des labels pour", layerId);

            // Supprimer tous les markers de la map
            if (layerState.tooltips) {
                layerState.tooltips.forEach(tooltip => {
                    try {
                        if (tooltip && tooltip.remove) {
                            tooltip.remove();
                        }
                    } catch (e) {
                        // Ignore
                    }
                });
                layerState.tooltips.clear();
            }

            // NE PAS changer layerState.enabled - on garde la config
            if (Log) Log.debug("[Labels] Labels masqués (enabled reste:", layerState.enabled, ")");
        },

        /**
         * Bascule l'affichage des labels pour une couche
         * @param {string} layerId - ID de la couche
         * @returns {boolean} Nouvel état (true = activé)
         */
        toggleLabels(layerId) {
            if (!layerId) return false;

            const layerState = _state$1.layers.get(layerId);
            if (!layerState) return false;

            // VÉRIFICATION CRITIQUE: Le style actuel doit autoriser les labels
            const layerData = this._getLayerData(layerId);
            const currentLabelEnabled = layerData?.currentStyle?.label?.enabled === true;

            if (!currentLabelEnabled) {
                return false;
            }

            if (layerState.enabled) {
                // Désactiver : masquer sans perdre la config
                this._hideLabelsForLayer(layerId);
                layerState.enabled = false;
                return false;
            } else {
                // Activer : changer l'état et rafraîchir (refreshLabels vérifiera la visibilité)
                layerState.enabled = true;
                this.refreshLabels(layerId);
                return true;
            }
        },

        /**
         * Vérifie si la config labels existe pour une couche
         * @param {string} layerId - ID de la couche
         * @returns {boolean}
         */
        hasLabelConfig(layerId) {
            return _state$1.layers.has(layerId);
        },

        /**
         * Vérifie si les labels sont actifs pour une couche
         * @param {string} layerId - ID de la couche
         * @returns {boolean}
         */
        areLabelsEnabled(layerId) {
            const layerState = _state$1.layers.get(layerId);
            return layerState ? layerState.enabled : false;
        },

        /**
         * Rafraîchit les labels d'une couche (après zoom, filtre, etc.)
         * @param {string} layerId - ID de la couche
         */
        refreshLabels(layerId) {
            if (!layerId) return;

            const layerState = _state$1.layers.get(layerId);
            if (!layerState || !layerState.enabled) return;

            // Vérifier si la couche est visible avant de créer les labels
            // Priorité: visibilité de couche prime sur les paramètres d'échelle
            const layerData = this._getLayerData(layerId);
            if (!layerData || !layerData._visibility || !layerData._visibility.current) {
                if (Log) Log.debug("[Labels] Couche invisible, skip refresh pour", layerId);
                return;
            }

            if (Log) Log.debug("[Labels] Rafraîchissement des labels pour", layerId);

            // Supprimer les anciens tooltips
            if (layerState.tooltips) {
                layerState.tooltips.forEach(tooltip => {
                    try {
                        if (tooltip && tooltip.remove) tooltip.remove();
                    } catch (e) {
                        // Ignore
                    }
                });
                layerState.tooltips.clear();
            }

            // Recréer les tooltips
            this._createLabelsForLayer(layerId);
        },

        /**
         * Crée les tooltips permanents pour toutes les features d'une couche
         * @private
         * @param {string} layerId - ID de la couche
         * @returns {Promise<void>}
         */
        async _createLabelsForLayer(layerId) {
            const layerState = _state$1.layers.get(layerId);
            if (!layerState || !layerState.enabled) {
                if (Log) Log.debug("[Labels] _createLabelsForLayer: layerState non trouvé ou désactivé pour", layerId);
                return;
            }

            // PRIORITÉ: Vérifier la visibilité de la couche AVANT les calculs d'échelle
            const layerData = this._getLayerData(layerId);
            if (!layerData || !layerData._visibility || !layerData._visibility.current) {
                if (Log) Log.debug("[Labels] Couche invisible, abandon création labels pour", layerId);
                return;
            }

            if (!layerData.layer) {
                if (Log) Log.warn("[Labels] Couche GeoJSON non trouvée:", layerId);
                return;
            }

            const { config, labelStyle } = layerState;

            if (Log) Log.debug("[Labels] Création labels pour", layerId, "labelStyle:", labelStyle);

            // Vérifier l'échelle actuelle si labelScale est défini
            const map = Core && Core.getMap ? Core.getMap() : null;

            if (map && labelStyle.labelScale) {
                const { minScale, maxScale } = labelStyle.labelScale;

                if (minScale !== null || maxScale !== null) {
                    // Calculer l'échelle actuelle de la carte
                    const currentScale = this._calculateMapScale(map);

                    if (Log) Log.debug("[Labels] Vérification échelle:", {
                        currentScale,
                        minScale,
                        maxScale,
                        visible: this._isScaleInRange(currentScale, minScale, maxScale)
                    });

                    if (!this._isScaleInRange(currentScale, minScale, maxScale)) {
                        if (Log) Log.debug("[Labels] Échelle hors limites pour", layerId, `(échelle: 1:${currentScale})`);
                        return;
                    }
                }
            } else if (map && config.minZoom !== undefined && config.maxZoom !== undefined) {
                // Fallback sur minZoom/maxZoom legacy
                const currentZoom = map.getZoom();
                if (currentZoom < config.minZoom || currentZoom > config.maxZoom) {
                    if (Log) Log.debug("[Labels] Zoom hors limites pour", layerId);
                    return;
                }
            }

            // Créer les tooltips via le renderer
            if (_LabelRenderer) {
                // Adapter le format nouveau (field) vers ancien (labelId) pour le renderer
                const rendererConfig = {
                    labelId: labelStyle.field || config.labelId,
                    minZoom: config.minZoom,
                    maxZoom: config.maxZoom
                };

                if (Log) Log.debug("[Labels] Appel renderer avec:", {
                    layerId,
                    labelId: rendererConfig.labelId,
                    hasLayer: !!layerData.layer,
                    hasStyle: !!labelStyle
                });

                _LabelRenderer.createTooltipsForLayer(
                    layerId,
                    layerData.layer,
                    rendererConfig,
                    labelStyle, // Passe le style de label extrait du style actuel
                    layerState.tooltips
                );

                if (Log) Log.debug("[Labels] Renderer terminé, tooltips créés:", layerState.tooltips.size);
            } else {
                if (Log) Log.error("[Labels] GeoLeaf._LabelRenderer non disponible!");
            }
        },

        /**
         * Récupère les données de la couche depuis GeoLeaf.GeoJSON
         * @private
         * @param {string} layerId - ID de la couche
         * @returns {Object|null} Layer data ou null si non trouvé
         */
        _getLayerData(layerId) {
            if (!GeoJSONCore || typeof GeoJSONCore.getLayerById !== "function") {
                if (Log) Log.warn("[Labels] GeoLeaf.GeoJSON non disponible");
                return null;
            }

            return GeoJSONCore.getLayerById(layerId);
        },

        /**
         * S'assure que l'écouteur de zoom est attaché
         * @private
         */
        _ensureZoomListener() {
            if (_state$1.zoomListenerAttached) return;

            const map = Core && Core.getMap ? Core.getMap() : null;
            if (map) {
                map.on('zoomend', () => {
                    const zoom = map.getZoom();
                    if (Log) Log.debug("[Labels] Zoom changé:", zoom);
                    this._handleZoomChange({ zoom: zoom });
                });
                _state$1.zoomListenerAttached = true;
                if (Log) Log.debug("[Labels] Écouteur zoom attaché à la carte");
            } else {
                if (Log) Log.warn("[Labels] Carte non disponible pour attacher l'écouteur de zoom");
            }
        },

        /**
         * Attache les écouteurs d'événements pour les couches
         * @private
         */
        _attachLayerEvents() {
            // Les écouteurs de zoom sont maintenant attachés dans _ensureZoomListener()

            // Écouter les événements personnalisés (si disponibles)
            if (typeof globalThis.addEventListener === "function") {
                // Écouter les événements de chargement de couches
                globalThis.addEventListener("geoleaf:layer-loaded", (evt) => {
                    if (evt.detail && evt.detail.layerId) {
                        this._handleLayerLoaded(evt.detail.layerId);
                    }
                });
            }
        },

        /**
         * Gère le changement de zoom/échelle
         * @private
         */
        _handleZoomChange(detail) {
            if (!detail) return;

            const map = Core && Core.getMap ? Core.getMap() : null;
            if (!map) return;

            // Calculer l'échelle actuelle
            const currentScale = this._calculateMapScale(map);

            // Parcourir toutes les couches avec labels
            _state$1.layers.forEach((layerState, layerId) => {
                if (!layerState.enabled) return;

                // PRIORITÉ: Vérifier visibilité couche AVANT calculs d'échelle (performance)
                const layerData = this._getLayerData(layerId);
                if (!layerData || !layerData._visibility || !layerData._visibility.current) {
                    // Couche invisible - masquer labels immédiatement, ignorer échelle
                    const isShowing = layerState.tooltips && layerState.tooltips.size > 0;
                    if (isShowing) {
                        layerState.tooltips.forEach(tooltip => {
                            if (tooltip && tooltip.remove) tooltip.remove();
                        });
                        layerState.tooltips.clear();
                    }
                    return;
                }

                // Couche visible: vérifier les contraintes d'échelle
                const { labelStyle, config } = layerState;
                let shouldShow = true;

                // Vérifier avec labelScale si disponible
                if (labelStyle && labelStyle.labelScale) {
                    const { minScale, maxScale } = labelStyle.labelScale;
                    shouldShow = this._isScaleInRange(currentScale, minScale, maxScale);
                } else if (config.minZoom !== undefined && config.maxZoom !== undefined) {
                    // Fallback sur minZoom/maxZoom legacy
                    const zoom = detail.zoom !== undefined ? detail.zoom : map.getZoom();
                    const minZoom = config.minZoom;
                    const maxZoom = config.maxZoom;
                    shouldShow = zoom >= minZoom && zoom <= maxZoom;
                }

                const isShowing = layerState.tooltips && layerState.tooltips.size > 0;

                if (shouldShow && !isShowing) {
                    // Afficher les labels
                    this._createLabelsForLayer(layerId);
                } else if (!shouldShow && isShowing) {
                    // Masquer les labels
                    layerState.tooltips.forEach(tooltip => {
                        if (tooltip && tooltip.remove) tooltip.remove();
                    });
                    layerState.tooltips.clear();
                }
            });
        },

        /**
         * Gère le chargement d'une couche
         * @private
         */
        async _handleLayerLoaded(layerId) {
            const layerState = _state$1.layers.get(layerId);
            if (layerState && layerState.enabled) {
                await this._createLabelsForLayer(layerId);
            }
        },

        /**
         * Récupère l'ID du profil actif
         * @private
         */
        _getProfileId() {
            return Config.get('id') || 'default';
        },

        /**
         * Calcule l'échelle actuelle de la carte (1:X format)
         * @private
         * @param {L.Map} map - Instance de la carte Leaflet
         * @returns {number} Échelle (ex: 5000000 pour 1:5M)
         */
        // Phase 4 dedup: removed inline fallback — ScaleUtils is canonical (loaded T2)
        _calculateMapScale(map) {
            if (ScaleUtils && typeof ScaleUtils.calculateMapScale === "function") {
                return ScaleUtils.calculateMapScale(map, { logger: Log });
            }
            if (Log) Log.warn('[Labels] ScaleUtils.calculateMapScale unavailable');
            return 0;
        },

        /**
         * Vérifie si une échelle est dans la plage min/max
         * @private
         * @param {number} currentScale - Échelle actuelle (ex: 5000000)
         * @param {number|null} minScale - Échelle minimale (plus grand nombre = plus dézoomé)
         * @param {number|null} maxScale - Échelle maximale (plus petit nombre = plus zoomé)
         * @returns {boolean} True si l'échelle est dans la plage
         *
         * Logique:
         * - minScale est l'échelle la plus "large" (ex: 15000000 = 1:15M, vue d'ensemble)
         * - maxScale est l'échelle la plus "détaillée" (ex: 1000 = 1:1k, vue rapprochée)
         * - Labels visibles si: maxScale <= currentScale <= minScale
         */
        // Phase 4 dedup: removed inline fallback — ScaleUtils is canonical (loaded T2)
        _isScaleInRange(currentScale, minScale, maxScale) {
            if (ScaleUtils && typeof ScaleUtils.isScaleInRange === "function") {
                return ScaleUtils.isScaleInRange(currentScale, minScale, maxScale, Log);
            }
            if (Log) Log.warn('[Labels] ScaleUtils.isScaleInRange unavailable');
            return true; // Default: visible if ScaleUtils missing
        },

        /**
         * Nettoie toutes les ressources du module
         */
        destroy() {
            if (Log) Log.debug("[Labels] Destruction du module Labels");

            _state$1.layers.forEach((layerState, layerId) => {
                this.disableLabels(layerId);
            });

            _state$1.layers.clear();
        }
    };

    /**
     * Gestionnaire centralisé pour le bouton de label dans le Layer Manager
     *
     * RESPONSABILITÉS:
     * - Créer le bouton de label lors du premier render d'une couche
     * - Synchroniser l'état du bouton (activé/désactivé, actif/inactif)
     * - Source unique de vérité pour la logique de décision
     *
     * LOGIQUE SIMPLIFIÉE:
     * - Le bouton est TOUJOURS visible pour toutes les couches
     * - Si couche visible ET label.enabled: true → bouton cliquable
     * - Sinon → bouton désactivé (grisé)
     * - État actif/inactif selon si les labels sont actuellement affichés
     */

    // Direct ESM bindings


    /**
     * Gestionnaire de boutons de label
     */
    const LabelButtonManager = {
        /**
         * Crée le bouton de label pour une couche
         * Appelé uniquement lors du premier render du layer manager
         * @param {string} layerId - ID de la couche
         * @param {HTMLElement} controlsContainer - Conteneur des contrôles
         * @returns {HTMLElement|null} Le bouton créé ou null si échec
         */
        createButton(layerId, controlsContainer) {
            if (!layerId || !controlsContainer) {
                if (Log) Log.warn("[LabelButtonManager] createButton: paramètres manquants", {layerId, hasContainer: !!controlsContainer});
                return null;
            }

            // Vérifier si le bouton existe déjà
            const existingButton = controlsContainer.querySelector('.gl-layer-manager__label-toggle');
            if (existingButton) {
                if (Log) Log.debug("[LabelButtonManager] Bouton déjà existant pour:", layerId);
                return existingButton;
            }

            if (Log) Log.debug("[LabelButtonManager] Création du bouton pour:", layerId);

            // Créer le bouton (toujours visible, sera activé/désactivé selon label.enabled)
            const labelToggle = globalThis.L.DomUtil.create("button", "gl-layer-manager__label-toggle");
            labelToggle.type = "button";
            labelToggle.setAttribute("aria-label", "Afficher/masquer les étiquettes");
            // Désactivé par défaut jusqu'à la synchronisation
            labelToggle.disabled = true;
            labelToggle.classList.add("gl-layer-manager__label-toggle--disabled");

            const iconSpan = document.createElement("span");
            iconSpan.className = "gl-layer-manager__label-toggle-icon";
            iconSpan.textContent = "🏷️";
            labelToggle.appendChild(iconSpan);
            labelToggle.title = "Afficher/masquer les étiquettes";

            // Gestionnaire de clic
            const onLabelToggle = function (ev) {
                if (globalThis.L && globalThis.L.DomEvent) globalThis.L.DomEvent.stopPropagation(ev);
                ev.preventDefault();

                if (labelToggle.disabled) return;

                try {
                    // Vérifier que le style actuel autorise les labels
                    const layerData = GeoJSONCore?.getLayerById?.(layerId);
                    const labelEnabled = layerData?.currentStyle?.label?.enabled === true;

                    if (!labelEnabled) {
                        if (Log) Log.warn("[LabelButtonManager] Impossible d'afficher les labels: le style actuel a label.enabled=false");
                        return;
                    }

                    // Toggle les labels
                    if (Labels?.toggleLabels) {
                        const newState = Labels.toggleLabels(layerId);

                        // Mettre à jour l'état visuel du bouton IMMÉDIATEMENT
                        if (newState) {
                            labelToggle.classList.add("gl-layer-manager__label-toggle--on");
                            labelToggle.setAttribute("aria-pressed", "true");
                        } else {
                            labelToggle.classList.remove("gl-layer-manager__label-toggle--on");
                            labelToggle.setAttribute("aria-pressed", "false");
                        }
                    }
                } catch (err) {
                    if (Log) Log.warn("[LabelButtonManager] Erreur lors du toggle des labels:", err);
                }
            };

            // Attacher le gestionnaire
            _UIComponents.attachEventHandler(labelToggle, "click", onLabelToggle);

            // Insérer le bouton avant le toggle de visibilité
            const visibilityToggle = controlsContainer.querySelector('.gl-layer-manager__item-toggle');
            if (visibilityToggle) {
                controlsContainer.insertBefore(labelToggle, visibilityToggle);
            } else {
                controlsContainer.appendChild(labelToggle);
            }

            if (Log) Log.debug("[LabelButtonManager] Bouton créé avec succès:", layerId);

            return labelToggle;
        },

        /**
         * Synchronise l'état du bouton de label
         * UNIQUE POINT D'ENTRÉE pour mettre à jour le bouton
         * @param {string} layerId - ID de la couche
         */
        sync(layerId) {
            if (!layerId) return;

            // Débounce pour éviter les mises à jour trop fréquentes
            if (this._syncTimeouts && this._syncTimeouts.has(layerId)) {
                clearTimeout(this._syncTimeouts.get(layerId));
            }

            if (!this._syncTimeouts) {
                this._syncTimeouts = new Map();
            }

            const timeout = setTimeout(() => {
                this._syncTimeouts.delete(layerId);
                this._doSync(layerId);
            }, 300);

            this._syncTimeouts.set(layerId, timeout);
        },

        /**
         * Exécute la synchronisation immédiate (méthode interne)
         * @private
         */
        _doSync(layerId) {
            if (!layerId) return;

            // Trouver le bouton - chercher directement dans tout le document
            // car le Layer Manager peut recréer des éléments
            let button = document.querySelector(`[data-layer-id="${layerId}"] .gl-layer-manager__label-toggle`);

            if (!button) {
                // Fallback: chercher le layerItem et créer le bouton si nécessaire
                const layerItem = document.querySelector(`[data-layer-id="${layerId}"]`);
                if (!layerItem) {
                    if (Log) Log.debug("[LabelButtonManager] LayerItem non trouvé (pas encore rendu):", layerId);
                    return;
                }

                const controlsContainer = layerItem.querySelector('.gl-layer-manager__item-controls');
                if (controlsContainer) {
                    // Vérifier si le bouton existe déjà dans controls
                    button = controlsContainer.querySelector('.gl-layer-manager__label-toggle');
                    if (!button) {
                        if (Log) Log.debug("[LabelButtonManager] Bouton manquant dans controls, création à la volée pour:", layerId);
                        button = this.createButton(layerId, controlsContainer);
                    }
                } else {
                    if (Log) Log.debug("[LabelButtonManager] Bouton et controlsContainer non trouvés pour:", layerId);
                    return;
                }
            }

            if (!button) {
                if (Log) Log.debug("[LabelButtonManager] Bouton non trouvé après toutes tentatives:", layerId);
                return;
            }

            // Collecter l'état actuel
            const state = this._getState(layerId);

            // Appliquer la logique de décision
            this._applyState(button, state);
        },

        /**
         * Collecte l'état actuel de tous les composants
         * @private
         */
        _getState(layerId) {
            const layerData = GeoJSONCore?.getLayerById?.(layerId);

            const state = {
                layerId: layerId,
                layerExists: !!layerData,
                layerVisible: layerData?._visibility?.current === true,
                labelEnabled: layerData?.currentStyle?.label?.enabled === true,
                areLabelsActive: Labels?.areLabelsEnabled?.(layerId) || false
            };

            return state;
        },

        /**
         * Applique l'état au bouton selon la logique simplifiée
         * RÈGLES:
         * - Bouton TOUJOURS visible
         * - Si label.enabled: true ET couche visible → bouton activé
         * - Sinon → bouton désactivé (grisé)
         * - État actif/inactif selon si les labels sont affichés
         * @private
         */
        _applyState(button, state) {
            // Bouton cliquable uniquement si la couche est visible et que le style autorise les labels
            const canUseLabels = state.labelEnabled && state.layerVisible;

            if (canUseLabels) {
                // Activer le bouton
                button.disabled = false;
                button.classList.remove("gl-layer-manager__label-toggle--disabled");

                // Appliquer l'état actif/inactif
                const shouldAppearOn = state.areLabelsActive && state.layerVisible;

                if (shouldAppearOn) {
                    button.classList.add("gl-layer-manager__label-toggle--on");
                    button.setAttribute("aria-pressed", "true");
                } else {
                    button.classList.remove("gl-layer-manager__label-toggle--on");
                    button.setAttribute("aria-pressed", "false");
                }
            } else {
                // Désactiver le bouton
                button.disabled = true;
                button.classList.add("gl-layer-manager__label-toggle--disabled");
                button.classList.remove("gl-layer-manager__label-toggle--on");
                button.setAttribute("aria-pressed", "false");
            }
        },

        /**
         * Synchronise immédiatement sans debouncing
         * Utilisé pour les cas où une réponse immédiate est nécessaire
         * @param {string} layerId - ID de la couche
         */
        syncImmediate(layerId) {
            if (!layerId) return;

            // Annuler tout debounce en cours
            if (this._syncTimeouts && this._syncTimeouts.has(layerId)) {
                clearTimeout(this._syncTimeouts.get(layerId));
                this._syncTimeouts.delete(layerId);
            }

            // Exécuter immédiatement
            this._doSync(layerId);
        }
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ========================================
    //   CONSTANTES
    // ========================================

    const POI_MARKER_SIZE = CONSTANTS.POI_MARKER_SIZE || 16;
    const POI_MAX_ZOOM = CONSTANTS.POI_MAX_ZOOM || 18;

    // Icône par défaut (cercle bleu SVG en base64)
    const defaultIconUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSIjNGE5MGU1IiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPjwvc3ZnPg==";

    // ========================================
    //   ÉTAT PARTAGÉ
    // ========================================

    /**
     * État mutable partagé entre tous les sous-modules POI
     */
    const state$1 = {
        // LayerGroup Leaflet contenant tous les marqueurs POI
        poiLayerGroup: null,


        // Cluster group (si activé)
        poiClusterGroup: null,

        // Tableau des données POI chargées
        allPois: [],

        // Map pour stocker les marqueurs Leaflet par ID de POI
        poiMarkers: new Map(),

        // Configuration du module POI
        poiConfig: {},

        // Référence vers la carte Leaflet
        mapInstance: null,

        // Indicateur de chargement en cours
        isLoading: false,

        // Élément DOM pour le panneau latéral POI
        sidePanelElement: null,

        // POI actuellement affiché dans le panneau
        currentPoiInPanel: null,

        // Overlay de fond sombre pour le side panel
        sidePanelOverlay: null,

        // Index de l'image courante dans la galerie
        currentGalleryIndex: 0
    };

    // ========================================
    //   UTILITAIRES PARTAGÉS
    // ========================================

    /**
     * Helper interne : garantit qu'un maxZoom numérique est défini sur la carte.
     * Utilisé pour éviter les erreurs du plugin de clustering ("Map has no maxZoom specified").
     *
     * @param {L.Map} map - Instance de la carte Leaflet
     * @param {number} [fallback=18] - Valeur par défaut si map.options.maxZoom n'existe pas
     */
    function ensureMapMaxZoom(map, fallback = 18) {
        if (!map || !map.options) return;
        if (typeof map.options.maxZoom !== 'number' || isNaN(map.options.maxZoom)) {
            map.options.maxZoom = fallback;
        }
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POIShared = {
        // Constantes (lecture seule)
        constants: Object.freeze({
            POI_MARKER_SIZE,
            POI_MAX_ZOOM,
            defaultIconUrl
        }),

        // État mutable (accessible en lecture/écriture par sous-modules)
        state: state$1,

        // Utilitaires
        ensureMapMaxZoom,

        // ── Getters publics (8.3.1) ────────────────────────────────────────────
        /** @public Retourne le tableau de tous les POI chargés */
        getAllPois() { return state$1.allPois; },

        /** @public Retourne la couche Leaflet active pour les marqueurs POI */
        getMarkerLayer() { return state$1.markerLayer || state$1.poiClusterGroup || state$1.poiLayerGroup; },

        /** @public Retourne l'instance de la carte Leaflet */
        getMapInstance() { return state$1.mapInstance; },

        /** @public Retourne la Map des marqueurs par ID */
        getPoiMarkers() { return state$1.poiMarkers; }
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ========================================
    //   NORMALISATION POI
    // ========================================

    /**
     * Normalise un POI vers la structure standard { id, latlng, title, attributes: {...} }.
     * Transforme l'ancien format vers le nouveau format attendu par le profile.json.
     *
     * @param {object} poi - POI au format brut (ancien ou nouveau).
     * @returns {object} POI normalisé.
     */
    function normalizePoi(poi) {
        if (!poi) return null;


        const p = poi;
        // Préférer les champs "attributes" du nouveau schéma
        const attr = (p && typeof p.attributes === 'object' && p.attributes) ? p.attributes : {};
        const props = p.properties || {};

        // Helper to sanitize URLs
        const sanitizeUrl = (url) => {
            if (!url || typeof url !== 'string') return null;
            const trimmed = url.trim();
            if (trimmed.match(/^(https?:\/\/|data:image\/)/i)) {
                return trimmed;
            }
            return null;
        };

        // Helper to escape HTML - utilise Security.escapeHtml
        const escapeHtml = Security.escapeHtml || ((str) => {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        });

        // Utilise resolveField : importé depuis utils/index.js

        // Construire la structure normalisée
        const normalized = {
            id: p.id || null,
            latlng: p.latlng || null,
            // Le titre provient du champ label (nouvelle structure) ou des anciens champs
            title: escapeHtml(resolveField$1(p, 'title', 'label', 'name', 'attributes.title', 'properties.label', 'properties.name') || 'Sans nom'),
            // Préserver aussi label et name au niveau racine
            label: escapeHtml(resolveField$1(p, 'label', 'name', 'title')),
            name: escapeHtml(resolveField$1(p, 'name', 'label', 'title')),
            description: escapeHtml(resolveField$1(p, 'description', 'attributes.description')),
            // ✅ IMPORTANT: Préserver les properties originales pour la résolution de champs comme "properties.Name"
            properties: p.properties || {},
            attributes: {
                // D'abord, copier TOUS les attributs originaux pour préserver les champs spécifiques
                ...attr,
                // Puis ajouter/surcharger avec les mappings normalisés
                // Description courte : premier niveau du POI
                shortDescription: escapeHtml(resolveField$1(p, 'description', 'attributes.shortDescription', 'properties.description')),
                // Description longue : champ attributes.description_long ou anciens champs
                longDescription: escapeHtml(resolveField$1(p, 'attributes.description_long', 'description_long', 'properties.description_long', 'attributes.longDescription')),
                // Catégories : préférer attributes.categoryId puis fallback anciens champs
                categoryId: attr.categoryId || p.categoryId || p.category || props.category || null,
                subCategoryId: attr.subCategoryId || p.subCategoryId || p.sub_category || props.sub_category || null,
                // Image principale : attributes.photo ou attributes.mainImage, sinon première image de la galerie
                mainImage: sanitizeUrl(attr.photo || attr.mainImage || props.photo || (attr.gallery && attr.gallery[0]) || (p.gallery && p.gallery[0]) || null),
                // Galerie d'images : provenant de attributes.gallery ou anciens champs
                gallery: ((attr.gallery || p.gallery || props.gallery || p.images || props.images) || [])
                    .map(img => {
                        if (typeof img === 'string') return sanitizeUrl(img);
                        if (img && img.url) return sanitizeUrl(img.url);
                        return null;
                    })
                    .filter(Boolean),
                price: attr.price || p.price || props.price || null,
                // Horaires d'ouverture : attributes.opening_hours (snake_case) ou openingHours camelCase
                openingHours: attr.opening_hours || attr.openingHours || p.opening_hours || props.opening_hours || p.openingHours || props.openingHours || null,
                openingHoursTable: null, // Sera construit à partir de openingHours si nécessaire
                reviews: attr.reviews ||
                         (attr.attributes && attr.attributes.reviews) ||
                         p.reviews ||
                         props.reviews ||
                         (props.attributes && props.attributes.reviews) ||
                         null,
                // Tags : préférer attributes.tags
                tags: (attr.tags || p.tags || props.tags || [])
                    .map(t => escapeHtml(String(t))),
                // Lien / site web : attributes.link (nouveau) ou anciens champs
                website: sanitizeUrl(attr.link || attr.website || p.link || props.link || p.website || props.website || null),
                address: escapeHtml(resolveField$1(p, 'attributes.address', 'address', 'properties.address')),
                phone: escapeHtml(resolveField$1(p, 'attributes.phone', 'phone', 'properties.phone')),
                email: escapeHtml(resolveField$1(p, 'attributes.email', 'email', 'properties.email')),
                services: (attr.services || p.services || props.services || [])
                    .map(s => escapeHtml(String(s)))
            }
        };

        // Construire openingHoursTable si openingHours existe
        if (normalized.attributes.openingHours && Array.isArray(normalized.attributes.openingHours)) {
            normalized.attributes.openingHoursTable = normalized.attributes.openingHours.map(raw => {
                if (raw == null) return null;
                const text = String(raw).trim();
                if (!text) return null;

                const parts = text.split(':');
                if (parts.length > 1) {
                    const day = parts.shift().trim();
                    const rest = parts.join(':').trim();

                    let open = '';
                    let close = '';
                    const hoursParts = rest.split(/[–-]/);
                    if (hoursParts.length > 1) {
                        open = hoursParts[0].trim();
                        close = hoursParts.slice(1).join('–').trim();
                    } else {
                        open = rest;
                    }

                    return { day, open, close };
                }

                return { day: text, open: '', close: '' };
            }).filter(Boolean);
        }

        // ✅ IMPORTANT: Préserver les métadonnées de configuration de couche
        // Ces champs sont ajoutés par GeoJSON._convertFeatureToPOI
        if (poi._sidepanelConfig) {
            normalized._sidepanelConfig = poi._sidepanelConfig;
        }
        if (poi._layerConfig) {
            normalized._layerConfig = poi._layerConfig;
        }

        return normalized;
    }

    /**
     * Extrait la valeur d'un champ depuis un POI normalisé en utilisant la notation pointée.
     *
     * @param {object} normalizedPoi - POI normalisé.
     * @param {string} fieldPath - Chemin du champ (ex: "title", "attributes.gallery", "attributes.reviews.rating").
     * @returns {*} Valeur du champ ou null si introuvable.
     */
    function getFieldValue(normalizedPoi, fieldPath) {
        if (!normalizedPoi || !fieldPath) return null;

        if (Log && typeof Log.debug === 'function') {
            Log.debug("[POI.getFieldValue] Recherche fieldPath:", fieldPath, "| POI:", normalizedPoi.id);
        }

        const parts = fieldPath.split('.');
        let value = normalizedPoi;

        for (const part of parts) {
            if (value == null || typeof value !== 'object') {
                if (Log && typeof Log.debug === 'function') {
                    Log.debug("[POI.getFieldValue] Chemin interrompu à la partie:", part, "| value actuelle:", value);
                }
                return null;
            }
            value = value[part];
        }

        if (Log && typeof Log.debug === 'function') {
            Log.debug("[POI.getFieldValue] Valeur trouvée pour", fieldPath, ":", value);
        }

        // Retourner null pour les valeurs vides
        if (value === undefined || value === '' || (Array.isArray(value) && value.length === 0)) {
            if (Log && typeof Log.debug === 'function') {
                Log.debug("[POI.getFieldValue] Valeur vide ou tableau vide, retourne null");
            }
            return null;
        }

        return value;
    }

    /**
     * Extrait les coordonnées d'un POI et les normalise en [lat, lng].
     *
     * @param {object} poi - POI brut.
     * @returns {Array<number>|null} Coordonnées [lat, lng] ou null si invalides.
     */
    function extractCoordinates(poi) {
        if (!poi) return null;

        let lat, lng;

        // Format 1: poi.latlng = [lat, lng]
        if (Array.isArray(poi.latlng) && poi.latlng.length >= 2) {
            lat = poi.latlng[0];
            lng = poi.latlng[1];
        }
        // Format 2: poi.latlng = {lat, lng}
        else if (poi.latlng && typeof poi.latlng === 'object') {
            lat = poi.latlng.lat;
            lng = poi.latlng.lng || poi.latlng.lon;
        }
        // Format 3: poi.lat, poi.lng
        else if (typeof poi.lat === 'number' && typeof poi.lng === 'number') {
            lat = poi.lat;
            lng = poi.lng;
        }
        // Format 4: poi.latitude, poi.longitude
        else if (typeof poi.latitude === 'number' && typeof poi.longitude === 'number') {
            lat = poi.latitude;
            lng = poi.longitude;
        }
        // Format 5: poi.geometry.coordinates (GeoJSON)
        else if (poi.geometry && Array.isArray(poi.geometry.coordinates)) {
            // GeoJSON: [lng, lat] (inversé!)
            lng = poi.geometry.coordinates[0];
            lat = poi.geometry.coordinates[1];
        }

        // Validation
        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
            return null;
        }

        // Validation bounds
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            return null;
        }

        return [lat, lng];
    }

    /**
     * Génère un ID unique pour un POI sans ID.
     *
     * @param {object} poi - POI.
     * @returns {string} ID généré.
     */
    function generatePoiId(poi) {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 10000);
        const label = (poi.title || poi.label || poi.name || 'poi').toLowerCase().replace(/[^a-z0-9]/g, '-').substring(0, 20);
        return `poi-${label}-${timestamp}-${random}`;
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POINormalizers = {
        normalizePoi,
        getFieldValue,
        extractCoordinates,
        generatePoiId
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        // ========================================
        //   DEPENDENCY RESOLUTION (Phase 4 dedup — direct imports)
        // ========================================

        function getResolveField$3() {
            return resolveField$1;
        }

        function getEscapeHtml$3() {
            return escapeHtml;
        }

        // getActiveProfile and getLog imported from general-utils.js (Phase 4 dedup)

        // ========================================
        //   CONFIG SORTING
        // ========================================

        /**
         * Sort config array by order property (Phase 4 dedup: delegates to compareByOrder)
         * @param {Array<Object>} config - Config array with optional order property
         * @returns {Array<Object>} Sorted config array
         */
        function sortConfigByOrder(config) {
            if (!Array.isArray(config)) return [];
            return [...config].sort(compareByOrder);
        }

        // ========================================
        //   BADGE TAXONOMY RESOLUTION
        // ========================================

        /**
         * Resolve string|number} value - Raw field value
         * @returns {string} Resolved label or original value
         *
         * @typedef {Object} POI
         * @property {string} id - POI identifier
         * @property {string} title - POI title
         * @property {Object} [attributes] - POI attributes
         * @property {string} [attributes.categoryId] - Category identifier
         * @property {string} [attributes.subCategoryId] - Subcategory identifier (duplicated 3 times)
         *
         * @param {Object} poi - POI data
         * @param {string} field - Field path (e.g., 'attributes.categoryId')
         * @param {any} value - Raw field value
         * @returns {string} Resolved label or original value
         *
         * @example
         * const label = resolveBadgeLabel(
         *   { attributes: { categoryId: 'restaurant' } },
         *   'attributes.categoryId',
         *   'restaurant'
         * );
         * // Returns: "Restaurants" (from taxonomy)
         */
        function resolveBadgeLabel(poi, field, value) {
            const profile = getActiveProfile();
            const taxonomy = profile?.taxonomy;
            if (!taxonomy) return value;

            const attrs = poi.attributes || {};

            // Subcategory resolution
            if (field.includes('subCategoryId')) {
                const catId = attrs.categoryId || attrs.category;
                const catData = taxonomy.categories?.[catId];
                const subCatData = catData?.subcategories?.[value];
                return subCatData?.label || value;
            }

            // Category resolution
            if (field.includes('categoryId')) {
                const catData = taxonomy.categories?.[value];
                return catData?.label || value;
            }

            return value;
        }

        // ========================================
        //   DEFAULT TITLE EXTRACTION
        // ========================================

        /**
         * Extract default title from POI (various field names)
         * Extracted from popup/tooltip/panel renderers (duplicated 3 times)
         *
         * @param {Object} poi - POI data
         * @returns {string} POI title or 'Sans titre'
         *
         * @example
         * getDefaultTitle({ title: 'Restaurant ABC' }); // 'Restaurant ABC'
         * getDefaultTitle({ label: 'Musée' }); // 'Musée'
         * getDefaultTitle({}); // 'Sans titre'
         */
        function getDefaultTitle(poi) {
            if (!poi) return 'Sans titre';

            const resolveField = getResolveField$3();

            return poi.title ||
                   poi.label ||
                   poi.name ||
                   resolveField(poi, 'attributes.name', 'attributes.nom', 'properties.name', 'properties.nom') ||
                   'Sans titre';
        }

        // ========================================
        //   DEBUG LOGGING
        // ========================================

        // For testing purposes only
        let _testWindow = null;

        /**
         * Check if debug mode is enabled for content builder
         * Extracted from assemblers.js (repeated pattern)
         *
         * @param {string} [context='popup'] - Context identifier (popup/tooltip/panel)
         * @returns {boolean}
         */
        function isDebugEnabled(context = 'popup') {
            const win = _testWindow || (typeof window !== 'undefined' ? window : null);
            if (!win) return false;

            const debugFlags = {
                popup: win.__GEOLEAF_DEBUG_POPUP__,
                tooltip: win.__GEOLEAF_DEBUG_TOOLTIP__,
                panel: win.__GEOLEAF_DEBUG_PANEL__
            };

            return !!debugFlags[context];
        }

        /**
         * Log debug message if debug enabled
         * @param {string} context - Context identifier
         * @param {string} message - Message to log
         * @param {*} [data] - Optional data to log
         */
        function debugLog(context, message, data) {
            if (!isDebugEnabled(context)) return;

            const log = getLog();
            if (data !== undefined) {
                log.warn(`[ContentBuilder.${context}] ${message}`, data);
            } else {
                log.warn(`[ContentBuilder.${context}] ${message}`);
            }
        }

        // ========================================
        //   FIELD VALUE VALIDATION
        // ========================================

        /**
         * Check if field value is empty/invalid
         * @param {*} value - Value to check
         * @param {Object} [options] - Validation options
         * @param {boolean} [options.allowZero=true] - Allow 0 as valid value
         * @param {boolean} [options.allowEmptyArray=false] - Allow [] as valid value
         * @param {boolean} [options.allowEmptyString=false] - Allow '' as valid value
         * @returns {boolean} True if value is empty/invalid
         */
        function isEmptyValue(value, options = {}) {
            const {
                allowZero = true,
                allowEmptyArray = false,
                allowEmptyString = false
            } = options;

            // Null/undefined
            if (value === null || value === undefined) return true;

            // Zero
            if (value === 0) return !allowZero;

            // Empty string
            if (value === '') return !allowEmptyString;

            // Empty array
            if (Array.isArray(value) && value.length === 0) return !allowEmptyArray;

            return false;
        }

        /**
         * Get field value from POI and validate
         * @param {Object} poi - POI data
         * @param {string} field - Field path
         * @param {Object} [options] - Validation options
         * @returns {*|null} Field value or null if invalid
         */
        function getValidFieldValue(poi, field, options = {}) {
            const resolveField = getResolveField$3();
            const value = resolveField(poi, field);

            return isEmptyValue(value, options) ? null : value;
        }

        // ========================================
        //   HTML BUILDER UTILITIES
        // ========================================

        /**
         * Wrap content in div with className
         * @param {string} content - HTML content
         * @param {string} className - CSS class name
         * @returns {string} Wrapped HTML
         */
        function wrapInDiv$1(content, className) {
            return `<div class="${className}">${content}</div>`;
        }

        /**
         * Create badge HTML element
         * @param {string} text - Badge text
         * @param {string} [style=''] - Inline style attribute
         * @returns {string} Badge HTML
         */
        function createBadge$1(text, style = '') {
            const escapeHtml = getEscapeHtml$3();
            const escapedText = escapeHtml(text);
            const styleAttr = style ? ` style="${style}"` : '';
            return `<span class="gl-poi-badge"${styleAttr}>${escapedText}</span>`;
        }

        /**
         * Create image HTML element
         * @param {string} src - Image source URL
         * @param {string} alt - Alt text
         * @param {string} [className='gl-poi-popup__photo'] - CSS class name
         * @returns {string} Image HTML
         */
        function createImage(src, alt, className = 'gl-poi-popup__photo') {
            const escapeHtml = getEscapeHtml$3();
            const escapedSrc = escapeHtml(src);
            const escapedAlt = escapeHtml(alt);
            return `<div class="${className}"><img src="${escapedSrc}" alt="${escapedAlt}" loading="lazy" /></div>`;
        }

        /**
         * Create link HTML element
         * @param {string} href - Link URL
         * @param {string} text - Link text
         * @param {Object} [options] - Link options
         * @param {boolean} [options.external=false] - Open in new tab
         * @param {string} [options.className='gl-poi-link'] - CSS class name
         * @returns {string} Link HTML
         */
        function createLink(href, text, options = {}) {
            const escapeHtml = getEscapeHtml$3();
            const {
                external = false,
                className = 'gl-poi-link'
            } = options;

            const escapedHref = escapeHtml(href);
            const escapedText = escapeHtml(text);
            const targetAttr = external ? ' target="_blank" rel="noopener noreferrer"' : '';

            return `<a href="${escapedHref}" class="${className}"${targetAttr}>${escapedText}</a>`;
        }

        // ========================================
        //   EXPORTS
        // ========================================

        const Helpers$1 = {
            // Dependency resolution
            getResolveField: getResolveField$3,
            getEscapeHtml: getEscapeHtml$3,
            getActiveProfile,
            getLog,

            // Config sorting
            sortConfigByOrder,

            // Badge resolution
            resolveBadgeLabel,

            // Title extraction
            getDefaultTitle,

            // Debug logging
            isDebugEnabled,
            debugLog,

            // Field validation
            isEmptyValue,
            getValidFieldValue,

            // HTML builders
            wrapInDiv: wrapInDiv$1,
            createBadge: createBadge$1,
            createImage,
            createLink,

            // Test utilities (only in test environments)
            __setDebugWindow: (win) => { _testWindow = win; }
        };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    // ========================================
    //   DÉPENDANCES & HELPERS
    // ========================================

    /**
     * Phase 4 dedup: resolveField direct import wrapper
     * @returns {Function}
     */
    function getResolveField$2() {
        return resolveField$1;
    }

    /**
     * Phase 4 dedup: escapeHtml direct import wrapper
     * @returns {Function}
     */
    function getEscapeHtml$2() {
        return escapeHtml;
    }

    // getActiveProfile and getLog imported from general-utils.js (Phase 4 dedup)

    // ========================================
    //   VALIDATORS
    // ========================================

    /**
     * Valide une URL d'image en vérifiant les protocoles autorisés et la structure.
     *
     * Utilise GeoLeaf.Security.validateUrl si disponible, sinon applique une validation
     * basique avec whitelist de protocoles (https://, http://, data:image//, /, ./).
     *
     * @function validateImageUrl
     * @param {string} url - URL à valider
     * @returns {string|null} URL valide (trimmed) ou null si invalide
     *
     * @example
     * // URL HTTPS valide
     * const url1 = validateImageUrl('https://example.com/photo.jpg');
     * // Retourne: 'https://example.com/photo.jpg'
     *
     * @example
     * // Data URL valide
     * const url2 = validateImageUrl('data:image/png;base64,iVBORw0KG...');
     * // Retourne: 'data:image/png;base64,iVBORw0KG...'
     *
     * @example
     * // Chemin relatif valide
     * const url3 = validateImageUrl('/images/photo.jpg');
     * // Retourne: '/images/photo.jpg'
     *
     * @example
     * // URL invalide (protocole interdit)
     * const url4 = validateImageUrl('javascript:alert(1)');
     * // Retourne: null
     */
    function validateImageUrl(url) {
        if (!url || typeof url !== 'string') return null;

        // Utiliser le validator de GeoLeaf.Security si disponible
        try {
            return validateUrl$2(url);
        } catch (e) {
            getLog().warn('[ContentBuilder.Core] URL image invalide:', e.message);
            return null;
        }

        // Fallback : validation basique
        const trimmed = url.trim();
        if (/^https?:\/\//i.test(trimmed) ||
            /^data:image\//i.test(trimmed) ||
            trimmed.startsWith('/') ||
            trimmed.startsWith('./') ||
            trimmed.startsWith('../')) {
            return trimmed;
        }

        return null;
    }

    /**
     * Valide des coordonnées géographiques (latitude, longitude) avec support
     * de plusieurs formats d'entrée.
     *
     * Supporte:
     * - Format array: [lat, lng]
     * - Format objet: {lat: number, lng: number}
     * - Validation limites: lat ∈ [-90, 90], lng ∈ [-180, 180]
     *
     * @function validateCoordinates
     * @param {Array<number>|Object|*} value - Coordonnées à valider
     * @returns {{lat: number, lng: number}|null} Coordonnées valides ou null
     *
     * @example
     * // Format array
     * const coords1 = validateCoordinates([45.7578, 4.8320]);
     * // Retourne: { lat: 45.7578, lng: 4.8320 }
     *
     * @example
     * // Format objet
     * const coords2 = validateCoordinates({ lat: 45.7578, lng: 4.8320 });
     * // Retourne: { lat: 45.7578, lng: 4.8320 }
     *
     * @example
     * // Coordonnées invalides (hors limites)
     * const coords3 = validateCoordinates([95, 200]);
     * // Retourne: null (lat > 90, lng > 180)
     *
     * @example
     * // Format invalide
     * const coords4 = validateCoordinates('45.7578, 4.8320');
     * // Retourne: null (string non supporté)
     */
    function validateCoordinates$1(value) {
        if (value == null) return null;

        let lat, lng;

        // Format array [lat, lng]
        if (Array.isArray(value) && value.length >= 2) {
            lat = parseFloat(value[0]);
            lng = parseFloat(value[1]);
        }
        // Format objet {lat, lng}
        else if (typeof value === 'object' && value.lat !== undefined && value.lng !== undefined) {
            lat = parseFloat(value.lat);
            lng = parseFloat(value.lng);
        }
        // Format invalide
        else {
            return null;
        }

        // Validation des valeurs
        if (isNaN(lat) || isNaN(lng)) return null;
        if (lat < -90 || lat > 90) return null;
        if (lng < -180 || lng > 180) return null;

        return { lat, lng };
    }

    /**
     * Valide une valeur numérique en la convertissant si nécessaire.
     *
     * Accepte number, string convertible en number.
     * Rejette NaN, null, undefined, chaînes vides.
     *
     * @function validateNumber
     * @param {number|string|*} value - Valeur à valider
     * @returns {number|null} Nombre valide ou null si invalide
     *
     * @example
     * // Number direct
     * const num1 = validateNumber(42.5);
     * // Retourne: 42.5
     *
     * @example
     * // String convertible
     * const num2 = validateNumber('42.5');
     * // Retourne: 42.5
     *
     * @example
     * // Valeurs invalides
     * validateNumber(null);      // null
     * validateNumber('');        // null
     * validateNumber('abc');     // null
     * validateNumber(NaN);       // null
     * validateNumber(undefined); // null
     */
    function validateNumber(value) {
        if (value == null || value === '') return null;
        const num = typeof value === 'number' ? value : parseFloat(value);
        return isNaN(num) ? null : num;
    }

    /**
     * Valide un rating (note) dans l'échelle 0-5.
     *
     * Utilise validateNumber puis vérifie que la valeur est dans [0, 5].
     * Utile pour les systèmes de notation 5 étoiles.
     *
     * @function validateRating
     * @param {number|string|*} value - Rating à valider
     * @returns {number|null} Rating valide ∈ [0, 5] ou null si invalide
     *
     * @example
     * // Rating valide
     * const rating1 = validateRating(4.5);
     * // Retourne: 4.5
     *
     * @example
     * // Rating valide (limites)
     * const rating2 = validateRating(0);   // 0 (valide)
     * const rating3 = validateRating(5);   // 5 (valide)
     *
     * @example
     * // Rating invalide (hors limites)
     * const rating4 = validateRating(-1);  // null (< 0)
     * const rating5 = validateRating(6);   // null (> 5)
     * const rating6 = validateRating('excellent'); // null (non numérique)
     */
    function validateRating(value) {
        const num = validateNumber(value);
        if (num === null) return null;
        if (num < 0 || num > 5) return null;
        return num;
    }

    // ========================================
    //   BADGE RESOLVER (Taxonomie + Styles)
    // ========================================

    /**
     * Résout un badge en appliquant la taxonomie et les styleRules de la couche.
     *
     * Processus:
     * 1. Récupère la valeur via resolveField (ex: categoryId)
     * 2. Cherche le label dans taxonomy.categories ou subcategories
     * 3. Applique les couleurs depuis GeoLeaf.Helpers.StyleResolver
     * 4. Retourne { displayValue, style } pour affichage HTML
     *
     * Gère 2 types de champs:
     * - categoryId: résolution catégorie principale
     * - subCategoryId: résolution sous-catégorie (avec parent categoryId)
     *
     * @function resolveBadge
     * @param {Object} poi - POI avec attributs et _layerConfig
     * @param {Object} poi.attributes - Attributs du POI (categoryId, subCategoryId, etc.)
     * @param {Object} poi._layerConfig - Configuration de la couche (styleRules)
     * @param {string} field - Chemin du champ (ex: 'attributes.categoryId')
     * @param {string} [variant] - Variante du badge (non utilisé actuellement)
     * @returns {{displayValue: string, style: string}} Badge résolu
     * @returns {string} returns.displayValue - Label du badge (taxonomie ou valeur brute)
     * @returns {string} returns.style - CSS inline (background-color, border-color)
     *
     * @example
     * // Résolution catégorie principale
     * const badge1 = resolveBadge(
     *   { attributes: { categoryId: 'restaurant' }, _layerConfig: { id: 'pois' } },
     *   'attributes.categoryId'
     * );
     * // Retourne: {
     * //   displayValue: 'Restaurant',
     * //   style: 'background-color: #e74c3c; border-color: #c0392b;'
     * // }
     *
     * @example
     * // Résolution sous-catégorie
     * const badge2 = resolveBadge(
     *   { attributes: { categoryId: 'restaurant', subCategoryId: 'gastronomique' } },
     *   'attributes.subCategoryId'
     * );
     * // Retourne: { displayValue: 'Gastronomique', style: '...' }
     *
     * @example
     * // Valeur non mappée dans taxonomie
     * const badge3 = resolveBadge(
     *   { attributes: { categoryId: 'unknown' } },
     *   'attributes.categoryId'
     * );
     * // Retourne: { displayValue: 'unknown', style: '' }
     */
    function resolveBadge(poi, field, variant) {
        const resolveField = getResolveField$2();
        const value = resolveField(poi, field);

        if (value == null || value === '') {
            return { displayValue: '', style: '' };
        }

        const profile = getActiveProfile();
        const taxonomy = profile?.taxonomy;
        let displayValue = String(value);
        let style = '';

        // Pas de taxonomie : retour simple
        if (!taxonomy || !field) {
            return { displayValue, style };
        }

        const attrs = poi.attributes || {};

        // Phase 4 dedup: factored taxonomy label resolution
        if (field.includes('subCategoryId')) {
            const catId = attrs.categoryId || attrs.category;
            const catData = taxonomy.categories?.[catId];
            const subCatData = catData?.subcategories?.[value];
            if (subCatData?.label) displayValue = subCatData.label;
        } else if (field.includes('categoryId')) {
            const catData = taxonomy.categories?.[value];
            if (catData?.label) displayValue = catData.label;
        }

        // Phase 4 dedup: single color resolution block (was duplicated for cat + subcat)
        if (getColorsFromLayerStyle && poi._layerConfig) {
            const styleColors = getColorsFromLayerStyle(poi, poi._layerConfig.id);
            if (styleColors) {
                if (styleColors.fillColor) style += 'background-color: ' + styleColors.fillColor + ';';
                if (styleColors.color) style += 'border-color: ' + styleColors.color + ';';
            }
        }

        return { displayValue, style };
    }

    /**
     * Résout un badge pour tooltip (texte uniquement, sans styles).
     *
     * Version simplifiée de resolveBadge:
     * - Retourne uniquement le texte (displayValue)
     * - Pas de styles CSS
     * - Optimisé pour tooltips HTML limités
     *
     * Supporte également categoryId et subCategoryId avec résolution taxonomie.
     *
     * @function resolveBadgeTooltip
     * @param {Object} poi - POI avec attributs
     * @param {Object} poi.attributes - Attributs du POI
     * @param {string} field - Chemin du champ (ex: 'attributes.categoryId')
     * @returns {string} Label du badge (ou valeur brute si pas de taxonomie)
     *
     * @example
     * // Résolution catégorie avec taxonomie
     * const text1 = resolveBadgeTooltip(
     *   { attributes: { categoryId: 'restaurant' } },
     *   'attributes.categoryId'
     * );
     * // Retourne: 'Restaurant' (label taxonomie)
     *
     * @example
     * // Résolution sous-catégorie
     * const text2 = resolveBadgeTooltip(
     *   { attributes: { categoryId: 'restaurant', subCategoryId: 'gastronomique' } },
     *   'attributes.subCategoryId'
     * );
     * // Retourne: 'Gastronomique'
     *
     * @example
     * // Valeur vide
     * const text3 = resolveBadgeTooltip(
     *   { attributes: {} },
     *   'attributes.unknownField'
     * );
     * // Retourne: ''
     */
    /**
     * Phase 4 dedup: resolveBadgeTooltip delegates to resolveBadge (text only)
     */
    function resolveBadgeTooltip(poi, field) {
        const result = resolveBadge(poi, field);
        return result.displayValue;
    }

    // ========================================
    //   UTILITAIRES DE FORMATAGE
    // ========================================

    /**
     * Formate un nombre avec la locale française (séparateurs FR).
     *
     * Utilise toLocaleString('fr-FR'):
     * - Séparateur de milliers: espace (\u202f)
     * - Séparateur de décimales: virgule
     *
     * @function formatNumber
     * @param {number} num - Nombre à formater
     * @returns {string} Nombre formaté avec conventions françaises
     *
     * @example
     * // Entier
     * const str1 = formatNumber(1234567);
     * // Retourne: '1\u202f234\u202f567'
     *
     * @example
     * // Décimal
     * const str2 = formatNumber(1234.56);
     * // Retourne: '1\u202f234,56'
     *
     * @example
     * // Petit nombre
     * const str3 = formatNumber(42);
     * // Retourne: '42'
     */
    function formatNumber(num) {
        return num.toLocaleString('fr-FR');
    }

    /**
     * Formate des coordonnées géographiques en chaîne "lat, lng".
     *
     * Utilise toFixed pour contrôler la précision décimale.
     * Précision recommandée: 6 décimales (~10cm de précision).
     *
     * @function formatCoordinates
     * @param {number} lat - Latitude (∈ [-90, 90])
     * @param {number} lng - Longitude (∈ [-180, 180])
     * @param {number} [precision=6] - Nombre de décimales (1-15)
     * @returns {string} Coordonnées formatées "lat, lng"
     *
     * @example
     * // Précision par défaut (6 décimales)
     * const str1 = formatCoordinates(45.7578137, 4.8320114);
     * // Retourne: '45.757814, 4.832011'
     *
     * @example
     * // Haute précision (8 décimales)
     * const str2 = formatCoordinates(45.7578137, 4.8320114, 8);
     * // Retourne: '45.75781370, 4.83201140'
     *
     * @example
     * // Faible précision (2 décimales)
     * const str3 = formatCoordinates(45.7578137, 4.8320114, 2);
     * // Retourne: '45.76, 4.83'
     */
    function formatCoordinates(lat, lng, precision = 6) {
        return lat.toFixed(precision) + ', ' + lng.toFixed(precision);
    }

    /**
     * Formate un rating (note) au format "X.X/5".
     *
     * Utilise toFixed pour afficher le nombre de décimales souhaité.
     * Compatible avec les systèmes de notation 5 étoiles.
     *
     * @function formatRating
     * @param {number} rating - Note à formater (∈ [0, 5])
     * @param {number} [precision=1] - Nombre de décimales (0-2)
     * @returns {string} Rating formaté (ex: "4.5/5", "3/5")
     *
     * @example
     * // Précision par défaut (1 décimale)
     * const str1 = formatRating(4.567);
     * // Retourne: '4.6/5'
     *
     * @example
     * // Sans décimale
     * const str2 = formatRating(4.567, 0);
     * // Retourne: '5/5'
     *
     * @example
     * // 2 décimales
     * const str3 = formatRating(4.567, 2);
     * // Retourne: '4.57/5'
     *
     * @example
     * // Note parfaite
     * const str4 = formatRating(5);
     * // Retourne: '5.0/5'
     */
    function formatRating(rating, precision = 1) {
        return rating.toFixed(precision) + '/5';
    }

    // ========================================
    //   EXPORT
    // ========================================

    const ContentBuilderCore = {
        // Helpers dépendances
        getResolveField: getResolveField$2,
        getEscapeHtml: getEscapeHtml$2,
        getActiveProfile,
        getLog,

        // Validators
        validateImageUrl,
        validateCoordinates: validateCoordinates$1,
        validateNumber,
        validateRating,

        // Badge resolver
        resolveBadge,
        resolveBadgeTooltip,

        // Formatters
        formatNumber,
        formatCoordinates,
        formatRating
    };

    getLog().info('[GeoLeaf._ContentBuilder.Core] Module Core chargé - Helpers + Validators + Badge resolver');

    // ========================================
    //   UTILITAIRES DE DÉPENDANCES
    // ========================================

    /**
     * Phase 4 dedup: resolveField direct import wrapper
     * @returns {Function}
     */
    function getResolveField$1() {
        return resolveField$1;
    }

    /**
     * Phase 4 dedup: escapeHtml direct import wrapper
     * @returns {Function}
     */
    function getEscapeHtml$1() {
        return escapeHtml;
    }

    // getActiveProfile and getLog imported from general-utils.js (Phase 4 dedup)

    // ========================================
    //   RENDERERS PAR TYPE
    // ========================================

    /**
     * Construit un élément de type "text"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu (context: 'popup'|'tooltip'|'panel')
     * @returns {string} HTML
     */
    function renderText$1(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const escaped = escapeHtml(String(value));
        const variant = config.variant || 'default';

        if (variant === 'title') {
            // Titre avec éventuelle icône
            let iconHtml = '';
            if (options.includeIcon && options.resolveCategoryDisplay) {
                const displayConfig = options.resolveCategoryDisplay(poi);
                if (displayConfig && displayConfig.iconId) {
                    const iconsConfig = (Config && typeof Config.getIconsConfig === "function")
                        ? Config.getIconsConfig()
                        : null;
                    const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || 'gl-poi-cat-';
                    const iconIdNormalized = String(displayConfig.iconId).trim().toLowerCase().replace(/\s+/g, '-');
                    const symbolId = iconPrefix + iconIdNormalized;
                    iconHtml = '<svg class="gl-poi-popup__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24">' +
                        '<circle cx="12" cy="12" r="10" fill="' + (displayConfig.colorFill || '#666') + '" stroke="' + (displayConfig.colorStroke || '#222') + '" stroke-width="1.5"/>' +
                        '<svg x="4" y="4" width="16" height="16" viewBox="0 0 32 32"><use href="#' + symbolId + '" style="color: #ffffff"/></svg>' +
                        '</svg>';
                }
            }
            return '<h3 class="gl-poi-popup__title">' + iconHtml + '<span class="gl-poi-popup__title-text">' + escaped + '</span></h3>';
        }

        if (variant === 'short') {
            return '<p class="gl-poi-popup__desc">' + escaped + '</p>';
        }

        if (variant === 'long' || variant === 'paragraph') {
            return '<p class="gl-poi-popup__desc gl-poi-popup__desc--long">' + escaped + '</p>';
        }

        return '<p class="gl-poi-popup__desc">' + escaped + '</p>';
    }

    /**
     * Construit un élément de type "longtext"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderLongtext(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const escaped = escapeHtml(String(value));
        return '<div class="gl-content__longtext"><p>' + escaped.replace(/\n/g, '</p><p>') + '</p></div>';
    }

    /**
     * Construit un élément de type "number"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderNumber(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const numValue = typeof value === 'number' ? value : parseFloat(value);
        if (isNaN(numValue)) return '';

        // Formater le nombre
        if (formatNumber$1) {
            return formatNumber$1(numValue);
        }
        const formatted = numValue.toLocaleString('fr-FR');
        const label = config.label ? escapeHtml(config.label) : '';
        const variant = config.variant || 'default';

        if (variant === 'stat') {
            return '<div class="gl-content__stat">' +
                (label ? '<span class="gl-content__stat-label">' + label + '</span>' : '') +
                '<span class="gl-content__stat-value">' + formatted + '</span>' +
                '</div>';
        }

        return '<p class="gl-content__number">' +
            (label ? '<strong>' + label + ':</strong> ' : '') +
            formatted + '</p>';
    }

    /**
     * Construit un élément de type "metric" (KPI, statistiques avec suffixe/préfixe)
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {string} [config.field] - Chemin du champ
     * @param {string} [config.label] - Label optionnel
     * @param {string} [config.prefix] - Préfixe (ex: "+", "-")
     * @param {string} [config.suffix] - Suffixe (ex: "%", "€", " km²")
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderMetric(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const numValue = typeof value === 'number' ? value : parseFloat(value);
        if (isNaN(numValue)) return '';

        const formatted = numValue.toLocaleString('fr-FR');
        const label = config.label ? escapeHtml(config.label) : '';
        const suffix = config.suffix ? escapeHtml(config.suffix) : '';
        const prefix = config.prefix ? escapeHtml(config.prefix) : '';

        return '<p class="gl-content__metric">' +
            (label ? '<strong>' + label + ':</strong> ' : '') +
            prefix + formatted + suffix + '</p>';
    }

    /**
     * Construit un élément de type "rating" (note avec étoiles)
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderRating(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const rating = typeof value === 'number' ? value : parseFloat(value);
        if (isNaN(rating)) return '';

        const label = config.label ? escapeHtml(config.label) : '';
        const variant = config.variant || 'default';

        // Affichage des étoiles (sur 5)
        let starsHtml = '<span class="gl-rating__stars">';
        for (let i = 1; i <= 5; i++) {
            const isFilled = i <= Math.round(rating);
            starsHtml += '<span class="gl-rating__star' + (isFilled ? ' gl-rating__star--filled' : '') + '">★</span>';
        }
        starsHtml += '</span>';

        // Affichage de la note numérique
        const numericValue = rating.toFixed(1);

        if (variant === 'stat') {
            return '<div class="gl-rating gl-rating--stat">' +
                (label ? '<span class="gl-rating__label">' + label + '</span>' : '') +
                '<div class="gl-rating__content">' +
                starsHtml +
                '<span class="gl-rating__value">' + numericValue + '/5</span>' +
                '</div>' +
                '</div>';
        }

        // Variant par défaut (compact)
        return '<div class="gl-rating">' +
            (label ? '<span class="gl-rating__label">' + label + ': </span>' : '') +
            starsHtml +
            '<span class="gl-rating__value">' + numericValue + '/5</span>' +
            '</div>';
    }

    /**
     * Construit un élément de type "badge"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderBadge(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const profile = getActiveProfile();
        const taxonomy = profile?.taxonomy;
        const variant = config.variant || 'default';

        let displayValue = value;
        let style = '';

        // Résolution du label (taxonomy) et des couleurs (depuis styleRules de la couche)
        if (taxonomy && config.field) {
            const attrs = poi.attributes || {};

            if (config.field.includes('categoryId') && !config.field.includes('subCategoryId')) {
                // Catégorie principale
                const catData = taxonomy.categories?.[value];
                if (catData?.label) displayValue = catData.label;

                // Couleurs depuis les styleRules de la couche
                if (getColorsFromLayerStyle && poi._layerConfig) {
                    const styleColors = getColorsFromLayerStyle(poi, poi._layerConfig.id);
                    if (styleColors && styleColors.fillColor) {
                        style += 'background-color: ' + styleColors.fillColor + ';';
                    }
                    if (styleColors && styleColors.color) {
                        style += 'border-color: ' + styleColors.color + ';';
                    }
                }
            } else if (config.field.includes('subCategoryId')) {
                // Sous-catégorie
                const catId = attrs.categoryId || attrs.category;
                const catData = taxonomy.categories?.[catId];
                const subCatData = catData?.subcategories?.[value];

                if (subCatData?.label) displayValue = subCatData.label;

                // Couleurs depuis les styleRules de la couche
                if (getColorsFromLayerStyle && poi._layerConfig) {
                    const styleColors = getColorsFromLayerStyle(poi, poi._layerConfig.id);
                    if (styleColors && styleColors.fillColor) {
                        style += 'background-color: ' + styleColors.fillColor + ';';
                    }
                    if (styleColors && styleColors.color) {
                        style += 'border-color: ' + styleColors.color + ';';
                    }
                }
            }
        }

        const escaped = escapeHtml(String(displayValue));
        const badgeClass = 'gl-poi-badge gl-poi-badge--' + variant;

        return '<span class="' + badgeClass + '"' + (style ? ' style="' + style + '"' : '') + '>' + escaped + '</span>';
    }

    /**
     * Construit un élément de type "image"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderImage(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        // Validation basique de l'URL
        let photoUrl = null;
        try {
            photoUrl = validateUrl$2(value);
        } catch (e) {
            getLog().warn('[ContentBuilder.Shared] URL image invalide:', e.message);
            return '';
        }

        if (!photoUrl) return '';

        const alt = escapeHtml(config.label || 'Image');
        const variant = config.variant || 'default';

        if (variant === 'hero') {
            return '<div class="gl-poi-popup__photo"><img src="' + photoUrl + '" alt="' + alt + '" loading="lazy" /></div>';
        }

        return '<div class="gl-poi-popup__photo"><img src="' + photoUrl + '" alt="' + alt + '" loading="lazy" /></div>';
    }

    /**
     * Construit un élément de type "link"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderLink(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || value === '') return '';

        const label = escapeHtml(config.label || value);
        const variant = config.variant || 'default';

        if (variant === 'button') {
            return '<a href="' + escapeHtml(value) + '" target="_blank" rel="noopener noreferrer" class="gl-content__link gl-content__link--button">' + label + '</a>';
        }

        return '<a href="' + escapeHtml(value) + '" target="_blank" rel="noopener noreferrer" class="gl-content__link">' + label + '</a>';
    }

    /**
     * Construit un élément de type "list"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderList$1(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null) return '';

        const variant = config.variant || 'disc';
        let items = [];

        if (Array.isArray(value)) {
            items = value;
        } else if (typeof value === 'object') {
            // Objet clé-valeur (ex: price)
            items = Object.entries(value).map(([k, v]) => k + ': ' + v);
        } else {
            return '';
        }

        if (items.length === 0) return '';

        const listClass = 'gl-content__list gl-content__list--' + variant;
        let html = '<ul class="' + listClass + '">';
        items.forEach(item => {
            html += '<li>' + escapeHtml(String(item)) + '</li>';
        });
        html += '</ul>';

        return html;
    }

    /**
     * Construit un élément de type "table"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderTable$1(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || !Array.isArray(value) || value.length === 0) return '';

        const columns = config.columns || [];
        if (columns.length === 0) return '';

        const borders = config.borders || {};
        let tableStyle = '';
        if (borders.color) {
            tableStyle += '--gl-table-border-color: ' + borders.color + ';';
        }

        let tableClass = 'gl-content__table';
        if (borders.outer) tableClass += ' gl-content__table--border-outer';
        if (borders.row) tableClass += ' gl-content__table--border-row';
        if (borders.column) tableClass += ' gl-content__table--border-column';

        let html = '<table class="' + tableClass + '"' + (tableStyle ? ' style="' + tableStyle + '"' : '') + '>';

        // Header
        html += '<thead><tr>';
        columns.forEach(col => {
            html += '<th>' + escapeHtml(col.label || col.key) + '</th>';
        });
        html += '</tr></thead>';

        // Body
        html += '<tbody>';
        value.forEach(row => {
            html += '<tr>';
            columns.forEach(col => {
                const cellValue = typeof row === 'object' ? (row[col.key] || '') : row;
                html += '<td>' + escapeHtml(String(cellValue)) + '</td>';
            });
            html += '</tr>';
        });
        html += '</tbody></table>';

        return html;
    }

    /**
     * Construit un élément de type "tags"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderTags(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || !Array.isArray(value) || value.length === 0) return '';

        let html = '<div class="gl-content__tags">';
        value.forEach(tag => {
            if (tag && typeof tag === 'string') {
                html += '<span class="gl-content__tag">' + escapeHtml(tag) + '</span>';
            }
        });
        html += '</div>';

        return html;
    }

    /**
     * Construit un élément de type "coordinates"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderCoordinates(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null) return '';

        let lat, lng;

        if (Array.isArray(value) && value.length >= 2) {
            [lat, lng] = value;
        } else if (typeof value === 'object' && value.lat !== undefined && value.lng !== undefined) {
            lat = value.lat;
            lng = value.lng;
        } else {
            return '';
        }

        const label = config.label ? escapeHtml(config.label) : 'Coordonnées';
        const formatted = lat.toFixed(6) + ', ' + lng.toFixed(6);

        return '<div class="gl-content__coordinates">' +
            '<span class="gl-content__coordinates-label">' + label + ':</span> ' +
            '<span class="gl-content__coordinates-value">' + formatted + '</span>' +
            '</div>';
    }

    /**
     * Construit un élément de type "gallery"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderGallery$1(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || !Array.isArray(value) || value.length === 0) return '';

        let html = '<div class="gl-content__gallery">';
        value.forEach((imgUrl, index) => {
            if (imgUrl && typeof imgUrl === 'string') {
                html += '<div class="gl-content__gallery-item" data-index="' + index + '">' +
                    '<img src="' + escapeHtml(imgUrl) + '" alt="Image ' + (index + 1) + '" loading="lazy" />' +
                    '</div>';
            }
        });
        html += '</div>';

        return html;
    }

    /**
     * Construit un élément de type "reviews"
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderReviews$1(poi, config, options = {}) {
        const resolveField = getResolveField$1();
        const escapeHtml = getEscapeHtml$1();

        const value = resolveField(poi, config.field);
        if (value == null || !Array.isArray(value) || value.length === 0) return '';

        let html = '<div class="gl-content__reviews">';
        value.forEach(review => {
            if (!review) return;

            html += '<div class="gl-content__review">';

            // Rating (étoiles)
            if (review.rating !== undefined) {
                const rating = parseFloat(review.rating) || 0;
                html += '<div class="gl-content__review-rating">';
                for (let i = 1; i <= 5; i++) {
                    html += '<span class="gl-content__review-star' + (i <= rating ? ' gl-content__review-star--filled' : '') + '">★</span>';
                }
                html += '</div>';
            }

            // Texte
            if (review.text || review.comment) {
                html += '<p class="gl-content__review-text">' + escapeHtml(review.text || review.comment) + '</p>';
            }

            // Auteur et date (support des deux conventions de nommage)
            const reviewAuthor = review.author || review.authorName;
            const reviewDate   = review.date   || review.createdAt;
            if (reviewAuthor || reviewDate) {
                html += '<div class="gl-content__review-meta">';
                if (reviewAuthor) {
                    const verifiedMark = review.verified ? ' <span class="gl-content__review-verified">✓</span>' : '';
                    html += '<span class="gl-content__review-author">' + escapeHtml(reviewAuthor) + verifiedMark + '</span>';
                }
                if (reviewDate) {
                    html += '<span class="gl-content__review-date">' + escapeHtml(reviewDate) + '</span>';
                }
                html += '</div>';
            }

            html += '</div>';
        });
        html += '</div>';

        return html;
    }

    // ========================================
    //   REGISTRE DES RENDERERS
    // ========================================

    const RENDERERS = {
        text: renderText$1,
        longtext: renderLongtext,
        number: renderNumber,
        metric: renderMetric,
        rating: renderRating,
        badge: renderBadge,
        image: renderImage,
        link: renderLink,
        list: renderList$1,
        table: renderTable$1,
        tags: renderTags,
        coordinates: renderCoordinates,
        gallery: renderGallery$1,
        reviews: renderReviews$1
    };

    /**
     * Rend un élément selon son type
     * @param {Object} poi - Données du POI
     * @param {Object} config - Configuration de l'élément
     * @param {Object} options - Options de rendu
     * @returns {string} HTML
     */
    function renderItem$2(poi, config, options = {}) {
        if (!config || !config.type) return '';

        const renderer = RENDERERS[config.type];
        if (!renderer) {
            getLog().warn('[ContentBuilder.Shared] Type de rendu non supporté:', config.type);
            return '';
        }

        return renderer(poi, config, options);
    }

    // ========================================
    //   EXPORT
    // ========================================

    const ContentBuilderShared = {
        // Renderers individuels
        renderText: renderText$1,
        renderLongtext,
        renderNumber,
        renderMetric,
        renderRating,
        renderBadge,
        renderImage,
        renderLink,
        renderList: renderList$1,
        renderTable: renderTable$1,
        renderTags,
        renderCoordinates,
        renderGallery: renderGallery$1,
        renderReviews: renderReviews$1,
        renderItem: renderItem$2,

        // Utilitaires
        getResolveField: getResolveField$1,
        getEscapeHtml: getEscapeHtml$1,
        getActiveProfile,
        getLog
    };

    if (getLog().debug) {
        getLog().debug('[ContentBuilder.Shared] Renderers partagés chargés');
    }

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    // ========================================
    //   ACCÈS AUX MODULES
    // ========================================

    /**
     * Get Helpers module (centralized utilities)
     * @returns {Object}
     */
    function getHelpers() {
        return Helpers$1 || {};
    }

    function getRenderers() {
        return ContentBuilderShared || {};
    }

    // Phase 4 dedup: direct imports for resolveField, escapeHtml
    function getResolveField() {
        return resolveField$1;
    }

    function getEscapeHtml() {
        return escapeHtml;
    }

    // getActiveProfile and getLog imported from general-utils.js (Phase 4 dedup)

    function renderItem$1(poi, config, options = {}) {
        const renderers = getRenderers();
        if (renderers && renderers.renderItem) {
            return renderers.renderItem(poi, config, options);
        }
        return '';
    }

    // ========================================
    //   ASSEMBLEURS
    // ========================================

    // ========================================
    //   BUILD POPUP HTML
    // ========================================

    /**
     * Group popup sections by type (hero images, badges, other)
     * Extracted from buildPopupHTML to reduce complexity
     *
     * @private
     * @param {Array<Object>} sortedConfig - Sorted config array
     * @param {Object} poi - POI data
     * @param {Object} renderOptions - Render options
     * @returns {Array<{type: string, html?: string, items?: Array<string>}>} Grouped sections
     *
     * @typedef {Object} PopupSection
     * @property {'hero'|'badges'|'content'} type - Section type
     * @property {string} [html] - HTML content for hero/content sections
     * @property {Array<string>} [items] - Badge HTML items for badges section
     */
    function groupPopupSections(sortedConfig, poi, renderOptions) {
        const sections = [];
        let badgeGroup = [];
        // ...logs [POPUP] supprimés...
        sortedConfig.forEach((item, index) => {
            const isHeroImage = item.type === 'image' && item.variant === 'hero';
            const isBadge = item.type === 'badge';
            const nextItem = sortedConfig[index + 1];
            const nextIsBadge = nextItem && nextItem.type === 'badge';
            const itemHtml = renderItem$1(poi, item, renderOptions);
            if (isHeroImage) {
                sections.push({ type: 'hero', html: itemHtml });
            } else if (isBadge) {
                badgeGroup.push(itemHtml);
                if (!nextIsBadge) {
                    sections.push({ type: 'badges', items: [...badgeGroup] });
                    badgeGroup = [];
                }
            } else {
                sections.push({ type: 'content', html: itemHtml });
            }
        });

        return sections;
    }

    /**
     * Assemble popup HTML from grouped sections
     * Extracted from buildPopupHTML to reduce complexity
     *
     * @private
     * @param {Object} poi - POI data with id property
     * @param {Array<PopupSection>} sections - Grouped popup sections
     * @returns {string} Complete popup HTML
     */
    function assemblePopupHTML(poi, sections) {
        let html = '<div class="gl-poi-popup">';
        let inBody = false;

        sections.forEach(section => {
            if (section.type === 'hero') {
                if (inBody) {
                    html += '</div>';
                    inBody = false;
                }
                html += section.html;
            } else {
                if (!inBody) {
                    html += '<div class="gl-poi-popup__body">';
                    inBody = true;
                }

                if (section.type === 'badges') {
                    html += '<div class="gl-poi-popup__badges">';
                    section.items.forEach(badgeHtml => {
                        html += badgeHtml;
                    });
                    html += '</div>';
                } else {
                    html += section.html;
                }
            }
        });

        // Lien "Voir plus"
        if (!inBody) {
            html += '<div class="gl-poi-popup__body">';
            inBody = true;
        }
        html += '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') + '">Voir plus >>></a>';

        if (inBody) {
            html += '</div>';
        }
        html += '</div>';

        return html;
    }

    /**
     * Construit le HTML complet d'un popup avec structure et groupement de badges.
     *
     * Gère la structure HTML du popup:
     * 1. Images hero (en dehors du body)
     * 2. Body avec badges groupés + autres éléments
     * 3. Lien "Voir plus >>>" automatique
     *
     * Tri automatique par config.order, badges groupés si consécutifs.
     *
     * @function buildPopupHTML
     * @param {Object} poi - Données du POI normalisé
     * @param {Object} poi.id - ID du POI
     * @param {Object} poi.attributes - Attributs du POI
     * @param {Array<Object>} config - Configuration detailPopup (array de renderers)
     * @param {Object} config[].type - Type de renderer ('text', 'badge', 'image', etc.)
     * @param {number} config[].order - Ordre d'affichage (tri croissant)
     * @param {string} [config[].variant] - Variante (ex: 'hero' pour images)
     * @param {Object} [options={}] - Options de rendu
     * @param {Function} [options.resolveCategoryDisplay] - Résolution taxonomie personnalisée
     * @returns {string} HTML complet du popup
     *
     * @example
     * // Popup avec image hero + badges + texte
     * const html = buildPopupHTML(
     *   poi,
     *   [
     *     { type: 'image', field: 'attributes.photo', variant: 'hero', order: 1 },
     *     { type: 'badge', field: 'attributes.categoryId', order: 2 },
     *     { type: 'badge', field: 'attributes.status', order: 3 },
     *     { type: 'text', field: 'attributes.description', order: 4 }
     *   ],
     *   {}
     * );
     * // Retourne:
     * // <div class="gl-poi-popup">
     * //   <img src="..." class="gl-poi-popup__hero"> (hero en dehors du body)
     * //   <div class="gl-poi-popup__body">
     * //     <div class="gl-poi-popup__badges">
     * //       <span class="gl-poi-badge">Restaurant</span>
     * //       <span class="gl-poi-badge">Ouvert</span>
     * //     </div>
     * //     <p>Description...</p>
     * //     <a href="#" class="gl-poi-popup__link" data-poi-id="123">Voir plus >>></a>
     * //   </div>
     * // </div>
     */
    function buildPopupHTML(poi, config, options = {}) {
        // Get helpers and utilities FIRST
        const helpers = getHelpers();
        const escapeHtml = getEscapeHtml();

        if (!poi) {
            getLog().warn('[Assemblers] POI invalide pour buildPopupHTML');
            return '';
        }

        if (!config || !Array.isArray(config) || config.length === 0) {
            const title = helpers.getDefaultTitle ? helpers.getDefaultTitle(poi) : (poi.title || poi.label || poi.name || 'Sans titre');
            helpers.debugLog?.('popup', 'No config provided, using default popup');

            return '<div class="gl-poi-popup">' +
                '<div class="gl-poi-popup__body">' +
                '<h3 class="gl-poi-popup__title"><span class="gl-poi-popup__title-text">' + escapeHtml(title) + '</span></h3>' +
                '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') + '">Voir plus >>></a>' +
                '</div></div>';
        }

        // ...log supprimé ([POPUP] buildPopupHTML - config items)...

        // Use helpers for config sorting (Phase 4 dedup)
        const sortedConfig = helpers.sortConfigByOrder ? helpers.sortConfigByOrder(config) :
            [...config].sort(compareByOrder);

        const renderOptions = {
            context: 'popup',
            includeIcon: true,
            resolveCategoryDisplay: options.resolveCategoryDisplay
        };

        // ...log supprimé ([POPUP] buildPopupHTML - sorted config)...

        // Group sections and assemble HTML
        try {
            const sections = groupPopupSections(sortedConfig, poi, renderOptions);
            // ...log supprimé ([POPUP] buildPopupHTML - sections grouped)...

            const html = assemblePopupHTML(poi, sections);
            // ...log supprimé ([POPUP] buildPopupHTML - HTML length)...

            return html;
        } catch(err) {
            // ...log supprimé ([POPUP] ERROR in buildPopupHTML)...
            return '<div class="gl-poi-popup"><div class="gl-poi-popup__body">Erreur: ' + escapeHtml(err.message) + '</div></div>';
        }
    }

    /**
     * Construit le HTML d'un tooltip (texte uniquement, limité).
     *
     * Génère un tooltip simple avec valeurs textuelles séparées par " | ".
     * Pas de HTML complexe, optimisé pour tooltips Leaflet.
     *
     * Processus:
     * 1. Si pas de config => utilise title/label/name par défaut
     * 2. Sinon extrait les valeurs textuelles de chaque renderer
     * 3. Gère badge resolution via resolveBadgeTooltip
     * 4. Joint les parties avec " | "
     *
     * @function buildTooltipHTML
     * @param {Object} poi - Données du POI normalisé
     * @param {Object} poi.title - Titre par défaut
     * @param {Object} poi.attributes - Attributs du POI
     * @param {Array<Object>} config - Configuration detailTooltip (array de renderers)
     * @param {string} config[].type - Type de renderer ('text', 'badge', 'number', etc.)
     * @param {string} config[].field - Chemin du champ (ex: 'attributes.name')
     * @param {number} [config[].order] - Ordre d'affichage (tri croissant)
     * @param {Object} [options={}] - Options de rendu
     * @returns {string} Texte du tooltip (pas de HTML, texte plat)
     *
     * @example
     * // Tooltip simple sans config
     * const text1 = buildTooltipHTML({ title: 'Restaurant Le Gourmet' }, []);
     * // Retourne: 'Restaurant Le Gourmet'
     *
     * @example
     * // Tooltip avec config (name + category + rating)
     * const text2 = buildTooltipHTML(
     *   poi,
     *   [
     *     { type: 'text', field: 'attributes.name', order: 1 },
     *     { type: 'badge', field: 'attributes.categoryId', order: 2 },
     *     { type: 'number', field: 'attributes.rating', order: 3 }
     *   ]
     * );
     * // Retourne: 'Le Gourmet | Restaurant | 4.5'
     *
     * @example
     * // Tooltip avec valeurs manquantes (skipés)
     * const text3 = buildTooltipHTML(
     *   poi,
     *   [
     *     { type: 'text', field: 'attributes.name', order: 1 },
     *     { type: 'text', field: 'attributes.missingField', order: 2 }
     *   ]
     * );
     * // Retourne: 'Le Gourmet' (missingField skippé)
     */
    function buildTooltipHTML(poi, config, options = {}) {
        if (!poi) {
            getLog().warn('[Assemblers] POI invalide pour buildTooltipHTML');
            return '';
        }

        const helpers = getHelpers();
        const escapeHtml = getEscapeHtml();
        const resolveField = getResolveField();

        // Si pas de config, tooltip par défaut - use helpers
        if (!config || !Array.isArray(config) || config.length === 0) {
            const title = helpers.getDefaultTitle ? helpers.getDefaultTitle(poi) :
                (poi.title || poi.label || poi.name ||
                 resolveField(poi, 'attributes.name', 'attributes.nom', 'properties.name', 'properties.nom') ||
                 'Sans titre');
            return escapeHtml(String(title));
        }

        // Use helpers for config sorting (Phase 4 dedup)
        const sortedConfig = helpers.sortConfigByOrder ? helpers.sortConfigByOrder(config) :
            [...config].sort(compareByOrder);
        const parts = [];

        sortedConfig.forEach((item, index) => {
            if (!item || !item.type || !item.field) return;

            const value = resolveField(poi, item.field);
            if (value == null || value === '') return;

            // Pour les tooltips, on extrait juste la valeur textuelle
            if (item.type === 'text' || item.type === 'badge') {
                let displayValue = value;

                // Use helpers for badge resolution
                if (item.type === 'badge' && helpers.resolveBadgeLabel) {
                    displayValue = helpers.resolveBadgeLabel(poi, item.field, value);
                } else if (item.type === 'badge') {
                    // Fallback to inline resolution
                    const profile = getActiveProfile();
                    const taxonomy = profile?.taxonomy;
                    if (taxonomy) {
                        const attrs = poi.attributes || {};
                        if (item.field.includes('subCategoryId')) {
                            const catId = attrs.categoryId || attrs.category;
                            const catData = taxonomy.categories?.[catId];
                            const subCatData = catData?.subcategories?.[value];
                            if (subCatData?.label) displayValue = subCatData.label;
                        } else if (item.field.includes('categoryId')) {
                            const catData = taxonomy.categories?.[value];
                            if (catData?.label) displayValue = catData.label;
                        }
                    }
                }

                parts.push(escapeHtml(String(displayValue)));
            }
            else if (item.type === 'number') {
                const numValue = typeof value === 'number' ? value : parseFloat(value);
                if (!isNaN(numValue)) {
                    parts.push(numValue.toLocaleString('fr-FR'));
                }
            }
            else if (item.type === 'image') {
                // Image en tooltip : afficher en ligne
                parts.push('<img src="' + escapeHtml(value) + '" alt="" style="max-width:150px;max-height:100px;display:block;margin:4px 0;" />');
            }
            else if (item.type === 'link') {
                const label = item.label || value;
                parts.push('<a href="' + escapeHtml(value) + '" target="_blank">' + escapeHtml(label) + '</a>');
            }
        });

        if (parts.length === 0) {
            const title = poi.title || poi.label || 'Sans titre';
            return escapeHtml(String(title));
        }

        // Joindre avec contentUnion ou espace
        let result = '';
        parts.forEach((part, index) => {
            result += part;
            if (index < parts.length - 1) {
                const item = sortedConfig[index];
                if (item && item.contentUnion) {
                    result += ' ' + escapeHtml(item.contentUnion) + ' ';
                } else {
                    result += ' ';
                }
            }
        });

        return result;
    }

    /**
     * Construit les éléments DOM pour un panneau latéral (side panel / accordion).
     *
     * Génère un tableau d'objets pour chaque élément du panneau:
     * - html: HTML rendu de l'élément
     * - config: Configuration renderer originale
     * - label: Label de l'élément (pour accordéon)
     * - accordion: Si true, élément dans un accordéon
     * - defaultOpen: Si true, accordéon ouvert par défaut
     *
     * Tri automatique par config.order, éléments sans valeur skipés.
     *
     * @function buildPanelItems
     * @param {Object} poi - Données du POI normalisé
     * @param {Object} poi.attributes - Attributs du POI
     * @param {Array<Object>} config - Configuration detailLayout (array de renderers)
     * @param {string} config[].type - Type de renderer ('text', 'list', 'image', etc.)
     * @param {string} config[].field - Chemin du champ (ex: 'attributes.description')
     * @param {number} [config[].order] - Ordre d'affichage (tri croissant)
     * @param {string} [config[].label] - Label de l'élément (pour accordéon)
     * @param {boolean} [config[].accordion] - Si true, élément dans un accordéon
     * @param {boolean} [config[].defaultOpen=true] - Si false, accordéon fermé par défaut
     * @param {Object} [options={}] - Options de rendu
     * @returns {Array<Object>} Tableau d'objets {html, config, label, accordion, defaultOpen}
     * @returns {string} returns[].html - HTML rendu de l'élément
     * @returns {Object} returns[].config - Configuration renderer originale
     * @returns {string} returns[].label - Label de l'élément
     * @returns {boolean} returns[].accordion - Si true, élément dans un accordéon
     * @returns {boolean} returns[].defaultOpen - Si true, accordéon ouvert par défaut
     *
     * @example
     * // Panel simple sans accordéon
     * const items1 = buildPanelItems(
     *   poi,
     *   [
     *     { type: 'text', field: 'attributes.name', label: 'Nom', order: 1 },
     *     { type: 'longtext', field: 'attributes.description', label: 'Description', order: 2 }
     *   ]
     * );
     * // Retourne: [
     * //   { html: '<p>...</p>', config: {...}, label: 'Nom', accordion: false, defaultOpen: true },
     * //   { html: '<div>...</div>', config: {...}, label: 'Description', accordion: false, defaultOpen: true }
     * // ]
     *
     * @example
     * // Panel avec accordéons
     * const items2 = buildPanelItems(
     *   poi,
     *   [
     *     { type: 'text', field: 'attributes.name', label: 'Nom', order: 1 },
     *     { type: 'list', field: 'attributes.tags', label: 'Tags', accordion: true, defaultOpen: true, order: 2 },
     *     { type: 'gallery', field: 'attributes.photos', label: 'Photos', accordion: true, defaultOpen: false, order: 3 }
     *   ]
     * );
     * // Retourne: [
     * //   { html: '<p>...</p>', label: 'Nom', accordion: false, defaultOpen: true },
     * //   { html: '<ul>...</ul>', label: 'Tags', accordion: true, defaultOpen: true },
     * //   { html: '<div>...</div>', label: 'Photos', accordion: true, defaultOpen: false }
     * // ]
     */
    function buildPanelItems(poi, config, options = {}) {
        if (!poi || !config || !Array.isArray(config)) {
            return [];
        }

        const resolveField = getResolveField();
        const renderOptions = { context: 'panel', ...options };

        // Trier par order (Phase 4 dedup)
        const sortedConfig = [...config].sort(compareByOrder);

        const items = [];

        sortedConfig.forEach(itemConfig => {
            if (!itemConfig || !itemConfig.type) return;

            // Vérifier si la valeur existe
            const value = resolveField(poi, itemConfig.field);
            const hasValue = value !== null && value !== undefined && value !== '' &&
                             !(Array.isArray(value) && value.length === 0);

            if (!hasValue && itemConfig.type !== 'coordinates') return;

            const html = renderItem$1(poi, itemConfig, renderOptions);
            if (html) {
                items.push({
                    html: html,
                    config: itemConfig,
                    label: itemConfig.label || '',
                    accordion: itemConfig.accordion === true,
                    defaultOpen: itemConfig.defaultOpen !== false
                });
            }
        });

        return items;
    }

    // ========================================
    //   EXPORT
    // ========================================

    const Assemblers = {
        buildPopupHTML,
        buildTooltipHTML,
        buildPanelItems
    };

    getLog().info('[GeoLeaf._ContentBuilder.Assemblers] Module Assemblers chargé');

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ========================================
    //   UTILITAIRES LOCAUX
    // ========================================

    /**
     * Récupère le ContentBuilder (Assemblers).
     * Les fonctions buildPopupHTML / buildTooltipHTML sont sur le sous-module Assemblers.
     * @returns {Object|null}
     */
    function getContentBuilder() {
        return Assemblers || null;
    }

    /**
     * Résout la valeur d'un champ à partir d'un objet POI.
     * Délègue à Utils.resolveField si disponible.
     *
     * @param {object} poi - Objet POI source.
     * @param {string} field - Chemin du champ (ex: "attributes.photo").
     * @returns {*} Valeur du champ ou null.
     */
    function resolveField(poi, field) {
        if (!poi || !field) return null;

        if (resolveField$1) {
            return resolveField$1(poi, field);
        }

        // Fallback minimal
        const parts = field.split(".");
        let current = poi;
        for (const part of parts) {
            if (current && typeof current === "object" && part in current) {
                current = current[part];
            } else {
                return null;
            }
        }
        return current;
    }

    // escapeHtml imported directly from security/index.js (A3 — DEAD-01)

    // ========================================
    //   CONFIGURATION
    // ========================================

    /**
     * Récupère la configuration de popup pour une couche/POI.
     *
     * @param {object} poi - Données du POI.
     * @returns {Array|null} Configuration detailPopup ou null.
     */
    function getPopupConfig(poi) {
        // 1. Config attachée depuis la couche du POI
        if (poi._layerConfig?.popup?.detailPopup) {
            Log.info && Log.info("[POI Popup] Config popup depuis layerConfig");
            return poi._layerConfig.popup.detailPopup;
        }

        // 2. Fallback: profil actif
        if (Config && typeof Config.getActiveProfile === "function") {
            const profile = Config.getActiveProfile();

            // Chercher la config dans les emplacements standards
            if (profile?.popup?.detailPopup) {
                Log.info &&
                    Log.info(
                        "[POI Popup] Config popup depuis profil actif (profile.popup.detailPopup)"
                    );
                return profile.popup.detailPopup;
            }

            // ALTERNATIVE: Vérifier aussi dans panels.poi (ancienne structure)
            if (profile?.panels?.poi?.popup?.detailPopup) {
                Log.info &&
                    Log.info(
                        "[POI Popup] Config popup depuis profil actif (profile.panels.poi.popup.detailPopup - ancienne structure)"
                    );
                return profile.panels.poi.popup.detailPopup;
            }
        }

        Log.warn &&
            Log.warn(
                "[POI Popup] Aucune configuration detailPopup trouvée pour POI:",
                poi.id || "unknown"
            );
        return null;
    }

    /**
     * Récupère la configuration de tooltip pour une couche/POI.
     *
     * @param {object} poi - Données du POI.
     * @returns {Array|null} Configuration detailTooltip ou null.
     */
    function getTooltipConfig(poi) {
        // 1. Config depuis popup.detailTooltip (structure standard)
        if (poi._layerConfig?.popup?.detailTooltip) {
            return poi._layerConfig.popup.detailTooltip;
        }

        // 2. Config depuis tooltip.detailTooltip
        if (poi._layerConfig?.tooltip?.detailTooltip) {
            return poi._layerConfig.tooltip.detailTooltip;
        }

        // 3. Config directe detailTooltip
        if (poi._layerConfig?.detailTooltip) {
            return poi._layerConfig.detailTooltip;
        }

        // 4. Fallback: profil actif
        if (Config && typeof Config.getActiveProfile === "function") {
            const profile = Config.getActiveProfile();
            if (profile?.popup?.detailTooltip) {
                return profile.popup.detailTooltip;
            }
        }

        return null;
    }

    // ========================================
    //   CONSTRUCTION DU CONTENU
    // ========================================

    /**
     * Construit le contenu HTML d'un popup rapide pour un POI.
     * Utilise ContentBuilder si disponible, sinon logique interne.
     *
     * @param {object} poi - Données du POI.
     * @param {Function} resolveCategoryDisplay - Fonction pour résoudre l'affichage de catégorie.
     * @returns {string} HTML du popup.
     */
    function buildQuickPopupContent(poi, resolveCategoryDisplay) {
        if (!poi) {
            Log.warn && Log.warn("[POI Popup] POI invalide");
            return "";
        }

        const config = getPopupConfig(poi);
        const ContentBuilder = getContentBuilder();

        // Si ContentBuilder disponible, déléguer
        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === "function") {
            return ContentBuilder.buildPopupHTML(poi, config, {
                resolveCategoryDisplay: resolveCategoryDisplay,
            });
        }

        // Fallback si ContentBuilder non chargé
        Log.warn && Log.warn("[POI Popup] ContentBuilder non disponible, fallback basique");
        return buildFallbackPopup(poi);
    }

    /**
     * Construit le contenu d'un tooltip pour un POI.
     * Utilise ContentBuilder si disponible.
     *
     * @param {object} poi - Données du POI.
     * @param {Function} resolveCategoryDisplay - Fonction pour résoudre l'affichage de catégorie.
     * @returns {string} HTML du tooltip.
     */
    function buildTooltipContent(poi, resolveCategoryDisplay) {
        if (!poi) {
            Log.warn && Log.warn("[POI Tooltip] POI invalide");
            return "";
        }

        const config = getTooltipConfig(poi);
        const ContentBuilder = getContentBuilder();

        // Si ContentBuilder disponible, déléguer
        if (ContentBuilder && typeof ContentBuilder.buildTooltipHTML === "function") {
            return ContentBuilder.buildTooltipHTML(poi, config, {
                resolveCategoryDisplay: resolveCategoryDisplay,
            });
        }

        // Fallback si ContentBuilder non chargé
        return escapeHtml(
            resolveField(poi, "title") ||
                resolveField(poi, "label") ||
                resolveField(poi, "name") ||
                "POI"
        );
    }

    /**
     * Fallback pour construire un popup basique sans ContentBuilder.
     *
     * @param {object} poi - Données du POI.
     * @param {Array} _config - Configuration detailPopup (réservé pour usage futur).
     * @param {Function} _resolveCategoryDisplay - Fonction pour résoudre l'affichage de catégorie (réservé).
     * @returns {string} HTML du popup.
     */
    function buildFallbackPopup(poi, _config, _resolveCategoryDisplay) {
        const title = escapeHtml(
            resolveField(poi, "title") ||
                resolveField(poi, "label") ||
                resolveField(poi, "name") ||
                "POI"
        );

        const description =
            resolveField(poi, "attributes.description") || resolveField(poi, "description") || "";

        let html = '<div class="gl-poi-popup">';
        html += '<div class="gl-poi-popup__body">';
        html +=
            '<h3 class="gl-poi-popup__title"><span class="gl-poi-popup__title-text">' +
            title +
            "</span></h3>";
        if (description) {
            html += '<p class="gl-poi-popup__desc">' + escapeHtml(description) + "</p>";
        }
        html +=
            '<a href="#" class="gl-poi-popup__link" data-poi-id="' +
            (poi.id || "") +
            '">Voir plus >>></a>';
        html += "</div></div>";

        return html;
    }

    // ========================================
    //   ATTACHMENT LEAFLET
    // ========================================

    /**
     * Attache un tooltip à un marqueur Leaflet.
     *
     * @param {L.Marker} marker - Marqueur Leaflet.
     * @param {string} content - Contenu du tooltip (texte).
     * @param {object} options - Options du tooltip.
     */
    function attachTooltip(marker, content, options) {
        if (!marker || typeof marker.bindTooltip !== "function") {
            Log.warn && Log.warn("[POI Popup] Marker invalide pour attachTooltip");
            return;
        }

        const defaultOptions = {
            direction: "top",
            offset: [0, -10],
            opacity: 0.9,
            className: "gl-poi-tooltip",
        };

        const finalOptions = Object.assign({}, defaultOptions, options || {});
        marker.bindTooltip(content, finalOptions);
    }

    /**
     * Gère le tooltip d'un marqueur selon la configuration.
     *
     * @param {L.Marker} marker - Marqueur Leaflet.
     * @param {object} poi - Données du POI.
     * @param {object} config - Configuration POI globale.
     * @param {Function} resolveCategoryDisplay - Fonction pour résoudre l'affichage de catégorie.
     */
    function manageTooltip(marker, poi, config, resolveCategoryDisplay) {
        if (!marker || !poi) return;

        const tooltipMode = config?.tooltipMode || "hover"; // "hover", "permanent", "none"

        if (tooltipMode === "none") {
            return;
        }

        // Construire le contenu du tooltip
        const tooltipText = buildTooltipContent(poi, resolveCategoryDisplay);

        if (tooltipMode === "permanent") {
            attachTooltip(marker, tooltipText, { permanent: true });
        } else {
            attachTooltip(marker, tooltipText);
        }
    }

    /**
     * Attache un popup à un marqueur Leaflet.
     *
     * @param {L.Marker} marker - Marqueur Leaflet.
     * @param {string} content - Contenu HTML du popup.
     * @param {object} options - Options du popup.
     */
    function attachPopup(marker, content, options) {
        if (!marker || typeof marker.bindPopup !== "function") {
            Log.error && Log.error("[POI Popup] Marker invalide ou pas de bindPopup");
            return;
        }

        const defaultOptions = {
            maxWidth: 300,
            minWidth: 200,
            className: "gl-poi-popup-leaflet",
            closeButton: true,
            autoPan: true,
        };

        const finalOptions = Object.assign({}, defaultOptions, options || {});
        marker.bindPopup(content, finalOptions);
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POIPopup = {
        // Construction de contenu
        buildQuickPopupContent,
        buildTooltipContent,

        // Gestion Leaflet
        attachTooltip,
        manageTooltip,
        attachPopup,

        // Configuration
        getPopupConfig,
        getTooltipConfig,
    };

    /**
     * @module shared/storage-contract
     * @description Interface optionnelle pour accéder au module Storage depuis
     * les modules non-Storage (POI, LayerManager…) sans importer directement
     * le plugin Storage (qui est optionnel).
     *
     * Phase 10-C — Pattern E : remplace le couplage runtime par
     * le contrat d'interface ESM pur `StorageContract.*`.
     *
     * CYCLE ROMPU :
     *   POI → StorageContract (no-dep ESM singleton)
     *   StorageContract.init() ← appelé par geoleaf.storage.js au chargement du plugin
     *
     * USAGE dans les modules consommateurs :
     *   import { StorageContract } from '../shared/storage-contract.js';
     *
     *   if (StorageContract.isAvailable()) {
     *       const items = await StorageContract.DB.getAllFromSyncQueue();
     *   }
     *
     *   // Image upload (POI) :
     *   if (StorageContract.isAvailable() && StorageContract.DB?.storeImageLocally) {
     *       await StorageContract.DB.storeImageLocally(imageData);
     *   }
     *
     * INITIALISATION :
     *   // Dans geoleaf.storage.js (ou le plugin Storage), après assemblage :
     *   StorageContract.init(Storage);
     */

    /** @type {Object|null} Référence à la facade Storage (geoleaf.storage.js) */
    let _storageRef = null;

    /**
     * Contrat d'interface optionnel pour le module Storage.
     *
     * Expose read-only les sous-modules DB et CacheManager via des getters paresseux.
     * `init(storage)` est la seule méthode d'écriture — appelée une seule fois
     * au boot du plugin Storage.
     *
     * @namespace StorageContract
     */
    const StorageContract = {
        /**
         * Initialise le contrat avec la facade Storage.
         * Appelé par `geoleaf.storage.js` lorsque le plugin Storage est chargé.
         *
         * @param {Object} storageModule - La facade Storage (export de geoleaf.storage.js)
         */
        init(storageModule) {
            _storageRef = storageModule;
        },

        /**
         * Retourne true si le plugin Storage est chargé ET que IndexedDB est ouvert.
         * @returns {boolean}
         */
        isAvailable() {
            if (!_storageRef) return false;
            return typeof _storageRef.isAvailable === "function"
                ? _storageRef.isAvailable()
                : !!_storageRef.DB;
        },

        /**
         * Accès au module IndexedDB (Storage.DB).
         * @returns {Object|null}
         */
        get DB() {
            return _storageRef?.DB ?? null;
        },

        /**
         * Accès au module CacheManager (Storage.CacheManager).
         * @returns {Object|null}
         */
        get CacheManager() {
            return _storageRef?.CacheManager ?? null;
        },

        /**
         * Accès au namespace Cache (Storage.Cache).
         * Contient CacheStorage, LayerSelector, etc.
         * @returns {Object|null}
         */
        get Cache() {
            return _storageRef?.Cache ?? null;
        },

        /**
         * Vérifie si un plugin Storage est enregistré (même non initialisé/DB fermée).
         * Différent de isAvailable() qui vérifie aussi que DB est ouverte.
         * @returns {boolean}
         */
        isPluginLoaded() {
            return _storageRef !== null;
        },

        /**
         * Télécharge un profil pour disponibilité offline.
         * @param {string} profileId - Identifiant du profil
         * @returns {Promise<Object>}
         */
        downloadProfileForOffline(profileId) {
            if (!_storageRef) {
                return Promise.reject(new Error("[StorageContract] Storage plugin not loaded"));
            }
            return _storageRef.downloadProfileForOffline(profileId);
        },
    };

    /**
     * GeoLeaf POI Module - Component Renderers
     * Rendu des composants UI (badges, liens, listes, tableaux, tags)
     * Phase 6.2 - Extraction depuis core.js
     */


    /**
     * Renderers pour les composants UI du side panel
     */
    class ComponentRenderers {
        constructor() {
            // Référence aux modules POI
            this.getMarkers = () => POIMarkers;
        }

        /**
         * Rend un badge avec style de catégorie
         * @param {object} section - Configuration de section
         * @param {string} value - Valeur du badge
         * @param {object} poi - POI complet
         * @returns {HTMLElement|null}
         */
        renderBadge(section, value, poi) {
            if (!value) return null;

            const container = document.createElement('div');
            container.className = 'gl-poi-badge-container';

            const badge = document.createElement('span');
            badge.className = 'gl-poi-badge';
            badge.textContent = value;

            // Récupérer les couleurs depuis la taxonomie si disponible
            const markers = this.getMarkers();
            if (markers && markers.resolveCategoryDisplay) {
                const displayInfo = markers.resolveCategoryDisplay(poi);
                if (displayInfo.colorFill) {
                    badge.style.background = displayInfo.colorFill;
                    badge.style.color = '#fff';
                }
            }

            container.appendChild(badge);
            return container;
        }

        /**
         * Rend un lien externe
         * @param {object} section - Configuration de section
         * @param {string} url - URL du lien
         * @returns {HTMLElement|null}
         */
        renderLink(section, url) {
            if (!url) return null;

            const container = document.createElement('div');
            container.className = 'gl-poi-link-container';

            const link = document.createElement('a');
            link.className = 'gl-poi-website-link';
            link.href = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = section.label || 'Visiter le site web →';

            container.appendChild(link);
            return container;
        }

        /**
         * Rend une liste (tableau de prix, etc.)
         * @param {object} section - Configuration de section
         * @param {Array|object} data - Données à afficher
         * @returns {HTMLElement|null}
         */
        renderList(section, data) {
            if (!data) {
                if (Log) Log.warn('[POI] renderList: data is null/undefined');
                return null;
            }

            const div = document.createElement('div');
            div.className = 'gl-poi-section';

            // Cas spécial pour price (objet)
            if (typeof data === 'object' && !Array.isArray(data)) {
                if (Log) Log.info('[POI] renderList: price object:', data);

                if (data.from || data.to) {
                    const p = document.createElement('p');
                    const strong = document.createElement('strong');

                    const safeFrom = Number.isFinite(Number(data.from)) ? Number(data.from) : null;
                    const safeTo = Number.isFinite(Number(data.to)) ? Number(data.to) : null;
                    const safeCurrency = data.currency || 'USD';

                    if (safeFrom !== null && safeTo !== null) {
                        strong.textContent = `De ${safeFrom} à ${safeTo} ${safeCurrency}`;
                    } else if (safeFrom !== null) {
                        strong.textContent = `À partir de ${safeFrom} ${safeCurrency}`;
                    } else if (safeTo !== null) {
                        strong.textContent = `Jusqu'à ${safeTo} ${safeCurrency}`;
                    }

                    if (strong.textContent) {
                        p.appendChild(strong);
                        div.appendChild(p);
                    }
                }
                if (data.description) {
                    const desc = document.createElement('p');
                    desc.textContent = data.description;
                    desc.style.fontSize = '0.85rem';
                    desc.style.color = 'var(--gl-color-text-muted)';
                    div.appendChild(desc);
                }

                if (div.children.length === 0) {
                    if (Log) Log.warn('[POI] renderList: price object has no displayable content');
                    return null;
                }
                return div;
            }

            // Liste normale (array)
            if (Array.isArray(data)) {
                const variant = section.variant || 'disc';

                const ul = document.createElement('ul');
                ul.className = 'gl-poi-list-unordered';

                // Appliquer le style de puce selon le variant
                if (variant === 'disc' || variant === 'circle' || variant === 'square') {
                    ul.style.listStyleType = variant;
                } else {
                    ul.style.listStyleType = 'disc'; // Par défaut
                }

                data.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    ul.appendChild(li);
                });

                div.appendChild(ul);
            }

            return div;
        }

        /**
         * Rend un tableau avec en-têtes et bordures
         * @param {object} section - Configuration de section
         * @param {Array} data - Données du tableau
         * @returns {HTMLElement|null}
         */
        renderTable(section, data) {
            if (!data || !Array.isArray(data)) {
                if (Log) Log.warn('[POI] renderTable: data is', data ? 'not an array' : 'null/undefined', '- type:', typeof data);
                return null;
            }

            if (Log) Log.info('[POI] renderTable: rendering', data.length, 'rows');

            // Transformer les chaînes en objets si nécessaire
            let tableData = data;
            if (data.length > 0 && typeof data[0] === 'string' && section.columns && section.columns.length === 2) {
                // Détecter le format "Clé : Valeur" ou "Clé – Valeur"
                tableData = data.map(str => {
                    const separators = [' : ', ': ', ' – ', '–', ' - ', '-'];
                    for (const sep of separators) {
                        const parts = str.split(sep);
                        if (parts.length >= 2) {
                            return {
                                [section.columns[0].key]: parts[0].trim(),
                                [section.columns[1].key]: parts.slice(1).join(sep).trim()
                            };
                        }
                    }
                    // Si aucun séparateur trouvé, tout dans la première colonne
                    return {
                        [section.columns[0].key]: str,
                        [section.columns[1].key]: ''
                    };
                });
                if (Log) Log.info('[POI] renderTable: transformed string array to object array');
            }

            const table = document.createElement('table');
            table.className = 'gl-poi-table';

            // Gestion des bordures selon la configuration
            const borders = section.borders || {};
            if (borders.outer !== false) {
                table.style.border = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
            }

            // En-têtes
            if (section.columns) {
                const thead = document.createElement('thead');
                const tr = document.createElement('tr');
                section.columns.forEach((col, index) => {
                    const th = document.createElement('th');
                    th.textContent = col.label;
                    th.style.padding = '8px';
                    th.style.textAlign = 'left';
                    th.style.fontWeight = '600';
                    th.style.backgroundColor = 'var(--gl-color-bg-subtle)';

                    if (borders.row !== false) {
                        th.style.borderBottom = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
                    }
                    if (borders.column && index > 0) {
                        th.style.borderLeft = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
                    }

                    tr.appendChild(th);
                });
                thead.appendChild(tr);
                table.appendChild(thead);
            }

            // Lignes de données
            const tbody = document.createElement('tbody');
            tableData.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                if (section.columns) {
                    section.columns.forEach((col, colIndex) => {
                        const td = document.createElement('td');
                        td.textContent = row[col.key] || '';
                        td.style.padding = '8px';

                        if (borders.row !== false && rowIndex < tableData.length - 1) {
                            td.style.borderBottom = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
                        }
                        if (borders.column && colIndex > 0) {
                            td.style.borderLeft = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
                        }

                        tr.appendChild(td);
                    });
                }
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            return table;
        }

        /**
         * Rend des tags
         * @param {object} section - Configuration de section
         * @param {Array<string>} tags - Liste de tags
         * @returns {HTMLElement|null}
         */
        renderTags(section, tags) {
            if (!tags || !Array.isArray(tags)) {
                if (Log) Log.warn('[POI] renderTags: tags is', tags ? 'not an array' : 'null/undefined', '- type:', typeof tags, '- value:', tags);
                return null;
            }

            if (tags.length === 0) {
                if (Log) Log.warn('[POI] renderTags: tags array is empty');
                return null;
            }

            if (Log) Log.info('[POI] renderTags: rendering', tags.length, 'tags');

            const div = document.createElement('div');
            div.className = 'gl-poi-sidepanel__tags';
            div.style.display = 'flex';
            div.style.flexWrap = 'wrap';
            div.style.gap = '6px';

            tags.forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.className = 'gl-poi-tag';
                tagSpan.textContent = tag;
                div.appendChild(tagSpan);
            });

            return div;
        }

        /**
         * Rend une note globale (étoiles)
         * @param {object} section - Configuration de section
         * @param {number} rating - Note numérique (0-5)
         * @returns {HTMLElement|null}
         */
        renderRating(section, rating) {
            const numRating = parseFloat(rating);
            if (!Number.isFinite(numRating)) {
                if (Log) Log.warn('[POI] renderRating: valeur non numérique:', rating);
                return null;
            }

            const container = document.createElement('div');
            container.className = 'gl-rating gl-rating--stat';

            if (section.label) {
                const label = document.createElement('span');
                label.className = 'gl-rating__label';
                label.textContent = section.label;
                container.appendChild(label);
            }

            const starsWrap = document.createElement('span');
            starsWrap.className = 'gl-rating__stars';
            for (let i = 1; i <= 5; i++) {
                const star = document.createElement('span');
                star.className = 'gl-rating__star' + (i <= Math.round(numRating) ? ' gl-rating__star--filled' : '');
                star.textContent = '\u2605';
                starsWrap.appendChild(star);
            }
            container.appendChild(starsWrap);

            const value = document.createElement('span');
            value.className = 'gl-rating__value';
            value.textContent = numRating.toFixed(1) + '/5';
            container.appendChild(value);

            return container;
        }

        /**
         * Rend les avis (reviews)
         * @param {object} section - Configuration de section
         * @param {Array} reviews - Liste d'avis
         * @returns {HTMLElement|null}
         */
        renderReviews(section, reviews) {
            if (!reviews || !Array.isArray(reviews)) {
                if (Log) Log.warn('[POI] renderReviews: reviews is', reviews ? 'not an array' : 'null/undefined', '- type:', typeof reviews);
                return null;
            }

            if (Log) Log.info('[POI] renderReviews: rendering', reviews.length, 'reviews');

            const div = document.createElement('div');
            div.className = 'gl-poi-reviews';

            const maxCount = section.maxCount || 5;
            reviews.slice(0, maxCount).forEach(review => {
                const reviewDiv = document.createElement('div');
                reviewDiv.className = 'gl-poi-review';
                reviewDiv.style.borderLeft = '3px solid var(--gl-color-accent-soft)';
                reviewDiv.style.paddingLeft = '12px';
                reviewDiv.style.marginBottom = '12px';

                const header = document.createElement('p');
                header.style.fontSize = '0.875rem';
                header.style.fontWeight = '600';
                header.style.marginBottom = '4px';

                const safeAuthor = review.authorName || 'Anonyme';
                const safeRating = Number.isFinite(review.rating) ? review.rating : 0;
                const verifiedMark = review.verified ? ' ✓' : '';
                header.textContent = `${safeAuthor} - ⭐${safeRating}/5${verifiedMark}`;
                reviewDiv.appendChild(header);

                if (review.comment) {
                    const comment = document.createElement('p');
                    comment.textContent = review.comment;
                    comment.style.fontSize = '0.85rem';
                    comment.style.marginBottom = '4px';
                    reviewDiv.appendChild(comment);
                }

                if (review.createdAt) {
                    const date = document.createElement('p');
                    date.style.fontSize = '0.75rem';
                    date.style.color = 'var(--gl-color-text-muted)';
                    date.textContent = review.createdAt;
                    reviewDiv.appendChild(date);
                }

                div.appendChild(reviewDiv);
            });

            return div;
        }
    }

    /**
     * POI Renderers - Field Renderers Module (Migrated to AbstractRenderer)
     * Rendu des champs simples: texte, badges, liens, tags
     *
     * @module poi/renderers/field-renderers
     * @requires renderers/abstract-renderer
     * @version 2.0.0 - Migrated to AbstractRenderer base class
     */

    /**
     * @class FieldRenderers
     * @extends AbstractRenderer
     * @description Renders simple POI fields: text, badges, links, tags
     */
    class FieldRenderers extends AbstractRenderer {
        constructor(options = {}) {
            super({
                name: 'FieldRenderers',
                debug: options.debug || false,
                config: options.config || {}
            });
            this.init();
        }

        /**
         * Render method (required by AbstractRenderer)
         * Delegates to specific render methods
         * @param {Object} data - Render data {section, poi, value, type}
         * @returns {HTMLElement|null} Rendered element
         */
        render(data) {
            const { section, poi, value, type } = data;

            switch (type) {
                case 'text':
                    return this.renderText(section, poi, value);
                case 'badge':
                    return this.renderBadge(section, value, poi);
                case 'link':
                    return this.renderLink(section, value);
                case 'tags':
                    return this.renderTags(section, value);
                default:
                    this.warn('Unknown render type:', type);
                    return null;
            }
        }

        /**
         * Rend un champ texte (title, description, etc.)
         * @param {Object} section - Section config
         * @param {Object} poi - POI data
         * @param {string} value - Text value
         * @returns {HTMLElement|null}
         */
        async renderText(section, poi, value) {

            // Cas spécial pour le titre avec icône
            if (section.style === 'title' || section.variant === 'title') {
                return await this._renderTitleWithIcon(poi, value);
            }

            // Texte normal ou multiline
            if (!value) {
                this.warn('renderText: no value provided');
                return null;
            }

            const element = this.createElement(
                section.variant === 'multiline' ? 'div' : 'p',
                'gl-poi-sidepanel__desc'
            );

            if (section.variant === 'multiline') {
                element.style.whiteSpace = 'pre-wrap';
                element.style.lineHeight = '1.6';
            }

            element.textContent = value;
            this.info('renderText: element created, variant:', section.variant || 'normal');

            return element;
        }

        /**
         * Rend un titre avec icône SVG
         * @private
         * @param {Object} poi - POI data
         * @param {string} value - Title text
         * @returns {HTMLElement}
         */
        async _renderTitleWithIcon(poi, value) {
            const titleH2 = this.createElement('h2', 'gl-poi-sidepanel__title');

            // Ajouter l'icône SVG au titre
            const markers = this._getMarkers();
            if (markers && markers.resolveCategoryDisplay && markers.ensureProfileSpriteInjectedSync) {
                const displayInfo = markers.resolveCategoryDisplay(poi);
                this.debug('_renderTitleWithIcon: displayInfo =', displayInfo);

                if (displayInfo.iconId) {
                    await markers.ensureProfileSpriteInjectedSync();

                    const svgIcon = this._createCategoryIcon(displayInfo);
                    if (svgIcon) {
                        this.debug('_renderTitleWithIcon: SVG icon created successfully');
                        titleH2.appendChild(svgIcon);
                    } else {
                        this.warn('_renderTitleWithIcon: SVG icon creation failed');
                    }
                } else {
                    this.debug('_renderTitleWithIcon: No iconId in displayInfo');
                }
            } else {
                this.warn('_renderTitleWithIcon: Markers or required methods not available');
            }

            // Ajouter le texte du titre
            const titleSpan = this.createTextElement('span',
                value || poi.title || poi.label || poi.name || 'POI',
                'gl-poi-sidepanel__title-text'
            );
            titleH2.appendChild(titleSpan);

            this.info('renderText: title element created with icon');
            return titleH2;
        }

        /**
         * Crée une icône SVG de catégorie
         * @private
         * @param {Object} displayInfo - Display information {iconId, colorFill, colorStroke}
         * @returns {SVGElement|null}
         */
        _createCategoryIcon(displayInfo) {
            // Récupérer la config d'icônes depuis globalThis.GeoLeaf.Config
            const iconsConfig = (Config && typeof Config.getIconsConfig === 'function')
                ? Config.getIconsConfig()
                : null;

            const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || "gl-poi-cat-";
            const iconIdNormalized = String(displayInfo.iconId).trim().toLowerCase().replace(/\s+/g, '-');
            const symbolId = iconPrefix + iconIdNormalized;

            this.debug('_createCategoryIcon: symbolId =', symbolId, ', colors =', displayInfo.colorFill, displayInfo.colorStroke);
            this.debug('_createCategoryIcon: iconPrefix from config =', iconPrefix);

            // Vérifier si le sprite existe dans le DOM
            const sprite = document.querySelector('svg[data-geoleaf-sprite="profile"]');
            if (!sprite) {
                this.warn('_createCategoryIcon: Sprite SVG non trouvé dans le DOM! Le sprite doit être chargé avant.');
            } else {
                this.debug('_createCategoryIcon: Sprite trouvé, nombre de symboles:', sprite.querySelectorAll('symbol').length);
            }

            // Vérifier si le symbole existe dans le sprite
            const spriteSymbol = sprite ? sprite.querySelector(`#${symbolId}`) : null;
            if (!spriteSymbol) {
                this.warn('_createCategoryIcon: Symbole non trouvé dans le sprite:', symbolId);
                if (sprite) {
                    // Lister les symboles disponibles pour debug
                    const availableSymbols = Array.from(sprite.querySelectorAll('symbol')).map(s => s.id).slice(0, 5);
                    this.debug('_createCategoryIcon: Premiers symboles disponibles:', availableSymbols);
                }
            }

            const svgIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgIcon.setAttribute('width', '32');
            svgIcon.setAttribute('height', '32');
            svgIcon.setAttribute('viewBox', '0 0 24 24');
            svgIcon.setAttribute('class', 'gl-poi-sidepanel__icon');
            svgIcon.style.marginRight = '10px';
            svgIcon.style.flexShrink = '0';

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '12');
            circle.setAttribute('cy', '12');
            circle.setAttribute('r', '10');
            circle.setAttribute('fill', displayInfo.colorFill || '#3388ff');
            circle.setAttribute('stroke', displayInfo.colorStroke || '#fff');
            circle.setAttribute('stroke-width', '1.5');

            svgIcon.appendChild(circle);

            // Ajouter le symbole uniquement s'il existe
            if (spriteSymbol) {
                // SVG imbriqué pour le symbole (comme dans le popup)
                const innerSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                innerSvg.setAttribute('x', '4');
                innerSvg.setAttribute('y', '4');
                innerSvg.setAttribute('width', '16');
                innerSvg.setAttribute('height', '16');
                innerSvg.setAttribute('viewBox', '0 0 32 32');

                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + symbolId);
                use.setAttribute('href', '#' + symbolId);
                use.style.color = '#ffffff';

                innerSvg.appendChild(use);
                svgIcon.appendChild(innerSvg);
            }

            this.debug('_createCategoryIcon: SVG structure created');
            return svgIcon;
        }

        /**
         * Rend un badge (catégorie, sous-catégorie)
         * @param {Object} section - Section config
         * @param {string} value - Badge text
         * @param {Object} poi - POI data
         * @returns {HTMLElement|null}
         */
        renderBadge(section, value, poi) {
            if (!value) return null;

            const container = this.createElement('div', 'gl-poi-badge-container');
            const badge = this.createTextElement('span', value, 'gl-poi-badge');

            // Récupérer les couleurs depuis la taxonomie
            const markers = this._getMarkers();
            if (markers && markers.resolveCategoryDisplay) {
                const displayInfo = markers.resolveCategoryDisplay(poi);
                if (displayInfo.colorFill) {
                    badge.style.background = displayInfo.colorFill;
                    badge.style.color = '#fff';
                }
            }

            container.appendChild(badge);
            return container;
        }

        /**
         * Rend un lien (website, etc.)
         * @param {Object} section - Section config
         * @param {string} url - URL
         * @returns {HTMLElement|null}
         */
        renderLink(section, url) {
            if (!url) return null;

            const linkP = this.createElement('p', 'gl-poi-sidepanel__link');
            const anchor = this.createElement('a', null, {
                href: url,
                target: '_blank',
                rel: 'noopener noreferrer'
            });

            anchor.textContent = section.linkText || url;
            linkP.appendChild(anchor);

            return linkP;
        }

        /**
         * Rend une liste de tags
         * @param {Object} section - Section config
         * @param {Array<string>} tags - Tags array
         * @returns {HTMLElement|null}
         */
        renderTags(section, tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) return null;

            const tagsDiv = this.createElement('div', 'gl-poi-sidepanel__tags');

            tags.forEach(tag => {
                if (tag) {
                    const tagSpan = this.createTextElement('span', tag, 'gl-poi-tag');
                    tagsDiv.appendChild(tagSpan);
                }
            });

            return tagsDiv;
        }

        /**
         * Get POI Markers module
         * @private
         * @returns {Object|null}
         */
        _getMarkers() {
            return POIMarkers || null;
        }
    }

    /**
     * POI Renderers - Media Renderers Module (Migrated to AbstractRenderer)
     * Rendu des médias: images, galeries, lightbox
     *
     * @module poi/renderers/media-renderers
     * @requires renderers/abstract-renderer
     * @version 2.0.0 - Migrated to AbstractRenderer base class
     */

    /**
     * @class MediaRenderers
     * @extends AbstractRenderer
     * @description Renders media elements: images, galleries, lightbox
     */
    class MediaRenderers extends AbstractRenderer {
        constructor(options = {}) {
            super({
                name: 'MediaRenderers',
                debug: options.debug || false,
                config: options.config || {}
            });
            this.init();
        }

        /**
         * Render method (required by AbstractRenderer)
         * @param {Object} data - Render data {section, value, type}
         * @returns {HTMLElement|null} Rendered element
         */
        render(data) {
            const { section, value, type } = data;

            switch (type) {
                case 'image':
                    return this.renderImage(section, value);
                case 'gallery':
                    return this.renderGallery(section, value);
                default:
                    this.warn('Unknown media render type:', type);
                    return null;
            }
        }

        /**
         * Rend une image (hero ou normale)
         * @param {Object} section - Section config
         * @param {string} imageUrl - Image URL
         * @returns {HTMLElement|null}
         */
        renderImage(section, imageUrl) {
            if (!imageUrl) return null;

            const className = section.variant === 'hero'
                ? 'gl-poi-sidepanel__photo gl-poi-sidepanel__photo--hero'
                : 'gl-poi-sidepanel__photo';

            const photoDiv = this.createElement('div', className);
            const img = this.createElement('img', null, {
                src: imageUrl,
                alt: section.label || 'Photo',
                loading: 'lazy'
            });

            photoDiv.appendChild(img);
            return photoDiv;
        }

        /**
         * Rend une galerie d'images avec miniatures
         * @param {Object} section - Section config
         * @param {Array<string>} gallery - Array of image URLs
         * @returns {HTMLElement|null}
         */
        renderGallery(section, gallery) {
            if (!gallery || !Array.isArray(gallery) || gallery.length === 0) {
                this.warn('renderGallery: invalid gallery data', gallery);
                return null;
            }

            this.info('renderGallery: rendering', gallery.length, 'images');

            const galleryDiv = this.createElement('div', 'gl-poi-gallery');

            // Image principale
            const mainDiv = this._createMainImage(gallery[0]);
            galleryDiv.appendChild(mainDiv);

            // Miniatures si plusieurs images
            if (gallery.length > 1) {
                const thumbsDiv = this._createThumbnails(gallery, mainDiv);
                galleryDiv.appendChild(thumbsDiv);
            }

            return galleryDiv;
        }

        /**
         * Crée l'image principale de la galerie
         * @private
         * @param {string} imageUrl - Image URL
         * @returns {HTMLElement}
         */
        _createMainImage(imageUrl) {
            const mainDiv = this.createElement('div', 'gl-poi-gallery__main', {
                'data-gallery-index': '0'
            });

            const mainImg = this.createElement('img', null, {
                src: imageUrl,
                alt: 'Image 1',
                loading: 'lazy'
            });

            mainDiv.appendChild(mainImg);
            return mainDiv;
        }

        /**
         * Crée les miniatures de la galerie
         * @private
         * @param {Array<string>} gallery - Array of image URLs
         * @param {HTMLElement} mainDiv - Main image container
         * @returns {HTMLElement}
         */
        _createThumbnails(gallery, mainDiv) {
            const thumbsDiv = this.createElement('div', 'gl-poi-gallery__thumbnails');
            const mainImg = mainDiv.querySelector('img');

            gallery.forEach((imgUrl, index) => {
                const thumbDiv = this._createThumbnail(imgUrl, index, mainImg, mainDiv, thumbsDiv);
                thumbsDiv.appendChild(thumbDiv);
            });

            return thumbsDiv;
        }

        /**
         * Crée une miniature individuelle
         * @private
         * @param {string} imgUrl - Image URL
         * @param {number} index - Image index
         * @param {HTMLElement} mainImg - Main image element
         * @param {HTMLElement} mainDiv - Main image container
         * @param {HTMLElement} thumbsDiv - Thumbnails container
         * @returns {HTMLElement}
         */
        _createThumbnail(imgUrl, index, mainImg, mainDiv, thumbsDiv) {
            const thumbDiv = this.createElement('div',
                index === 0 ? 'gl-poi-gallery__thumb active' : 'gl-poi-gallery__thumb',
                { 'data-index': index.toString() }
            );

            const imgThumb = this.createElement('img', null, {
                src: imgUrl,
                alt: `Image ${index + 1}`,
                loading: 'lazy'
            });

            thumbDiv.appendChild(imgThumb);

            // Event listener pour changer l'image principale
            this.addEventListener(thumbDiv, 'click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Retirer la classe active de toutes les miniatures
                const allThumbs = thumbsDiv.querySelectorAll('.gl-poi-gallery__thumb');
                allThumbs.forEach(t => t.classList.remove('active'));

                // Ajouter la classe active à la miniature cliquée
                thumbDiv.classList.add('active');

                // Changer l'image principale
                mainImg.src = imgUrl;
                mainImg.alt = `Image ${index + 1}`;
                mainDiv.setAttribute('data-gallery-index', index.toString());

                this.info('Gallery: Switched to image', index + 1);
            }, true);

            return thumbDiv;
        }

        /**
         * Cleanup when gallery is destroyed
         * @override
         */
        destroy() {
            this.debug('Destroying MediaRenderers');
            super.destroy();
        }
    }

    /**
     * GeoLeaf POI Module - Section Orchestrator
     * Orchestration du rendu des sections (dispatcher, extraction valeurs, accordéons)
     * Phase 6.2 - Extraction depuis core.js
     */

    /**
     * Orchestrateur de sections pour le side panel POI
     */
    class SectionOrchestrator {
        constructor() {
            // Initialiser les renderers
            this.componentRenderers = null;
            this.fieldRenderers = null;
            this.mediaRenderers = null;
        }

        /**
         * Initialise les renderers (lazy loading)
         * @private
         */
        _initRenderers() {
            if (!this.componentRenderers) {
                this.componentRenderers = new ComponentRenderers();
            }
            if (!this.fieldRenderers) {
                this.fieldRenderers = new FieldRenderers({ debug: true });
            }
            if (!this.mediaRenderers) {
                this.mediaRenderers = new MediaRenderers({ debug: true });
            }
        }

        /**
         * Récupère la valeur d'un champ avec support du dot notation
         * @param {object} poi - POI complet
         * @param {string} fieldPath - Chemin du champ (ex: "attributes.address.city")
         * @returns {*}
         */
        getFieldValue(poi, fieldPath) {
            if (!fieldPath) return null;

            const resolve_fn =
                resolveField$1 ||
                function (obj, path) {
                    const parts = path.split(".");
                    let current = obj;
                    for (const part of parts) {
                        if (current && typeof current === "object" && part in current) {
                            current = current[part];
                        } else {
                            return null;
                        }
                    }
                    return current;
                };

            const value = resolve_fn(poi, fieldPath);

            if (Log && Log.info) {
                Log.info(
                    "[POI] getFieldValue:",
                    fieldPath,
                    "→",
                    value === undefined
                        ? "undefined"
                        : value === null
                          ? "null"
                          : value === ""
                            ? '""(empty string)'
                            : Array.isArray(value)
                              ? `Array(${value.length})`
                              : value && typeof value === "object"
                                ? `Object(${Object.keys(value).length} keys)`
                                : value
                );
            }

            return value;
        }

        /**
         * Wrappe un contenu dans un accordéon <details>
         * @param {object} section - Configuration de section
         * @param {HTMLElement} content - Contenu à wrapper
         * @param {boolean} isOpen - Ouvrir par défaut
         * @returns {HTMLElement}
         */
        wrapInAccordion(section, content, isOpen = false) {
            const details = document.createElement("details");
            details.className = "gl-accordion";
            if (isOpen) details.setAttribute("open", "");

            const summary = document.createElement("summary");
            summary.className = "gl-accordion__header";
            summary.textContent = section.label || "Section";

            const arrow = document.createElement("span");
            arrow.className = "gl-accordion__arrow";
            arrow.textContent = "▼";
            summary.appendChild(arrow);

            const panel = document.createElement("div");
            panel.className = "gl-accordion__panel";

            const panelContent = document.createElement("div");
            panelContent.className = "gl-accordion__panel-content";
            panelContent.appendChild(content);

            panel.appendChild(panelContent);

            details.appendChild(summary);
            details.appendChild(panel);

            return details;
        }

        /**
         * Rend une section complète selon son type
         * @param {object} section - Configuration de section
         * @param {object} poi - POI complet
         * @param {object} state - État partagé POI
         * @returns {Promise<HTMLElement|null>}
         */
        async renderSection(section, poi, _state) {
            if (!section || !section.type) return null;

            // Initialiser les renderers si nécessaire
            this._initRenderers();

            // Résoudre la valeur du champ
            const fieldValue = this.getFieldValue(poi, section.field);

            if (Log) {
                const valueType = Array.isArray(fieldValue)
                    ? `Array(${fieldValue.length})`
                    : fieldValue && typeof fieldValue === "object"
                      ? `Object(${Object.keys(fieldValue).length} keys)`
                      : typeof fieldValue;
                Log.debug(
                    "[POI] Section:",
                    section.label || section.type,
                    "- Field:",
                    section.field,
                    "- ValueType:",
                    valueType,
                    "- Value:",
                    fieldValue
                );
            }

            // Ne pas afficher si la valeur est vide, SAUF pour:
            // - text avec style='title' (le titre est obligatoire)
            // - badge (peut avoir un comportement par défaut)
            const isRequiredField =
                (section.type === "text" && section.style === "title") || section.type === "badge";

            // Vérifier si la valeur est vraiment vide (null, undefined, '', [], {})
            // ATTENTION: 0 est une valeur valide (pour les prix, métriques, etc.)
            const isEmpty =
                fieldValue === null ||
                fieldValue === undefined ||
                fieldValue === "" ||
                (Array.isArray(fieldValue) && fieldValue.length === 0) ||
                (typeof fieldValue === "object" &&
                    !Array.isArray(fieldValue) &&
                    Object.keys(fieldValue).length === 0);

            if (Log) {
                Log.info(
                    "[POI] Check isEmpty for:",
                    section.label,
                    "- fieldValue:",
                    fieldValue,
                    "- isArray:",
                    Array.isArray(fieldValue),
                    "- arrayLength:",
                    Array.isArray(fieldValue) ? fieldValue.length : "N/A",
                    "- isEmpty:",
                    isEmpty
                );
            }

            if (isEmpty && !isRequiredField) {
                if (Log)
                    Log.warn("[POI] Section ignorée (valeur vide):", section.label || section.type);
                return null;
            }

            if (Log)
                Log.info(
                    "[POI] → Appel render pour:",
                    section.label,
                    "- Type:",
                    section.type,
                    "- Value:",
                    Array.isArray(fieldValue)
                        ? `Array(${fieldValue.length})`
                        : fieldValue && typeof fieldValue === "object"
                          ? "Object"
                          : fieldValue
                );

            // Créer l'élément selon le type
            let content = null;

            switch (section.type) {
                case "text":
                case "longtext": // Alias pour text avec plus de contenu
                    if (this.fieldRenderers) {
                        content = await this.fieldRenderers.renderText(section, poi, fieldValue);
                    }
                    break;
                case "number": // Afficher un nombre simple comme du texte
                    if (this.fieldRenderers) {
                        content = await this.fieldRenderers.renderText(
                            section,
                            poi,
                            String(fieldValue)
                        );
                    }
                    break;
                case "metric": {
                    // Nombre avec suffixe/préfixe
                    const suffix = section.suffix || "";
                    const prefix = section.prefix || "";
                    if (this.fieldRenderers) {
                        content = await this.fieldRenderers.renderText(
                            section,
                            poi,
                            prefix + String(fieldValue) + suffix
                        );
                    }
                    break;
                }
                case "image":
                    if (this.mediaRenderers) {
                        content = this.mediaRenderers.renderImage(section, fieldValue);
                    }
                    break;
                case "gallery":
                    if (this.mediaRenderers) {
                        content = this.mediaRenderers.renderGallery(section, fieldValue);
                    }
                    break;
                case "badge":
                    content = this.componentRenderers.renderBadge(section, fieldValue, poi);
                    break;
                case "link":
                    content = this.componentRenderers.renderLink(section, fieldValue);
                    break;
                case "list":
                    content = this.componentRenderers.renderList(section, fieldValue);
                    break;
                case "table":
                    content = this.componentRenderers.renderTable(section, fieldValue);
                    break;
                case "tags":
                    content = this.componentRenderers.renderTags(section, fieldValue);
                    break;
                case "rating":
                    content = this.componentRenderers.renderRating(section, fieldValue);
                    break;
                case "reviews":
                    content = this.componentRenderers.renderReviews(section, fieldValue);
                    break;
                default:
                    if (Log) Log.warn("[POI] Type de section inconnu:", section.type);
                    return null;
            }

            if (!content) {
                if (Log) Log.debug("[POI] Aucun contenu généré pour:", section.label || section.type);
                return null;
            }

            if (Log)
                Log.debug(
                    "[POI] Contenu généré pour:",
                    section.label || section.type,
                    "- Accordion:",
                    section.accordion
                );

            // Wraper dans un accordéon si nécessaire
            if (section.accordion) {
                return this.wrapInAccordion(section, content, section.defaultOpen);
            }

            return content;
        }
    }

    /**
     * GeoLeaf POI Module - Lightbox Manager
     * Gestion de l'affichage lightbox pour les images avec navigation galerie
     * Phase 6.2 - Extraction depuis core.js
     */

    /**
     * Gestionnaire de lightbox pour affichage d'images en plein écran
     * Supporte la navigation dans une galerie d'images (flèches gauche/droite)
     */
    class LightboxManager {
        constructor() {
            this.currentLightbox = null;
            this.keyHandler = null;
            /** @type {string[]} Liste des URLs d'images de la galerie */
            this.galleryImages = [];
            /** @type {number} Index courant dans la galerie */
            this.currentIndex = 0;
            /** @type {HTMLImageElement|null} Référence vers l'élément image affichée */
            this._imgElement = null;
            /** @type {HTMLElement|null} Référence vers le compteur */
            this._counterElement = null;
            /** @type {HTMLElement|null} Référence vers le bouton précédent */
            this._prevButton = null;
            /** @type {HTMLElement|null} Référence vers le bouton suivant */
            this._nextButton = null;
            /** @type {Function|null} Callback appelé quand l'index change */
            this.onIndexChange = null;
        }

        /**
         * Ouvre une lightbox pour afficher une image en plein écran.
         * Si un tableau d'images est fourni, active la navigation par flèches.
         * @param {string} imageSrc - URL de l'image à afficher
         * @param {string[]} [galleryImages] - Tableau d'URLs pour navigation galerie
         * @param {number} [startIndex] - Index de départ dans la galerie
         */
        open(imageSrc, galleryImages, startIndex) {
            // Fermer lightbox précédente si existe
            this.close();

            // Configurer la galerie
            if (Array.isArray(galleryImages) && galleryImages.length > 1) {
                this.galleryImages = galleryImages;
                this.currentIndex = typeof startIndex === 'number' ? startIndex : galleryImages.indexOf(imageSrc);
                if (this.currentIndex < 0) this.currentIndex = 0;
            } else {
                this.galleryImages = [imageSrc];
                this.currentIndex = 0;
            }

            // Créer le conteneur principal (utilise les classes CSS existantes)
            const lightbox = document.createElement('div');
            lightbox.className = 'gl-poi-lightbox-global';
            lightbox.style.display = 'flex';

            // Overlay (clic pour fermer)
            const overlay = document.createElement('div');
            overlay.className = 'gl-poi-lightbox__overlay';
            overlay.addEventListener('click', () => this.close());
            lightbox.appendChild(overlay);

            // Conteneur de contenu
            const content = document.createElement('div');
            content.className = 'gl-poi-lightbox__content';
            lightbox.appendChild(content);

            // Image
            const img = document.createElement('img');
            img.className = 'gl-poi-lightbox__image';
            img.src = imageSrc;
            img.alt = '';
            content.appendChild(img);
            this._imgElement = img;

            // Bouton fermer
            const closeBtn = document.createElement('button');
            closeBtn.className = 'gl-poi-lightbox__close';
            closeBtn.setAttribute('aria-label', 'Fermer');
            closeBtn.textContent = '\u00D7';
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.close();
            });
            lightbox.appendChild(closeBtn);

            // Navigation galerie (flèches + compteur) si plusieurs images
            if (this.galleryImages.length > 1) {
                this._createNavigation(lightbox);
            }

            document.body.appendChild(lightbox);
            this.currentLightbox = lightbox;

            // Gestion clavier : Escape, flèches gauche/droite
            this.keyHandler = (e) => {
                if (e.key === 'Escape') {
                    this.close();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    this.prev();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    this.next();
                }
            };
            document.addEventListener('keydown', this.keyHandler);
        }

        /**
         * Crée les boutons de navigation et le compteur
         * @private
         * @param {HTMLElement} lightbox - Conteneur lightbox
         */
        _createNavigation(lightbox) {
            // Bouton précédent
            const prevBtn = document.createElement('button');
            prevBtn.className = 'gl-poi-lightbox__prev';
            prevBtn.setAttribute('aria-label', 'Image précédente');
            prevBtn.textContent = '\u2039';
            prevBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.prev();
            });
            lightbox.appendChild(prevBtn);
            this._prevButton = prevBtn;

            // Bouton suivant
            const nextBtn = document.createElement('button');
            nextBtn.className = 'gl-poi-lightbox__next';
            nextBtn.setAttribute('aria-label', 'Image suivante');
            nextBtn.textContent = '\u203A';
            nextBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.next();
            });
            lightbox.appendChild(nextBtn);
            this._nextButton = nextBtn;

            // Compteur (ex: "2 / 5")
            const counter = document.createElement('div');
            counter.className = 'gl-poi-lightbox__counter';
            lightbox.appendChild(counter);
            this._counterElement = counter;

            this._updateNavState();
        }

        /**
         * Navigue vers l'image précédente
         */
        prev() {
            if (this.galleryImages.length <= 1) return;
            this.currentIndex = (this.currentIndex - 1 + this.galleryImages.length) % this.galleryImages.length;
            this._updateImage();
        }

        /**
         * Navigue vers l'image suivante
         */
        next() {
            if (this.galleryImages.length <= 1) return;
            this.currentIndex = (this.currentIndex + 1) % this.galleryImages.length;
            this._updateImage();
        }

        /**
         * Met à jour l'image affichée et l'état de navigation
         * @private
         */
        _updateImage() {
            if (!this._imgElement) return;
            this._imgElement.src = this.galleryImages[this.currentIndex];
            this._updateNavState();

            // Notifier le changement d'index (pour synchroniser les miniatures)
            if (typeof this.onIndexChange === 'function') {
                this.onIndexChange(this.currentIndex);
            }
        }

        /**
         * Met à jour le compteur et la visibilité des flèches
         * @private
         */
        _updateNavState() {
            if (this._counterElement) {
                this._counterElement.textContent = `${this.currentIndex + 1} / ${this.galleryImages.length}`;
            }
        }

        /**
         * Ferme la lightbox active
         */
        close() {
            if (this.currentLightbox && document.body.contains(this.currentLightbox)) {
                document.body.removeChild(this.currentLightbox);
            }

            if (this.keyHandler) {
                document.removeEventListener('keydown', this.keyHandler);
                this.keyHandler = null;
            }

            this.currentLightbox = null;
            this._imgElement = null;
            this._counterElement = null;
            this._prevButton = null;
            this._nextButton = null;
            this.galleryImages = [];
            this.currentIndex = 0;
            this.onIndexChange = null;
        }

        /**
         * Vérifie si une lightbox est actuellement ouverte
         * @returns {boolean}
         */
        isOpen() {
            return this.currentLightbox !== null && document.body.contains(this.currentLightbox);
        }
    }

    /**
     * GeoLeaf POI Module - UI Behaviors
     * Comportements interactifs pour le side panel (accordéons, galeries)
     * Phase 6.2 - Extraction depuis core.js
     */


    /**
     * Comportements UI pour le side panel POI
     */
    const UIBehaviors = {
        /**
         * Attache le comportement d'accordéon exclusif (un seul ouvert à la fois)
         * @param {HTMLElement} container - Conteneur parent des accordéons
         */
        attachSingleAccordionBehavior(container) {
            const accordions = container.querySelectorAll('details.gl-accordion');
            if (accordions.length === 0) return;

            accordions.forEach(accordion => {
                accordion.addEventListener('toggle', (event) => {
                    // Si cet accordéon vient d'être ouvert
                    if (event.target.open) {
                        // Fermer tous les autres accordéons
                        accordions.forEach(otherAccordion => {
                            if (otherAccordion !== event.target && otherAccordion.open) {
                                otherAccordion.removeAttribute('open');
                            }
                        });
                    }
                });
            });

            if (Log) Log.info('[POI] Comportement singleAccordion activé:', accordions.length, 'accordéons');
        },

        /**
         * Attache les événements de navigation pour une galerie d'images
         * @param {HTMLElement} sidePanelElement - Élément du side panel
         * @param {LightboxManager} lightboxManager - Instance du gestionnaire de lightbox
         */
        attachGalleryEvents(sidePanelElement, lightboxManager) {
            if (!sidePanelElement) return;
            if (sidePanelElement._galleryEventsAttached) return;
            sidePanelElement._galleryEventsAttached = true;

            // Navigation par miniatures
            const thumbs = sidePanelElement.querySelectorAll('.gl-poi-gallery__thumb');
            const mainImg = sidePanelElement.querySelector('.gl-poi-gallery__main img');

            if (!mainImg || thumbs.length === 0) return;

            // Collecter toutes les URLs d'images de la galerie
            const galleryImages = Array.from(thumbs).map(
                thumb => thumb.querySelector('img').src
            );

            thumbs.forEach((thumb) => {
                thumb.addEventListener('click', () => {
                    const index = parseInt(thumb.getAttribute('data-index'), 10);
                    const imgSrc = thumb.querySelector('img').src;

                    // Mettre à jour l'image principale
                    mainImg.src = imgSrc;
                    mainImg.alt = `Image ${index + 1}`;

                    // Mettre à jour l'état actif des miniatures
                    thumbs.forEach(t => t.classList.remove('active'));
                    thumb.classList.add('active');
                });
            });

            // Clic sur l'image principale pour lightbox avec navigation galerie
            mainImg.addEventListener('click', () => {
                if (lightboxManager) {
                    // Déterminer l'index courant depuis la miniature active
                    const activeThumb = sidePanelElement.querySelector('.gl-poi-gallery__thumb.active');
                    const currentIndex = activeThumb
                        ? parseInt(activeThumb.getAttribute('data-index'), 10)
                        : 0;

                    // Ouvrir la lightbox avec toute la galerie
                    lightboxManager.open(mainImg.src, galleryImages, currentIndex);

                    // Synchroniser les miniatures quand on navigue dans la lightbox
                    lightboxManager.onIndexChange = (newIndex) => {
                        thumbs.forEach(t => t.classList.remove('active'));
                        const targetThumb = sidePanelElement.querySelector(
                            `.gl-poi-gallery__thumb[data-index="${newIndex}"]`
                        );
                        if (targetThumb) {
                            targetThumb.classList.add('active');
                            // Mettre à jour l'image principale du panneau aussi
                            const imgSrc = targetThumb.querySelector('img').src;
                            mainImg.src = imgSrc;
                            mainImg.alt = `Image ${newIndex + 1}`;
                        }
                    };
                }
            });
        },

        /**
         * Configure tous les comportements UI pour le side panel
         * @param {HTMLElement} container - Conteneur du side panel
         * @param {LightboxManager} lightboxManager - Instance du gestionnaire de lightbox
         */
        setupAll(container, lightboxManager) {
            this.attachSingleAccordionBehavior(container);
            this.attachGalleryEvents(container, lightboxManager);
        }
    };

    /**
     * GeoLeaf POI Module - Renderers Core
     * Orchestrateur principal pour le rendu du side panel POI
     * Phase 6.2 - Version refactorisÃƒÂ©e (837 LOC Ã¢â€ â€™ ~140 LOC)
     *
     * Architecture modulaire:
     * - lightbox-manager.js: Gestion lightbox
     * - ui-behaviors.js: Comportements UI (accordÃƒÂ©ons, galerie)
     * - component-renderers.js: Renderers composants (badges, links, lists, tables, tags)
     * - section-orchestrator.js: Dispatcher de sections + extraction valeurs
     * - field-renderers-v2.js: Renderers texte
     * - media-renderers-v2.js: Renderers media
     */

    // Initialiser les nouveaux modules
    let sectionOrchestrator = null;
    let lightboxManager = null;
    let uiBehaviors = null;

    /**
     * Initialise les modules (lazy loading)
     * @private
     */
    function _initModules() {
        if (!sectionOrchestrator) {
            sectionOrchestrator = new SectionOrchestrator();
        }
        if (!lightboxManager) {
            lightboxManager = new LightboxManager();
        }
        if (!uiBehaviors) {
            uiBehaviors = UIBehaviors;
        }
    }

    /**
     * Peuple le side panel avec les donnÃƒÂ©es du POI en utilisant le layout JSON.
     *
     * @param {object} poi - POI normalisÃƒÂ©.
     * @param {object} customLayout - Layout personnalisÃƒÂ© (optionnel).
     * @returns {Promise<void>}
     */
    async function populateSidePanel(poi, customLayout) {
        // Initialiser les modules
        _initModules();

        const shared = POIShared;
        if (!shared) {
            if (Log) Log.error('[POI] populateSidePanel : shared is null');
            return;
        }
        const state = shared.state;

        if (!state.sidePanelElement) {
            if (Log) Log.error('[POI] populateSidePanel : sidePanelElement not found');
            return;
        }

        const contentDiv = state.sidePanelElement.querySelector('.gl-poi-sidepanel__content');
        if (!contentDiv) return;

        // Clear contenu précédent + réinitialiser le flag de galerie pour que les
        // événements soient bien rattachés aux nouveaux éléments DOM
        DOMSecurity.clearElementFast(contentDiv);
        delete state.sidePanelElement._galleryEventsAttached;

        // Normaliser le POI
        const normalizers = POINormalizers;
        const normalized = normalizers ? normalizers.normalizePoi(poi) : poi;

        if (Log) {
            Log.debug('[POI] POI normalisÃƒÂ©:', normalized.title || normalized.label);
            Log.debug('[POI] Champs attributes disponibles:', Object.keys(normalized.attributes || {}));
        }

        // RÃƒÂ©cupÃƒÂ©rer le layout depuis la config du profile
        let layout = customLayout;

        // Ã¢Å“â€¦ PRIORITÃƒâ€° 1: VÃƒÂ©rifier si le POI a une configuration sidepanel attachÃƒÂ©e (depuis sa couche)
        if (!layout && normalized._sidepanelConfig && normalized._sidepanelConfig.detailLayout) {
            layout = normalized._sidepanelConfig.detailLayout;
            if (Log) Log.info('[POI] Layout rÃƒÂ©cupÃƒÂ©rÃƒÂ© depuis la configuration de couche attachÃƒÂ©e au POI');
        }

        // Ã¢Å“â€¦ PRIORITÃƒâ€° 2: Essayer de rÃƒÂ©cupÃƒÂ©rer depuis le profil actif
        if (!layout) {
            if (Config && typeof Config.getActiveProfile === 'function') {
                const activeProfile = Config.getActiveProfile();
                if (activeProfile && activeProfile.panels && activeProfile.panels.detail) {
                    layout = activeProfile.panels.detail.layout;
                    if (Log) Log.info('[POI] Layout rÃƒÂ©cupÃƒÂ©rÃƒÂ© depuis le profil actif:', activeProfile.id || 'unknown');
                }
            }
        }

        // Fallback sur poiConfig si disponible
        if (!layout && state.poiConfig?.panels?.detail?.layout) {
            layout = state.poiConfig.panels.detail.layout;
        }

        // Si toujours pas de layout, utiliser le layout par dÃƒÂ©faut
        if (!layout || layout.length === 0) {
            if (Log) Log.warn('[POI] Aucun layout trouvÃƒÂ©, utilisation du layout par dÃƒÂ©faut');
            layout = _getDefaultLayout();
        }

        // Ã¢Å“â€¦ IMPORTANT: Trier les sections par 'order' (Phase 4 dedup)
        const sortedLayout = [...layout].sort(compareByOrder);

        if (Log) Log.info('[POI] GÃƒÂ©nÃƒÂ©ration du side panel avec', sortedLayout.length, 'sections');

        // Body du panneau
        const body = document.createElement('div');
        body.className = 'gl-poi-sidepanel__body';

        // GÃƒÂ©nÃƒÂ©rer chaque section selon le layout triÃƒÂ© (dÃƒÂ©lÃƒÂ©guer ÃƒÂ  SectionOrchestrator)
        for (const section of sortedLayout) {
            try {
                const element = sectionOrchestrator
                    ? await sectionOrchestrator.renderSection(section, normalized, state)
                    : null;

                if (element) {
                    body.appendChild(element);
                    if (Log) Log.info('[POI] Ã¢Å“â€œ Section ajoutÃƒÂ©e:', section.label || section.type);
                } else {
                    if (Log) Log.warn('[POI] Ã¢Å“â€” Section ignorÃƒÂ©e (element null):', section.label || section.type, '- field:', section.field);
                }
            } catch (error) {
                console.error('[SIDEPANEL] ERROR rendering section:', section.label, error);
                if (Log) Log.error('[POI] Erreur lors du rendu de la section:', section.label, error);
            }
        }

        contentDiv.appendChild(body);

        // GÃƒÂ©rer le comportement singleAccordion si configurÃƒÂ©
        const singleAccordion = normalized._sidepanelConfig?.singleAccordion;
        if (singleAccordion === true && uiBehaviors) {
            uiBehaviors.attachSingleAccordionBehavior(body);
        }

        // Attacher les ÃƒÂ©vÃƒÂ©nements aprÃƒÂ¨s le rendu
        if (uiBehaviors) {
            uiBehaviors.attachGalleryEvents(state.sidePanelElement, lightboxManager);
        }
    }

    /**
     * Retourne un layout par dÃƒÂ©faut si aucun n'est configurÃƒÂ©.
     * @private
     */
    function _getDefaultLayout() {
        return [
            { type: 'text', field: 'title', style: 'title', accordion: false },
            { type: 'image', field: 'attributes.mainImage', variant: 'hero', accordion: false },
            { type: 'text', field: 'attributes.shortDescription', variant: 'short', accordion: false },
            { type: 'text', label: 'Informations', field: 'attributes.longDescription', variant: 'multiline', accordion: true, defaultOpen: true },
            { type: 'text', label: 'Description', field: 'attributes.description_long', variant: 'multiline', accordion: true, defaultOpen: true },
            { type: 'gallery', label: 'Galerie photos', field: 'attributes.gallery', accordion: true, defaultOpen: true },
            { type: 'list', label: 'Prix', field: 'attributes.price', accordion: true, defaultOpen: false },
            { type: 'reviews', label: 'Avis rÃƒÂ©cents', field: 'attributes.reviews.recent', maxCount: 5, accordion: true, defaultOpen: false },
            { type: 'tags', label: 'Tags', field: 'attributes.tags', accordion: false },
            { type: 'link', label: 'Visiter le site web Ã¢â€ â€™', field: 'attributes.website', accordion: false }
        ];
    }

    const RendererCore = {
        populateSidePanel
    };

    /**
     * Module Renderers/Links pour POI
     * Rendu des liens
     */


    /**
     * Module Links Renderer
     * @namespace _POIRendererLinks
     * @private
     */
    const _POIRendererLinks = {
        /**
         * Rend un lien (website, etc.)
         * @param {Object} section - Configuration de la section
         * @param {string} url - URL du lien
         * @returns {HTMLElement|null}
         */
        renderLink(section, url) {
            if (!url) return null;

            const container = document.createElement('div');
            container.className = 'gl-poi-link-container';

            const link = document.createElement('a');
            link.className = 'gl-poi-website-link';
            link.href = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = section.label || url;

            container.appendChild(link);
            return container;
        }
    };


    // ── ESM Export ──
    const RendererLinks = _POIRendererLinks;

    /**
     * GeoLeaf Contract — POI Renderers (lazy-chunk boundary)
     *
     * Interface ESM pure pour accéder aux sous-modules de rendu POI
     * (RendererCore, FieldRenderers, MediaRenderers, RendererLinks)
     * depuis la façade poi/renderers.js sans couplage runtime.
     *
     * Phase 10-D — Pattern C : contrat de chunk POI Renderers.
     *
     * USAGE :
     *   import { POIRenderersContract } from '../../contracts/poi-renderers.contract.js';
     *
     *   const fragment = POIRenderersContract.renderContent(poi, state);
     *   await POIRenderersContract.populateSidePanel(poi, layout);
     */

    /** @type {FieldRenderers|null} Instance singleton paresseuse */
    let _fieldRenderers = null;

    /** @type {MediaRenderers|null} Instance singleton paresseuse */
    let _mediaRenderers = null;

    /**
     * Retourne l'instance singleton de FieldRenderers (lazy-init).
     * @returns {FieldRenderers}
     * @private
     */
    function _getFieldRenderers() {
        if (!_fieldRenderers) {
            _fieldRenderers = new FieldRenderers({ debug: false });
        }
        return _fieldRenderers;
    }

    /**
     * Retourne l'instance singleton de MediaRenderers (lazy-init).
     * @returns {MediaRenderers}
     * @private
     */
    function _getMediaRenderers() {
        if (!_mediaRenderers) {
            _mediaRenderers = new MediaRenderers({ debug: false });
        }
        return _mediaRenderers;
    }

    /**
     * Contrat d'interface pour les sous-modules POI Renderers.
     * @namespace POIRenderersContract
     */
    const POIRenderersContract = {
        /**
         * Peuple le side panel avec les données d'un POI.
         * @param {Object} poi - POI normalisé
         * @param {Object} customLayout - Layout personnalisé (optionnel)
         * @returns {Promise<void>}
         */
        async populateSidePanel(poi, customLayout) {
            if (RendererCore && typeof RendererCore.populateSidePanel === "function") {
                return RendererCore.populateSidePanel(poi, customLayout);
            }
        },

        /**
         * Rend le contenu complet d'un POI (side panel).
         * @param {Object} poi - Données du POI
         * @param {Object} state - État
         * @returns {DocumentFragment}
         */
        renderContent(poi, state) {
            if (RendererCore && typeof RendererCore.renderContent === "function") {
                return RendererCore.renderContent(poi, state);
            }
            return document.createDocumentFragment();
        },

        /**
         * Rend un champ texte.
         * @param {Object} section
         * @param {Object} poi
         * @param {string} value
         * @returns {Promise<HTMLElement|null>}
         */
        async renderText(section, poi, value) {
            return _getFieldRenderers().renderText(section, poi, value);
        },

        /**
         * Rend un badge.
         * @param {Object} section
         * @param {*} value
         * @param {Object} poi
         * @returns {HTMLElement|null}
         */
        renderBadge(section, value, poi) {
            return _getFieldRenderers().renderBadge(section, value, poi);
        },

        /**
         * Rend une image.
         * @param {Object} section
         * @param {string} imageUrl
         * @returns {HTMLElement|null}
         */
        renderImage(section, imageUrl) {
            return _getMediaRenderers().renderImage(section, imageUrl);
        },

        /**
         * Rend une galerie.
         * @param {Object} section
         * @param {Array<string>} gallery
         * @returns {HTMLElement|null}
         */
        renderGallery(section, gallery) {
            return _getMediaRenderers().renderGallery(section, gallery);
        },

        /**
         * Rend un lien.
         * @param {Object} section
         * @param {string} url
         * @returns {HTMLElement|null}
         */
        renderLink(section, url) {
            return RendererLinks.renderLink(section, url);
        },
    };

    /*!
     * GeoLeaf Core
     *  2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const _POIRenderers = {
        /**
         * Rend le contenu complet d'un POI
         * @param {Object} poi - Données du POI
         * @param {Object} state - État
         * @returns {DocumentFragment}
         */
        renderContent(poi, state) {
            return POIRenderersContract.renderContent(poi, state);
        },

        /**
         * Rend un champ texte
         */
        renderText(section, poi, value) {
            return POIRenderersContract.renderText(section, poi, value);
        },

        /**
         * Rend un badge
         */
        renderBadge(section, value, poi) {
            return POIRenderersContract.renderBadge(section, value, poi);
        },

        /**
         * Rend une image
         */
        renderImage(section, imageUrl) {
            return POIRenderersContract.renderImage(section, imageUrl);
        },

        /**
         * Rend une galerie
         */
        renderGallery(section, gallery) {
            return POIRenderersContract.renderGallery(section, gallery);
        },

        /**
         * Rend un lien
         */
        renderLink(section, url) {
            return POIRenderersContract.renderLink(section, url);
        },

        /**
         * Peuple le side panel avec les données du POI
         * @returns {Promise<void>}
         */
        async populateSidePanel(poi, customLayout) {
            return POIRenderersContract.populateSidePanel(poi, customLayout);
        },
    };

    //  ESM Export
    const POIRenderers = _POIRenderers;

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */





    /**
     * Shorthand for createElement
     */
    const $create$1 = (tag, props, ...children) => {
        return createElement$1(tag, props, ...children);
    };

    // Référence au module shared




    /**
     * Crée l'élément DOM du panneau latéral si non existant.
     */
    function createSidePanel() {
        const shared = POIShared;
        if (!shared) return;
        const state = shared.state;

        if (state.sidePanelElement) return; // Déjà créé

        // Créer l'overlay
        const overlay = $create$1('div', {
            className: 'gl-poi-sidepanel-overlay',
            attributes: { 'aria-hidden': 'true' }
        });
        // Ajouter à .gl-main pour support du mode plein écran
        const glMain = document.querySelector('.gl-main');
        if (glMain) {
            glMain.appendChild(overlay);
        } else {
            document.body.appendChild(overlay);
        }
        state.sidePanelOverlay = overlay;

        // Créer le panneau
        const panel = $create$1('aside', {
            className: 'gl-poi-sidepanel',
            attributes: {
                'aria-hidden': 'true',
                'role': 'complementary'
            }
        });

        // Créer le header avec bouton fermer
        const header = $create$1('div', { className: 'gl-poi-sidepanel__header' });
        const closeBtn = $create$1('button', {
            className: 'gl-poi-sidepanel__close',
            attributes: { 'aria-label': 'Fermer' },
            textContent: '×',
            onClick: closeSidePanel
        });
        header.appendChild(closeBtn);

        // Créer le content
        const content = $create$1('div', { className: 'gl-poi-sidepanel__content' });

        panel.appendChild(header);
        panel.appendChild(content);
        // Ajouter à .gl-main pour support du mode plein écran
        if (glMain) {
            glMain.appendChild(panel);
        } else {
            document.body.appendChild(panel);
        }
        state.sidePanelElement = panel;
        state.sidePanelContent = content;

        // Event listeners
        overlay.addEventListener('click', closeSidePanel);

        if (Log) Log.info('[POI] Side panel créé.');
    }

    /**
     * Ouvre le panneau latéral avec les infos complètes du POI.
     *
     * @param {object} poi - Données complètes du POI.
     * @param {object} customLayout - Layout personnalisé (optionnel).
     * @returns {Promise<void>}
     */
    async function openSidePanel(poi, customLayout) {
        if (!poi) {
            if (Log) Log.warn('[POI] openSidePanel() : POI invalide.');
            return;
        }

        if (Log) {
            Log.debug('[POI] openSidePanel:', poi.id || poi.name);
        }

        const shared = POIShared;
        if (!shared) {
            if (Log) Log.error('[POI] openSidePanel() : POIShared is null');
            return;
        }
        const state = shared.state;

        // S'assurer que le panneau existe
        if (!state.sidePanelElement) {
            createSidePanel();
        }

        if (!state.sidePanelElement) {
            if (Log) Log.error('[POI] openSidePanel() : Impossible de créer le panneau latéral.');
            return;
        }

        state.currentPoiInPanel = poi;
        state.currentGalleryIndex = 0;

        // Peupler le panneau (la lightbox sera créée par renderers.js si nécessaire)
        const renderers = POIRenderers;
        if (renderers && typeof renderers.populateSidePanel === 'function') {
            try {
                await renderers.populateSidePanel(poi, customLayout);
            } catch (err) {
                // Une erreur de rendu ne doit pas bloquer l'ouverture du panneau
                if (Log) Log.error('[POI] Erreur lors du peuplement du side panel :', err);
            }
        } else {
            if (Log) Log.warn('[POI] openSidePanel() : renderers.populateSidePanel non disponible');
        }

        // Afficher l'overlay et le panneau avec animation
        if (state.sidePanelOverlay) {
            state.sidePanelOverlay.classList.add('open');
        }
        state.sidePanelElement.classList.add('open');
        state.sidePanelElement.setAttribute('aria-hidden', 'false');

        // Ajouter classe au body pour décaler la carte
        document.body.classList.add('gl-poi-sidepanel-open');

        if (Log) Log.info('[POI] Panneau latéral ouvert pour :', poi.title || poi.name || poi.label);
    }

    /**
     * Ferme le panneau latéral.
     */
    function closeSidePanel() {
        const shared = POIShared;
        if (!shared) return;
        const state = shared.state;

        if (!state.sidePanelElement) return;

        state.sidePanelElement.classList.remove('open');
        state.sidePanelElement.setAttribute('aria-hidden', 'true');

        if (state.sidePanelOverlay) {
            state.sidePanelOverlay.classList.remove('open');
        }

        // Retirer classe du body
        document.body.classList.remove('gl-poi-sidepanel-open');

        // Nettoyer la lightbox globale
        const lightbox = document.querySelector('.gl-poi-lightbox-global');
        if (lightbox) {
            lightbox.remove();
        }

        state.currentPoiInPanel = null;

        if (Log) Log.info('[POI] Panneau latéral fermé.');
    }

    /**
     * Alias pour fermer le panneau (API publique).
     */
    function hideSidePanel() {
        closeSidePanel();
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POISidepanel = {
        createSidePanel,
        openSidePanel,
        closeSidePanel,
        hideSidePanel
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */




    // Références aux modules POI





    /**
     * Fonction principale d'initialisation du module POI.
     *
     * @param {L.Map|object} mapOrOptions - Instance de la carte Leaflet ou objet {map, config}.
     * @param {object} config - Configuration POI depuis globalThis.GeoLeaf.config.json (optionnel si premier param est objet).
     */
    async function init$1(mapOrOptions, config) {
        // Support pour les deux signatures: init(map, config) et init({map, config})
        let map, opts;


        if (mapOrOptions && typeof mapOrOptions === 'object' && mapOrOptions.map) {
            map = mapOrOptions.map;
            opts = mapOrOptions.config || mapOrOptions;
        } else {
            map = mapOrOptions;
            opts = config;
        }

        if (!map || typeof map.addLayer !== 'function') {
            if (Log) Log.error('[POI] Aucune carte Leaflet valide fournie. Impossible d\'initialiser le module POI.');
            return;
        }

        const shared = POIShared;
        if (!shared) {
            if (Log) Log.error('[POI] Module shared non chargé.');
            return;
        }

        const state = shared.state;
        const constants = shared.constants;

        state.mapInstance = map;
        state.poiConfig = opts || {};

        if (Log) Log.info('[POI] Initialisation du module POI...');

        // Forcer un maxZoom valide sur la carte
        if (shared.ensureMapMaxZoom) {
            shared.ensureMapMaxZoom(map, constants.POI_MAX_ZOOM);
        }

        // Créer le layer group principal
        state.poiLayerGroup = L.layerGroup().addTo(map);

        // Créer le cluster group si clustering activé
        const clustering = state.poiConfig.clustering !== false;
        if (clustering && typeof L !== 'undefined' && typeof L.markerClusterGroup === 'function') {
            state.poiClusterGroup = L.markerClusterGroup({
                maxClusterRadius: state.poiConfig.clusterRadius || 80,
                disableClusteringAtZoom: state.poiConfig.disableClusteringAtZoom || constants.POI_MAX_ZOOM,
                animate: false,
                showCoverageOnHover: false
            });
            state.mapInstance.addLayer(state.poiClusterGroup);
            if (Log) Log.info('[POI] Clustering activé (MarkerClusterGroup créé).');
        }

        // Créer le panneau latéral (caché par défaut)
        const sidePanel = POISidepanel;
        if (sidePanel && typeof sidePanel.createSidePanel === 'function') {
            sidePanel.createSidePanel();
        }

        // Charger le sprite SVG AVANT de charger les POIs
        const markers = POIMarkers;
        if (markers && typeof markers.ensureProfileSpriteInjectedSync === 'function') {
            await markers.ensureProfileSpriteInjectedSync();
        }

        // Charger et afficher les POIs — event-driven (perf: suppression setTimeout 1000ms)
        if (state.poiConfig.enabled !== false) {
            // Si Storage déjà prêt, charger immédiatement ; sinon attendre l'événement
            const storageReady = StorageContract.isAvailable();
            if (storageReady) {
                loadAndDisplay();
            } else {
                // Écouter l'événement une seule fois, avec fallback DOMContentLoaded
                const onStorageReady = () => {
                    document.removeEventListener('geoleaf:storage:ready', onStorageReady);
                    loadAndDisplay();
                };
                document.addEventListener('geoleaf:storage:ready', onStorageReady, { once: true });
                // Fallback : si l'événement n'arrive pas (Storage absent), charger quand même après DOMContentLoaded
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        document.removeEventListener('geoleaf:storage:ready', onStorageReady);
                        loadAndDisplay();
                    }, { once: true });
                } else {
                    // DOM déjà prêt : planifier au prochain tick pour laisser Storage finir son init synchrone
                    Promise.resolve().then(() => {
                        document.removeEventListener('geoleaf:storage:ready', onStorageReady);
                        loadAndDisplay();
                    });
                }
            }
        }
    }

    /**
     * ✅ NOUVELLE FONCTION: Charge et fusionne les POI stockés localement avec les POI existants
     */
    function loadAndMergeStoredPois(existingPois, callback) {
        if (typeof callback !== 'function') {
            if (Log) Log.error('[POI] loadAndMergeStoredPois: callback requis');
            return;
        }

        // Phase 10-C: Vérification disponibilité Storage via StorageContract
        const checkStorageAvailable = () => {
            return StorageContract.isAvailable() && typeof StorageContract.DB?.getAllFromSyncQueue === 'function';
        };

        if (!checkStorageAvailable()) {
            // perf: remplacer setTimeout(1000) par écoute événement geoleaf:storage:ready
            if (Log) Log.warn('[POI] Module Storage pas encore prêt, attente événement geoleaf:storage:ready...');
            const onReady = () => {
                if (checkStorageAvailable()) {
                    loadAndMergeStoredPois(existingPois, callback);
                } else {
                    if (Log) Log.error('[POI] Module Storage toujours non disponible, abandon.');
                    callback(existingPois);
                }
            };
            document.addEventListener('geoleaf:storage:ready', onReady, { once: true });
            // Fallback si l'événement n'arrive jamais (Storage absent du build)
            Promise.resolve().then(() => {
                if (!checkStorageAvailable()) {
                    document.removeEventListener('geoleaf:storage:ready', onReady);
                    callback(existingPois);
                }
            });
            return;
        }

        if (Log) Log.info('[POI] Module Storage disponible, récupération des POI...');

        // Utiliser le module de synchronisation pour récupérer les POI du cache
        StorageContract.DB.getAllFromSyncQueue()
            .then(queueItems => {
                if (Log) Log.info(`[POI] Récupération cache: ${queueItems.length} items trouvés`);

                if (!Array.isArray(queueItems) || queueItems.length === 0) {
                    if (Log) Log.info('[POI] Aucun POI trouvé dans la file de synchronisation.');
                    callback(existingPois);
                    return;
                }

                // Débugger les types d'items trouvés
                if (Log) {
                    const itemTypes = queueItems.map(item => `${item.action}:${item.data?.type || 'no-type'}`);
                    Log.info(`[POI] Types d'items dans le cache: [${itemTypes.join(', ')}]`);

                    // DEBUG: Structure complète des premiers items
                    queueItems.slice(0, 2).forEach((item, i) => {
                        Log.info(`[POI] DEBUG Item ${i}:`, {
                            action: item.action,
                            type: item.type,
                            data_type: item.data?.type,
                            keys: Object.keys(item),
                            data_keys: item.data ? Object.keys(item.data) : 'no data'
                        });
                    });
                }

                // Filtrer les éléments POI (action 'add' ou 'update') et extraire les données
                const cachedPois = [];
                const normalizers = POINormalizers;

                if (!normalizers) {
                    if (Log) Log.error('[POI] Module Normalizers non disponible pour les POI du cache.');
                    callback(existingPois);
                    return;
                }

                queueItems.forEach(item => {
                    // Essayer différents formats de structure pour les POI
                    let isPoi = false;
                    let poiData = null;
                    let itemAction = null;

                    // Format 1: item.data.type === 'poi' && item.action contient 'add'
                    if (item.data && item.data.type === 'poi' && item.action &&
                        (item.action.includes('add') || item.action.includes('update'))) {
                        isPoi = true;
                        poiData = item.data;
                        itemAction = item.action;
                    }
                    // Format 2: item.type === 'poi' directement
                    else if (item.type === 'poi') {
                        isPoi = true;
                        poiData = item;
                        itemAction = item.action || 'add';
                    }
                    // Format 3: Contient un id POI et des coordonnées (detection heuristique)
                    else if (item.data && (item.data.id || item.data.latlng || item.data.latitude)) {
                        isPoi = true;
                        poiData = item.data;
                        itemAction = item.action || 'add';
                        if (Log) Log.info(`[POI] Détection heuristique POI: ${item.data.id || 'no-id'}`);
                    }
                    // Format 4: L'item lui-même est un POI (pas d'enveloppe data)
                    else if (item.id && (item.latlng || item.latitude)) {
                        isPoi = true;
                        poiData = item;
                        itemAction = 'add';
                        if (Log) Log.info(`[POI] Détection POI direct: ${item.id}`);
                    }

                    if (isPoi && poiData) {
                        // Normaliser le POI stocké comme les autres
                        const normalizedPoi = normalizers.normalizePoi(poiData);
                        if (normalizedPoi) {
                            cachedPois.push(normalizedPoi);
                            if (Log) Log.info(`[POI] POI du cache normalisé: ${normalizedPoi.id || 'Sans ID'} (action: ${itemAction})`);
                        } else {
                            if (Log) Log.warn('[POI] Échec normalisation POI du cache:', poiData);
                        }
                    } else {
                        if (Log) Log.debug(`[POI] Item ignoré - action: ${item.action}, type: ${item.type || item.data?.type}, keys: ${Object.keys(item).join(',')}`);
                    }
                });

                if (cachedPois.length > 0) {
                    if (Log) Log.info(`[POI] ${cachedPois.length} POI(s) récupéré(s) du cache local.`);

                    // Fusionner avec les POI existants (éviter les doublons par ID)
                    const mergedPois = [...existingPois];
                    cachedPois.forEach(cachedPoi => {
                        if (!mergedPois.find(p => p.id === cachedPoi.id)) {
                            mergedPois.push(cachedPoi);
                        }
                    });

                    callback(mergedPois);
                } else {
                    callback(existingPois);
                }
            })
            .catch(err => {
                if (Log) Log.error('[POI] Erreur lors de la récupération des POI du cache :', err);
                callback(existingPois);
            });
    }

    /**
     * Charge les POIs et les affiche sur la carte.
     */
    function loadAndDisplay() {
        const shared = POIShared;
        if (!shared) return;
        const state = shared.state;

        if (state.isLoading) {
            if (Log) Log.warn('[POI] Chargement déjà en cours...');
            return;
        }

        // 1) Essayer d'utiliser les POI normalisés du profil actif
        try {
            if (Config && typeof Config.getActiveProfilePoi === 'function') {
                const profilePois = Config.getActiveProfilePoi();
                if (Array.isArray(profilePois) && profilePois.length > 0) {
                    state.allPois = profilePois;
                    if (Log) Log.info(`[POI] ${state.allPois.length} POI(s) provenant du profil actif.`);

                    // ✅ CORRECTION: Charger aussi les POI du cache après les POI du profil
                    loadAndMergeStoredPois(state.allPois, function(mergedPois) {
                        state.allPois = mergedPois;
                        displayPois(state.allPois);
                    });
                    return;
                }
            }
        } catch (err) {
            if (Log) Log.error('[POI] Erreur lors de la récupération des POI du profil actif :', err);
        }

        // ✅ CORRECTION: Essayer de charger les POI stockés en cache AVANT le fallback dataUrl
        loadAndMergeStoredPois([], function(cachedPois) {
            if (cachedPois.length > 0) {
                state.allPois = cachedPois;
                if (Log) Log.info(`[POI] ${cachedPois.length} POI(s) chargé(s) depuis le cache local.`);
                displayPois(cachedPois);
                return;
            }

            // 2) Fallback : charger un fichier JSON depuis dataUrl (mode historique)
            const dataUrl = state.poiConfig.dataUrl;
            if (!dataUrl) {
                if (Log) Log.info('[POI] Aucune dataUrl spécifiée et aucun POI en cache. Mode ajout manuel.');
                return;
            }

            state.isLoading = true;
            if (Log) Log.info('[POI] Chargement des données POI depuis :', dataUrl);

            fetch(dataUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ${response.status} lors du chargement de ${dataUrl}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (Array.isArray(data)) {
                        state.allPois = data;
                    } else if (data && Array.isArray(data.pois)) {
                        state.allPois = data.pois;
                    } else {
                        state.allPois = [];
                    }
                    if (Log) Log.info(`[POI] ${state.allPois.length} POI(s) chargé(s) depuis dataUrl.`);
                    displayPois(state.allPois);
                })
                .catch(err => {
                    if (Log) Log.error('[POI] Erreur lors du chargement des POIs :', err);
                })
                .finally(() => {
                    state.isLoading = false;
                });
        });
    }

    /**
     * Affiche tous les POIs passés en paramètre sur la carte.
     *
     * @param {array} pois - Tableau d'objets POI.
     */
    function displayPois(pois) {
        if (!pois || !Array.isArray(pois)) {
            if (Log) Log.warn('[POI] displayPois() : Aucune donnée POI valide à afficher.');
            return;
        }

        const shared = POIShared;
        if (!shared) return;
        const state = shared.state;

        // Nettoyer les layers existants
        if (state.poiLayerGroup) {
            state.poiLayerGroup.clearLayers();
        }
        if (state.poiClusterGroup) {
            state.poiClusterGroup.clearLayers();
        }

        const clustering = state.poiConfig.clustering !== false;
        const markers = POIMarkers;

        if (!markers || typeof markers.createMarker !== 'function') {
            if (Log) Log.error('[POI] Module Markers non chargé.');
            return;
        }

        if (clustering && state.poiClusterGroup) {
            // Mode clustering
            pois.forEach(poi => {
                const marker = markers.createMarker(poi);
                if (marker) {
                    state.poiClusterGroup.addLayer(marker);
                    state.poiMarkers.set(poi.id || poi.title || poi.label, marker);
                }
            });

            if (!state.mapInstance.hasLayer(state.poiClusterGroup)) {
                state.mapInstance.addLayer(state.poiClusterGroup);
            }

            if (Log) Log.info('[POI] Affichage avec clustering.');
        } else {
            // Mode sans clustering
            pois.forEach(poi => {
                const marker = markers.createMarker(poi);
                if (marker) {
                    state.poiLayerGroup.addLayer(marker);
                    state.poiMarkers.set(poi.id || poi.title || poi.label, marker);
                }
            });

            if (!state.mapInstance.hasLayer(state.poiLayerGroup)) {
                state.mapInstance.addLayer(state.poiLayerGroup);
            }

            if (Log) Log.info('[POI] Affichage sans clustering.');
        }
    }

    /**
     * Ajoute un POI manuellement sur la carte.
     * CORRIGÉ V3: Normalisation systématique des nouveaux POI
     *
     * @param {object} poi - Données du POI.
     * @returns {L.Marker|null} Marqueur créé ou null.
     */
    function addPoi(poi) {
        if (!poi) {
            if (Log) Log.warn('[POI] addPoi() : POI invalide.');
            return null;
        }

        const shared = POIShared;
        if (!shared) return null;
        const state = shared.state;

        const normalizers = POINormalizers;
        const markers = POIMarkers;

        if (!normalizers || !markers) {
            if (Log) Log.error('[POI] Modules Normalizers ou Markers non chargés.');
            return null;
        }

        // ✅ CORRECTION V3: NORMALISER le POI avant traitement
        // Ceci garantit une structure cohérente avec les POI existants
        const normalizedPoi = normalizers.normalizePoi(poi);
        if (!normalizedPoi) {
            if (Log) Log.warn('[POI] addPoi() : Échec de la normalisation du POI.', poi);
            return null;
        }

        // Générer un ID si manquant après normalisation
        if (!normalizedPoi.id) {
            normalizedPoi.id = normalizers.generatePoiId(normalizedPoi);
        }

        if (Log) {
            Log.info('[POI] Adding normalized POI:', normalizedPoi.id);
            Log.info('[POI] - Has _layerConfig:', !!normalizedPoi._layerConfig);
            Log.info('[POI] - Has _sidepanelConfig:', !!normalizedPoi._sidepanelConfig);
            Log.info('[POI] - Has _popupConfig:', !!normalizedPoi._popupConfig);
            Log.info('[POI] - Attributes keys:', Object.keys(normalizedPoi.attributes || {}));
        }

        // Créer le marqueur avec le POI normalisé
        const marker = markers.createMarker(normalizedPoi);
        if (!marker) {
            if (Log) Log.warn('[POI] addPoi() : Impossible de créer le marqueur pour ce POI normalisé.', normalizedPoi);
            return null;
        }

        // Ajouter au bon layer group
        const clustering = state.poiConfig.clustering !== false;
        if (clustering && state.poiClusterGroup) {
            state.poiClusterGroup.addLayer(marker);
        } else {
            state.poiLayerGroup.addLayer(marker);
        }

        // Stocker le POI NORMALISÉ dans la liste (important pour la cohérence)
        state.allPois.push(normalizedPoi);
        state.poiMarkers.set(normalizedPoi.id, marker);

        // Note: La sauvegarde en cache est gérée par le submit-handler via SyncHandler
        // pour éviter la duplication et assurer la cohérence

        if (Log) Log.info('[POI] ✅ POI normalisé ajouté avec succès :', normalizedPoi.id);

        return marker;
    }

    /**
     * Récupère tous les POI chargés.
     *
     * @returns {array} Tableau des POI.
     */
    function getAllPois() {
        const shared = POIShared;
        return shared ? shared.state.allPois : [];
    }

    /**
     * Récupère un POI par son ID.
     *
     * @param {string} id - ID du POI.
     * @returns {object|null} POI trouvé ou null.
     */
    function getPoiById(id) {
        const shared = POIShared;
        if (!shared) return null;
        const state = shared.state;

        return state.allPois.find(p => p.id === id) || null;
    }

    /**
     * Recharge les POI (efface et réaffiche).
     *
     * @param {array} pois - Nouveau tableau de POI (optionnel).
     */
    function reload(pois) {
        const shared = POIShared;
        if (!shared) return;
        const state = shared.state;

        if (pois && Array.isArray(pois)) {
            state.allPois = pois;
        }

        displayPois(state.allPois);

        if (Log) Log.info('[POI] POI rechargés.');
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POICore = {
        init: init$1,
        loadAndDisplay,
        displayPois,
        addPoi,
        getAllPois,
        getPoiById,
        reload,
        getDisplayedPoisCount: function() {
            const shared = POIShared;
            return shared && shared.state ? (shared.state.allPois || []).length : 0;
        }
    };

    /**
     * GeoLeaf Contract — POI Core operations
     *
     * Interface ESM pour que les modules POI (add-form, sync…) puissent appeler
     * les opérations CRUD du module POI (addPoi, updatePoi, removePoi, notify)
     * sans couplage runtime vers le namespace global.
     *
     * Phase 10-E — Pattern G.
     *
     * REGISTRATION (dans globals.poi.js ou geoleaf.core.js) :
     *   import { POICoreContract } from '../../contracts/poi-core.contract.js';
     *   POICoreContract.register({ addPoi, updatePoi, removePoi }, notifyInstance);
     */

    /** @type {{updatePoi?: Function, removePoi?: Function}|null} */
    let _extra = null;
    /** @type {{success: Function, error: Function}|null} */
    let _notify = null;

    /**
     * @namespace POICoreContract
     */
    const POICoreContract = {
        /**
         * Enregistre les fonctions POI non-exportées et le système de notification.
         * Appelé par globals.poi.js ou le plugin addpoi au chargement.
         * @param {{updatePoi?: Function, removePoi?: Function}} extras
         * @param {{success: Function, error: Function}} [notifyInstance]
         */
        register(extras, notifyInstance) {
            _extra = extras || {};
            if (notifyInstance) _notify = notifyInstance;
        },

        /**
         * @returns {boolean}
         */
        canShowDetails() {
            return !!(_extra && typeof _extra.showPoiDetails === 'function');
        },

        /**
         * Show POI details panel.
         * @param {Object} poi
         */
        showPoiDetails(poi) {
            if (_extra && typeof _extra.showPoiDetails === 'function') {
                _extra.showPoiDetails(poi);
            }
        },
        /**
         * Enregistre l'instance UI.notify.
         * @param {{success: Function, error: Function}} notifyInstance
         */
        registerNotify(notifyInstance) {
            _notify = notifyInstance;
        },

        // ── POI CRUD ──

        /**
         * @param {Object} poi
         * @returns {L.Marker|null}
         */
        addPoi(poi) {
            return POICore.addPoi(poi);
        },

        /**
         * @param {Object} poiData
         */
        updatePoi(poiData) {
            if (_extra && typeof _extra.updatePoi === 'function') {
                _extra.updatePoi(poiData);
            }
            // else: graceful no-op — updatePoi not yet registered
        },

        /**
         * @param {string} poiId
         */
        removePoi(poiId) {
            if (_extra && typeof _extra.removePoi === 'function') {
                _extra.removePoi(poiId);
            }
        },

        /**
         * @returns {boolean}
         */
        canUpdate() {
            return !!(_extra && typeof _extra.updatePoi === 'function');
        },

        /**
         * @returns {boolean}
         */
        canRemove() {
            return !!(_extra && typeof _extra.removePoi === 'function');
        },

        // ── Notifications ──

        /**
         * @param {string} message
         */
        notifySuccess(message) {
            if (_notify && typeof _notify.success === 'function') {
                _notify.success(message);
            }
        },

        /**
         * @param {string} message
         */
        notifyError(message) {
            if (_notify && typeof _notify.error === 'function') {
                _notify.error(message);
            }
        },
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */





    // Références aux modules POI





    /**
     * Obtient la configuration de base des POI depuis le profil actif.
     *
     * @returns {object} Configuration de base { radius, weight, colorFill, colorStroke, fillOpacity, opacity, showIconsOnMap }.
     */
    function getPoiBaseConfig() {
        const base = {
            radius: 6,
            weight: 1.5,
            colorFill: "#4a90e5",
            colorStroke: "#ffffff",
            fillOpacity: 0.8,
            opacity: 0.9,
            showIconsOnMap: true
        };

        try {
            if (Config && typeof Config.getActiveProfile === "function") {
                const activeProfile = Config.getActiveProfile();
                const poiCfg =
                    activeProfile &&
                    activeProfile.appearance &&
                    activeProfile.appearance.poi;

                if (poiCfg) {
                    if (typeof poiCfg.radius === "number") base.radius = poiCfg.radius;
                    if (typeof poiCfg.weight === "number") base.weight = poiCfg.weight;
                    if (typeof poiCfg.fillOpacity === "number") base.fillOpacity = poiCfg.fillOpacity;
                    if (typeof poiCfg.opacity === "number") base.opacity = poiCfg.opacity;
                    if (typeof poiCfg.showIconsOnMap === "boolean") base.showIconsOnMap = poiCfg.showIconsOnMap;

                    if (typeof poiCfg.colorFill === "string") {
                        base.colorFill = poiCfg.colorFill;
                    }
                    if (typeof poiCfg.colorStroke === "string") {
                        base.colorStroke = poiCfg.colorStroke;
                    }
                }
            }

            // Fallback sur variables CSS
            if (typeof document !== "undefined" && typeof window !== "undefined" && window.getComputedStyle) {
                const root = getComputedStyle(document.documentElement);
                const fillCss = root.getPropertyValue("--gl-color-poi-fill-default").trim();
                const strokeCss = root.getPropertyValue("--gl-color-poi-stroke-default").trim();
                if (fillCss && !base.colorFill) base.colorFill = fillCss;
                if (strokeCss && !base.colorStroke) base.colorStroke = strokeCss;
            }
        } catch (err) {
            if (Log) Log.warn("[POI] getPoiBaseConfig() : Erreur lecture config :", err);
        }

        return base;
    }

    /**
     * Résout les couleurs d'un POI depuis category.style.json du profil actif.
     * Ordre de priorité des couleurs :
     * 1. Style de la couche (poi._layerConfig.style)
     * 2. Style de catégorie (category.style.json)
     * 3. Style par défaut (baseConfig)
     *
     * @param {object} poi - Données du POI.
     * @param {object} baseConfig - Configuration de base avec couleurs par défaut
     * @returns {object} { colorFill, colorStroke, colorRoute, weight, radius, fillOpacity, opacity }
     */
    function resolveCategoryColors(poi, baseConfig) {
        const colors = {
            colorFill: baseConfig.colorFill,
            colorStroke: baseConfig.colorStroke,
            colorRoute: null,
            weight: baseConfig.weight,
            radius: baseConfig.radius,
            fillOpacity: baseConfig.fillOpacity !== undefined ? baseConfig.fillOpacity : null,
            opacity: baseConfig.opacity !== undefined ? baseConfig.opacity : null
        };

        // 1. Appliquer d'abord le style de la couche si disponible
        if (poi._layerConfig && poi._layerConfig.style) {
            const layerStyle = poi._layerConfig.style;
            if (layerStyle.fillColor) colors.colorFill = layerStyle.fillColor;
            if (layerStyle.color) colors.colorStroke = layerStyle.color;
            if (typeof layerStyle.weight === 'number') colors.weight = layerStyle.weight;
            if (typeof layerStyle.radius === 'number') colors.radius = layerStyle.radius;
            if (typeof layerStyle.fillOpacity === 'number') colors.fillOpacity = layerStyle.fillOpacity;
            if (typeof layerStyle.opacity === 'number') colors.opacity = layerStyle.opacity;
        }

        // 2. Appliquer ensuite les couleurs depuis les styleRules de la couche
        if (StyleResolver) {
            const styleColors = StyleResolver.resolvePoiColors(poi);
            if (styleColors.colorFill) colors.colorFill = styleColors.colorFill;
            if (styleColors.colorStroke) colors.colorStroke = styleColors.colorStroke;
            if (styleColors.colorRoute) colors.colorRoute = styleColors.colorRoute;
        }

        return colors;
    }

    /**
     * Résout l'affichage d'un POI (icône + couleurs) depuis la taxonomie et category.style.json du profil actif.
     * Ordre de priorité des styles :
     * 1. Style de la couche (poi._layerConfig.style) pour les couleurs
     * 2. Style de catégorie (category.style.json) pour les couleurs
     * 3. Taxonomie pour les icônes
     * 4. Style par défaut (baseConfig)
     *
     * @param {object} poi - Données du POI.
     * @returns {object} Configuration d'affichage { useIcon, iconId, colorFill, colorStroke, weight, radius, fillOpacity, opacity }.
     */
    function resolveCategoryDisplay(poi) {
        const categoriesConfig = Config.getCategories?.()
            ?? {};

        const shared = POIShared;
        const poiConfig = shared ? shared.state.poiConfig : {};
        const showIconsOnMap = (poiConfig.showIconsOnMap !== false);

        const baseConfig = getPoiBaseConfig();

        // Résoudre les couleurs via resolveCategoryColors
        const colors = resolveCategoryColors(poi, baseConfig);

        const result = {
            useIcon: false,
            iconId: null,
            colorFill: colors.colorFill,
            colorStroke: colors.colorStroke,
            colorRoute: colors.colorRoute,
            weight: colors.weight,
            radius: colors.radius,
            fillOpacity: colors.fillOpacity,
            opacity: colors.opacity
        };

        // Déterminer si on utilise les icônes
        if (showIconsOnMap) {
            try {
                const iconsConfig = Config.getIconsConfig?.()
                    ?? null;

                if (iconsConfig && iconsConfig.showOnMap !== false) {
                    result.useIcon = true;
                }
            } catch (e) {
                // Fallback showIconsOnMap reste true par défaut
            }
        }

        const categoryId = poi.categoryId || poi.category ||
            (poi.attributes && poi.attributes.categoryId) ||
            (poi.properties && poi.properties.categoryId) ||
            (poi.properties && poi.properties.category);

        const subCategoryId = poi.subCategoryId || poi.subCategory || poi.sub_category ||
            (poi.attributes && poi.attributes.subCategoryId) ||
            (poi.properties && poi.properties.subCategoryId) ||
            (poi.properties && poi.properties.sub_category);

        // Résolution de l'icône depuis la taxonomie (pas les couleurs)
        // Lookup case-insensitive : on cherche d'abord la clé exacte, puis en majuscules/minuscules
        const resolveCatKey = (id) => {
            if (!id || !categoriesConfig) return null;
            if (categoriesConfig[id]) return id;
            const upper = String(id).toUpperCase();
            if (categoriesConfig[upper]) return upper;
            const lower = String(id).toLowerCase();
            if (categoriesConfig[lower]) return lower;
            // Parcours linéaire comme filet de sécurité
            return Object.keys(categoriesConfig).find(k => k.toLowerCase() === lower) || null;
        };

        const resolvedCatKey = resolveCatKey(categoryId);

        if (subCategoryId && resolvedCatKey && categoriesConfig[resolvedCatKey]?.subcategories) {
            const subCat = categoriesConfig[resolvedCatKey].subcategories[subCategoryId] ||
                           categoriesConfig[resolvedCatKey].subcategories[String(subCategoryId).toUpperCase()] ||
                           categoriesConfig[resolvedCatKey].subcategories[String(subCategoryId).toLowerCase()];
            const cat = categoriesConfig[resolvedCatKey];

            if (subCat) {
                result.iconId = subCat.icon || subCat.iconId || cat.icon || cat.iconId || null;
            } else {
                result.iconId = cat.icon || cat.iconId || null;
            }
        } else if (resolvedCatKey) {
            const cat = categoriesConfig[resolvedCatKey];
            result.iconId = cat.icon || cat.iconId || null;
        } else {
            // Ne logger que si une catégorie est réellement définie (éviter les warnings pour undefined/null)
            if (categoryId && categoryId !== 'undefined' && categoryId !== 'null' && Log) {
                Log.warn(`[POI] resolveCategoryDisplay() : Catégorie '${categoryId}' non trouvée dans la taxonomie.`);
            }
        }

        return result;
    }

    /**
     * Injecte le sprite SVG du profil actif dans le DOM (asynchrone).
     * Lit la configuration des icônes depuis taxonomy.icons.
     * Évite les duplications en vérifiant l'existence.
     * Note: La fonction reste nommée "Sync" pour la compatibilité, mais utilise fetch (async) en interne.
     */
    async function ensureProfileSpriteInjectedSync() {
        try {
            if (typeof Config === "undefined" || typeof Config.getIconsConfig !== "function") {
                if (Log) Log.warn("[POI] Config.getIconsConfig non disponible");
                return;
            }

            const iconsCfg = Config.getIconsConfig();
            // Log seulement la première fois ou si la config change
            if (!ensureProfileSpriteInjectedSync._lastConfig || JSON.stringify(iconsCfg) !== JSON.stringify(ensureProfileSpriteInjectedSync._lastConfig)) {
                if (Log) Log.debug("[POI] IconsConfig récupéré:", iconsCfg);
                ensureProfileSpriteInjectedSync._lastConfig = iconsCfg;
            }
            if (!iconsCfg) {
                if (Log) Log.warn("[POI] Aucune configuration d'icônes trouvée");
                return;
            }

            const spriteUrl = iconsCfg.spriteUrl;

            if (!spriteUrl || typeof spriteUrl !== "string") {
                if (Log) Log.warn("[POI] spriteUrl manquant ou invalide:", spriteUrl);
                return;
            }

            // Vérifier si le sprite est déjà injecté
            const existing = document.querySelector('svg[data-geoleaf-sprite="profile"]');
            if (existing) {
                if (Log) Log.debug("[POI] Sprite SVG déjà injecté");
                return;
            }

            if (Log) Log.info("[POI] Chargement sprite depuis:", spriteUrl);

            // ✅ NOUVEAU: Utiliser fetch asynchrone pour éviter l'avertissement de dépréciation
            // et améliorer les performances en évitant de bloquer le thread principal
            try {
                const response = await fetch(spriteUrl);

                if (response.ok) {
                    const svgText = await response.text();

                    // SAFE: Utilisation de DOMParser au lieu de innerHTML pour éviter l'exécution de scripts
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");

                    // Vérifier les erreurs de parsing
                    const parserError = doc.querySelector("parsererror");
                    if (parserError) {
                        if (Log) Log.warn("[POI] Erreur parsing SVG sprite :", parserError.textContent);
                        return;
                    }

                    const svgEl = doc.documentElement;
                    if (svgEl && svgEl.tagName.toLowerCase() === "svg") {
                        svgEl.setAttribute("data-geoleaf-sprite", "profile");
                        svgEl.style.position = "absolute";
                        svgEl.style.width = "0";
                        svgEl.style.height = "0";
                        svgEl.style.overflow = "hidden";
                        svgEl.setAttribute("aria-hidden", "true");

                        if (document.body.firstChild) {
                            document.body.insertBefore(svgEl, document.body.firstChild);
                        } else {
                            document.body.appendChild(svgEl);
                        }

                        const symbolCount = svgEl.querySelectorAll('symbol').length;
                        if (Log) Log.info("[POI] Sprite SVG profil injecté dans le DOM (async).", symbolCount, "symboles chargés.");
                    }
                } else {
                    if (Log) Log.warn("[POI] Erreur chargement sprite profil: HTTP", response.status);
                }
            } catch (err) {
                if (Log) Log.warn("[POI] Erreur chargement sprite profil (async):", err);
            }
        } catch (err) {
            if (Log) Log.warn("[POI] Erreur chargement sprite profil :", err);
        }
    }

    /**
     * Extrait les coordonnées d'un POI pour la création de marqueur.
     *
     * @param {object} poi - Données du POI.
     * @returns {[number, number]|null} [latitude, longitude] ou null si invalides.
     */
    function extractMarkerCoordinates(poi) {
        if (!poi) {
            if (Log) Log.warn("[POI] extractMarkerCoordinates() : POI invalide.", poi);
            return null;
        }

        const normalizers = POINormalizers;
        if (!normalizers) {
            if (Log) Log.error("[POI] extractMarkerCoordinates() : Module Normalizers non chargé.");
            return null;
        }

        const coords = normalizers.extractCoordinates(poi);
        if (!coords) {
            if (Log) Log.warn("[POI] extractMarkerCoordinates() : POI sans coordonnées valides.", poi);
            return null;
        }

        return coords;
    }

    /**
     * Construit l'icône Leaflet (DivIcon) pour un marqueur POI.
     * Mode icône : utilise le sprite SVG profil avec cercle de fond.
     * Mode simple : cercle simple sans icône.
     *
     * @param {object} displayConfig - Configuration d'affichage { useIcon, iconId, colorFill, colorStroke, radius, weight, fillOpacity, opacity }.
     * @returns {L.DivIcon} Icône Leaflet configurée.
     */
    function buildMarkerIcon(displayConfig) {
        const baseConfig = getPoiBaseConfig();
        const radius = displayConfig.radius !== undefined ? displayConfig.radius : baseConfig.radius;
        const weight = displayConfig.weight !== undefined ? displayConfig.weight : baseConfig.weight;
        const fillOpacity = displayConfig.fillOpacity;
        const strokeOpacity = displayConfig.opacity;

        const iconSizeCircle = Math.max(Math.round((radius * 2) + (weight * 2)), 8);
        const iconSizeIcon = Math.max(Math.round((radius * 2) + (weight * 2)), 16);

        // Appliquer fillOpacity à colorFill si défini
        let colorFill = displayConfig.colorFill;
        if (fillOpacity !== null && typeof fillOpacity === 'number') {
            // Convertir la couleur hex en rgba avec fillOpacity
            if (colorFill && colorFill.startsWith('#')) {
                const r = parseInt(colorFill.slice(1, 3), 16);
                const g = parseInt(colorFill.slice(3, 5), 16);
                const b = parseInt(colorFill.slice(5, 7), 16);
                colorFill = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + fillOpacity + ')';
            }
        }

        // Appliquer opacity au stroke (colorStroke) si défini
        let colorStroke = displayConfig.colorStroke;
        if (strokeOpacity !== null && typeof strokeOpacity === 'number') {
            // Convertir la couleur hex en rgba avec opacity
            if (colorStroke && colorStroke.startsWith('#')) {
                const r = parseInt(colorStroke.slice(1, 3), 16);
                const g = parseInt(colorStroke.slice(3, 5), 16);
                const b = parseInt(colorStroke.slice(5, 7), 16);
                colorStroke = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + strokeOpacity + ')';
            }
        }

        if (displayConfig.useIcon && displayConfig.iconId) {
            // Mode icône : DivIcon avec sprite métier
            const iconsConfig = Config.getIconsConfig?.()
                ?? null;
            const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || "gl-poi-cat-";

            const iconIdNormalized = String(displayConfig.iconId)
                .trim()
                .toLowerCase()
                .replace(/\s+/g, "-");

            const symbolId = iconPrefix + iconIdNormalized;

            const htmlIcon = [
                '<div class="gl-poi-marker" style="',
                "--gl-poi-fill:", colorFill, ";",
                "--gl-poi-stroke:", colorStroke, ";",
                "width:", iconSizeIcon, "px;",
                "height:", iconSizeIcon, "px;",
                '">',
                '<svg class="gl-poi-marker__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24" style="overflow: visible;">',
                '<circle cx="12" cy="12" r="10" fill="', colorFill, '" stroke="', colorStroke, '" stroke-width="', weight, '"/>',
                '<svg x="2" y="2" width="20" height="20" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" overflow="visible">',
                '<use href="#', symbolId, '" style="color: #ffffff"/>',
                '</svg>',
                "</svg>",
                "</div>"
            ].join("");

            return L.divIcon({
                html: htmlIcon,
                className: "gl-poi-divicon",
                iconSize: [iconSizeIcon, iconSizeIcon],
                iconAnchor: [iconSizeIcon / 2, iconSizeIcon / 2],
                popupAnchor: [0, -(iconSizeIcon / 2)]
            });
        } else {
            // Mode point simple (sans icône)
            const htmlCircle = [
                '<div class="gl-poi-marker" style="',
                "--gl-poi-fill:", colorFill, ";",
                "--gl-poi-stroke:", colorStroke, ";",
                "width:", iconSizeCircle, "px;",
                "height:", iconSizeCircle, "px;",
                '">',
                '<svg class="gl-poi-marker__circle" aria-hidden="true" focusable="false">',
                '<circle cx="50%" cy="50%" r="', radius, '"',
                ' fill="', colorFill, '"',
                ' stroke="', colorStroke, '"',
                ' stroke-width="', weight, '" />',
                "</svg>",
                "</div>"
            ].join("");

            return L.divIcon({
                html: htmlCircle,
                className: "gl-poi-divicon",
                iconSize: [iconSizeCircle, iconSizeCircle],
                iconAnchor: [iconSizeCircle / 2, iconSizeCircle / 2],
                popupAnchor: [0, -(iconSizeCircle / 2)]
            });
        }
    }

    /**
     * Attache les événements et comportements à un marqueur POI (tooltip, popup, side panel).
     *
     * @param {L.Marker} marker - Marqueur Leaflet à configurer.
     * @param {object} poi - Données du POI.
     */
    function attachMarkerEvents(marker, poi) {
        // Attacher métadonnées POI
        marker._geoleafPoiData = poi;

        const shared = POIShared;
        const poiConfig = shared ? shared.state.poiConfig : {};
        const popupModule = POIPopup;

        // Gestion tooltip
        if (popupModule && typeof popupModule.manageTooltip === 'function') {
            popupModule.manageTooltip(marker, poi, poiConfig, resolveCategoryDisplay);
        }

        // Vérifier si les popups sont activés (par défaut: true)
        const showPopup = (poiConfig.showPopup !== false);

        if (showPopup) {
            // Mode popup: afficher le popup avec lien "Voir plus"
            if (popupModule && typeof popupModule.buildQuickPopupContent === 'function') {
                const popupContent = popupModule.buildQuickPopupContent(poi, resolveCategoryDisplay);
                if (popupContent) {
                    if (popupModule.attachPopup) {
                        popupModule.attachPopup(marker, popupContent);
                    } else {
                        marker.bindPopup(popupContent);
                    }
                } else {
                    Log.error('[markers] Popup content vide pour POI:', poi.id);
                }

                // Initialiser le flag de popup actif
                marker._geoleafPopupActive = false;

                // Bloquer l'ouverture du tooltip pendant que le popup est actif
                marker.on('tooltipopen', function() {
                    if (marker._geoleafPopupActive) {
                        marker.closeTooltip();
                    }
                });

                // Attacher événement pour le lien "Voir plus" du popup
                marker.on('popupopen', function() {
                    // Marquer le popup comme actif et fermer le tooltip
                    marker._geoleafPopupActive = true;
                    marker.closeTooltip();

                    setTimeout(function() {
                        const link = document.querySelector('.gl-poi-popup__link[data-poi-id="' + poi.id + '"]');
                        if (link) {
                            if (Log) Log.info('[POI] Lien "Voir plus" trouvé pour POI:', poi.id);

                            // Retirer les anciens listeners pour éviter les doublons
                            const newLink = link.cloneNode(true);
                            link.parentNode.replaceChild(newLink, link);

                            newLink.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();

                                if (Log) Log.info('[POI] Clic sur "Voir plus" pour POI:', poi.id);

                                // Fermer le popup
                                if (marker && marker.closePopup) {
                                    marker.closePopup();
                                }

                                // Ouvrir le side panel avec un petit délai
                                setTimeout(function() {
                                    if (Log) Log.info('[POI] Appel de showPoiDetails pour:', poi.id);
                                    const _gPOI = typeof globalThis !== 'undefined' ? globalThis : window;
                                    if (_gPOI.GeoLeaf?.POI?.showPoiDetails) {
                                        _gPOI.GeoLeaf.POI.showPoiDetails(poi);
                                    } else {
                                        POICoreContract.showPoiDetails?.(poi);
                                    }
                                }, 100);
                            });
                        } else {
                            if (Log) Log.warn('[POI] Lien "Voir plus" non trouvé pour POI:', poi.id);
                        }
                    }, 50);
                });

                // Réactiver le tooltip quand le popup se ferme
                marker.on('popupclose', function() {
                    marker._geoleafPopupActive = false;

                    // Réouvrir le tooltip s'il est permanent (mode "always")
                    if (marker.getTooltip() && marker.getTooltip().options.permanent) {
                        setTimeout(function() {
                            if (marker.openTooltip && !marker._geoleafPopupActive) {
                                marker.openTooltip();
                            }
                        }, 50);
                    }
                });
            }
        } else {
            // Mode direct: ouvrir le side panel directement au clic sur le marker (sans popup)
            marker.on('click', function(e) {
                e.originalEvent.stopPropagation();

                if (Log) Log.info('[POI] Clic direct sur marker (sans popup) pour POI:', poi.id);

                const _gPOI = typeof globalThis !== 'undefined' ? globalThis : window;
                if (_gPOI.GeoLeaf?.POI?.showPoiDetails) {
                    _gPOI.GeoLeaf.POI.showPoiDetails(poi);
                } else {
                    POICoreContract.showPoiDetails?.(poi);
                }
            });
        }
    }

    /**
     * Crée un marqueur Leaflet pour un POI.
     * Orchestrateur principal : coordonnées → affichage → icône → événements.
     *
     * @param {object} poi - Données du POI.
     * @returns {L.Marker|null} Marqueur Leaflet ou null si invalide.
     */
    /**
     * Crée un marqueur Leaflet pour un POI.
     * Orchestrateur principal : coordonnées → affichage → icône → événements.
     *
     * @param {object} poi - Données du POI.
     * @param {object} [options] - Options de création.
     * @param {boolean} [options.attachEvents=true] - Si false, ne pas attacher les événements (popup, tooltip).
     * @param {string} [options.pane] - Nom du pane Leaflet à utiliser pour le z-index.
     * @returns {L.Marker|null} Marqueur Leaflet ou null si invalide.
     */
    function createMarker(poi, options = {}) {
        if (!poi) {
            if (Log) Log.warn("[POI] createMarker() : POI invalide.", poi);
            return null;
        }

        const { attachEvents = true, pane } = options;

        // Extraction coordonnées
        const coords = extractMarkerCoordinates(poi);
        if (!coords) {
            return null;
        }

        const [lat, lon] = coords;

        // Résolution de l'affichage (icône et couleurs)
        const displayConfig = resolveCategoryDisplay(poi);

        // Construction de l'icône Leaflet
        const customIcon = buildMarkerIcon(displayConfig);

        // Options du marker avec pane si fourni
        const markerOptions = { icon: customIcon };
        if (pane) {
            markerOptions.pane = pane;
        }

        // Création du marqueur Leaflet avec le pane
        const marker = L.marker([lat, lon], markerOptions);

        // Attacher événements et comportements (sauf si désactivé)
        if (attachEvents) {
            attachMarkerEvents(marker, poi);
        }

        return marker;
    }

    // ========================================
    //   EXPORT
    // ========================================

    const POIMarkers = {
        getPoiBaseConfig,
        resolveCategoryDisplay,
        ensureProfileSpriteInjectedSync,
        extractMarkerCoordinates,
        buildMarkerIcon,
        attachMarkerEvents,
        createMarker
    };

    /**
     * Module Legend Renderer
     * Rendu des symboles de légende cartographique
     *
     * DÉPENDANCES:
     * - Leaflet (L.DomUtil)
     * - GeoLeaf.Log (optionnel)
     *
     * EXPOSE:
     * - GeoLeaf._LegendRenderer
     */



    /**
     * Rendu d'une section de légende
     * @param {HTMLElement} container - Conteneur parent
     * @param {Object} section - Section de légende
     */
    function renderSection(container, section) {
        const sectionEl = globalThis.L.DomUtil.create("div", "gl-legend__section", container);

        // Titre de section
        if (section.title) {
            const titleEl = globalThis.L.DomUtil.create("h3", "gl-legend__section-title", sectionEl);
            titleEl.textContent = section.title;
        }

        // Items
        const itemsContainer = globalThis.L.DomUtil.create("div", "gl-legend__items", sectionEl);
        if (Array.isArray(section.items)) {
            section.items.forEach(item => renderItem(itemsContainer, item));
        }

        return sectionEl;
    }


    /**
     * Rendu d'un item de légende
     * @param {HTMLElement} container - Conteneur parent
     * @param {Object} item - Item de légende
     */
    function renderItem(container, item) {
        const itemEl = globalThis.L.DomUtil.create("div", "gl-legend__item", container);

        // Symbole
        const symbolEl = globalThis.L.DomUtil.create("div", "gl-legend__symbol", itemEl);
        renderSymbol(symbolEl, item);

        // Texte
        const textContainer = globalThis.L.DomUtil.create("div", "gl-legend__text", itemEl);

        const labelEl = globalThis.L.DomUtil.create("span", "gl-legend__label", textContainer);
        labelEl.textContent = item.label || "";

        if (item.description) {
            const descEl = globalThis.L.DomUtil.create("span", "gl-legend__description", textContainer);
            descEl.textContent = item.description;
        }

        return itemEl;
    }

    /**
     * Rendu d'un symbole selon son type
     * @param {HTMLElement} container - Conteneur du symbole
     * @param {Object} item - Configuration du symbole
     */
    function renderSymbol(container, item) {
        // Déléguer au module commun
        if (_UIComponents && typeof _UIComponents.renderSymbol === 'function') {
            _UIComponents.renderSymbol(container, item);
        } else {
            // Fallback si module non chargé
            if (Log) Log.error("[LegendRenderer] Module _UIComponents non disponible");
        }
    }

    /**
     * Rendu du footer
     * @param {HTMLElement} container - Conteneur parent
     * @param {Object} footer - Configuration du footer
     */
    function renderFooter(container, footer) {
        if (!footer || !footer.text) return;

        const footerEl = globalThis.L.DomUtil.create("div", "gl-legend__footer", container);
        footerEl.textContent = footer.text;

        if (footer.style === "italic") {
            footerEl.style.fontStyle = "italic";
        }
    }

    /**
     * Rendu d'un accordéon pour une couche
     * @param {HTMLElement} container - Conteneur parent
     * @param {Object} accordionData - Configuration de l'accordéon
     * @param {string} accordionData.layerId - ID de la couche
     * @param {string} accordionData.label - Titre de l'accordéon
     * @param {boolean} accordionData.collapsed - État initial
     * @param {boolean} accordionData.visible - Couche visible ou non (pour grisage)
     * @param {Array} accordionData.sections - Sections de légende
     */
    function renderAccordion(container, accordionData) {
        // Utiliser le module commun pour créer l'accordéon
        const _UIComponents = (typeof globalThis !== 'undefined' ? globalThis : window)?.GeoLeaf?._UIComponents;
        if (!_UIComponents) {
            if (Log) Log.error("[LegendRenderer] Module _UIComponents non disponible");
            return;
        }

        const { bodyEl } = _UIComponents.createAccordion(container, {
            layerId: accordionData.layerId,
            label: accordionData.label,
            collapsed: accordionData.collapsed !== false,
            visible: accordionData.visible,
            onToggle: (layerId, expanded) => {
                // Notifier le module Legend du changement
                const _gl = (typeof globalThis !== 'undefined' ? globalThis : window);
                if (_gl.GeoLeaf && _gl.GeoLeaf.Legend && typeof _gl.GeoLeaf.Legend.toggleAccordion === "function") {
                    _gl.GeoLeaf.Legend.toggleAccordion(layerId);
                }
            }
        });

        // Rendre les sections à l'intérieur du body
        if (Array.isArray(accordionData.sections)) {
            accordionData.sections.forEach(section => {
                renderSection(bodyEl, section);
            });
        }
    }

    const LegendRenderer = {
        renderSection: renderSection,
        renderItem: renderItem,
        renderSymbol: renderSymbol,
        renderFooter: renderFooter,
        renderAccordion: renderAccordion
    };

    /**
     * Module Legend Control
     * Contrôle Leaflet pour afficher une légende cartographique
     *
     * DÉPENDANCES:
     * - Leaflet (L.Control, L.DomUtil, L.DomEvent)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf._LegendRenderer
     *
     * EXPOSE:
     * - GeoLeaf._LegendControl
     */

    // Direct ESM bindings (P3-DEAD-01 complete)
    // Leaflet (L) and optional GeoLeaf runtime modules accessed via globalThis

    /**
     * S'assure que le sprite SVG des icônes est chargé avec vérification robuste
     * @private
     * @param {Function} [callback] - Fonction à appeler une fois le sprite chargé
     */
    async function ensureSpriteLoaded(callback) {
        if (POIMarkers && typeof POIMarkers.ensureProfileSpriteInjectedSync === "function") {
            // Éviter les logs répétitifs - log seulement la première fois
            if (!ensureSpriteLoaded._alreadyLogged) {
                if (Log) Log.debug("[Legend] Chargement du sprite SVG pour les icônes...");
                ensureSpriteLoaded._alreadyLogged = true;
            }

            // Attendre que le sprite soit chargé de manière asynchrone
            await POIMarkers.ensureProfileSpriteInjectedSync();

            // Perf 6.3.4: MutationObserver au lieu du polling setTimeout × 20
            const spriteEl = document.querySelector('svg[data-geoleaf-sprite="profile"]');
            if (spriteEl) {
                if (!ensureSpriteLoaded._spriteDetected) {
                    if (Log) Log.info("[Legend] Sprite SVG détecté et prêt pour utilisation");
                    ensureSpriteLoaded._spriteDetected = true;
                }
                if (typeof callback === "function") callback(true);
                return;
            }

            // Sprite pas encore dans le DOM : observer jusqu'à son apparition (max 2s)
            new Promise((resolve) => {
                const observer = new MutationObserver((_mutations, obs) => {
                    const el = document.querySelector('svg[data-geoleaf-sprite="profile"]');
                    if (el) {
                        obs.disconnect();
                        clearTimeout(timerId);
                        if (!ensureSpriteLoaded._spriteDetected) {
                            if (Log) Log.info("[Legend] Sprite SVG détecté via MutationObserver");
                            ensureSpriteLoaded._spriteDetected = true;
                        }
                        resolve(true);
                    }
                });
                observer.observe(document.documentElement || document.body, {
                    childList: true,
                    subtree: true,
                });

                const timerId = setTimeout(() => {
                    observer.disconnect();
                    if (Log) Log.warn("[Legend] Sprite SVG non trouvé après 2s");
                    resolve(false);
                }, 2000);
            }).then((found) => {
                if (typeof callback === "function") callback(found);
            });
        } else {
            if (Log)
                Log.debug(
                    "[Legend] GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync non disponible"
                );
            if (typeof callback === "function") {
                callback(false);
            }
        }
    }

    /**
     * Crée un contrôle Leaflet pour la légende cartographique
     * @param {Object} options - Options du contrôle
     * @returns {L.Control} - Instance du contrôle Leaflet
     */
    function createLegendControl(options) {
        if (!globalThis.L || !globalThis.L.Control) {
            if (Log) Log.error("[Legend] Leaflet L.Control non disponible");
            return null;
        }

        const LegendControl = globalThis.L.Control.extend({
            options: {
                position: options.position || "bottomleft",
            },

            initialize: function (controlOptions) {
                globalThis.L.setOptions(this, controlOptions || {});
                this._glOptions = controlOptions._glOptions;
            },

            onAdd: function (mapInstance) {
                this._map = mapInstance;
                this._container = globalThis.L.DomUtil.create("div", "gl-map-legend");

                // Empêcher les interactions carte
                if (globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.disableClickPropagation(this._container);
                    globalThis.L.DomEvent.disableScrollPropagation(this._container);
                }

                this._buildStructure();
                return this._container;
            },

            onRemove: function () {
                this._map = null;
                this._container = null;
            },

            /**
             * Construit la structure DOM de la légende
             * @private
             */
            _buildStructure: function () {
                const opts = this._glOptions;

                // Wrapper principal
                const wrapper = globalThis.L.DomUtil.create(
                    "div",
                    "gl-map-legend__wrapper",
                    this._container
                );

                // En-tête : titre + bouton collapse
                if (opts.title) {
                    const header = globalThis.L.DomUtil.create("div", "gl-map-legend__header", wrapper);

                    const titleEl = globalThis.L.DomUtil.create("h2", "gl-map-legend__title", header);
                    titleEl.textContent = opts.title;

                    if (opts.collapsible) {
                        const toggleEl = globalThis.L.DomUtil.create(
                            "button",
                            "gl-map-legend__toggle",
                            header
                        );
                        toggleEl.type = "button";
                        toggleEl.setAttribute("aria-label", "Basculer la légende");
                        toggleEl.textContent = "⟱";

                        const self = this;
                        globalThis.L.DomEvent.on(toggleEl, "click", function (ev) {
                            globalThis.L.DomEvent.stopPropagation(ev);
                            self._toggleCollapsed();
                        });
                    }
                }

                // Corps de la légende
                this._bodyEl = globalThis.L.DomUtil.create("div", "gl-map-legend__body", wrapper);

                // Appliquer l'état collapsed initial
                if (opts.collapsed) {
                    this._container.classList.add("gl-map-legend--collapsed");
                }

                // Rendu des sections via le renderer
                this._renderContent();
            },

            /**
             * Rend le contenu de la légende
             * @private
             */
            _renderContent: function () {
                if (!this._bodyEl) return;
                const opts = this._glOptions;

                // Vider le contenu existant
                DOMSecurity.clearElementFast(this._bodyEl);
                const renderer = LegendRenderer;

                if (!renderer) {
                    if (Log) Log.error("[Legend] LegendRenderer non disponible");
                    return;
                }

                // S'assurer que le sprite SVG est chargé pour les icônes
                ensureSpriteLoaded();

                // Rendu des sections (ancien mode pour compatibilité)
                if (Array.isArray(opts.sections)) {
                    opts.sections.forEach((section) => {
                        renderer.renderSection(this._bodyEl, section);
                    });
                }

                // Rendu du footer
                if (opts.footer) {
                    renderer.renderFooter(this._bodyEl, opts.footer);
                }
            },

            /**
             * Mise à jour du contenu multi-couches avec accordéons
             * @param {Array} legendsArray - Tableau d'accordéons à afficher
             */
            updateMultiLayerContent: function (legendsArray) {
                if (!this._bodyEl) return;

                // Vider le contenu existant
                DOMSecurity.clearElementFast(this._bodyEl);

                const renderer = LegendRenderer;

                if (!renderer || typeof renderer.renderAccordion !== "function") {
                    if (Log) Log.error("[Legend] Renderer.renderAccordion non disponible");
                    return;
                }

                // S'assurer que le sprite SVG est chargé avant le rendu
                const self = this;
                ensureSpriteLoaded(function (spriteLoaded) {
                    if (Log)
                        Log.debug("[Legend] Sprite chargé:", spriteLoaded, "- Rendu des accordéons");

                    // Rendre chaque accordéon (même si le sprite n'est pas chargé pour éviter une interface vide)
                    if (Array.isArray(legendsArray)) {
                        legendsArray.forEach((accordionData) => {
                            renderer.renderAccordion(self._bodyEl, accordionData);
                        });
                    }

                    // Si le sprite n'était pas chargé, réessayer dans 1 seconde
                    if (!spriteLoaded) {
                        setTimeout(function () {
                            const spriteEl = document.querySelector(
                                'svg[data-geoleaf-sprite="profile"]'
                            );
                            if (spriteEl && Log) {
                                Log.info(
                                    "[Legend] Sprite chargé tardivement - Re-rendu des accordéons"
                                );
                                self.updateMultiLayerContent(legendsArray);
                            }
                        }, 1000);
                    }
                });
            },

            /**
             * Mise à jour du contenu de la légende (ancien mode)
             * @param {Object} legendData - Nouvelles données de légende
             */
            updateContent: function (legendData) {
                if (legendData.title) this._glOptions.title = legendData.title;
                if (legendData.sections) this._glOptions.sections = legendData.sections;
                if (legendData.footer) this._glOptions.footer = legendData.footer;

                this._renderContent();
            },

            /**
             * Bascule l'état collapsed
             * @private
             */
            _toggleCollapsed: function () {
                const isCollapsed = this._container.classList.toggle("gl-map-legend--collapsed");
                this._glOptions.collapsed = isCollapsed;
            },

            /**
             * Montre la légende
             * @public
             */
            show: function () {
                if (this._container) {
                    this._container.style.display = "block";
                }
            },

            /**
             * Cache la légende
             * @public
             */
            hide: function () {
                if (this._container) {
                    this._container.style.display = "none";
                }
            },
        });

        return new LegendControl({
            position: options.position,
            _glOptions: options,
        });
    }

    const LegendControl = {
        create: createLegendControl,
    };

    /**
     * Module Legend Generator
     * Génère automatiquement les légendes depuis les fichiers de style
     *
     * DÉPENDANCES:
     * - GeoLeaf.Log (optionnel)
     *
     * EXPOSE:
     * - GeoLeaf._LegendGenerator
     */

    /**
     * Récupère l'icône depuis taxonomy pour une règle donnée
     * @param {Object} rule - Règle de style avec condition when
     * @param {Object} taxonomyData - Données de taxonomy
     * @param {string} symbolPrefix - Préfixe des symboles (ex: "tourism-poi-cat-")
     * @returns {string|null} - ID de l'icône sprite ou null
     * @private
     */
    function getIconFromTaxonomy(rule, taxonomyData, symbolPrefix) {
        if (!rule.when || !taxonomyData || !taxonomyData.categories) {
            if (Log)
                Log.debug("[LegendGenerator] Données insuffisantes pour récupérer icône:", {
                    hasRule: !!rule.when,
                    hasTaxonomy: !!taxonomyData,
                    hasCategories: !!(taxonomyData && taxonomyData.categories),
                });
            return null;
        }

        const field = rule.when.field;
        const value = rule.when.value;
        const categories = taxonomyData.categories;

        if (Log) Log.debug(`[LegendGenerator] Recherche icône pour ${field}=${value}`);

        // Déterminer le type de recherche
        const isSubCategory =
            field === "properties.subCategoryId" || field === "attributes.subCategoryId";
        const isCategoryId = field === "properties.categoryId" || field === "attributes.categoryId";

        // Recherche dans subCategoryId
        if (isSubCategory) {
            for (const categoryKey in categories) {
                const subcategories = categories[categoryKey].subcategories;
                if (subcategories && subcategories[value] && subcategories[value].icon) {
                    const iconId = symbolPrefix + subcategories[value].icon;
                    if (Log) Log.debug(`[LegendGenerator] Icône trouvée (subcat): ${iconId}`);
                    return iconId;
                }
            }
        }

        // Recherche dans categoryId
        if (isCategoryId && categories[value] && categories[value].icon) {
            const iconId = symbolPrefix + categories[value].icon;
            if (Log) Log.debug(`[LegendGenerator] Icône trouvée (cat): ${iconId}`);
            return iconId;
        }

        if (Log) Log.warn(`[LegendGenerator] Aucune icône trouvée pour ${field}=${value}`);
        return null;
    }

    // Fonction utilitaire pour déterminer si les icônes doivent être affichées
    // Copie exactement la logique de markers.js resolveCategoryDisplay()
    function shouldUseIcons() {
        try {
            // Récupérer l'état partagé (comme dans markers.js)
            const shared = POIShared ?? null;
            const poiConfig = shared ? shared.state.poiConfig : {};
            const showIconsOnMap = poiConfig.showIconsOnMap !== false;

            if (showIconsOnMap) {
                // Vérifier la config d'icônes (comme dans markers.js)
                const iconsConfig = Config.getIconsConfig?.() ?? null;

                if (iconsConfig && iconsConfig.showOnMap !== false) {
                    return true;
                }
            }
        } catch (e) {
            // Ignorer les erreurs silencieusement
        }

        return false;
    }

    /**
     * Génère les données de légende depuis un fichier de style
     * @param {Object} styleData - Données du style (JSON parsé)
     * @param {string} geometryType - Type de géométrie (point, line, polygon)
     * @param {Object} taxonomyData - Données de taxonomy (pour les icônes POI)
     * @returns {Object} - Données de légende formatées
     */
    function generateLegendFromStyle(styleData, geometryType, taxonomyData) {
        if (!styleData) {
            if (Log) Log.warn("[LegendGenerator] Style data manquant");
            return null;
        }

        const legendData = {
            version: "3.0",
            id: styleData.id,
            title: styleData.label || "Sans titre",
            description: styleData.description || "",
            sections: [],
        };

        const items = [];
        const symbolPrefix = taxonomyData?.icons?.symbolPrefix || "tourism-poi-cat-";

        // Cas 1 : Style avec styleRules
        if (Array.isArray(styleData.styleRules) && styleData.styleRules.length > 0) {
            styleData.styleRules.forEach((rule) => {
                if (!rule.legend) {
                    if (Log) Log.warn("[LegendGenerator] Règle sans propriété legend:", rule);
                    return;
                }

                const item = generateLegendItem(
                    rule.style,
                    rule.legend,
                    geometryType,
                    styleData.style, // style de base
                    rule,
                    taxonomyData,
                    symbolPrefix
                );

                if (item) {
                    items.push(item);
                }
            });

            // Trier par order (Phase 4 dedup)
            items.sort(compareByOrder);

            // Cas 2 : Style simple sans règles ou avec styleRules vide
        }

        // Si pas d'items générés à partir des styleRules (ou pas de styleRules)
        // essayer d'utiliser la légende au niveau racine
        if (items.length === 0 && styleData.style && styleData.legend) {
            const item = generateLegendItem(
                styleData.style,
                styleData.legend,
                geometryType,
                null,
                null,
                taxonomyData,
                symbolPrefix
            );

            if (item) {
                items.push(item);
            }
        }

        // Créer une section par défaut avec tous les items
        if (items.length > 0) {
            legendData.sections.push({
                title: "",
                items: items,
            });
        }

        return legendData;
    }

    /**
     * Génère un item de légende selon le type de géométrie
     * @param {Object} style - Style de l'entité
     * @param {Object} legend - Propriétés legend (label, order, description)
     * @param {string} geometryType - Type de géométrie
     * @param {Object} baseStyle - Style de base (pour héritage)
     * @param {Object} rule - Règle complète (pour extraction icône)
     * @param {Object} taxonomyData - Données taxonomy
     * @param {string} symbolPrefix - Préfixe symboles
     * @param {boolean} showIconsOnMap - Si true, génère les icônes
     * @returns {Object|null} - Item de légende
     * @private
     */
    function generateLegendItem(
        style,
        legend,
        geometryType,
        baseStyle,
        rule,
        taxonomyData,
        symbolPrefix
    ) {
        if (!style || !legend) {
            return null;
        }

        // Fusionner avec le style de base si présent
        const mergedStyle = baseStyle ? Object.assign({}, baseStyle, style) : style;

        const item = {
            label: legend.label || "Sans label",
            order: legend.order || 999,
        };

        if (legend.description) {
            item.description = legend.description;
        }

        // Génération du symbole selon le type de géométrie
        switch (geometryType) {
            case "point":
                item.symbol = generatePointSymbol(mergedStyle, rule, taxonomyData, symbolPrefix);
                break;

            case "line":
                item.symbol = generateLineSymbol(mergedStyle);
                break;

            case "polygon":
                item.symbol = generatePolygonSymbol(mergedStyle);
                break;

            default:
                if (Log) Log.warn("[LegendGenerator] Type de géométrie non reconnu:", geometryType);
                item.symbol = generatePointSymbol(mergedStyle, rule, taxonomyData, symbolPrefix);
        }

        return item;
    }

    /**
     * Ajoute les propriétés communes d'opacité à un symbole
     * @param {Object} symbol - Objet symbole
     * @param {Object} style - Style source
     * @param {Array<string>} opacityProps - Propriétés d'opacité à copier
     * @private
     */
    function applyOpacityProperties(symbol, style, opacityProps) {
        opacityProps.forEach((prop) => {
            if (style[prop] !== undefined) {
                symbol[prop] = style[prop];
            }
        });
    }

    /**
     * Résout les icônes d'une règle selon la configuration showIconsOnMap
     * @param {Object} rule - Règle de style
     * @returns {Object} - {useIcon: boolean, iconId: string|null}
     * @private
     */
    function resolveRuleIcons(rule) {
        // Utiliser la même logique que markers.js
        if (!shouldUseIcons()) {
            return { useIcon: false, iconId: null };
        }
        // Récupérer la configuration des catégories
        const categoriesConfig = Config.getCategories?.() ?? {};

        if (!categoriesConfig || Object.keys(categoriesConfig).length === 0) {
            return { useIcon: false, iconId: null };
        }

        // Mappage de fclass vers categoryId/subCategoryId pour les icônes
        // Permet de résoudre les icônes pour les règles qui utilisent fclass au lieu de categoryId
        const fclassMappings = {
            // Cultures
            archaeological: { categoryId: "CULTURES", subCategoryId: "SITE ARCHEOLOGIQUE" },
            museum: { categoryId: "CULTURES", subCategoryId: "MUSEE" },
            // Hébergements
            camp_site: { categoryId: "HEBERGEMENT", subCategoryId: "CAMPING" },
            hotel: { categoryId: "HEBERGEMENT", subCategoryId: "HOTEL" },
        };

        // Extraire categoryId et subCategoryId depuis la règle
        let categoryId = null;
        let subCategoryId = null;

        // Format v3 : rule.when avec field/value
        if (rule.when && rule.when.field && rule.when.value !== undefined) {
            // NOUVEAU: Cas spécial pour fclass (résoudre via mapping)
            if (rule.when.field === "properties.fclass" || rule.when.field === "fclass") {
                const mapping = fclassMappings[rule.when.value];
                if (mapping) {
                    categoryId = mapping.categoryId;
                    subCategoryId = mapping.subCategoryId;
                }
            } else if (
                rule.when.field === "properties.categoryId" ||
                rule.when.field === "categoryId"
            ) {
                categoryId = rule.when.value;
            } else if (
                rule.when.field === "properties.subCategoryId" ||
                rule.when.field === "subCategoryId"
            ) {
                subCategoryId = rule.when.value;
            } else if (rule.when.field === "properties.category" || rule.when.field === "category") {
                categoryId = rule.when.value;
            } else if (
                rule.when.field === "properties.subCategory" ||
                rule.when.field === "subCategory"
            ) {
                subCategoryId = rule.when.value;
            }
        }
        // Format legacy : rule.condition
        else if (rule.condition) {
            if (typeof rule.condition.categoryId !== "undefined") {
                categoryId = rule.condition.categoryId;
            }
            if (typeof rule.condition.subCategoryId !== "undefined") {
                subCategoryId = rule.condition.subCategoryId;
            }
            if (typeof rule.condition.category !== "undefined") {
                categoryId = rule.condition.category;
            }
            if (typeof rule.condition.subCategory !== "undefined") {
                subCategoryId = rule.condition.subCategory;
            }
        }

        // Pour les subCategoryId, il faut deviner la categoryId depuis la taxonomie
        if (subCategoryId && !categoryId) {
            // Chercher dans quelle catégorie se trouve cette sous-catégorie
            Object.keys(categoriesConfig).forEach((catKey) => {
                const cat = categoriesConfig[catKey];
                if (cat.subcategories && cat.subcategories[subCategoryId]) {
                    categoryId = catKey;
                }
            });
        }

        if (!categoryId && !subCategoryId) {
            return { useIcon: false, iconId: null };
        }

        // Résolution de l'icône depuis la taxonomie
        let iconId = null;
        if (subCategoryId && categoriesConfig[categoryId]?.subcategories) {
            const subCat = categoriesConfig[categoryId].subcategories[subCategoryId];
            const cat = categoriesConfig[categoryId];

            if (subCat) {
                iconId = subCat.icon || subCat.iconId || cat.icon || cat.iconId || null;
            } else {
                iconId = cat.icon || cat.iconId || null;
            }
        } else if (categoriesConfig[categoryId]) {
            const cat = categoriesConfig[categoryId];
            iconId = cat.icon || cat.iconId || null;
        }

        return {
            useIcon: iconId !== null,
            iconId: iconId,
        };
    }

    /**
     * Génère un symbole pour les points (POI)
     * @param {Object} style - Style du point
     * @param {Object} rule - Règle complète (pour extraction icône)
     * @param {Object} taxonomyData - Données taxonomy
     * @param {string} symbolPrefix - Préfixe symboles
     * @param {boolean} showIconsOnMap - Si true, génère les icônes
     * @returns {Object} - Configuration du symbole
     * @private
     */
    function generatePointSymbol(style, rule, taxonomyData, symbolPrefix) {
        const fill = style.fill || {};
        const stroke = style.stroke || {};

        const resolvedRadius =
            style.radius || style.size || (style.sizePx ? style.sizePx / 2 : undefined);

        // Taille par défaut plus grande pour que les icônes soient visibles dans la légende
        // Utiliser 24px pour les icônes, 16px pour les cercles simples
        const defaultRadius = 24;

        const symbol = {
            type: "circle",
            radius: resolvedRadius || defaultRadius,
            fillColor: style.fillColor || style.color || fill.color || "#3388ff",
            fillOpacity:
                style.fillOpacity !== undefined
                    ? style.fillOpacity
                    : fill.opacity !== undefined
                      ? fill.opacity
                      : 1,
            color: style.color || stroke.color || "#ffffff",
            weight: style.weight || stroke.widthPx || 2,
            opacity:
                style.opacity !== undefined
                    ? style.opacity
                    : stroke.opacity !== undefined
                      ? stroke.opacity
                      : 1,
        };

        // Priorité 1 : Vérifier si l'icône est directement dans le style (showIconsOnMap)
        if (style.useIcon && style.iconId) {
            symbol.icon = style.iconId;
            symbol.iconColor = "#ffffff"; // Couleur par défaut pour icônes
            if (Log) Log.debug(`[LegendGenerator] Icône trouvée dans le style: ${style.iconId}`);
        }
        // Priorité 2 : Résoudre l'icône depuis la configuration showIconsOnMap
        else if (rule && shouldUseIcons()) {
            const iconResolution = resolveRuleIcons(rule);

            if (iconResolution.useIcon && iconResolution.iconId) {
                // Ajouter le préfixe sprite si nécessaire
                const fullIconId = iconResolution.iconId.startsWith("#")
                    ? iconResolution.iconId
                    : symbolPrefix
                      ? symbolPrefix + iconResolution.iconId
                      : "#sprite-" + iconResolution.iconId;

                symbol.icon = fullIconId;
                symbol.iconColor = "#ffffff";
                if (Log) Log.debug(`[LegendGenerator] Icône résolue depuis la config: ${fullIconId}`);
            }
        }
        // Priorité 3 : Tenter de récupérer l'icône depuis taxonomy (méthode legacy)
        if (!symbol.icon && rule && taxonomyData && shouldUseIcons()) {
            const icon = getIconFromTaxonomy(rule, taxonomyData, symbolPrefix);
            if (icon) {
                symbol.icon = icon;
                symbol.iconColor = "#ffffff"; // Couleur par défaut pour icônes
                if (Log) Log.debug("[LegendGenerator] Icône taxonomy ajoutée:", icon);
            }
        }

        return symbol;
    }

    /**
     * Génère un symbole pour les lignes
     * @param {Object} style - Style de la ligne
     * @returns {Object} - Configuration du symbole
     * @private
     */
    function generateLineSymbol(style) {
        const stroke = style.stroke || {};
        const casing = style.casing || {};

        // Stratégie : afficher le casing comme contour/bordure du stroke
        // Si casing existe, utiliser la couleur du casing comme contour
        // et le stroke comme couleur principale
        const symbol = {
            type: "line",
            color: stroke.color || style.color || "#3388ff",
            width: stroke.widthPx || style.weight || 3,
            style: "solid", // Par défaut
        };

        // Si casing est activé, ajouter une bordure/outline fine
        // Limiter l'épaisseur pour la légende (réduit d'un facteur)
        if (casing.enabled && casing.color) {
            symbol.outlineColor = casing.color;
            // Utiliser une fraction de la largeur du casing pour la légende
            symbol.outlineWidth = Math.max(0.5, (casing.widthPx || 1) * 0.4);
            symbol.outlineOpacity = casing.opacity || 1;
        }

        // Appliquer l'opacité
        if (stroke.opacity !== undefined) {
            symbol.opacity = stroke.opacity;
        }

        // Support pour dashArray - passer la valeur complète
        const dashArray = style.dashArray || stroke.dashArray;
        if (dashArray) {
            symbol.dashArray = dashArray;
            // Garder le style pour la rétrocompatibilité
            if (dashArray === "5, 5" || dashArray === "10, 10") {
                symbol.style = "dashed";
            } else if (dashArray === "1, 3" || dashArray === "2, 4") {
                symbol.style = "dotted";
            }
        }

        return symbol;
    }

    /**
     * Génère un symbole pour les polygones
     * @param {Object} style - Style du polygone
     * @returns {Object} - Configuration du symbole
     * @private
     */
    function generatePolygonSymbol(style) {
        const fill = style.fill || {};
        const stroke = style.stroke || {};

        const symbol = {
            type: "polygon",
            fillColor: style.fillColor || style.color || fill.color || "#3388ff",
            color: style.color || stroke.color || "#333",
            weight: style.weight || stroke.widthPx || 1,
        };

        // Appliquer l'opacité du fill (pas du stroke qui écrase)
        applyOpacityProperties(symbol, style, ["fillOpacity"]);
        // Si pas de fillOpacity, prendre l'opacity directement du fill
        if (fill.opacity !== undefined) {
            symbol.opacity = fill.opacity;
        }
        // Puis vérifier style.opacity en dernier (peut être au niveau racine)
        if (style.opacity !== undefined) {
            symbol.opacity = style.opacity;
        }

        // Support pour dashArray sur le contour
        const dashArray = style.dashArray || stroke.dashArray;
        if (dashArray) {
            symbol.dashArray = dashArray;
        }

        // Support pour patterns de hachures
        if (style.fillPattern) {
            symbol.fillPattern = style.fillPattern;
        }

        // Support pour les hachures (format moderne)
        if (style.hatch) {
            symbol.hatch = style.hatch;
        }

        return symbol;
    }

    const LegendGenerator = {
        generateLegendFromStyle: generateLegendFromStyle,
        generateLegendItem: generateLegendItem,
    };

    /*!
     * GeoLeaf Core – Baselayers / Providers
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */

    /**
     * Définitions des couches tuiles par défaut (100 % utilisables sans clé API).
     * @type {Object.<string, {label: string, url: string, options: object}>}
     */
    const DEFAULT_BASELAYERS = {
        street: {
            label: "Street",
            url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
            options: {
                maxZoom: 19,
                attribution: "&copy; OpenStreetMap contributors",
            },
        },
        topo: {
            label: "Topo",
            url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
            options: {
                maxZoom: 17,
                attribution:
                    "Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap",
            },
        },
        satellite: {
            label: "Satellite",
            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            options: {
                maxZoom: 19,
                attribution:
                    "Tiles &copy; Esri — Source: Esri, Earthstar Geographics, and the GIS user community",
            },
        },
    };

    /**
     * Normalise les options Leaflet pour une définition de couche.
     * @param {object} definition
     * @returns {object} Options normalisées
     */
    function normalizeOptions(definition) {
        const opts = Object.assign({}, definition.options || {});
        if (typeof opts.minZoom !== "number" && typeof definition.minZoom === "number") {
            opts.minZoom = definition.minZoom;
        }
        if (typeof opts.maxZoom !== "number") {
            opts.maxZoom = typeof definition.maxZoom === "number" ? definition.maxZoom : 19;
        }
        if (!opts.attribution && definition.attribution) {
            opts.attribution = definition.attribution;
        }
        return opts;
    }

    /**
     * Silence MapLibre GL v5 "Expected value to be of type number, but found null"
     * warnings emitted by the Liberty (OpenFreeMap) basemap style.
     * Applique des filtres corrigés via setFilter() — aucun rechargement de tuiles.
     * @param {object} glMap - Instance live MapLibre Map
     */
    function applyLibertyFilters(glMap) {
        const PATCHES = {
            boundary_3: { admin_level: -1, maritime: 0, disputed: 0 },
            road_motorway_link: { ramp: 0 },
            road_motorway_link_casing: { ramp: 0 },
            road_link: { ramp: 0 },
            road_link_casing: { ramp: 0 },
            bridge_motorway_link: { ramp: 0 },
            bridge_motorway_link_casing: { ramp: 0 },
            tunnel_motorway_link: { ramp: 0 },
            tunnel_motorway_link_casing: { ramp: 0 },
            tunnel_link: { ramp: 0 },
            tunnel_link_casing: { ramp: 0 },
            road_one_way_arrow: { oneway: 0 },
            road_one_way_arrow_opposite: { oneway: 0 },
            label_city: { capital: 0 },
            label_city_capital: { capital: 0 },
            poi_r1: { rank: 0 },
            poi_r7: { rank: 0 },
            poi_r20: { rank: 0 },
            label_country_1: { rank: 0 },
            label_country_2: { rank: 0 },
            label_country_3: { rank: 0 },
        };

        function _patchExpr(expr, propMap) {
            if (!Array.isArray(expr)) return expr;
            if (expr[0] === "get" && expr.length === 2 && typeof expr[1] === "string") {
                if (Object.prototype.hasOwnProperty.call(propMap, expr[1])) {
                    return ["coalesce", expr, propMap[expr[1]]];
                }
            }
            return expr.map((item) => (Array.isArray(item) ? _patchExpr(item, propMap) : item));
        }

        for (const [layerId, propMap] of Object.entries(PATCHES)) {
            try {
                if (!glMap.getLayer(layerId)) continue;
                const currentFilter = glMap.getFilter(layerId);
                if (!currentFilter) continue;
                glMap.setFilter(layerId, _patchExpr(currentFilter, propMap));
            } catch (_e) {
                // layer absent from this style — skip silently
            }
        }
    }

    /*!
     * GeoLeaf Core – Baselayers / Registry
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$j =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    // ---------------------------------------------------------
    // État interne partagé
    // ---------------------------------------------------------
    let _map$1 = null;
    let _activeKey = null;
    const _baseLayers = Object.create(null);

    // ---------------------------------------------------------
    // Résolution de la carte
    // ---------------------------------------------------------
    function ensureMap(explicitMap) {
        if (_map$1 && typeof _map$1.setView === "function") return;

        const mh = _g$j.GeoLeaf?.Utils?.MapHelpers;
        const resolved = mh && typeof mh.ensureMap === "function" ? mh.ensureMap() : null;
        if (resolved) {
            _map$1 = resolved;
            Log.info("[GeoLeaf.Baselayers] ensureMap: acquired via MapHelpers.ensureMap().");
        }
    }

    function setMap(mapInstance) {
        _map$1 = mapInstance;
    }

    // ---------------------------------------------------------
    // Enregistrement des couches
    // ---------------------------------------------------------
    function registerDefaultBaseLayers() {
        const L = _g$j.L;
        if (!L) return;
        Object.keys(DEFAULT_BASELAYERS).forEach((key) => {
            if (!_baseLayers[key]) registerBaseLayer(key, DEFAULT_BASELAYERS[key]);
        });
    }

    function registerBaseLayer(key, definition) {
        const L = _g$j.L;
        if (!key) {
            Log.warn("[GeoLeaf.Baselayers] registerBaseLayer appelé sans clé.");
            return;
        }
        if (!definition) {
            Log.warn("[GeoLeaf.Baselayers] Définition manquante pour la couche :", key);
            return;
        }

        const actualKey = definition.id || key;
        let layerInstance = null;
        const label = definition.label || actualKey;

        if (definition instanceof L.TileLayer) {
            layerInstance = definition;
        } else if (definition.layer && definition.layer instanceof L.TileLayer) {
            layerInstance = definition.layer;
        } else if (definition.type === "maplibre" || definition.style) {
            if (typeof L.maplibreGL === "function") {
                const mlOptions = {
                    style: definition.style,
                    attribution: definition.attribution || "",
                    interactive: false,
                    padding: 0.25,
                    maplibreOptions: {
                        preserveDrawingBuffer: true,
                        trackResize: true,
                        fadeDuration: 0,
                    },
                };
                layerInstance = L.maplibreGL(mlOptions);
                layerInstance.once("add", function () {
                    const glMap = layerInstance.getMaplibreMap && layerInstance.getMaplibreMap();
                    if (glMap) {
                        glMap.once("styledata", function () {
                            applyLibertyFilters(glMap);
                        });
                    }
                });
                Log.info("[GeoLeaf.Baselayers] Basemap vectorielle MapLibre créée :", actualKey);
            } else {
                Log.warn(
                    "[GeoLeaf.Baselayers] MapLibre GL plugin non chargé. Fallback raster pour :",
                    actualKey
                );
                const fallbackUrl = definition.url || definition.fallbackUrl;
                layerInstance = fallbackUrl
                    ? L.tileLayer(fallbackUrl, normalizeOptions(definition))
                    : L.tileLayer(DEFAULT_BASELAYERS.street.url, DEFAULT_BASELAYERS.street.options);
            }
        } else if (definition.url) {
            layerInstance = L.tileLayer(definition.url, normalizeOptions(definition));
        } else {
            Log.warn(
                "[GeoLeaf.Baselayers] Définition invalide pour la couche :",
                actualKey,
                "(aucune url / aucun layer fourni)"
            );
            return;
        }

        _baseLayers[actualKey] = { key: actualKey, label, layer: layerInstance };
    }

    function registerBaseLayers(definitions) {
        if (!definitions || typeof definitions !== "object") {
            Log.warn("[GeoLeaf.Baselayers] registerBaseLayers attend un objet de définitions.");
            return;
        }
        Object.keys(definitions).forEach((key) => registerBaseLayer(key, definitions[key]));
    }

    // ---------------------------------------------------------
    // Activation de couche
    // ---------------------------------------------------------
    function setBaseLayer(key, options) {
        options = options || {};
        if (!key) {
            Log.warn("[GeoLeaf.Baselayers] setBaseLayer appelé sans clé.");
            return;
        }

        const previousKey = _activeKey;
        ensureMap();

        Log.info("[GeoLeaf.Baselayers] setBaseLayer:", key, "_map=", !!_map$1);

        if (!_map$1) {
            Log.warn("[GeoLeaf.Baselayers] Aucun L.Map disponible.");
            return;
        }

        if (!_baseLayers[key]) {
            Log.warn("[GeoLeaf.Baselayers] Couche inconnue :", key);
            const keys = Object.keys(_baseLayers);
            if (!previousKey && keys.length > 0) {
                setBaseLayer(keys[0], { silent: true });
            }
            return;
        }

        if (_activeKey === key) {
            // Signal UI refresh — ui.js écoute via l'export refreshUI
            return;
        }

        if (previousKey && _baseLayers[previousKey]) {
            const prev = _baseLayers[previousKey].layer;
            try {
                if (prev && _map$1 && typeof _map$1.hasLayer === "function" && _map$1.hasLayer(prev)) {
                    _map$1.removeLayer(prev);
                }
            } catch (e) {
                Log.warn("[GeoLeaf.Baselayers] Impossible de retirer la couche précédente:", e);
            }
        }

        const nextLayer = _baseLayers[key].layer;
        if (!nextLayer || typeof nextLayer.addTo !== "function") {
            Log.error("[GeoLeaf.Baselayers] Couche invalide pour la clé:", key);
            return;
        }

        try {
            nextLayer.addTo(_map$1);
        } catch (e) {
            Log.error("[GeoLeaf.Baselayers] Impossible d'ajouter la couche:", e);
            return;
        }

        _activeKey = key;
        Log.info("[GeoLeaf.Baselayers] Couche active :", key);

        if (!options.silent) {
            _dispatchBasemapChange(key, previousKey, nextLayer);
        }
    }

    function _dispatchBasemapChange(key, previousKey, layer) {
        if (typeof document === "undefined" || typeof document.dispatchEvent !== "function") return;
        const detail = { key, previousKey, map: _map$1, layer, source: "geoleaf.baselayers" };
        try {
            document.dispatchEvent(new CustomEvent("geoleaf:basemap:change", { detail }));
        } catch (err) {
            Log.warn("[GeoLeaf.Baselayers] Impossible d'émettre geoleaf:basemap:change.", err);
        }
    }

    // ---------------------------------------------------------
    // Accesseurs
    // ---------------------------------------------------------
    function getBaseLayers() {
        return Object.assign({}, _baseLayers);
    }

    function getActiveKey() {
        return _activeKey;
    }

    function getActiveLayer() {
        return _activeKey && _baseLayers[_activeKey] ? _baseLayers[_activeKey].layer : null;
    }

    /*!
     * GeoLeaf Core – Baselayers / UI
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$i =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    let _uiBound = false;
    let _resizeHandler = null;

    // ---------------------------------------------------------
    // Indicateur actif
    // ---------------------------------------------------------
    function _updateActiveIndicator(panel, activeButton) {
        if (!panel || !activeButton) return;
        const panelRect = panel.getBoundingClientRect();
        const buttonRect = activeButton.getBoundingClientRect();
        panel.style.setProperty("--indicator-left", buttonRect.left - panelRect.left + "px");
        panel.style.setProperty("--indicator-width", buttonRect.width + "px");
    }

    // ---------------------------------------------------------
    // Rafraîchissement de l'UI
    // ---------------------------------------------------------
    function refreshUI() {
        if (!_g$i.document) return;

        const elements = _g$i.document.querySelectorAll("[data-gl-baselayer]");
        const leftPanel = _g$i.document.getElementById("gl-left-panel");
        const activeKey = getActiveKey();
        let activeElement = null;

        elements.forEach((el) => {
            const key = el.getAttribute("data-gl-baselayer");
            if (!key) return;
            const isActive = key === activeKey;
            el.classList.toggle("gl-baselayer-active", isActive);
            el.classList.toggle("is-active", isActive);
            el.setAttribute("aria-pressed", String(isActive));
            if (isActive) activeElement = el;
        });

        if (leftPanel && activeElement) {
            _updateActiveIndicator(leftPanel, activeElement);
        }
    }

    // ---------------------------------------------------------
    // Création des contrôles UI
    // ---------------------------------------------------------
    function createBaseLayerControlsUI(config) {
        if (!_g$i.document) return;

        if (!config && _g$i.GeoLeaf?.Config?.get) {
            config = {
                ui: _g$i.GeoLeaf.Config.get("ui"),
                basemaps: _g$i.GeoLeaf.Config.get("basemaps") || {},
            };
        }

        const uiCfg = config && config.ui;
        const showControls = uiCfg && uiCfg.showBaseLayerControls === false ? false : !!uiCfg;

        Log.info(
            "[GeoLeaf.Baselayers] showBaseLayerControls =",
            showControls,
            "(config.ui.showBaseLayerControls =",
            uiCfg ? uiCfg.showBaseLayerControls : "N/A",
            ")"
        );

        let leftPanel = _g$i.document.getElementById("gl-left-panel");

        if (showControls) {
            if (!leftPanel) {
                leftPanel = _g$i.document.createElement("div");
                leftPanel.id = "gl-left-panel";
                leftPanel.className = "gl-left-panel";
                const mapContainer =
                    _g$i.document.getElementById("geoleaf-map") || _g$i.document.querySelector(".gl-map");
                (mapContainer || _g$i.document.body).appendChild(leftPanel);
            }

            if (_g$i.GeoLeaf?.DOMSecurity?.clearElementFast) {
                _g$i.GeoLeaf.DOMSecurity.clearElementFast(leftPanel);
            } else {
                leftPanel.innerHTML = "";
            }

            Object.keys(_baseLayers).forEach((key) => {
                const def = _baseLayers[key];
                const button = _g$i.document.createElement("button");
                button.className = "gl-baselayer-btn";
                button.setAttribute("data-gl-baselayer", key);
                button.setAttribute("aria-label", def.label || key);
                button.textContent = def.label || key;
                leftPanel.appendChild(button);
            });

            leftPanel.style.display = "flex";
            Log.info(
                "[GeoLeaf.Baselayers] Contrôles créés avec",
                Object.keys(_baseLayers).length,
                "boutons"
            );

            setTimeout(refreshUI, 50);
        } else {
            if (leftPanel && leftPanel.parentNode) {
                leftPanel.parentNode.removeChild(leftPanel);
            }
        }
    }

    // ---------------------------------------------------------
    // Binding DOM (une seule fois)
    // ---------------------------------------------------------
    function bindUIOnce() {
        if (_uiBound || !_g$i.document) return;
        _uiBound = true;

        _g$i.document.addEventListener("click", (evt) => {
            const target = evt.target.closest("[data-gl-baselayer]");
            if (!target) return;
            const key = target.getAttribute("data-gl-baselayer");
            if (!key) return;
            evt.preventDefault();
            setBaseLayer(key);
            refreshUI();
        });

        let resizeTimeout;
        _resizeHandler = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(refreshUI, 100);
        };
        _g$i.addEventListener("resize", _resizeHandler);
    }

    // ---------------------------------------------------------
    // Nettoyage
    // ---------------------------------------------------------
    function destroyUI() {
        if (_resizeHandler) {
            _g$i.removeEventListener("resize", _resizeHandler);
            _resizeHandler = null;
        }
        _uiBound = false;
    }

    /*!
     * GeoLeaf Core – Baselayers / Index (barrel)
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    function init(options) {
        options = options || {};

        if (options.map) {
            setMap(options.map);
        } else {
            ensureMap();
        }

        registerDefaultBaseLayers();

        if (options.baselayers && typeof options.baselayers === "object") {
            registerBaseLayers(options.baselayers);
        }

        if (options.activeKey) {
            setBaseLayer(options.activeKey, { silent: true });
        }

        if (!getActiveKey()) {
            const keys = Object.keys(getBaseLayers());
            if (keys.length > 0) {
                setBaseLayer(keys[0], { silent: true });
            }
        }

        createBaseLayerControlsUI(options);
        bindUIOnce();
        refreshUI();

        return {
            activeKey: getActiveKey(),
            layers: getBaseLayers(),
        };
    }

    const Baselayers = {
        init,
        registerBaseLayer,
        registerBaseLayers,
        setBaseLayer,
        setActive: setBaseLayer, // alias compat
        getBaseLayers,
        getActiveKey,
        getActiveId: getActiveKey, // alias compat
        getActiveLayer,
        destroy: destroyUI,
    };

    /**
     * Module Basemap Selector pour LayerManager
     * Gestion du sélecteur de fonds de carte
     *
     * DÉPENDANCES:
     * - Leaflet (L.DomUtil, L.DomEvent)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf.Baselayers (optionnel, pour getActiveId et setBaseLayer)
     *
     * EXPOSE:
     * - GeoLeaf._LayerManagerBasemapSelector
     */



    /**
     * Module Basemap Selector
     * @namespace _LayerManagerBasemapSelector
     * @private
     */
    const _LayerManagerBasemapSelector = {
        /**
         * Rend le sélecteur de basemap
         * @param {Object} section - Section basemap avec items
         * @param {HTMLElement} sectionEl - Élément DOM de la section
         */
        render(section, sectionEl) {
            // Validation des paramètres
            if (!section || !sectionEl) {
                return;
            }

            const container = globalThis.L.DomUtil.create(
                "div",
                "gl-layer-manager__items gl-layer-manager__basemap-select",
                sectionEl
            );

            const select = globalThis.L.DomUtil.create("select", "gl-layer-manager__basemap-select__select", container);

            // Remplir les options
            if (Array.isArray(section.items)) {
                section.items.forEach(function (item) {
                    if (!item || !item.id) return;
                    const opt = document.createElement("option");
                    opt.value = item.id;
                    opt.textContent = item.label || item.id;
                    select.appendChild(opt);
                });
            }

            // Valeur initiale -> clé active des basemaps
            try {
                const activeKey = Baselayers && typeof Baselayers.getActiveKey === "function"
                    ? Baselayers.getActiveKey()
                    : null;
                if (activeKey) {
                    select.value = activeKey;
                }
            } catch (e) {
                // ignore
            }

            // Changement par l'utilisateur
            this._attachChangeHandler(select);

            // Écouter les changements externes
            this._attachExternalListener(select);
        },

        /**
         * Attache le gestionnaire de changement au select
         * @private
         */
        _attachChangeHandler(select) {
            const handler = function (ev) {
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.stopPropagation(ev);
                }
                try {
                    const val = select.value;
                    if (Baselayers && typeof Baselayers.setBaseLayer === "function") {
                        Baselayers.setBaseLayer(val);
                    }
                } catch (err) {
                    if (Log) Log.warn("Erreur lors du changement de basemap depuis la légende:", err);
                }
            };

            if (globalThis.L && globalThis.L.DomEvent) {
                globalThis.L.DomEvent.on(select, "change", handler);
            } else {
                select.addEventListener("change", handler);
            }
        },

        /**
         * Écoute les événements de changement de basemap externe
         * @private
         */
        _attachExternalListener(select) {
            if (typeof document !== "undefined") {
                this._externalHandler = function (e) {
                    try {
                        if (e && e.detail && e.detail.key) {
                            select.value = e.detail.key;
                        }
                    } catch (err) {
                        // ignore
                    }
                };
                document.addEventListener("geoleaf:basemap:change", this._externalHandler);
            }
        },

        /**
         * Nettoie les listeners pour éviter les fuites mémoire
         */
        destroy() {
            if (this._externalHandler) {
                document.removeEventListener("geoleaf:basemap:change", this._externalHandler);
                this._externalHandler = null;
            }
        }
    };

    const BasemapSelector = _LayerManagerBasemapSelector;

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        // Constantes pour les priorités de la queue
        const PRIORITY = {
            ERROR: 3,
            WARNING: 2,
            SUCCESS: 1,
            INFO: 1
        };

    class NotificationSystem {
        constructor() {
            this.container = null;
            this.maxVisible = 3;              // Max toasts temporaires visibles
            this.maxPersistent = 2;           // Max toasts persistants visibles
            this.durations = {
                success: 3000,
                error: 5000,
                warning: 4000,
                info: 3000
            };
            this.config = {
                enabled: true,
                position: 'bottom-center',
                animations: true
            };

            // Managers pour cleanup
            this._eventManager = null;
            this._timerManager = null;
            this._activeToasts = new Map();

            // Queue avec priorités (limite: 15 max en attente)
            this._queue = [];
            this._maxQueueSize = 15;
        }

        /**
         * Initialise le système de notifications
         * @param {Object} config - Configuration
         * @param {string} config.container - Sélecteur du container
         * @param {number} config.maxVisible - Nombre max de toasts visibles
         * @param {Object} config.durations - Durées par type
         * @param {string} config.position - Position ('bottom-center', 'top-right', etc.)
         * @param {boolean} config.animations - Activer les animations
         */
        init(config = {}) {
            // Fusionner la config
            this.config = { ...this.config, ...config };
            this.maxVisible = config.maxVisible || 3;
            this.durations = { ...this.durations, ...config.durations };

            // Récupérer le container
            this.container = document.querySelector(config.container || '#gl-notifications');

            if (!this.container) {
                if (Log) Log.warn('[GeoLeaf Notifications] Container introuvable:', config.container);
                return false;
            }

            // Appliquer la classe de position
            if (config.position) {
                this.container.className = `gl-notifications gl-notifications--${config.position}`;
            }

            if (Log) Log.debug('[GeoLeaf Notifications] Système initialisé');

            // Initialiser les managers pour le cleanup
            this._eventManager = events ? events.createManager('notifications') : null;
            this._timerManager = new TimerManager('notifications');

            return true;
        }

        /**
         * Affiche une notification générique (méthode publique standardisée)
         * Support double signature:
         * - show(message, type, duration) : Appel positionnel classique
         * - show(message, options) : Appel avec objet options
         *
         * @param {string} message - Message à afficher
         * @param {string|Object} typeOrOptions - Type ('success', 'error', 'warning', 'info') OU objet options
         * @param {number} [duration] - Durée personnalisée (ms) - ignoré si typeOrOptions est un objet
         *
         * @example
         * // Appel positionnel
         * show("Message", "success", 3000);
         *
         * @example
         * // Appel avec options
         * show("Message", {
         *   type: "success",
         *   duration: 3000,
         *   persistent: false,      // Toast persistant (ne s'auto-dismiss pas)
         *   dismissible: true,      // Bouton de fermeture
         *   icon: "✓",             // Icône personnalisée (futur)
         *   action: {               // Action button (futur)
         *     label: "Annuler",
         *     callback: () => {}
         *   }
         * });
         */
        show(message, typeOrOptions = 'info', duration) {
            // Parser les arguments selon la signature
            let options = {};

            if (typeof typeOrOptions === 'string') {
                // Signature positionnelle: show(message, type, duration)
                options = {
                    type: typeOrOptions,
                    duration: duration
                };
            } else if (typeof typeOrOptions === 'object' && typeOrOptions !== null) {
                // Signature objet: show(message, options)
                options = typeOrOptions;
            } else {
                // Fallback par défaut
                options = { type: 'info' };
            }

            // Ajouter à la queue avec priorité
            return this._enqueue(message, options);
        }

        /**
         * Affiche une notification de succès
         * Support double signature:
         * - success(message, duration)
         * - success(message, options)
         *
         * @param {string} message - Message à afficher
         * @param {number|Object} [durationOrOptions] - Durée (ms) OU objet options
         *
         * @example
         * success("Sauvegarde réussie", 3000);
         * success("Sauvegarde réussie", { duration: 3000, persistent: false });
         */
        success(message, durationOrOptions) {
            if (typeof durationOrOptions === 'number') {
                return this.show(message, 'success', durationOrOptions);
            } else if (typeof durationOrOptions === 'object') {
                return this.show(message, { ...durationOrOptions, type: 'success' });
            } else {
                return this.show(message, 'success');
            }
        }

        /**
         * Affiche une notification d'erreur
         * Support double signature:
         * - error(message, duration)
         * - error(message, options)
         *
         * @param {string} message - Message à afficher
         * @param {number|Object} [durationOrOptions] - Durée (ms) OU objet options
         *
         * @example
         * error("Erreur réseau", 5000);
         * error("Erreur réseau", { duration: 5000, persistent: true });
         */
        error(message, durationOrOptions) {
            if (typeof durationOrOptions === 'number') {
                return this.show(message, 'error', durationOrOptions);
            } else if (typeof durationOrOptions === 'object') {
                return this.show(message, { ...durationOrOptions, type: 'error' });
            } else {
                return this.show(message, 'error');
            }
        }

        /**
         * Affiche une notification d'avertissement
         * Support double signature:
         * - warning(message, duration)
         * - warning(message, options)
         *
         * @param {string} message - Message à afficher
         * @param {number|Object} [durationOrOptions] - Durée (ms) OU objet options
         *
         * @example
         * warning("Connexion instable", 4000);
         * warning("Connexion instable", { duration: 4000 });
         */
        warning(message, durationOrOptions) {
            if (typeof durationOrOptions === 'number') {
                return this.show(message, 'warning', durationOrOptions);
            } else if (typeof durationOrOptions === 'object') {
                return this.show(message, { ...durationOrOptions, type: 'warning' });
            } else {
                return this.show(message, 'warning');
            }
        }

        /**
         * Affiche une notification d'information
         * Support double signature:
         * - info(message, duration)
         * - info(message, options)
         *
         * @param {string} message - Message à afficher
         * @param {number|Object} [durationOrOptions] - Durée (ms) OU objet options
         *
         * @example
         * info("Synchronisation en cours", 3000);
         * info("Synchronisation en cours", { persistent: true, dismissible: false });
         */
        info(message, durationOrOptions) {
            if (typeof durationOrOptions === 'number') {
                return this.show(message, 'info', durationOrOptions);
            } else if (typeof durationOrOptions === 'object') {
                return this.show(message, { ...durationOrOptions, type: 'info' });
            } else {
                return this.show(message, 'info');
            }
        }

        /**
         * Ajoute une notification à la queue avec priorité
         * @private
         * @param {string} message - Message
         * @param {Object} options - Options de la notification
         */
        _enqueue(message, options) {
            const type = options.type || 'info';
            const priority = PRIORITY[type.toUpperCase()] || PRIORITY.INFO;

            const item = {
                message,
                options: {
                    type,
                    duration: options.duration,
                    persistent: options.persistent || false,
                    dismissible: options.dismissible !== false, // true par défaut
                    icon: options.icon,
                    action: options.action
                },
                priority,
                timestamp: Date.now()
            };

            // Vérifier la limite de la queue
            if (this._queue.length >= this._maxQueueSize) {
                // Trouver l'élément de plus faible priorité (et plus ancien si égalité)
                const lowestPriorityIndex = this._queue.reduce((minIdx, item, idx, arr) => {
                    const minItem = arr[minIdx];
                    if (item.priority < minItem.priority ||
                        (item.priority === minItem.priority && item.timestamp < minItem.timestamp)) {
                        return idx;
                    }
                    return minIdx;
                }, 0);

                // Si le nouvel item est plus prioritaire que le moins prioritaire dans la queue
                if (item.priority > this._queue[lowestPriorityIndex].priority) {
                    // Supprimer le moins prioritaire
                    this._queue.splice(lowestPriorityIndex, 1);

                    if (Log) Log.warn('[GeoLeaf Notifications] Queue pleine, notification droppée');
                } else {
                    // Dropper le nouveau item
                    if (Log) Log.warn('[GeoLeaf Notifications] Queue pleine, notification rejetée');
                    return;
                }
            }

            // Ajouter à la queue
            this._queue.push(item);

            // Trier la queue par priorité (desc) puis timestamp (asc)
            this._queue.sort((a, b) => {
                if (b.priority !== a.priority) {
                    return b.priority - a.priority; // Priorité décroissante
                }
                return a.timestamp - b.timestamp; // Timestamp croissant (FIFO pour même priorité)
            });

            // Traiter la queue
            return this._processQueue();
        }

        /**
         * Traite la queue et affiche les notifications selon disponibilité
         * @private
         */
        _processQueue() {
            if (!this.container || !this.config.enabled || this._queue.length === 0) {
                return null;
            }

            // Compter les toasts actuellement visibles
            const visibleToasts = this.container.querySelectorAll('.gl-toast:not(.gl-toast--removing)');
            const temporaryToasts = Array.from(visibleToasts).filter(t => !t.dataset.persistent);
            const persistentToasts = Array.from(visibleToasts).filter(t => t.dataset.persistent);

            // Tant qu'il y a de la place et des items dans la queue
            let lastToast = null;
            while (this._queue.length > 0) {
                const nextItem = this._queue[0];
                const isPersistent = nextItem.options.persistent;

                // Vérifier si on peut afficher ce toast
                const canShow = isPersistent
                    ? persistentToasts.length < this.maxPersistent
                    : temporaryToasts.length < this.maxVisible;

                if (!canShow) {
                    // Si c'est un toast prioritaire (error), retirer un toast existant moins prioritaire
                    if (nextItem.priority === PRIORITY.ERROR && temporaryToasts.length > 0) {
                        // Trouver un toast info ou success à retirer
                        const toastToRemove = temporaryToasts.find(t =>
                            t.classList.contains('gl-toast--info') ||
                            t.classList.contains('gl-toast--success')
                        ) || temporaryToasts[0];

                        this._remove(toastToRemove, true); // true = reorganization
                        // Continuer pour afficher le toast prioritaire
                    } else {
                        // Pas de place, arrêter le traitement
                        break;
                    }
                }

                // Retirer de la queue et afficher
                const item = this._queue.shift();
                lastToast = this._showImmediate(item.message, item.options);

                // Mettre à jour les compteurs
                if (isPersistent) {
                    persistentToasts.push(null); // Placeholder
                } else {
                    temporaryToasts.push(null); // Placeholder
                }
            }

            return lastToast;
        }

        /**
         * Affiche une notification immédiatement (utilisée par la queue)
         * @private
         * @param {string} message - Message à afficher
         * @param {Object} options - Options de la notification
         */
        _showImmediate(message, options) {
            const type = options.type || 'info';
            const duration = options.duration || this.durations[type];
            const persistent = options.persistent || false;
            const dismissible = options.dismissible !== false;

            // Créer le toast
            const toast = createElement$1('div', {
                className: `gl-toast gl-toast--${type}`,
                attributes: {
                    'role': 'alert',
                    // Utiliser assertive pour errors et toasts prioritaires
                    'aria-live': (type === 'error' || options.priority === PRIORITY.ERROR) ? 'assertive' : 'polite'
                }
            });

            // Marquer si persistant
            if (persistent) {
                toast.dataset.persistent = 'true';
            }

            // Créer le message (textContent = sécurisé)
            const messageSpan = createElement$1('span', {
                className: 'gl-toast__message',
                textContent: message
            });
            toast.appendChild(messageSpan);

            // Créer le bouton de fermeture (si dismissible)
            if (dismissible) {
                const closeBtn = createElement$1('button', {
                    className: 'gl-toast__close',
                    attributes: {
                        'aria-label': 'Fermer la notification',
                        'title': 'Fermer'
                    },
                    textContent: '×',
                    onClick: () => {
                        this._remove(toast, false);
                    }
                });
                toast.appendChild(closeBtn);
            }

            // Ajouter au DOM
            this.container.appendChild(toast);

            // Animation d'entrée
            if (this.config.animations) {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        toast.classList.add('gl-toast--visible');
                    });
                });
            } else {
                toast.classList.add('gl-toast--visible');
            }

            // Planifier l'auto-suppression (seulement si non persistant)
            // Perf 6.2.6: Un seul timer — timerManager si disponible, sinon setTimeout nu
            if (!persistent) {
                if (this._timerManager) {
                    toast.dataset.timerId = this._timerManager.setTimeout(() => {
                        this._remove(toast, false);
                    }, duration);
                } else {
                    const autoRemove = setTimeout(() => {
                        this._remove(toast, false);
                    }, duration);
                    toast.dataset.timeoutId = autoRemove;
                }
            }

            return toast;
        }

        /**
         * Retire une notification
         * @private
         * @param {HTMLElement} toast - Élément toast à retirer
         * @param {boolean} isReorganization - Si true, c'est une réorganisation (animation différente)
         */
        _remove(toast, isReorganization = false) {
            if (!toast || toast.classList.contains('gl-toast--removing')) {
                return;
            }

            // Annuler le timeout auto si fermeture manuelle
            if (toast.dataset.timeoutId) {
                clearTimeout(parseInt(toast.dataset.timeoutId));
                delete toast.dataset.timeoutId;
            }
            if (toast.dataset.timerId && this._timerManager) {
                this._timerManager.clearTimeout(toast.dataset.timerId);
                delete toast.dataset.timerId;
            }

            // Animation de sortie
            toast.classList.add('gl-toast--removing');
            toast.classList.remove('gl-toast--visible');

            // Appliquer animation spécifique pour réorganisation
            if (isReorganization && this.config.animations) {
                toast.classList.add('gl-toast--sliding-up');
            }

            const removeDelay = this.config.animations ? 200 : 0;
            // Perf 6.2.6: Un seul timer — timerManager si disponible, sinon setTimeout nu
            const _doRemove = () => {
                if (toast.parentNode) {
                    toast.remove();
                }
                this._processQueue();
            };
            if (this._timerManager) {
                this._timerManager.setTimeout(_doRemove, removeDelay);
            } else {
                setTimeout(_doRemove, removeDelay);
            }
        }

        /**
         * Efface toutes les notifications
         */
        clearAll() {
            if (!this.container) return;

            const toasts = this.container.querySelectorAll('.gl-toast');
            toasts.forEach(toast => this._remove(toast, false));

            // Vider aussi la queue
            this._queue = [];
        }

        /**
         * Ferme une notification spécifique par sa référence DOM
         * @param {HTMLElement} toastEl - Élément toast retourné par show/info/success/etc.
         */
        dismiss(toastEl) {
            if (!toastEl) return;
            this._remove(toastEl, false);
        }

        /**
         * Désactive temporairement les notifications
         */
        disable() {
            this.config.enabled = false;
            if (Log) Log.debug('[GeoLeaf Notifications] Système désactivé');
        }

        /**
         * Réactive les notifications
         */
        enable() {
            this.config.enabled = true;
            if (Log) Log.debug('[GeoLeaf Notifications] Système activé');
            // Traiter la queue au cas où des items sont en attente
            this._processQueue();
        }

        /**
         * Détruit le système de notifications et nettoie toutes les ressources
         * Retire tous les event listeners et timers actifs
         */
        destroy() {

            // Clear tous les timers actifs
            if (this._timerManager) {
                this._timerManager.destroy();
                this._timerManager = null;
            }

            // Retire tous les event listeners
            if (this._eventManager) {
                this._eventManager.destroy();
                this._eventManager = null;
            }

            // Retire tous les toasts actifs
            if (this.container) {
                const toasts = this.container.querySelectorAll('.gl-toast');
                toasts.forEach(toast => toast.remove());
            }

            // Clear la queue
            this._queue = [];

            // Clear la map
            this._activeToasts.clear();

            // Reset les propriétés
            this.container = null;
            this.config.enabled = false;

            if (Log) Log.info('[GeoLeaf Notifications] Système détruit et nettoyé');
        }

        /**
         * Get current status of notification system
         * @returns {Object} Status information
         */
        getStatus() {
            const visibleToasts = this.container ? this.container.querySelectorAll('.gl-toast:not(.gl-toast--removing)') : [];
            const temporaryToasts = Array.from(visibleToasts).filter(t => !t.dataset.persistent);
            const persistentToasts = Array.from(visibleToasts).filter(t => t.dataset.persistent);

            return {
                enabled: this.config.enabled,
                initialized: !!this.container,
                activeToasts: visibleToasts.length,
                temporaryToasts: temporaryToasts.length,
                persistentToasts: persistentToasts.length,
                queued: this._queue.length,
                maxVisible: this.maxVisible,
                maxPersistent: this.maxPersistent,
                position: this.config.position
            };
        }
    }

    // Créer une instance singleton et l'exposer
    const _UINotifications = new NotificationSystem();

    /**
     * Module LayerManager - Cache Section
     *
     * Ajoute une section de gestion du cache offline dans le gestionnaire de couches.
     * Permet de télécharger/effacer le cache du profil actif.
     *
     * @module GeoLeaf.LayerManager.CacheSection
     * @version 3.0.0
     */


    /**
     * Module de section cache pour la légende
     */
    const CacheSection = {
        /**
         * Génère la section HTML du cache
         *
         * @returns {Object} Section configuration
         */
        generateSection() {
            return {
                id: "offline-cache",
                label: "📥 Cache Hors Ligne",
                order: 98,
                collapsedByDefault: false,
                customContent: this._generateContent(),
                init: () => this._attachEventListeners()
            };
        },

        /**
         * Génère le contenu HTML
         * @private
         */
        _generateContent() {
            return `
            <div class="gl-cache-section">
                <div class="gl-cache-status">
                    <div class="gl-cache-status__header">
                        <span class="gl-cache-status__icon">💾</span>
                        <span class="gl-cache-status__label">Statut</span>
                    </div>
                    <div class="gl-cache-status__info">
                        <div class="gl-cache-status__row">
                            <span class="gl-cache-status__key">Profil:</span>
                            <span class="gl-cache-status__value" id="gl-cache-profile">-</span>
                        </div>
                        <div class="gl-cache-status__row">
                            <span class="gl-cache-status__key">État:</span>
                            <span class="gl-cache-status__value" id="gl-cache-state">Non téléchargé</span>
                        </div>
                        <div class="gl-cache-status__row">
                            <span class="gl-cache-status__key">Taille:</span>
                            <span class="gl-cache-status__value" id="gl-cache-size">0 MB</span>
                        </div>
                        <div class="gl-cache-status__row">
                            <span class="gl-cache-status__key">Quota:</span>
                            <span class="gl-cache-status__value" id="gl-cache-quota">0 MB disponible</span>
                        </div>
                    </div>
                </div>

                <div class="gl-cache-actions">
                    <button
                        id="gl-cache-download"
                        class="gl-btn gl-btn--primary gl-cache-btn"
                        title="Télécharger le profil pour usage offline">
                        <span class="gl-btn__icon">⬇️</span>
                        <span class="gl-btn__text">Télécharger profil</span>
                    </button>

                    <button
                        id="gl-cache-clear"
                        class="gl-btn gl-btn--secondary gl-cache-btn"
                        title="Effacer le cache du profil"
                        disabled>
                        <span class="gl-btn__icon">🗑️</span>
                        <span class="gl-btn__text">Vider cache</span>
                    </button>
                </div>

                <div class="gl-cache-progress" id="gl-cache-progress" style="display: none;">
                    <div class="gl-cache-progress__bar">
                        <div class="gl-cache-progress__fill" id="gl-cache-progress-fill"></div>
                    </div>
                    <div class="gl-cache-progress__text" id="gl-cache-progress-text">
                        Téléchargement en cours...
                    </div>
                </div>
            </div>
        `;
        },

        /**
         * Attache les event listeners
         * @private
         */
        _attachEventListeners() {
            const downloadBtn = document.getElementById("gl-cache-download");
            const clearBtn = document.getElementById("gl-cache-clear");

            if (downloadBtn) {
                downloadBtn.addEventListener("click", () => this._handleDownload());
            }

            if (clearBtn) {
                clearBtn.addEventListener("click", () => this._handleClear());
            }

            // Mettre à jour le statut initial
            this._updateStatus();

            // Écouter les événements de cache
            document.addEventListener("geoleaf:cache:completed", () => this._updateStatus());
            document.addEventListener("geoleaf:cache:cleared", () => this._updateStatus());
            document.addEventListener("geoleaf:profile:loaded", () => this._updateStatus());
        },

        /**
         * Met à jour l'affichage du statut
         * @private
         */
        async _updateStatus() {
            if (!StorageContract.isAvailable()) {
                return;
            }

            try {
                const profileId = Config.get("data.activeProfile", "");
                const status = await StorageContract.CacheManager.getCacheStatus(profileId);
                const quota = await StorageContract.CacheManager.getStorageQuota();

                // Mettre à jour les éléments DOM
                const profileEl = document.getElementById("gl-cache-profile");
                const stateEl = document.getElementById("gl-cache-state");
                const sizeEl = document.getElementById("gl-cache-size");
                const quotaEl = document.getElementById("gl-cache-quota");
                const clearBtn = document.getElementById("gl-cache-clear");

                if (profileEl) profileEl.textContent = profileId || "-";

                if (status && status.resourcesCount > 0) {
                    if (stateEl) {
                        stateEl.textContent = "✅ Téléchargé";
                        stateEl.style.color = "#22c55e";
                    }
                    if (sizeEl) {
                        sizeEl.textContent = `${(status.totalSize / 1024 / 1024).toFixed(2)} MB`;
                    }
                    if (clearBtn) clearBtn.disabled = false;
                } else {
                    if (stateEl) {
                        stateEl.textContent = "❌ Non téléchargé";
                        stateEl.style.color = "#ef4444";
                    }
                    if (sizeEl) sizeEl.textContent = "0 MB";
                    if (clearBtn) clearBtn.disabled = true;
                }

                if (quotaEl) {
                    quotaEl.textContent = `${(quota.available / 1024 / 1024).toFixed(2)} MB disponible`;
                }

            } catch (error) {
                Log.error(`[CacheSection] Failed to update status: ${error.message}`);
            }
        },

        /**
         * Gère le téléchargement du profil
         * @private
         */
        async _handleDownload() {
            if (!StorageContract.isAvailable()) {
                _UINotifications.error("Stockage offline non disponible", 5000);
                return;
            }

            const profileId = Config.get("data.activeProfile", "");
            if (!profileId) {
                _UINotifications.error("Aucun profil actif", 3000);
                return;
            }

            const downloadBtn = document.getElementById("gl-cache-download");
            const progressEl = document.getElementById("gl-cache-progress");
            const progressText = document.getElementById("gl-cache-progress-text");

            try {
                // Désactiver le bouton
                if (downloadBtn) {
                    downloadBtn.disabled = true;
                    downloadBtn.querySelector(".gl-btn__text").textContent = "Téléchargement...";
                }

                // Afficher la barre de progression
                if (progressEl) progressEl.style.display = "block";
                if (progressText) progressText.textContent = "Préparation...";

                Log.info(`[CacheSection] Starting download for profile: ${profileId}`);

                // Télécharger le profil
                const result = await StorageContract.downloadProfileForOffline(profileId);

                if (progressText) {
                    progressText.textContent = `✅ ${result.resourcesCount} ressources téléchargées`;
                }

                // Notification de succès
                _UINotifications.success(`Profil téléchargé : ${(result.totalSize / 1024 / 1024).toFixed(2)} MB`, 4000);

                // Masquer la progression après 2s
                setTimeout(() => {
                    if (progressEl) progressEl.style.display = "none";
                }, 2000);

                await this._updateStatus();

            } catch (error) {
                Log.error(`[CacheSection] Download failed: ${error.message}`);

                if (progressText) progressText.textContent = `❌ Erreur: ${error.message}`;

                _UINotifications.error(`Erreur téléchargement: ${error.message}`, 5000);

                setTimeout(() => {
                    if (progressEl) progressEl.style.display = "none";
                }, 3000);

            } finally {
                // Réactiver le bouton
                if (downloadBtn) {
                    downloadBtn.disabled = false;
                    downloadBtn.querySelector(".gl-btn__text").textContent = "Télécharger profil";
                }
            }
        },

        /**
         * Gère l'effacement du cache
         * @private
         */
        async _handleClear() {
            if (!StorageContract.isAvailable()) {
                return;
            }

            const profileId = Config.get("data.activeProfile", "");
            if (!profileId) {
                return;
            }

            // Confirmation
            if (!confirm(`Voulez-vous vraiment effacer le cache du profil "${profileId}" ?`)) {
                return;
            }

            const clearBtn = document.getElementById("gl-cache-clear");

            try {
                if (clearBtn) {
                    clearBtn.disabled = true;
                    clearBtn.querySelector(".gl-btn__text").textContent = "Effacement...";
                }

                Log.info(`[CacheSection] Clearing cache for profile: ${profileId}`);

                const deleted = await StorageContract.CacheManager.clearCache(profileId);

                _UINotifications.success(`Cache effacé : ${deleted} ressources supprimées`, 3000);

                await this._updateStatus();

            } catch (error) {
                Log.error(`[CacheSection] Clear failed: ${error.message}`);

                _UINotifications.error(`Erreur effacement: ${error.message}`, 5000);
            } finally {
                if (clearBtn) {
                    clearBtn.querySelector(".gl-btn__text").textContent = "Vider cache";
                }
            }
        }
    };

    /**
     * GeoLeaf Legend API (assemblage namespace Legend)
     * @module legend/legend-api
     */
    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    const _g$h =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$h.GeoLeaf = _g$h.GeoLeaf || {};

    let _map = null;
    let _control = null;
    let _options = {};
    let _profileConfig = null;
    let _taxonomyData = null;

    // Timers and UI helpers
    let _rebuildTimer = null;
    const REBUILD_DEBOUNCE_MS = 150;
    let _loadingOverlayEl = null;
    let _loadingOverlayTimer = null;
    const LOADING_OVERLAY_TIMEOUT_MS = 12000;

    // Map<layerId, {label, styleId, legendData, visible, order, geometryType}>
    const _allLayers = new Map();

    function _normalizeGeometryType(rawGeometry) {
        const value = (rawGeometry).toLowerCase();
        if (value === "polyline" || value === "line") return "line";
        if (value === "polygon") return "polygon";
        return "point";
    }

    function _scheduleRebuild() {
        if (_rebuildTimer) {
            clearTimeout(_rebuildTimer);
        }
        _rebuildTimer = setTimeout(() => {
            _rebuildTimer = null;
            LegendModule._rebuildDisplay();
        }, REBUILD_DEBOUNCE_MS);
    }

    function _ensureSpinnerStyles() {
        if (document.getElementById("gl-legend-spinner-style")) return;
        const styleEl = document.createElement("style");
        styleEl.id = "gl-legend-spinner-style";
        styleEl.textContent =
            "@keyframes gl-legend-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }";
        document.head.appendChild(styleEl);
    }

    function _clearOverlayTimeout() {
        if (_loadingOverlayTimer) {
            clearTimeout(_loadingOverlayTimer);
            _loadingOverlayTimer = null;
        }
    }

    function _showLoadingOverlay() {
        if (!_control || !_control._container) return;

        _ensureSpinnerStyles();
        _clearOverlayTimeout();

        const container = _control._container;
        if (!container.style.position) {
            container.style.position = "relative";
        }

        if (!_loadingOverlayEl) {
            const overlay = document.createElement("div");
            overlay.className = "gl-map-legend__loading-overlay";
            overlay.style.position = "absolute";
            overlay.style.inset = "0";
            overlay.style.background = "rgba(255,255,255,0.6)";
            overlay.style.display = "flex";
            overlay.style.alignItems = "center";
            overlay.style.justifyContent = "center";
            overlay.style.pointerEvents = "auto";
            overlay.style.zIndex = "2";
            overlay.setAttribute("aria-hidden", "false");

            const spinner = document.createElement("div");
            spinner.className = "gl-map-legend__spinner";
            spinner.style.width = "34px";
            spinner.style.height = "34px";
            spinner.style.border = "3px solid rgba(0,0,0,0.12)";
            spinner.style.borderTop = "3px solid rgba(0,0,0,0.55)";
            spinner.style.borderRadius = "50%";
            spinner.style.animation = "gl-legend-spin 1s linear infinite";

            overlay.appendChild(spinner);
            _loadingOverlayEl = overlay;
        }

        if (!_loadingOverlayEl.parentElement) {
            container.appendChild(_loadingOverlayEl);
        }

        container.setAttribute("aria-busy", "true");
        container.setAttribute("aria-live", "polite");

        _loadingOverlayTimer = setTimeout(() => {
            _loadingOverlayTimer = null;
            _hideLoadingOverlay();
        }, LOADING_OVERLAY_TIMEOUT_MS);
    }

    function _hideLoadingOverlay() {
        _clearOverlayTimeout();
        if (_loadingOverlayEl && _loadingOverlayEl.parentElement) {
            _loadingOverlayEl.parentElement.removeChild(_loadingOverlayEl);
        }
        if (_control && _control._container) {
            _control._container.removeAttribute("aria-busy");
            _control._container.removeAttribute("aria-live");
        }
    }

    const LegendModule = {
        /**
         * Initialise le module Legend
         * @param {L.Map} mapInstance - Instance de la carte Leaflet
         * @param {Object} options - Options du module
         * @param {string} [options.position="bottomleft"] - Position du contrôle
         * @param {boolean} [options.collapsible=true] - Légende repliable
         * @param {boolean} [options.collapsed=false] - État replié initial
         */
        init: function (mapInstance, options) {
            if (!mapInstance) {
                if (Log) Log.error("[Legend] Carte Leaflet requise pour initialiser Legend");
                return false;
            }

            _map = mapInstance;

            // Charger la configuration depuis le profil
            if (_g$h.GeoLeaf.Config && typeof _g$h.GeoLeaf.Config.get === "function") {
                const legendConfig = _g$h.GeoLeaf.Config.get("legendConfig");

                _options = Object.assign(
                    {
                        position: (legendConfig && legendConfig.position) || "bottomleft",
                        collapsible: true,
                        collapsed: (legendConfig && legendConfig.collapsedByDefault) || false,
                        title: (legendConfig && legendConfig.title) || "Légende",
                    },
                    options || {}
                );

                // Récupérer le profil actif complet
                if (typeof _g$h.GeoLeaf.Config.getActiveProfile === "function") {
                    _profileConfig = _g$h.GeoLeaf.Config.getActiveProfile();
                } else {
                    // Fallback : essayer de récupérer depuis getAll
                    const allConfig = _g$h.GeoLeaf.Config.getAll();
                    _profileConfig = {
                        id: allConfig.id || _g$h.GeoLeaf.Config.get("id"),
                        layers: allConfig.layers || _g$h.GeoLeaf.Config.get("layers") || [],
                    };
                }
            } else {
                _options = Object.assign(
                    {
                        position: "bottomleft",
                        collapsible: true,
                        collapsed: false,
                        title: "Légende",
                    },
                    options || {}
                );
            }

            // Charger la taxonomy pour les icônes
            this._loadTaxonomy();

            // Initialiser toutes les couches du profil
            this._initializeAllLayers();

            if (Log)
                Log.info("[Legend] Module Legend initialisé avec génération automatique depuis styles");
            return true;
        },

        /**
         * Charge la taxonomy pour la correspondance catégories → icônes
         * @private
         */
        _loadTaxonomy: function () {
            if (!_profileConfig) return;

            const Config = _g$h.GeoLeaf.Config;
            const dataCfg = Config && Config.get ? Config.get("data") : null;
            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
            const profileId = _profileConfig.id;

            if (!profileId) {
                if (Log) Log.warn("[Legend] Impossible de charger taxonomy sans profileId");
                return;
            }

            const taxonomyPath = `${profilesBasePath}/${profileId}/taxonomy.json`;

            fetch(taxonomyPath)
                .then((response) => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.json();
                })
                .then((data) => {
                    _taxonomyData = data;
                    if (Log) Log.debug("[Legend] Taxonomy chargée");
                })
                .catch((err) => {
                    if (Log) Log.warn(`[Legend] Erreur chargement taxonomy: ${err.message}`);
                });
        },

        /**
         * Initialise toutes les couches définies dans le profil
         * @private
         */
        _initializeAllLayers: function () {
            if (!_profileConfig || !Array.isArray(_profileConfig.layers)) {
                if (Log) Log.warn("[Legend] Aucune couche définie dans le profil");
                return;
            }

            _profileConfig.layers.forEach((layerDef, index) => {
                _allLayers.set(layerDef.id, {
                    label: layerDef.id, // Sera mis à jour lors du chargement du config
                    styleId: null,
                    legendData: null,
                    visible: false,
                    order: index + 1,
                    geometryType: null,
                    configFile: layerDef.configFile,
                });
            });

            if (Log) Log.debug(`[Legend] ${_allLayers.size} couche(s) initialisée(s)`);
        },

        /**
         * Charge et génère la légende pour une couche
         * @param {string} layerId - ID de la couche
         * @param {string} styleId - ID du style à appliquer
         * @param {Object} layerConfig - Configuration de la couche
         */
        loadLayerLegend: function (layerId, styleId, layerConfig) {
            if (!_map) {
                if (Log) Log.warn("[Legend] Module non initialisé");
                return;
            }

            const layerInfo = _allLayers.get(layerId);
            if (!layerInfo) {
                if (Log) Log.warn(`[Legend] Couche ${layerId} non trouvée dans le profil`);
                return;
            }

            // S'assurer que le sprite SVG est disponible dès le début
            if (
                _g$h.GeoLeaf._POIMarkers &&
                typeof _g$h.GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync === "function"
            ) {
                _g$h.GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync();
                if (Log) Log.debug(`[Legend] Sprite SVG demandé pour couche ${layerId}`);
            }

            // Mettre à jour les informations de la couche
            layerInfo.label = layerConfig.label || layerId;
            layerInfo.geometryType = _normalizeGeometryType(
                layerConfig.geometryType || layerConfig.geometry || layerInfo.geometryType || "point"
            );
            layerInfo.styleId = styleId;

            // Charger le fichier de style
            const Config = _g$h.GeoLeaf.Config;
            const dataCfg = Config && Config.get ? Config.get("data") : null;
            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
            const profileId = layerConfig._profileId || _profileConfig.id;
            const layerDir = layerConfig._layerDirectory;

            if (!layerConfig.styles || !layerConfig.styles.directory) {
                if (Log) Log.warn(`[Legend] Configuration styles manquante pour ${layerId}`);
                return;
            }

            const stylesDir = layerConfig.styles.directory;
            const styleFile =
                layerConfig.styles.available?.find((s) => s.id === styleId)?.file ||
                layerConfig.styles.default;

            const stylePath = `${profilesBasePath}/${profileId}/${layerDir}/${stylesDir}/${styleFile}`;

            if (Log) Log.debug(`[Legend] Chargement style: ${stylePath}`);

            fetch(stylePath)
                .then((response) => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.json();
                })
                .then((styleData) => {
                    // Générer la légende depuis le style
                    if (!_g$h.GeoLeaf._LegendGenerator) {
                        if (Log) Log.error("[Legend] LegendGenerator non disponible");
                        return;
                    }

                    // Temporairement stocker la config de couche pour le générateur (comme dans markers.js)
                    const originalPOIShared = _g$h.GeoLeaf._POIShared;
                    if (layerConfig.showIconsOnMap !== undefined) {
                        // Créer un état temporaire pour cette couche
                        _g$h.GeoLeaf._POIShared = {
                            state: {
                                poiConfig: {
                                    showIconsOnMap: layerConfig.showIconsOnMap,
                                },
                            },
                        };
                    }

                    const legendData = _g$h.GeoLeaf._LegendGenerator.generateLegendFromStyle(
                        styleData,
                        layerInfo.geometryType,
                        _taxonomyData
                    );

                    // Restaurer l'état POI original
                    if (layerConfig.showIconsOnMap !== undefined) {
                        _g$h.GeoLeaf._POIShared = originalPOIShared;
                    }

                    if (legendData) {
                        layerInfo.legendData = legendData;
                        _allLayers.set(layerId, layerInfo);
                        if (Log) Log.debug(`[Legend] Légende générée pour ${layerId}`);

                        // Reconstruire l'affichage
                        _scheduleRebuild();
                    }
                })
                .catch((err) => {
                    if (Log) Log.warn(`[Legend] Erreur chargement style: ${err.message}`);
                });
        },

        /**
         * Met à jour la visibilité d'une couche dans la légende
         * @param {string} layerId - ID de la couche
         * @param {boolean} visible - Visible ou non
         */
        setLayerVisibility: function (layerId, visible) {
            const layerInfo = _allLayers.get(layerId);
            if (layerInfo) {
                layerInfo.visible = visible;
                _allLayers.set(layerId, layerInfo);
                _scheduleRebuild();
                if (Log) Log.debug(`[Legend] Visibilité de ${layerId}: ${visible}`);
            }
        },

        /**
         * Reconstruit l'affichage de toutes les légendes
         * @private
         */
        _rebuildDisplay: function () {
            if (!_map) return;

            // Si aucune couche, supprimer le contrôle
            if (_allLayers.size === 0) {
                if (_control && _map) {
                    _map.removeControl(_control);
                    _control = null;
                }
                return;
            }

            // Créer le contrôle si nécessaire
            if (!_control) {
                _control = _g$h.GeoLeaf._LegendControl.create(_options);
                if (_control) {
                    _map.addControl(_control);
                }
            }

            // Préparer les données pour le rendu (afficher toutes les couches)
            if (_control && typeof _control.updateMultiLayerContent === "function") {
                const visibilityManager = _g$h.GeoLeaf._LayerVisibilityManager;
                const legendsArray = [];

                _allLayers.forEach((data, layerId) => {
                    if (!data.legendData) return;

                    const visState =
                        visibilityManager && typeof visibilityManager.getVisibilityState === "function"
                            ? visibilityManager.getVisibilityState(layerId)
                            : null;

                    const isVisible = visState ? visState.current : data.visible;
                    if (!isVisible) return;

                    legendsArray.push({
                        layerId: layerId,
                        label: data.label,
                        collapsed: true,
                        order: data.order,
                        visible: true,
                        sections: data.legendData.sections || [],
                    });
                });

                // Trier par ordre
                legendsArray.sort((a, b) => a.order - b.order);

                _control.updateMultiLayerContent(legendsArray);

                // Si nous avons des icônes mais pas de sprite, programmer un retry
                const hasIcons = legendsArray.some((legend) =>
                    legend.sections.some(
                        (section) => section.items && section.items.some((item) => item.icon)
                    )
                );

                if (hasIcons) {
                    const sprite = document.querySelector('svg[data-geoleaf-sprite="profile"]');
                    if (!sprite) {
                        if (Log)
                            Log.info(
                                "[Legend] Icônes détectées mais sprite manquant - programmation retry"
                            );
                        // Programmer un nouveau rendu dans 2 secondes
                        setTimeout(() => {
                            const spriteCheck = document.querySelector(
                                'svg[data-geoleaf-sprite="profile"]'
                            );
                            if (spriteCheck && Log) {
                                Log.info("[Legend] Sprite disponible - nouveau rendu de la légende");
                                this._rebuildDisplay();
                            }
                        }, 2000);
                    }
                }
            }
        },

        /**
         * Bascule l'état d'un accordéon
         * @param {string} layerId - ID de la couche
         */
        toggleAccordion: function (_layerId) {
            // Géré visuellement par le renderer
        },

        /**
         * Récupère toutes les couches
         * @returns {Map}
         */
        getAllLayers: function () {
            return _allLayers;
        },

        /**
         * Cache la légende
         */
        hideLegend: function () {
            if (_control) {
                _control.hide();
            }
        },

        /**
         * Supprime toutes les légendes
         */
        removeLegend: function () {
            _allLayers.forEach((layerInfo, _layerId) => {
                layerInfo.legendData = null;
                layerInfo.visible = false;
            });

            if (_control && _map) {
                _map.removeControl(_control);
                _control = null;
                if (Log) Log.debug("[Legend] Toutes les légendes supprimées");
            }
        },

        /**
         * Vérifie si des légendes sont affichées
         * @returns {boolean}
         */
        isLegendVisible: function () {
            return _control !== null && _allLayers.size > 0;
        },

        showLoadingOverlay: function () {
            _showLoadingOverlay();
        },

        hideLoadingOverlay: function () {
            _hideLoadingOverlay();
        },
    };

    const Legend = LegendModule;

    /**
     * GeoLeaf Contract — Legend (lazy-chunk boundary)
     *
     * Interface ESM pure pour accéder au module Legend depuis les modules core
     * sans couplage runtime — interface ESM pure.
     *
     * Phase 10-D — Pattern C : contrat de chunk Legend.
     *
     * USAGE :
     *   import { LegendContract } from '../../../contracts/legend.contract.js';
     *
     *   if (LegendContract.isAvailable()) {
     *       LegendContract.loadLayerLegend(layerId, styleId, layerConfig);
     *   }
     *
     * POURQUOI un contrat ?
     * Legend (geoleaf.legend.js) est une façade qui dépend de l'init runtime
     * (map + profil). Le contrat encapsule la garde d'initialisation et fournit
     * un point d'entrée typé, sans exposer le namespace global.
     */

    /**
     * Contrat d'interface pour le module Legend.
     * @namespace LegendContract
     */
    const LegendContract = {
        /**
         * Retourne true si Legend est initialisé (carte chargée).
         * @returns {boolean}
         */
        isAvailable() {
            return !!Legend && typeof Legend.loadLayerLegend === "function";
        },

        /**
         * Charge et affiche la légende pour une couche et un style donnés.
         * @param {string} layerId
         * @param {string} styleId
         * @param {Object} layerConfig
         */
        loadLayerLegend(layerId, styleId, layerConfig) {
            if (typeof Legend.loadLayerLegend === "function") {
                Legend.loadLayerLegend(layerId, styleId, layerConfig);
            }
        },

        /**
         * Met à jour la visibilité d'une couche dans la légende.
         * @param {string} layerId
         * @param {boolean} visible
         */
        setLayerVisibility(layerId, visible) {
            if (typeof Legend.setLayerVisibility === "function") {
                Legend.setLayerVisibility(layerId, visible);
            }
        },
    };

    /**
     * @module _LayerManagerStyleSelector
     * @description Sélecteur de styles pour le gestionnaire de couches.
     * Permet de changer dynamiquement le style appliqué à une couche.
     * Utilise le nouveau style-loader pour charger et valider les styles.
     * @version 3.1.0
     */

    /**
     * État interne du sélecteur de styles
     * @private
     */
    const state = {
        currentStyles: new Map(), // layerId -> styleId
    };

    /**
     * Module sélecteur de styles pour le gestionnaire de couches
     * @namespace
     */
    const _LayerManagerStyleSelector = {
        /**
         * Récupère le style actuel d'une couche
         * @param {string} layerId - Identifiant de la couche
         * @returns {string|null} Identifiant du style actuel
         */
        getCurrentStyle: function (layerId) {
            return state.currentStyles.get(layerId) || null;
        },

        /**
         * Définit le style actuel d'une couche
         * @param {string} layerId - Identifiant de la couche
         * @param {string} styleId - Identifiant du style
         */
        setCurrentStyle: function (layerId, styleId) {
            state.currentStyles.set(layerId, styleId);
        },

        /**
         * Génère l'élément DOM du sélecteur de styles
         * @param {Object} item - Configuration de l'item de couche
         * @param {string} item.id - Identifiant de la couche
         * @param {Object} item.styles - Configuration des styles disponibles
         * @param {Array} item.styles.available - Tableau des styles disponibles
         * @param {string} item.styles.default - Style par défaut
         * @returns {HTMLElement|null} Élément DOM du sélecteur ou null
         */
        renderDOM: function (item) {
            // ...log supprimé ([StyleSelector] renderDOM)...

            if (
                !item.styles ||
                !Array.isArray(item.styles.available) ||
                item.styles.available.length <= 1
            ) {
                // ...log supprimé ([StyleSelector] Pas de sélecteur nécessaire)...
                return null;
            }

            const currentStyle =
                this.getCurrentStyle(item.id) || item.styles.default || item.styles.available[0].id;
            const selectId = "style-selector-" + item.id;

            // Créer le conteneur
            const container = document.createElement("div");
            container.className = "gl-layer-manager__style-selector";

            // Créer le select
            const select = document.createElement("select");
            select.id = selectId;
            select.className = "gl-layer-manager__style-select";
            select.setAttribute("data-layer-id", item.id);

            // Ajouter les options
            item.styles.available.forEach(function (style) {
                const option = document.createElement("option");
                option.value = style.id;
                option.textContent = style.label;
                if (style.id === currentStyle) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            container.appendChild(select);
            return container;
        },

        /**
         * Initialise les événements du sélecteur de styles
         * @param {HTMLElement} container - Conteneur des contrôles
         * @param {Object} item - Configuration de l'item de couche
         */
        bindEvents: function (container, item) {
            if (
                !item.styles ||
                !Array.isArray(item.styles.available) ||
                item.styles.available.length <= 1
            ) {
                return;
            }

            const selectId = "style-selector-" + item.id;
            const select = container.querySelector("#" + selectId);

            if (!select) {
                return;
            }

            const self = this;

            select.addEventListener("change", function () {
                const styleId = this.value;
                const layerId = this.getAttribute("data-layer-id");

                // Enregistrer le style actuel
                self.setCurrentStyle(layerId, styleId);

                // Appliquer le style à la couche
                self.applyStyle(layerId, styleId);
            });
        },

        /**
         * Applique un style à une couche
         * Utilise le style-loader pour charger, valider et appliquer le style
         * @param {string} layerId - Identifiant de la couche
         * @param {string} styleId - Identifiant du style
         */
        applyStyle: async function (layerId, styleId) {
            if (!GeoJSONCore) {
                // ...log supprimé ([StyleSelector] Module GeoJSON non disponible)...
                return;
            }

            // Récupérer les données de la couche
            const layerData = GeoJSONCore.getLayerData(layerId);

            if (!layerData) {
                // ...log supprimé ([StyleSelector] Couche non trouvée)...
                return;
            }

            if (!layerData.config.styles || !Array.isArray(layerData.config.styles.available)) {
                // ...log supprimé ([StyleSelector] Aucun style disponible pour la couche)...
                return;
            }

            // Trouver la configuration du style
            const styleConfig = layerData.config.styles.available.find(function (s) {
                return s.id === styleId;
            });

            if (!styleConfig) {
                // ...log supprimé ([StyleSelector] Style non trouvé)...
                return;
            }

            // ...log supprimé ([StyleSelector] Application du style)...

            try {
                // Vérifier que le style-loader est disponible
                if (!StyleLoader) {
                    // ...log supprimé ([StyleSelector] GeoLeaf._StyleLoader non disponible)...
                    // Fallback vers ancien système si nécessaire
                    this._applyStyleLegacy(layerId, styleId, layerData, styleConfig);
                    return;
                }

                // Récupérer les métadonnées nécessaires
                const profileId = layerData.config._profileId;
                const layerDirectory = layerData.config._layerDirectory;

                if (!profileId || !layerDirectory) {
                    // ...log supprimé ([StyleSelector] Métadonnées manquantes)...
                    return;
                }

                // Charger et valider le style avec le style-loader
                // ...log supprimé ([StyleSelector] Chargement du style via style-loader)...

                const result = await StyleLoader.loadAndValidateStyle(
                    profileId,
                    layerId,
                    styleId,
                    styleConfig.file,
                    layerDirectory
                );

                // ...log supprimé ([StyleSelector] Style chargé et validé)...

                // Stocker le style actuel dans layerData pour que les labels puissent y accéder
                layerData.currentStyle = result.styleData;
                layerData.currentStyleMetadata = result.metadata;

                // Appliquer le style via GeoJSONCore
                if (typeof GeoJSONCore.setLayerStyle === "function") {
                    GeoJSONCore.setLayerStyle(layerId, result.styleData);
                    // ...log supprimé ([StyleSelector] Style appliqué avec succès)...
                }

                // Réinitialiser les labels selon le nouveau style et visibleByDefault
                if (Labels && typeof Labels.initializeLayerLabels === "function") {
                    Labels.initializeLayerLabels(layerId);
                }

                // Mettre à jour l'état du bouton des labels selon le nouveau style
                // Utiliser syncImmediate car currentStyle vient d'être mis à jour
                if (LabelButtonManager) {
                    // ...log supprimé ([StyleSelector] Synchronisation du bouton label)...
                    LabelButtonManager.syncImmediate(layerId);
                }

                // Charger la légende correspondante
                if (LegendContract.isAvailable()) {
                    LegendContract.loadLayerLegend(layerData.config.id, styleId, layerData.config);
                }
            } catch (error) {
                // ...log supprimé ([StyleSelector] Erreur lors du chargement/application du style)...
                // ...log supprimé ([StyleSelector] Stack trace)...
            }
        },

        /**
         * Méthode legacy de chargement de style — fallback quand _StyleLoader est absent.
         * Utilisée uniquement par applyStyle() quand GeoLeaf._StyleLoader n'est pas disponible.
         * @private
         * @see applyStyle
         * TODO(C13): Retirer quand _StyleLoader sera toujours disponible (après lazy-load garanti)
         */
        _applyStyleLegacy: function (layerId, styleId, layerData, styleConfig) {
            // ...log supprimé ([StyleSelector] Utilisation de la méthode legacy)...

            const profileId = layerData.config._profileId;
            const layerDirectory = layerData.config._layerDirectory;

            if (!profileId || !layerDirectory) {
                // ...log supprimé ([StyleSelector] Métadonnées manquantes)...
                return;
            }

            const dataCfg = Config.get ? Config.get("data") : null;
            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";

            const styleDirectory = layerData.config.styles.directory || "styles";
            const stylePath =
                profilesBasePath +
                "/" +
                profileId +
                "/" +
                layerDirectory +
                "/" +
                styleDirectory +
                "/" +
                styleConfig.file;

            // ...log supprimé ([StyleSelector] Chargement du fichier de style (legacy))...

            fetch(stylePath)
                .then(function (response) {
                    if (!response.ok) {
                        throw new Error("Erreur HTTP " + response.status);
                    }
                    return response.json();
                })
                .then(function (styleData) {
                    if (typeof GeoJSONCore.setLayerStyle === "function") {
                        GeoJSONCore.setLayerStyle(layerId, styleData);
                        // ...log supprimé ([StyleSelector] Style appliqué avec succès (legacy))...
                    }

                    if (LegendContract.isAvailable()) {
                        LegendContract.loadLayerLegend(layerData.config.id, styleId, layerData.config);
                    }
                })
                .catch(function (_error) {
                    // ...log supprimé ([StyleSelector] Erreur lors du chargement du style (legacy))...
                });
        },
    };

    const StyleSelector = _LayerManagerStyleSelector;

    /**
     * GeoLeaf LayerManager API (assemblage namespace LayerManager)
     * @module layer-manager/layer-manager-api
     */
    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    const _g$g =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$g.GeoLeaf = _g$g.GeoLeaf || {};

    /**
     * Namespace global GeoLeaf
     */

    /**
     * Logger unifié
     */

    /**
     * Module GeoLeaf.LayerManager (REFACTORISÉ v3.0)
     *
     * ARCHITECTURE MODULAIRE :
     * - layer-manager/shared.js : État partagé
     * - layer-manager/control.js : Contrôle Leaflet (L.Control)
     * - layer-manager/renderer.js : Rendu des sections et items
     * - layer-manager/basemap-selector.js : Sélecteur de fonds de carte
     * - layer-manager/theme-selector.js : Sélecteur de thèmes
     * - geoleaf.layer-manager.js (ce fichier) : Agrégateur/façade publique
     *
     * DÉPENDANCES REQUISES (chargées avant ce module) :
     * - layer-manager/shared.js → GeoLeaf._LayerManagerShared
     * - layer-manager/renderer.js → GeoLeaf._LayerManagerRenderer
     * - layer-manager/basemap-selector.js → GeoLeaf._LayerManagerBasemapSelector
     * - layer-manager/theme-selector.js → GeoLeaf._LayerManagerThemeSelector
     * - layer-manager/control.js → GeoLeaf._LayerManagerControl
     *
     * Rôle :
     * - Créer un contrôle Leaflet de gestionnaire de couches pour GeoLeaf
     * - Afficher des sections structurées (basemaps, couches, catégories)
     * - Gérer un mode repliable (collapsible)
     * - Préparation pour l'intégration avec le module Legend (Phase 6)
     */
    const LayerManagerModule = {
        /**
         * Référence à la carte Leaflet
         * @type {L.Map|null}
         * @private
         */
        _map: null,

        /**
         * Référence au contrôle Leaflet de légende
         * @type {L.Control|null}
         * @private
         */
        _control: null,

        /**
         * Timeout pour le debounce du refresh
         * @type {number|null}
         * @private
         */
        _refreshTimeout: null,

        /**
         * Options internes du module
         * @type {Object}
         * @private
         */
        _options: {
            position: "bottomright",
            title: "Gestionnaire de couches",
            collapsible: true,
            collapsed: false,
            sections: [],
        },

        /**
         * Initialisation du module LayerManager
         *
         * @param {Object} options
         * @param {L.Map} [options.map] - Carte Leaflet (si absent, tentative via GeoLeaf.Core.getMap())
         * @param {string} [options.position]
         * @param {string} [options.title]
         * @param {boolean} [options.collapsible]
         * @param {boolean} [options.collapsed]
         * @param {Array} [options.sections]
         * @returns {L.Control|null} - Le contrôle LayerManager ou null
         */
        init(options = {}) {
            if (typeof _g$g.L === "undefined" || !_g$g.L || !_g$g.L.Control) {
                if (Log)
                    Log.error(
                        "[GeoLeaf.LayerManager] Leaflet (L.Control) est requis mais introuvable."
                    );
                return null;
            }

            let map = options.map || null;

            // Tentative de récupération via GeoLeaf.Core
            if (!map && _g$g.GeoLeaf.Core && typeof _g$g.GeoLeaf.Core.getMap === "function") {
                map = _g$g.GeoLeaf.Core.getMap();
            }

            if (!map) {
                if (Log)
                    Log.error(
                        "[GeoLeaf.LayerManager] Aucune carte Leaflet disponible. Passe une instance dans init({ map })."
                    );
                return null;
            }

            this._map = map;
            if (Log) Log.info("[GeoLeaf.LayerManager] init: map assigned");

            this._options = this._mergeOptions(this._options, options);

            // Charger les sections depuis layerManagerConfig si disponibles
            this._loadConfigSections();

            // Remplir automatiquement la section basemap
            this._autoPopulateBasemap();

            // Autoremplissage minimal si aucune section
            this._autoPopulateSections();

            // Créer le contrôle Leaflet via le sous-module
            if (!_g$g.GeoLeaf._LayerManagerControl) {
                if (Log) Log.error("[GeoLeaf.LayerManager] Module _LayerManagerControl non chargé");
                return null;
            }

            this._control = _g$g.GeoLeaf._LayerManagerControl.create(this._options);

            if (!this._control) {
                if (Log) Log.error("[GeoLeaf.LayerManager] Échec création contrôle");
                return null;
            }

            this._control.addTo(this._map);

            if (Log) Log.info("[GeoLeaf.LayerManager] Contrôle créé et ajouté à la carte");
            return this._control;
        },

        /**
         * Charge les sections depuis la configuration
         * @private
         */
        _loadConfigSections() {
            if (_g$g.GeoLeaf.Config && typeof _g$g.GeoLeaf.Config.get === "function") {
                const layerManagerConfig = _g$g.GeoLeaf.Config.get("layerManagerConfig");
                if (_g$g.GeoLeaf.Log)
                    _g$g.GeoLeaf.Log.debug("[LayerManager] Configuration chargée:", {
                        title: layerManagerConfig?.title,
                        collapsed: layerManagerConfig?.collapsedByDefault,
                        sectionsCount: layerManagerConfig?.sections?.length || 0,
                    });
                if (layerManagerConfig) {
                    if (layerManagerConfig.title) {
                        this._options.title = layerManagerConfig.title;
                    }

                    // Paramètre global collapsed/collapsedByDefault
                    if (typeof layerManagerConfig.collapsedByDefault === "boolean") {
                        this._options.collapsed = layerManagerConfig.collapsedByDefault;
                    }

                    if (
                        Array.isArray(layerManagerConfig.sections) &&
                        layerManagerConfig.sections.length > 0
                    ) {
                        const configSections = layerManagerConfig.sections
                            .slice()
                            .sort((a, b) => (a.order || 0) - (b.order || 0))
                            .map((s) => ({
                                id: s.id,
                                label: s.label,
                                order: s.order,
                                collapsedByDefault: s.collapsedByDefault,
                                items: [],
                            }));

                        if (!Array.isArray(this._options.sections)) {
                            this._options.sections = [];
                        }

                        configSections.forEach((configSection) => {
                            const existingSection = this._options.sections.find(
                                (s) => s.id === configSection.id
                            );
                            if (!existingSection) {
                                this._options.sections.push(configSection);
                            } else if (configSection.label && !existingSection.label) {
                                existingSection.label = configSection.label;
                            }
                        });

                        this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));

                        if (Log)
                            Log.info(
                                "[GeoLeaf.LayerManager] Sections fusionnées avec layerManagerConfig"
                            );
                    }
                }
            }
        },

        /**
         * Remplit automatiquement la section basemap
         * @private
         */
        _autoPopulateBasemap() {
            if (!Array.isArray(this._options.sections)) return;

            const basemapSection = this._options.sections.find((s) => s.id === "basemap");
            if (basemapSection && (!basemapSection.items || basemapSection.items.length === 0)) {
                try {
                    let basemapDefs = null;
                    if (
                        _g$g.GeoLeaf &&
                        _g$g.GeoLeaf.Baselayers &&
                        typeof _g$g.GeoLeaf.Baselayers.getBaseLayers === "function"
                    ) {
                        basemapDefs = _g$g.GeoLeaf.Baselayers.getBaseLayers() || {};
                    } else if (_g$g.GeoLeaf.Config && typeof _g$g.GeoLeaf.Config.get === "function") {
                        basemapDefs = _g$g.GeoLeaf.Config.get("basemaps") || {};
                    }

                    if (basemapDefs && Object.keys(basemapDefs).length > 0) {
                        basemapSection.items = Object.keys(basemapDefs).map((k) => {
                            const d = basemapDefs[k] || {};
                            return { id: d.id || k, label: d.label || k };
                        });
                        if (Log)
                            Log.info("[GeoLeaf.LayerManager] Section basemap remplie automatiquement");
                    }
                } catch (e) {
                    if (Log)
                        Log.warn(
                            "[GeoLeaf.LayerManager] Erreur lors du remplissage automatique des basemaps:",
                            e
                        );
                }
            }
        },

        /**
         * Autoremplissage minimal des sections
         * @private
         */
        _autoPopulateSections() {
            if (Array.isArray(this._options.sections) && this._options.sections.length > 0) return;

            const autoSections = [];
            try {
                if (
                    _g$g.GeoLeaf &&
                    _g$g.GeoLeaf.Baselayers &&
                    typeof _g$g.GeoLeaf.Baselayers.getBaseLayers === "function"
                ) {
                    const defs = _g$g.GeoLeaf.Baselayers.getBaseLayers() || {};
                    const baseItems = Object.keys(defs).map((k) => {
                        const d = defs[k] || {};
                        return { id: k, label: d.label || k };
                    });
                    if (baseItems.length) {
                        autoSections.push({ id: "basemap", label: "Fond de carte", items: baseItems });
                    }
                }
            } catch (e) {
                // ignore
            }

            if (autoSections.length) {
                this._options.sections = autoSections;
                if (Log) Log.info("[GeoLeaf.LayerManager] auto-populated sections from Baselayers");
            } else {
                if (Log)
                    Log.warn(
                        "[GeoLeaf.LayerManager] Aucune section fournie et autoremplissage impossible."
                    );
            }
        },

        /**
         * Enregistre une couche GeoJSON dans la légende
         * @param {string} layerId - ID de la couche
         * @param {Object} options - Options de la couche
         */
        _registerGeoJsonLayer(layerId, options = {}) {
            // ...log supprimé ([LayerManager] _registerGeoJsonLayer appelé pour)...

            if (!this._options.sections) {
                this._options.sections = [];
            }

            // Utiliser layerManagerId ou legendSection (rétrocompatibilité)
            const sectionId = options.layerManagerId || options.legendSection || "geojson-default";
            let section = this._options.sections.find((s) => s.id === sectionId);

            if (!section) {
                section = {
                    id: sectionId,
                    label: options.legendSectionLabel || "Couches GeoJSON",
                    order: 10,
                    items: [],
                };
                this._options.sections.push(section);
                this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));
            }

            const existingItem = section.items.find((item) => item.id === layerId);
            if (!existingItem) {
                section.items.push({
                    id: layerId,
                    label: options.label || layerId,
                    toggleable: true,
                    themes: options.themes || null,
                    styles: options.styles || null,
                    labels: options.labels || null,
                });

                this._updateContent();
                if (Log)
                    Log.debug(
                        `[LayerManager] Couche "${layerId}" enregistrée dans section "${sectionId}"`
                    );
            }
        },

        /**
         * Désenregistre une couche GeoJSON de la légende
         * @param {string} layerId - ID de la couche
         */
        _unregisterGeoJsonLayer(layerId) {
            if (!Array.isArray(this._options.sections)) return;

            this._options.sections.forEach((section) => {
                if (Array.isArray(section.items)) {
                    section.items = section.items.filter((item) => item.id !== layerId);
                }
            });

            this._options.sections = this._options.sections.filter(
                (section) =>
                    section.id === "basemap" ||
                    (Array.isArray(section.items) && section.items.length > 0)
            );

            this._updateContent();
            if (Log) Log.debug(`[LayerManager] Couche "${layerId}" désenregistrée`);
        },

        /**
         * Met à jour les sections de la légende
         * @param {Array} sections - Nouvelles sections
         */
        updateSections(sections) {
            if (!Array.isArray(sections)) {
                if (Log)
                    Log.warn("[GeoLeaf.LayerManager] updateSections: sections doit être un tableau");
                return;
            }
            this._options.sections = sections;
            this._updateContent();
        },

        /**
         * Ajoute ou met à jour une section dans la légende
         * @param {Object} section - Section à ajouter {id, label, order, items}
         */
        addSection(section) {
            if (!section || !section.id) {
                if (Log) Log.warn("[GeoLeaf.LayerManager] addSection: section invalide (id manquant)");
                return;
            }

            if (!Array.isArray(this._options.sections)) {
                this._options.sections = [];
            }

            // Chercher une section existante avec le même id
            const existingIndex = this._options.sections.findIndex((s) => s.id === section.id);

            if (existingIndex !== -1) {
                // Fusionner avec la section existante
                const existing = this._options.sections[existingIndex];

                // Fusionner les items
                if (Array.isArray(section.items)) {
                    if (!Array.isArray(existing.items)) {
                        existing.items = [];
                    }

                    section.items.forEach((newItem) => {
                        const existingItemIndex = existing.items.findIndex((i) => i.id === newItem.id);
                        if (existingItemIndex !== -1) {
                            // Mettre à jour l'item existant
                            existing.items[existingItemIndex] = Object.assign(
                                {},
                                existing.items[existingItemIndex],
                                newItem
                            );
                        } else {
                            // Ajouter le nouvel item
                            existing.items.push(newItem);
                        }
                    });

                    // Trier les items par order
                    existing.items.sort((a, b) => (a.order || 0) - (b.order || 0));
                }

                // Mettre à jour les autres propriétés si fournies
                if (section.label) existing.label = section.label;
                if (section.order !== undefined) existing.order = section.order;
                if (section.collapsedByDefault !== undefined)
                    existing.collapsedByDefault = section.collapsedByDefault;
            } else {
                // Ajouter la nouvelle section
                this._options.sections.push({
                    id: section.id,
                    label: section.label || section.id,
                    order: section.order || 99,
                    collapsedByDefault: section.collapsedByDefault || false,
                    items: section.items || [],
                });

                // Trier les sections par order
                this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));
            }

            this._updateContent();
            if (Log) Log.debug(`[LayerManager] Section "${section.id}" ajoutée/mise à jour`);
        },

        /**
         * Bascule l'état replié/déplié de la légende
         */
        toggleCollapse() {
            this._options.collapsed = !this._options.collapsed;
            if (!this._control) return;
            if (this._options.collapsed) {
                this._control._container.classList.add("gl-layer-manager--collapsed");
            } else {
                this._control._container.classList.remove("gl-layer-manager--collapsed");
            }
        },

        /**
         * Indique si la légende est repliée
         * @returns {boolean}
         */
        isCollapsed() {
            return !!this._options.collapsed;
        },

        /**
         * Force le re-rendu du contenu
         * @private
         */
        _updateContent() {
            if (!this._control || typeof this._control.updateSections !== "function") {
                return;
            }
            this._control.updateSections(this._options.sections || []);
        },

        /**
         * Rafraîchit l'affichage du LayerManager
         * Utilisé notamment après l'application d'un thème pour mettre à jour l'état des boutons toggle
         * Version debounced pour grouper les appels multiples (ex: plusieurs couches changent de visibilité au zoom)
         * @public
         * @param {boolean} [immediate=false] - Si true, force le refresh immédiat sans debounce
         */
        refresh(immediate = false) {
            if (!this._control || typeof this._control.refresh !== "function") {
                if (Log)
                    Log.warn(
                        "[LayerManager] refresh(): contrôle non disponible ou méthode refresh manquante"
                    );
                return;
            }

            // Si refresh immédiat demandé, annuler le debounce et exécuter
            if (immediate) {
                if (this._refreshTimeout) {
                    clearTimeout(this._refreshTimeout);
                    this._refreshTimeout = null;
                }
                this._control.refresh();
                if (Log) Log.debug("[LayerManager] Affichage rafraîchi (immédiat)");
                return;
            }

            // Debounce: annuler le timeout précédent et programmer un nouveau refresh
            if (this._refreshTimeout) {
                clearTimeout(this._refreshTimeout);
            }

            this._refreshTimeout = setTimeout(() => {
                this._refreshTimeout = null;
                this._control.refresh();
                if (Log) Log.debug("[LayerManager] Affichage rafraîchi (debounced)");
            }, 250);
        },

        /**
         * Fusion d'options (shallow + fusion légère pour sous-objets)
         * @param {Object} base
         * @param {Object} override
         * @returns {Object}
         * @private
         */
        _mergeOptions(base, override) {
            const result = Object.assign({}, base || {});
            if (!override) return result;

            Object.keys(override).forEach((key) => {
                const value = override[key];

                if (
                    value &&
                    typeof value === "object" &&
                    !Array.isArray(value) &&
                    base &&
                    typeof base[key] === "object" &&
                    !Array.isArray(base[key])
                ) {
                    result[key] = Object.assign({}, base[key], value);
                } else {
                    result[key] = value;
                }
            });

            return result;
        },
    };

    const LayerManager = LayerManagerModule;

    /**
     * GeoLeaf Theme Applier - Core
     * Module state, init/cleanup, applyTheme orchestration, getCurrentThemeId
     *
     * @module themes/theme-applier/core
     */

    /**
     * Module Theme Applier
     * @namespace _ThemeApplier
     * @private
     */
    const _ThemeApplier = {
        /** @type {string|null} Thème actuellement actif */
        _currentThemeId: null,

        /** @type {boolean} Flag pour savoir si c'est le premier chargement */
        _isFirstLoad: true,

        /**
         * Initialise le ThemeApplier
         * @private
         */
        _init() {
            this._pendingLayerConfigs = new Map();
            this._pendingCheckTimer = null;
        },

        /**
         * Nettoie les ressources
         * @private
         */
        _cleanup() {
            if (this._pendingCheckTimer) {
                clearTimeout(this._pendingCheckTimer);
                this._pendingCheckTimer = null;
            }
            if (this._pendingLayerConfigs) {
                this._pendingLayerConfigs.clear();
            }
        },

        /**
         * Applique un thème
         * @param {Object} theme - Configuration du thème
         * @param {Object} [options] - Options d'application
         * @param {boolean} [options.fitBounds] - Force le fitBounds
         * @returns {Promise<void>}
         */
        applyTheme(theme, options = {}) {
            // Initialiser si nécessaire
            if (!this._pendingLayerConfigs) {
                this._init();
            }

            if (Legend && typeof Legend.showLoadingOverlay === "function") {
                Legend.showLoadingOverlay();
            }

            if (!theme || !theme.id) {
                return Promise.reject(new Error("Thème invalide"));
            }

            // Vérifier les dépendances
            if (!GeoJSONCore || !LayerManager) {
                return Promise.reject(new Error("Modules GeoJSON ou LayerManager non disponibles"));
            }

            // Notifier le début du chargement du thème
            try {
                document.dispatchEvent(new CustomEvent('geoleaf:theme:applying', {
                    detail: {
                        themeId: theme.id,
                        themeName: theme.name || theme.label || theme.id
                    }
                }));
            } catch (e) { /* silencieux */ }

            // Désactiver toutes les couches d'abord
            this._hideAllLayers();

            // Appliquer les couches du thème avec chargement optimisé par lots
            const layerConfigs = theme.layers || [];

            // Récupérer la configuration de performance depuis le profil
            const profileConfig = Config?.Profile?.getActiveProfileConfig();
            const perfConfig = profileConfig?.performance || {};
            // fitBounds désactivé : le positionnement se fait via map.bounds du profil
            const enableFitBounds = false;

            // Séparer les couches visibles et invisibles
            const visibleLayers = layerConfigs.filter(config => config.visible !== false);

            // Charger d'abord les couches visibles par lots
            const BATCH_SIZE = perfConfig.themeBatchSize || 3;

            // Helper progression pour l'écran de chargement (97→99)
            const updateProgress = (p) => {
                try {
                    if (typeof window !== 'undefined' && window._glLoadingScreen && typeof window._glLoadingScreen.updateProgress === 'function') {
                        window._glLoadingScreen.updateProgress(p);
                    }
                } catch (e) { /* ignore */ }
            };

            const loadInBatches = async (layers) => {
                for (let i = 0; i < layers.length; i += BATCH_SIZE) {
                    const batch = layers.slice(i, i + BATCH_SIZE);
                    await Promise.all(batch.map(layerConfig => this._applyLayerConfig(layerConfig)));

                    if (i === 0) {
                        updateProgress(98);
                    }
                }
            };

            const self = this;

            return loadInBatches(visibleLayers)
                .then(() => {
                    updateProgress(98);
                    return Promise.resolve();
                })
                .then(() => {
                    updateProgress(99);
                    self._currentThemeId = theme.id;

                    // Rafraîchir le LayerManager
                    if (LayerManager && LayerManager.refresh) {
                        LayerManager.refresh();
                    }

                    // Synchroniser l'état de visibilité dans la légende
                    self._syncLegendVisibility();

                    // Événement de thème appliqué
                    try {
                        const themeNotificationEvent = new CustomEvent('geoleaf:theme:applied', {
                            detail: {
                                themeId: theme.id,
                                themeName: theme.name || theme.label || theme.id,
                                layerCount: visibleLayers.length,
                                totalLayersInTheme: layerConfigs.length,
                                timestamp: new Date().toISOString()
                            }
                        });
                        document.dispatchEvent(themeNotificationEvent);
                    } catch (e) {
                        // Silencieux
                    }

                    // FitBounds selon la configuration
                    const shouldFitBounds = options.fitBounds === true ||
                                           (self._isFirstLoad && enableFitBounds);
                    if (shouldFitBounds) {
                        setTimeout(() => {
                            self._fitBoundsOnAllLayers();
                        }, 1000);
                        self._isFirstLoad = false;
                    }
                })
                .catch((err) => {
                    throw err;
                })
                .finally(() => {
                    if (Legend && typeof Legend.hideLoadingOverlay === "function") {
                        Legend.hideLoadingOverlay();
                    }
                });
        },

        /**
         * Récupère l'ID du thème actuellement actif
         * @returns {string|null}
         */
        getCurrentThemeId() {
            return this._currentThemeId;
        }
    };

    /**
     * Module Renderer pour LayerManager
     * Logique de rendu des sections et items de la légende
     *
     * DÉPENDANCES:
     * - Leaflet (L.DomUtil, L.DomEvent)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf._LayerManagerBasemapSelector (pour section basemap)
     * - GeoLeaf._LayerManagerThemeSelector (pour thèmes)
     * - GeoLeaf.Themes (pour getAvailableThemes)
     * - GeoLeaf.GeoJSON (pour setTheme)
     *
     * EXPOSE:
     * - GeoLeaf._LayerManagerRenderer
     */

    /**
     * Module Renderer pour LayerManager
     * @namespace _LayerManagerRenderer
     * @private
     */
    const _LayerManagerRenderer = {
        /**
         * Rend les sections de la légende
         * @param {HTMLElement} bodyEl - Élément body de la légende
         * @param {Array} sections - Liste des sections à rendre
         */
        renderSections(bodyEl, sections) {
            if (!bodyEl) {
                return;
            }

            // Clear content sans innerHTML
            DOMSecurity.clearElementFast(bodyEl);

            if (!Array.isArray(sections) || sections.length === 0) {
                const emptyEl = globalThis.L.DomUtil.create("div", "gl-layer-manager__empty", bodyEl);
                emptyEl.textContent = "Aucune couche \u00e0 afficher.";
                return;
            }

            // Filtrer les sections legacy "poi" et "route" (obsolètes)
            const filteredSections = sections.filter((s) => s.id !== "poi" && s.id !== "route");

            filteredSections.forEach((section) => {
                const isCollapsible = typeof section.collapsedByDefault === "boolean";
                const isCollapsed = section.collapsedByDefault === true;

                const sectionEl = globalThis.L.DomUtil.create(
                    "div",
                    isCollapsible
                        ? "gl-layer-manager__section gl-layer-manager__section--accordion"
                        : "gl-layer-manager__section",
                    bodyEl
                );

                if (isCollapsed) {
                    sectionEl.classList.add("gl-layer-manager__section--collapsed");
                }

                if (section.label) {
                    if (isCollapsible) {
                        // En-tête cliquable pour accordéon
                        const accordionHeader = globalThis.L.DomUtil.create(
                            "div",
                            "gl-layer-manager__accordion-header",
                            sectionEl
                        );

                        const sectionTitle = globalThis.L.DomUtil.create(
                            "div",
                            "gl-layer-manager__section-title",
                            accordionHeader
                        );
                        sectionTitle.textContent = section.label;

                        const accordionArrow = globalThis.L.DomUtil.create(
                            "span",
                            "gl-layer-manager__accordion-arrow",
                            accordionHeader
                        );
                        accordionArrow.textContent = "▶";

                        // Gestionnaire de clic pour l'accordéon
                        globalThis.L.DomEvent.on(accordionHeader, "click", function (ev) {
                            globalThis.L.DomEvent.stopPropagation(ev);
                            globalThis.L.DomEvent.preventDefault(ev);

                            const wasCollapsed = sectionEl.classList.contains(
                                "gl-layer-manager__section--collapsed"
                            );
                            sectionEl.classList.toggle("gl-layer-manager__section--collapsed");

                            // Mettre à jour la flèche avec animation
                            accordionArrow.textContent = wasCollapsed ? "▼" : "▶";

                            // Mettre à jour l'état dans la section
                            section._isExpanded = wasCollapsed;

                            if (Log)
                                Log.debug(
                                    "[LayerManager] Accordéon",
                                    section.id,
                                    wasCollapsed ? "ouvert" : "fermé"
                                );
                        });
                    } else {
                        // Titre simple pour section non-accordéon
                        const sectionTitle = globalThis.L.DomUtil.create(
                            "div",
                            "gl-layer-manager__section-title",
                            sectionEl
                        );
                        sectionTitle.textContent = section.label;
                    }
                }

                // Si pas d'items, garder la section visible avec son titre seulement
                if (!Array.isArray(section.items) || section.items.length === 0) {
                    return;
                }

                // Créer le corps de la section (accordéon ou simple)
                const sectionBody = isCollapsible
                    ? globalThis.L.DomUtil.create("div", "gl-layer-manager__accordion-body", sectionEl)
                    : sectionEl;

                // Section basemap : déléguer au BasemapSelector
                if (section.id === "basemap") {
                    if (BasemapSelector) {
                        BasemapSelector.render(section, sectionBody);
                    }
                } else {
                    // Autres sections : rendre les items
                    this._renderItems(section, sectionBody);
                }
            });

            // Synchroniser immédiatement les boutons de labels après re-render
            if (LabelButtonManager && GeoJSONCore) {
                const allLayers = GeoJSONCore._layers || new Map();
                allLayers.forEach((layerData, layerId) => {
                    if (layerData.currentStyle) {
                        LabelButtonManager.syncImmediate(layerId);
                    }
                });
            }
        },

        /**
         * Synchronise l'état des toggles existants sans re-générer le DOM
         * Utilisé après l'application d'un thème pour mettre à jour les toggles
         * @public
         */
        syncToggles() {
            // Trouver tous les items de couche dans le DOM
            const layerItems = document.querySelectorAll("[data-layer-id]");

            if (Log)
                Log.debug(`[LayerManager Renderer] Synchronisation de ${layerItems.length} toggles`);

            layerItems.forEach((itemEl) => {
                const layerId = itemEl.getAttribute("data-layer-id");
                if (!layerId) return;

                // Récupérer les infos de visibilité pour le log
                const layerData = GeoJSONCore?.getLayerById(layerId);
                const isVisible = this._checkLayerVisibility(layerId);

                if (Log)
                    Log.debug(`[LayerManager Renderer] Couche ${layerId}:`, {
                        isVisible,
                        hasLayerData: !!layerData,
                        hasVisibility: !!(layerData && layerData._visibility),
                        currentValue: layerData?._visibility?.current,
                        onMap: layerData?.layer
                            ? GeoJSONShared.state.map?.hasLayer(layerData.layer)
                            : false,
                    });

                // Mettre à jour la classe gl-layer--hidden
                if (isVisible) {
                    itemEl.classList.remove("gl-layer--hidden");
                } else {
                    itemEl.classList.add("gl-layer--hidden");
                }

                // Trouver et mettre à jour le toggle button
                const toggleBtn = itemEl.querySelector(".gl-layer-manager__item-toggle");
                if (toggleBtn) {
                    toggleBtn.setAttribute("aria-pressed", isVisible ? "true" : "false");

                    // Harmoniser avec createToggleButton: suffixe "--on"
                    const onClass = "gl-layer-manager__item-toggle--on";
                    if (isVisible) {
                        toggleBtn.classList.add(onClass);
                    } else {
                        toggleBtn.classList.remove(onClass);
                    }
                }
            });

            if (Log) Log.debug("[LayerManager Renderer] États des toggles synchronisés");
        },

        /**
         * Rend les items d'une section
         * @private
         */
        _renderItems(section, sectionEl) {
            const listEl = globalThis.L.DomUtil.create("div", "gl-layer-manager__items", sectionEl);

            section.items.forEach((item) => {
                const itemEl = globalThis.L.DomUtil.create("div", "gl-layer-manager__item", listEl);

                // Ajouter l'attribut data-layer-id pour faciliter la recherche DOM
                if (item.id) {
                    itemEl.setAttribute("data-layer-id", item.id);

                    // Ajouter la classe gl-layer--hidden si la couche n'est pas visible au chargement
                    const isVisible = this._checkLayerVisibility(item.id);
                    if (!isVisible) {
                        itemEl.classList.add("gl-layer--hidden");
                    }
                }

                // Conteneur de la ligne principale (toujours créé pour le layout en colonne)
                const mainRow = globalThis.L.DomUtil.create(
                    "div",
                    "gl-layer-manager__item-row",
                    itemEl
                );

                // Libellé
                const labelEl = globalThis.L.DomUtil.create("span", "gl-layer-manager__label", mainRow);
                labelEl.textContent = item.label || "";

                // Toggle d'affichage pour les couches toggleable
                if (item.toggleable && item.id) {
                    this._renderToggleControls(item, mainRow, itemEl);
                } else if (item.id) {
                    // Même pour les couches non-toggleable, créer le bouton label
                    const controlsContainer = globalThis.L.DomUtil.create(
                        "div",
                        "gl-layer-manager__item-controls",
                        mainRow
                    );

                    // Créer le bouton de label
                    if (LabelButtonManager) {
                        LabelButtonManager.createButton(item.id, controlsContainer);
                        LabelButtonManager.syncImmediate(item.id);
                    }
                } else {
                    // Valeur/info complémentaire pour items sans ID
                    if (typeof item.value !== "undefined") {
                        const valueEl = globalThis.L.DomUtil.create(
                            "span",
                            "gl-layer-manager__value",
                            itemEl
                        );
                        valueEl.textContent = String(item.value);
                    }
                }
            });
        },

        /**
         * Rend les contrôles toggle pour un item
         * @private
         */
        _renderToggleControls(item, mainRow, itemEl) {
            // Conteneur des contrôles (toggle + flèche thème)
            const controlsContainer = globalThis.L.DomUtil.create(
                "div",
                "gl-layer-manager__item-controls",
                mainRow
            );

            // Créer le bouton de label via le gestionnaire centralisé
            if (LabelButtonManager) {
                LabelButtonManager.createButton(item.id, controlsContainer);
                LabelButtonManager.syncImmediate(item.id);
            }

            // Vérifier l'état initial
            const isActive = this._checkLayerVisibility(item.id);

            const toggleBtn = _UIComponents.createToggleButton(controlsContainer, {
                isActive: isActive,
                className: "gl-layer-manager__item-toggle",
                title: "Afficher / masquer la couche",
            });

            // Attacher le gestionnaire de toggle
            this._attachToggleHandler(toggleBtn, item.id);

            // Sélecteur de styles si disponible
            if (item.styles && StyleSelector) {
                const styleElement = StyleSelector.renderDOM(item);
                if (styleElement) {
                    itemEl.appendChild(styleElement);
                    StyleSelector.bindEvents(styleElement, item);
                }
            }
        },

        /**
         * Vérifie si une couche est visible
         * @private
         */
        _checkLayerVisibility(layerId) {
            try {
                if (layerId && GeoJSONCore) {
                    const layerData = GeoJSONCore.getLayerById(layerId);

                    // IMPORTANT: Utiliser logicalState (état du bouton ON/OFF) au lieu de current (état physique sur carte)
                    // Le bouton doit refléter l'intention de l'utilisateur/thème, pas les contraintes de zoom
                    const logicalState =
                        layerData &&
                        layerData._visibility &&
                        typeof layerData._visibility.logicalState === "boolean"
                            ? layerData._visibility.logicalState
                            : layerData && layerData.visible === true;

                    const result = logicalState;

                    if (Log) {
                        Log.debug(
                            `[LayerManager Renderer] _checkLayerVisibility(${layerId}): logicalState=${logicalState}`
                        );
                    }

                    return result;
                }
            } catch (e) {
                if (Log) Log.error("[LayerManager Renderer] Erreur dans _checkLayerVisibility:", e);
            }
            return false;
        },

        /**
         * Attache le gestionnaire de toggle pour une couche
         * @private
         */
        _attachToggleHandler(toggleBtn, itemId) {
            // GUARD: Vérifier si un gestionnaire est déjà attaché
            if (toggleBtn._toggleHandlerAttached) {
                return;
            }

            // Marquer comme attaché AVANT de créer le gestionnaire
            toggleBtn._toggleHandlerAttached = true;

            const self = this;

            const onToggle = function (ev) {
                // EMPÊCHER LES MULTIPLES CLICS EN PREMIER
                if (toggleBtn._isToggling) {
                    if (Log) Log.warn("[LayerManager] ⏸️ Toggle DÉJÀ en cours, BLOQUÉ:", itemId);
                    if (globalThis.L && globalThis.L.DomEvent) {
                        globalThis.L.DomEvent.stopPropagation(ev);
                        globalThis.L.DomEvent.preventDefault(ev);
                    }
                    return; // SORTIR IMMÉDIATEMENT
                }

                // Marquer comme en cours IMMÉDIATEMENT
                toggleBtn._isToggling = true;

                // Arrêter la propagation
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.stopPropagation(ev);
                    globalThis.L.DomEvent.preventDefault(ev);
                }

                // Réinitialiser après 100ms (juste pour empêcher les double-clics rapides)
                setTimeout(() => {
                    toggleBtn._isToggling = false;
                }, 100);

                try {
                    if (itemId && GeoJSONCore) {
                        const layerData = GeoJSONCore.getLayerById(itemId);

                        // Si la couche n'est pas encore chargée, la charger à la demande
                        if (!layerData) {
                            if (Log)
                                Log.info(
                                    "[LayerManager] ⏳ Couche non chargée, chargement à la demande:",
                                    itemId
                                );

                            // Indicateur visuel de chargement
                            toggleBtn.classList.add("gl-layer-manager__item-toggle--loading");
                            toggleBtn.disabled = true;

                            if (
                                _ThemeApplier &&
                                typeof _ThemeApplier._loadLayerFromProfile === "function"
                            ) {
                                _ThemeApplier._loadLayerFromProfile(itemId)
                                    .then(function (loadedLayer) {
                                        // Retirer l'indicateur de chargement
                                        toggleBtn.classList.remove(
                                            "gl-layer-manager__item-toggle--loading"
                                        );
                                        toggleBtn.disabled = false;

                                        if (loadedLayer) {
                                            if (Log)
                                                Log.info(
                                                    "[LayerManager] ✅ Couche chargée avec succès:",
                                                    itemId
                                                );

                                            // Afficher la couche via le gestionnaire standard
                                            GeoJSONCore.showLayer(itemId);

                                            // Mettre à jour l'UI du toggle
                                            toggleBtn.setAttribute("aria-pressed", "true");
                                            toggleBtn.classList.add(
                                                "gl-layer-manager__item-toggle--on"
                                            );

                                            const layerItem = document.querySelector(
                                                '[data-layer-id="' + itemId + '"]'
                                            );
                                            if (layerItem) {
                                                layerItem.classList.remove("gl-layer--hidden");
                                            }

                                            // Réactiver le bouton label si applicable
                                            let labelBtn = null;
                                            if (layerItem) {
                                                labelBtn = layerItem.querySelector(
                                                    ".gl-layer-manager__label-toggle"
                                                );
                                            }
                                            if (!labelBtn && toggleBtn.parentElement) {
                                                labelBtn = toggleBtn.parentElement.querySelector(
                                                    ".gl-layer-manager__label-toggle"
                                                );
                                            }
                                            if (labelBtn) {
                                                const ld = GeoJSONCore?.getLayerById?.(itemId);
                                                const labelEnabled =
                                                    ld?.currentStyle?.label?.enabled === true;
                                                if (labelEnabled) {
                                                    labelBtn.disabled = false;
                                                    labelBtn.classList.remove(
                                                        "gl-layer-manager__label-toggle--disabled"
                                                    );
                                                }
                                            }
                                        } else {
                                            if (Log)
                                                Log.warn(
                                                    "[LayerManager] ❌ Échec du chargement de la couche:",
                                                    itemId
                                                );
                                        }
                                    })
                                    .catch(function (err) {
                                        toggleBtn.classList.remove(
                                            "gl-layer-manager__item-toggle--loading"
                                        );
                                        toggleBtn.disabled = false;
                                        if (Log)
                                            Log.error(
                                                "[LayerManager] Erreur lors du chargement de la couche:",
                                                itemId,
                                                err
                                            );
                                    });
                            } else {
                                toggleBtn.classList.remove("gl-layer-manager__item-toggle--loading");
                                toggleBtn.disabled = false;
                                if (Log)
                                    Log.warn(
                                        "[LayerManager] ThemeApplierCore non disponible pour charger:",
                                        itemId
                                    );
                            }
                            return;
                        }

                        const isCurrentlyVisible = self._checkLayerVisibility(itemId);

                        // Trouver le layerItem pour ajouter/retirer la classe CSS
                        const layerItem = document.querySelector(`[data-layer-id="${itemId}"]`);

                        if (isCurrentlyVisible) {
                            // Masquer la couche
                            GeoJSONCore.hideLayer(itemId);
                            toggleBtn.setAttribute("aria-pressed", "false");
                            toggleBtn.classList.remove("gl-layer-manager__item-toggle--on");

                            // Ajouter la classe gl-layer--hidden
                            if (layerItem) {
                                layerItem.classList.add("gl-layer--hidden");
                            }

                            // Désactiver immédiatement le bouton label (couche cachée)
                            // Chercher dans tout le layerItem, pas juste les enfants directs
                            let labelBtn = null;
                            if (layerItem) {
                                labelBtn = layerItem.querySelector(".gl-layer-manager__label-toggle");
                            }
                            // Fallback: chercher via le sibling du toggle button (même container)
                            if (!labelBtn && toggleBtn.parentElement) {
                                labelBtn = toggleBtn.parentElement.querySelector(
                                    ".gl-layer-manager__label-toggle"
                                );
                            }
                            if (labelBtn) {
                                labelBtn.disabled = true;
                                labelBtn.classList.add("gl-layer-manager__label-toggle--disabled");
                                labelBtn.classList.remove("gl-layer-manager__label-toggle--on");
                                labelBtn.setAttribute("aria-pressed", "false");
                            } else {
                                if (Log)
                                    Log.warn(
                                        "[LayerManager] Bouton label NON TROUVÉ pour désactivation:",
                                        itemId
                                    );
                            }
                        } else {
                            // Afficher la couche
                            GeoJSONCore.showLayer(itemId);
                            toggleBtn.setAttribute("aria-pressed", "true");
                            toggleBtn.classList.add("gl-layer-manager__item-toggle--on");

                            // Retirer la classe gl-layer--hidden
                            if (layerItem) {
                                layerItem.classList.remove("gl-layer--hidden");
                            }

                            // Réactiver le bouton label
                            let labelBtn = null;
                            if (layerItem) {
                                labelBtn = layerItem.querySelector(".gl-layer-manager__label-toggle");
                            }
                            if (!labelBtn && toggleBtn.parentElement) {
                                labelBtn = toggleBtn.parentElement.querySelector(
                                    ".gl-layer-manager__label-toggle"
                                );
                            }
                            if (labelBtn) {
                                // Vérifier si label.enabled dans le style avant de réactiver
                                const ld = GeoJSONCore?.getLayerById?.(itemId);
                                const labelEnabled = ld?.currentStyle?.label?.enabled === true;
                                if (labelEnabled) {
                                    labelBtn.disabled = false;
                                    labelBtn.classList.remove(
                                        "gl-layer-manager__label-toggle--disabled"
                                    );
                                }
                            }
                        }
                    }
                } catch (err) {
                    if (Log) Log.warn("Erreur toggle légende :", err);
                }
            };

            // TEMPORAIREMENT: utiliser uniquement L.DomEvent pour déboguer
            if (globalThis.L && globalThis.L.DomEvent) {
                globalThis.L.DomEvent.on(toggleBtn, "click", onToggle);
                globalThis.L.DomEvent.disableClickPropagation(toggleBtn);
            } else {
                toggleBtn.addEventListener("click", onToggle);
            }
        },

        /**
         * Fallback pour créer un toggle button si _UIComponents non disponible
         * @private
         */
        _createToggleFallback(container, isActive) {
            const toggleBtn = globalThis.L.DomUtil.create(
                "button",
                "gl-layer-manager__item-toggle",
                container
            );
            toggleBtn.type = "button";
            toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");
            toggleBtn.title = "Afficher / masquer la couche";
            if (isActive) {
                toggleBtn.classList.add("gl-layer-manager__item-toggle--on");
            }
            return toggleBtn;
        },

        /**
         * Crée le bouton de labels pour une couche (appelé lors de l'application d'un style)
         * @param {string} layerId - ID de la couche
         */
    };

    const LMRenderer = _LayerManagerRenderer;

    /**
     * Module Control pour LayerManager
     * Définition du contrôle Leaflet personnalisé
     *
     * DÉPENDANCES:
     * - Leaflet (L.Control, L.DomUtil, L.DomEvent, L.setOptions)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf._LayerManagerRenderer (pour renderSections)
     *
     * EXPOSE:
     * - GeoLeaf._LayerManagerControl
     */


    /**
     * Crée un contrôle Leaflet pour le gestionnaire de couches
     * @param {Object} options - Options du contrôle
     * @returns {L.Control} - Instance du contrôle Leaflet
     */
    function createLayerManagerControl(options) {
        if (!globalThis.L || !globalThis.L.Control) {
            if (Log) Log.error("[LayerManager] Leaflet L.Control non disponible");
            return null;
        }

        const LayerManagerControl = globalThis.L.Control.extend({
            options: {
                position: options.position || "bottomright"
            },

            initialize: function (controlOptions) {
                globalThis.L.setOptions(this, controlOptions || {});
                this._glOptions = controlOptions._glOptions;
            },


            onAdd: function (mapInstance) {
                this._map = mapInstance;
                this._container = globalThis.L.DomUtil.create("div", "gl-layer-manager");

                // Empêcher les interactions carte
                if (globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.disableClickPropagation(this._container);
                    globalThis.L.DomEvent.disableScrollPropagation(this._container);
                }

                this._buildStructure();
                return this._container;
            },

            onRemove: function () {
                this._map = null;
                this._container = null;
            },

            /**
             * Construit la structure DOM de la légende
             * @private
             */
            _buildStructure: function () {
                const opts = this._glOptions;

                // Conteneur principal (flex container)
                const mainWrapper = globalThis.L.DomUtil.create("div", "gl-layer-manager__main-wrapper", this._container);

                // Wrapper du header (reste fixe)
                const headerWrapper = globalThis.L.DomUtil.create("div", "gl-layer-manager__header-wrapper", mainWrapper);

                // En-tête : titre + bouton collapse
                const header = globalThis.L.DomUtil.create("div", "gl-layer-manager__header", headerWrapper);

                const titleEl = globalThis.L.DomUtil.create(
                    "div",
                    "gl-layer-manager__title",
                    header
                );
                titleEl.textContent = opts.title || "Légende";

                let toggleEl = null;
                if (opts.collapsible) {
                    toggleEl = globalThis.L.DomUtil.create(
                        "button",
                        "gl-layer-manager__toggle",
                        header
                    );
                    toggleEl.type = "button";
                    toggleEl.setAttribute("aria-label", "Basculer la légende");
                    toggleEl.textContent = "⟱";

                    const self = this;
                    globalThis.L.DomEvent.on(toggleEl, "click", function (ev) {
                        globalThis.L.DomEvent.stopPropagation(ev);
                        self._toggleCollapsed();
                    });
                }

                // Wrapper du body avec scrollbar
                const bodyWrapper = globalThis.L.DomUtil.create("div", "gl-layer-manager__body-wrapper", mainWrapper);

                // Corps de la légende
                this._bodyEl = globalThis.L.DomUtil.create(
                    "div",
                    "gl-layer-manager__body",
                    bodyWrapper
                );

                // Appliquer l'état collapsed initial (depuis options ou collapsedByDefault)
                const initialCollapsed = opts.collapsed || opts.collapsedByDefault || false;
                if (initialCollapsed) {
                    this._container.classList.add("gl-layer-manager--collapsed");
                    opts.collapsed = true; // Synchroniser l'état
                }

                // Rendu des sections via le renderer
                this._renderSections(opts.sections || []);
            },

            /**
             * Rend les sections (délègue au renderer)
             * @private
             */
            _renderSections: function (sections) {
                if (LMRenderer) {
                    LMRenderer.renderSections(this._bodyEl, sections);
                } else {
                    if (Log) Log.error("[LayerManager] _LayerManagerRenderer non disponible");
                }
            },

            /**
             * Mise à jour des sections
             * @param {Array} sections - Nouvelles sections
             */
            updateSections: function (sections) {
                this._glOptions.sections = Array.isArray(sections) ? sections : [];
                this._renderSections(this._glOptions.sections);
            },

            /**
             * Rafraîchit l'affichage pour mettre à jour l'état des boutons toggle
             * Utilisé notamment après l'application d'un thème
             * @public
             */
            refresh: function () {
                // Synchroniser uniquement les toggles au lieu de re-générer tout le DOM
                if (LMRenderer && typeof LMRenderer.syncToggles === 'function') {
                    LMRenderer.syncToggles();
                } else if (this._glOptions && this._glOptions.sections) {
                    // Fallback: re-générer les sections si syncToggles n'est pas disponible
                    this._renderSections(this._glOptions.sections);
                }
            },

            /**
             * Bascule l'état collapsed
             * @private
             */
            _toggleCollapsed: function () {
                const isCollapsed = this._container.classList.toggle("gl-layer-manager--collapsed");
                this._glOptions.collapsed = isCollapsed;
            }
        });

        return new LayerManagerControl({
            position: options.position,
            _glOptions: options
        });
    }

    const LMControl = {
        create: createLayerManagerControl
    };

    /**
     * Module partagé pour LayerManager
     * État et utilitaires communs entre les sous-modules
     *
     * DÉPENDANCES:
     * - GeoLeaf.Log (optionnel)
     *
     * EXPOSE:
     * - GeoLeaf._LayerManagerShared
     */



    /**
     * État partagé pour LayerManager (privé interne)
     * @private
     */
    const _LayerManagerShared = {
        /**
         * Référence à la carte Leaflet
         * @type {L.Map|null}
         */
        map: null,

        /**
         * Référence au contrôle Leaflet
         * @type {L.Control|null}
         */
        control: null,

        /**
         * Options internes du module
         * @type {Object}
         */
        options: {
            position: "bottomright",
            title: "Légende",
            collapsible: true,
            collapsed: false,
            sections: []
        }
    };

    const LMShared = _LayerManagerShared;

    /**
     * GeoLeaf Theme Cache
     * Cache léger pour les couches GeoJSON utilisées par les thèmes.
     */

    /**
     * Phase 7 — Premium Separation: IndexedDB lives in GeoLeaf-Plugins/plugin-storage.
     * Access it only via GeoLeaf.Storage.DB at runtime (after the plugin is loaded).
     */
    function _getIndexedDB() {
        const g = typeof globalThis !== "undefined" ? globalThis : window;
        return g?.GeoLeaf?.Storage?.DB ?? null;
    }

    const MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 jours

    const ThemeCache = {
        _config: {
            enabled: true,
            maxAge: MAX_AGE_MS,
        },

        /**
         * Récupère une couche depuis le cache si elle est encore valide.
         * @param {string} layerId
         * @param {string} [profileId]
         * @returns {Promise<Object|null>}
         */
        async get(layerId, profileId) {
            if (!this._config.enabled) {
                return null;
            }

            const StorageDB = _getIndexedDB();
            if (!StorageDB) {
                return null;
            }

            try {
                const cached = await StorageDB.getLayer(layerId);
                if (!cached) {
                    return null;
                }

                if (profileId && cached.profileId && cached.profileId !== profileId) {
                    if (Log) Log.debug(`[ThemeCache] Cache mismatch profil pour ${layerId}`);
                    return null;
                }

                const age = Date.now() - cached.timestamp;
                if (age > this._config.maxAge) {
                    if (Log) Log.debug(`[ThemeCache] Cache expiré pour ${layerId}`);
                    return null;
                }

                if (Log) Log.info(`[ThemeCache] Cache hit pour ${layerId}`);
                return cached.data;
            } catch (err) {
                if (Log)
                    Log.warn(`[ThemeCache] Lecture cache impossible pour ${layerId}: ${err.message}`);
                return null;
            }
        },

        /**
         * Stocke une couche dans le cache.
         * @param {string} layerId
         * @param {string} [profileId]
         * @param {Object} data
         * @param {Object} [metadata]
         * @returns {Promise<void>}
         */
        async store(layerId, profileId, data, metadata = {}) {
            if (!this._config.enabled) {
                return;
            }

            const StorageDB = _getIndexedDB();
            if (!StorageDB) {
                return;
            }

            try {
                await StorageDB.cacheLayer(layerId, data, profileId || null, metadata);
                if (Log) Log.debug(`[ThemeCache] Couche mise en cache: ${layerId}`);
            } catch (err) {
                if (Log) Log.warn(`[ThemeCache] Échec mise en cache ${layerId}: ${err.message}`);
            }
        },

        /**
         * Invalide une couche en cache.
         * @param {string} layerId
         * @returns {Promise<void>}
         */
        async invalidate(layerId) {
            const StorageDB = _getIndexedDB();
            if (!StorageDB) {
                return;
            }

            try {
                await StorageDB.removeLayer(layerId);
                if (Log) Log.info(`[ThemeCache] Cache invalidé pour ${layerId}`);
            } catch (err) {
                if (Log) Log.warn(`[ThemeCache] Impossible d'invalider ${layerId}: ${err.message}`);
            }
        },
    };

    /**
     * Module Theme Loader
     * Charge et met en cache le fichier themes.json
     *
     * DÉPENDANCES:
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf.Core.getActiveProfile()
     *
     * EXPOSE:
     * - GeoLeaf._ThemeLoader
     *
     * @module _ThemeLoader
     * @private
     */


    /**
     * Cache pour les configurations de thèmes
     * @type {Map<string, Object>}
     */
    const _cache = new Map();

    /**
     * Promises en cours de chargement
     * @type {Map<string, Promise>}
     */
    const _loadingPromises = new Map();

    /**
     * Module Theme Loader
     * @namespace _ThemeLoader
     * @private
     */
    const _ThemeLoader = {
        /**
         * Charge le fichier themes.json pour un profil
         * @param {string} profileId - ID du profil
         * @returns {Promise<Object>} Configuration des thèmes
         */
        loadThemesConfig(profileId) {
            if (Log) Log.debug("[ThemeLoader] loadThemesConfig appelé pour:", profileId);

            // Vérifier le cache
            if (_cache.has(profileId)) {
                if (Log) Log.debug("[ThemeLoader] Config en cache pour:", profileId);
                return Promise.resolve(_cache.get(profileId));
            }

            // Vérifier si déjà en cours de chargement
            if (_loadingPromises.has(profileId)) {
                if (Log) Log.debug("[ThemeLoader] Chargement déjà en cours pour:", profileId);
                return _loadingPromises.get(profileId);
            }

            // Construire le chemin du fichier
            // Utiliser un chemin relatif depuis la racine du projet
            // Si on est dans /demo/, on remonte avec ../
            const isInDemo = window.location.pathname.includes('/demo/');
            const basePath = isInDemo ? '../' : '';
            const themesPath = `${basePath}profiles/${profileId}/themes.json`;

            // Sprint 3.3: Unified fetch using FetchHelper with timeout and retry
            // FetchHelper: imported from utils/fetch-helper.js
            let loadPromise;

            if (FetchHelper) {
                // Use enhanced FetchHelper with timeout and retry
                loadPromise = FetchHelper.get(themesPath, {
                    timeout: 8000,
                    retries: 1,
                    parseResponse: true
                })
                .then((data) => {
                    if (Log) Log.debug("[ThemeLoader] Fichier chargé:", themesPath);

                    // Valider la structure
                    const validated = this._validateConfig(data);

                    // Mettre en cache
                    _cache.set(profileId, validated);
                    _loadingPromises.delete(profileId);

                    return validated;
                })
                .catch((err) => {
                    if (Log) Log.warn("[ThemeLoader] Erreur chargement themes.json:", err.message);
                    _loadingPromises.delete(profileId);
                    throw err;
                });
            } else {
                // Fallback to raw fetch if FetchHelper not available
                loadPromise = fetch(themesPath)
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error(`Erreur HTTP ${response.status} lors du chargement de ${themesPath}`);
                        }
                        return response.json();
                    })
                    .then((data) => {
                        if (Log) Log.debug("[ThemeLoader] Fichier chargé:", themesPath);

                        // Valider la structure
                        const validated = this._validateConfig(data);

                        // Mettre en cache
                        _cache.set(profileId, validated);
                        _loadingPromises.delete(profileId);

                        return validated;
                    })
                    .catch((err) => {
                        if (Log) Log.warn("[ThemeLoader] Erreur chargement themes.json:", err.message);
                        _loadingPromises.delete(profileId);
                        throw err;
                    });
            }

            // Stocker la promesse en cours
            _loadingPromises.set(profileId, loadPromise);

            return loadPromise;
        },

        /**
         * Valide et normalise la configuration des thèmes
         * @param {Object} config - Configuration brute
         * @returns {Object} Configuration validée
         * @private
         */
        _validateConfig(config) {
            if (!config || typeof config !== 'object') {
                throw new Error("Configuration de thèmes invalide");
            }

            // Valeurs par défaut pour config
            const validatedConfig = {
                config: {
                    primaryThemes: {
                        enabled: true,
                        position: "top-map",
                        ...(config.config?.primaryThemes || {})
                    },
                    secondaryThemes: {
                        enabled: true,
                        placeholder: "Sélectionner un thème...",
                        showNavigationButtons: true,
                        position: "top-layermanager",
                        ...(config.config?.secondaryThemes || {})
                    }
                },
                themes: [],
                defaultTheme: config.defaultTheme || null
            };

            // Valider les thèmes
            if (!Array.isArray(config.themes)) {
                if (Log) Log.warn("[ThemeLoader] Aucun thème défini dans la configuration");
                return validatedConfig;
            }

            // Normaliser chaque thème
            validatedConfig.themes = config.themes.map((theme) => {
                if (!theme.id) {
                    if (Log) Log.warn("[ThemeLoader] Thème sans ID ignoré");
                    return null;
                }

                return {
                    id: theme.id,
                    label: theme.label || theme.id,
                    type: theme.type || "secondary", // Par défaut: secondary
                    description: theme.description || "",
                    icon: theme.icon || "",
                    layers: Array.isArray(theme.layers) ? theme.layers : []
                };
            }).filter(Boolean); // Supprimer les thèmes invalides

            // Vérifier qu'il y a au moins un thème
            if (validatedConfig.themes.length === 0) {
                throw new Error("Aucun thème valide trouvé dans la configuration");
            }

            // Vérifier que le defaultTheme existe
            if (validatedConfig.defaultTheme) {
                const defaultExists = validatedConfig.themes.some(
                    (t) => t.id === validatedConfig.defaultTheme
                );
                if (!defaultExists) {
                    if (Log) Log.warn("[ThemeLoader] defaultTheme introuvable, utilisation du premier thème");
                    validatedConfig.defaultTheme = validatedConfig.themes[0].id;
                }
            } else {
                // Pas de defaultTheme défini, utiliser le premier
                validatedConfig.defaultTheme = validatedConfig.themes[0].id;
            }

            if (Log) Log.debug("[ThemeLoader] Configuration validée:", validatedConfig.themes.length, "thèmes");

            return validatedConfig;
        },

        /**
         * Vide le cache (pour tests ou rechargement)
         * @param {string} [profileId] - ID du profil (optionnel, vide tout si non spécifié)
         */
        clearCache(profileId) {
            if (profileId) {
                _cache.delete(profileId);
                _loadingPromises.delete(profileId);
                if (Log) Log.debug("[ThemeLoader] Cache vidé pour:", profileId);
            } else {
                _cache.clear();
                _loadingPromises.clear();
                if (Log) Log.debug("[ThemeLoader] Cache complet vidé");
            }
        }
    };

    /**
     * Module Theme Selector
     * SÃ¯Â¿Â½lecteur de thÃ¯Â¿Â½mes global (principaux + secondaires)
     *
     * DÃ¯Â¿Â½PENDANCES:
     * - Leaflet (L.DomUtil, L.DomEvent)
     * - GeoLeaf.Log (optionnel)
     * - GeoLeaf._ThemeLoader
     * - GeoLeaf._ThemeApplier
     * - GeoLeaf.Core.getActiveProfile()
     *
     * EXPOSE:
     * - GeoLeaf.ThemeSelector
     *
     * @module ThemeSelector
     * @public
     */

    /**
     * Ã¯Â¿Â½tat du module
     */
    const _state = {
        initialized: false,
        profileId: null,
        config: null,
        themes: [],
        primaryThemes: [],
        secondaryThemes: [],
        currentTheme: null,
        // RÃ¯Â¿Â½fÃ¯Â¿Â½rences UI
        primaryContainer: null,
        secondaryContainer: null,
        dropdown: null,
        // Event listener cleanup tracking
        _eventCleanups: [],
    };

    /**
     * Module Theme Selector
     * @namespace ThemeSelector
     * @public
     */
    const ThemeSelector = {
        /**
         * Initialise le sÃ¯Â¿Â½lecteur de thÃ¯Â¿Â½mes
         * @param {Object} options - Options d'initialisation
         * @param {string} options.profileId - ID du profil
         * @param {HTMLElement} [options.primaryContainer] - Conteneur pour boutons principaux
         * @param {HTMLElement} [options.secondaryContainer] - Conteneur pour dropdown secondaire
         * @returns {Promise<void>}
         */
        init(options) {
            if (!options || !options.profileId) {
                return Promise.reject(new Error("profileId requis pour ThemeSelector.init"));
            }

            if (Log) Log.debug("[ThemeSelector] Initialisation pour profil:", options.profileId);

            _state.profileId = options.profileId;
            _state.primaryContainer = options.primaryContainer || null;
            _state.secondaryContainer = options.secondaryContainer || null;

            // Charger la configuration des thÃ¯Â¿Â½mes
            return _ThemeLoader.loadThemesConfig(options.profileId)
                .then((themesConfig) => {
                    _state.config = themesConfig.config;
                    _state.themes = themesConfig.themes;
                    _state.primaryThemes = themesConfig.themes.filter((t) => t.type === "primary");
                    _state.secondaryThemes = themesConfig.themes.filter((t) => t.type === "secondary");
                    _state.currentTheme = themesConfig.defaultTheme;

                    if (Log)
                        Log.debug("[ThemeSelector] Configuration chargÃ¯Â¿Â½e:", {
                            total: _state.themes.length,
                            primary: _state.primaryThemes.length,
                            secondary: _state.secondaryThemes.length,
                        });

                    // CrÃ¯Â¿Â½er l'UI
                    this._createUI();

                    // Marquer comme initialisÃ¯Â¿Â½ AVANT d'appliquer le thÃ¯Â¿Â½me
                    _state.initialized = true;

                    // Appliquer le thÃ¯Â¿Â½me par dÃ¯Â¿Â½faut
                    return this.setTheme(_state.currentTheme);
                })
                .then(() => {
                    if (Log) Log.debug("[ThemeSelector] Initialisation terminÃ¯Â¿Â½e");
                    // Ã¯Â¿Â½mettre l'Ã¯Â¿Â½vÃ¯Â¿Â½nement de fin de chargement des thÃ¯Â¿Â½mes
                    const event = new CustomEvent("geoleaf:themes:ready", {
                        detail: { time: Date.now() },
                    });
                    document.dispatchEvent(event);
                })
                .catch((err) => {
                    if (Log) Log.warn("[ThemeSelector] Erreur initialisation:", err.message);
                    // Ã¯Â¿Â½mettre l'Ã¯Â¿Â½vÃ¯Â¿Â½nement mÃ¯Â¿Â½me en cas d'erreur
                    const event = new CustomEvent("geoleaf:themes:ready", {
                        detail: { time: Date.now(), error: err.message },
                    });
                    document.dispatchEvent(event);
                    throw err;
                });
        },

        /**
         * CrÃ¯Â¿Â½e l'interface utilisateur
         * @private
         */
        _createUI() {
            // VÃ¯Â¿Â½rifier si le sÃ¯Â¿Â½lecteur de thÃ¯Â¿Â½mes est activÃ¯Â¿Â½ globalement
            const uiConfig = Config?.get?.("ui") ?? null;
            const showThemeSelector = uiConfig ? uiConfig.showThemeSelector === true : false;

            if (!showThemeSelector) {
                if (Log)
                    Log.debug("[ThemeSelector] showThemeSelector est false, UI non crÃ¯Â¿Â½Ã¯Â¿Â½e");
                return;
            }

            // CrÃ¯Â¿Â½er l'UI des thÃ¯Â¿Â½mes principaux
            if (_state.config.primaryThemes.enabled && _state.primaryContainer) {
                this._createPrimaryUI();
            }

            // CrÃ¯Â¿Â½er l'UI des thÃ¯Â¿Â½mes secondaires
            if (_state.config.secondaryThemes.enabled && _state.secondaryContainer) {
                this._createSecondaryUI();
            }
        },

        /**
         * CrÃ¯Â¿Â½e l'UI des thÃ¯Â¿Â½mes principaux (boutons)
         * @private
         */
        _createPrimaryUI() {
            if (!_state.primaryContainer) {
                return;
            }

            // Vider le conteneur
            DOMSecurity.clearElementFast(_state.primaryContainer);

            // Ajouter la classe CSS
            _state.primaryContainer.classList.add("gl-theme-selector-primary");

            // CrÃ¯Â¿Â½er un bouton pour chaque thÃ¯Â¿Â½me principal
            _state.primaryThemes.forEach((theme) => {
                const btn = globalThis.L.DomUtil.create(
                    "button",
                    "gl-theme-btn",
                    _state.primaryContainer
                );
                btn.type = "button";
                btn.dataset.themeId = theme.id;
                btn.title = theme.description || theme.label;

                // Contenu du bouton: icÃ¯Â¿Â½ne + label
                const iconSpan = globalThis.L.DomUtil.create("span", "gl-theme-btn__icon", btn);
                iconSpan.textContent = theme.icon || "??";

                const labelSpan = globalThis.L.DomUtil.create("span", "gl-theme-btn__label", btn);
                labelSpan.textContent = theme.label;

                // Marquer le thÃ¯Â¿Â½me actif
                if (theme.id === _state.currentTheme) {
                    btn.classList.add("gl-theme-btn--active");
                }

                // Gestionnaire de clic
                this._attachPrimaryButtonHandler(btn, theme);
            });

            if (Log)
                Log.debug(
                    "[ThemeSelector] UI primaire crÃ¯Â¿Â½Ã¯Â¿Â½e:",
                    _state.primaryThemes.length,
                    "boutons"
                );
        },

        /**
         * Attache le gestionnaire de clic sur un bouton de thÃ¯Â¿Â½me principal
         * @param {HTMLElement} btn - Bouton
         * @param {Object} theme - Configuration du thÃ¯Â¿Â½me
         * @private
         */
        _attachPrimaryButtonHandler(btn, theme) {
            const onClick = (ev) => {
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.stopPropagation(ev);
                }
                ev.preventDefault();

                this.setTheme(theme.id);
            };

            if (globalThis.L && globalThis.L.DomEvent) {
                globalThis.L.DomEvent.on(btn, "click", onClick);
                globalThis.L.DomEvent.disableClickPropagation(btn);
                // Store cleanup for L.DomEvent.off
                _state._eventCleanups.push(() => {
                    if (globalThis.L && globalThis.L.DomEvent) {
                        globalThis.L.DomEvent.off(btn, "click", onClick);
                    }
                });
            } else if (events) {
                _state._eventCleanups.push(
                    events.on(btn, "click", onClick, false, "ThemeSelector.primaryButton")
                );
            } else {
                btn.addEventListener("click", onClick);
            }
        },

        /**
         * CrÃ¯Â¿Â½e l'UI des thÃ¯Â¿Â½mes secondaires (dropdown + boutons prev/next)
         * @private
         */
        _createSecondaryUI() {
            if (!_state.secondaryContainer) {
                if (Log) Log.warn("[ThemeSelector] Conteneur secondaire introuvable");
                return;
            }

            if (Log)
                Log.debug(
                    "[ThemeSelector] CrÃ¯Â¿Â½ation UI secondaire:",
                    _state.secondaryThemes.length,
                    "thÃ¯Â¿Â½mes"
                );
            if (Log)
                Log.debug(
                    "[ThemeSelector] IDs des thÃ¯Â¿Â½mes secondaires:",
                    _state.secondaryThemes.map((t) => t.id)
                );

            // Vider le conteneur
            DOMSecurity.clearElementFast(_state.secondaryContainer);

            // Ajouter la classe CSS
            _state.secondaryContainer.classList.add("gl-theme-selector-secondary");

            // CrÃ¯Â¿Â½er le wrapper
            const wrapper = globalThis.L.DomUtil.create(
                "div",
                "gl-theme-selector-secondary__wrapper",
                _state.secondaryContainer
            );

            // Bouton prÃ¯Â¿Â½cÃ¯Â¿Â½dent (si activÃ¯Â¿Â½)
            if (_state.config.secondaryThemes.showNavigationButtons) {
                const prevBtn = globalThis.L.DomUtil.create(
                    "button",
                    "gl-theme-nav gl-theme-nav--prev",
                    wrapper
                );
                prevBtn.type = "button";
                prevBtn.textContent = "\u276E";
                prevBtn.title = "ThÃ¯Â¿Â½me prÃ¯Â¿Â½cÃ¯Â¿Â½dent";
                this._attachNavButtonHandler(prevBtn, "prev");
            }

            // Dropdown
            const select = globalThis.L.DomUtil.create("select", "gl-theme-dropdown", wrapper);
            _state.dropdown = select;

            // Option placeholder
            const placeholder = createElement$1("option", {
                value: "",
                textContent: _state.config.secondaryThemes.placeholder,
                disabled: true,
            });
            select.appendChild(placeholder);

            // Options pour les thÃ¯Â¿Â½mes secondaires
            _state.secondaryThemes.forEach((theme) => {
                const opt = createElement$1("option", {
                    value: theme.id,
                    textContent: theme.label,
                });
                select.appendChild(opt);
            });

            // SÃ¯Â¿Â½lectionner le thÃ¯Â¿Â½me actif si c'est un thÃ¯Â¿Â½me secondaire
            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
            if (currentIsSecondary) {
                select.value = _state.currentTheme;
            } else {
                select.value = "";
            }

            // Gestionnaire de changement
            this._attachDropdownHandler(select);

            // Bouton suivant (si activÃ¯Â¿Â½)
            if (_state.config.secondaryThemes.showNavigationButtons) {
                const nextBtn = globalThis.L.DomUtil.create(
                    "button",
                    "gl-theme-nav gl-theme-nav--next",
                    wrapper
                );
                nextBtn.type = "button";
                nextBtn.textContent = "\u276F";
                nextBtn.title = "ThÃ¯Â¿Â½me suivant";
                this._attachNavButtonHandler(nextBtn, "next");
            }

            if (Log)
                Log.debug(
                    "[ThemeSelector] UI secondaire crÃ¯Â¿Â½Ã¯Â¿Â½e:",
                    _state.secondaryThemes.length,
                    "thÃ¯Â¿Â½mes"
                );
        },

        /**
         * Attache le gestionnaire de changement sur le dropdown
         * @param {HTMLSelectElement} select - Dropdown
         * @private
         */
        _attachDropdownHandler(select) {
            const onChange = (ev) => {
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.stopPropagation(ev);
                }

                const themeId = select.value;
                if (Log) Log.info(`[ThemeSelector] Dropdown changÃ¯Â¿Â½: ${themeId}`);

                if (themeId) {
                    this.setTheme(themeId);
                } else {
                    if (Log) Log.warn("[ThemeSelector] Dropdown: themeId vide");
                }
            };

            if (globalThis.L && globalThis.L.DomEvent) {
                globalThis.L.DomEvent.on(select, "change", onChange);
                globalThis.L.DomEvent.disableClickPropagation(select);
                // Store cleanup for L.DomEvent.off
                _state._eventCleanups.push(() => {
                    if (globalThis.L && globalThis.L.DomEvent) {
                        globalThis.L.DomEvent.off(select, "change", onChange);
                    }
                });
            } else if (events) {
                _state._eventCleanups.push(
                    events.on(select, "change", onChange, false, "ThemeSelector.dropdown")
                );
            } else {
                select.addEventListener("change", onChange);
            }

            if (Log) Log.debug("[ThemeSelector] Gestionnaire dropdown attachÃ¯Â¿Â½");
        },

        /**
         * Attache le gestionnaire sur un bouton de navigation (prev/next)
         * @param {HTMLElement} btn - Bouton
         * @param {string} direction - "prev" | "next"
         * @private
         */
        _attachNavButtonHandler(btn, direction) {
            const onClick = (ev) => {
                if (globalThis.L && globalThis.L.DomEvent) {
                    globalThis.L.DomEvent.stopPropagation(ev);
                }
                ev.preventDefault();

                if (direction === "next") {
                    this.nextTheme();
                } else {
                    this.previousTheme();
                }
            };

            if (globalThis.L && globalThis.L.DomEvent) {
                globalThis.L.DomEvent.on(btn, "click", onClick);
                globalThis.L.DomEvent.disableClickPropagation(btn);
                // Store cleanup for L.DomEvent.off
                _state._eventCleanups.push(() => {
                    if (globalThis.L && globalThis.L.DomEvent) {
                        globalThis.L.DomEvent.off(btn, "click", onClick);
                    }
                });
            } else if (events) {
                _state._eventCleanups.push(
                    events.on(btn, "click", onClick, false, "ThemeSelector.navButton")
                );
            } else {
                btn.addEventListener("click", onClick);
            }
        },

        /**
         * Active un thÃ¯Â¿Â½me par son ID
         * @param {string} themeId - ID du thÃ¯Â¿Â½me
         * @returns {Promise<void>}
         */
        setTheme(themeId) {
            if (!_state.initialized) {
                return Promise.reject(new Error("ThemeSelector non initialisÃ¯Â¿Â½"));
            }

            const theme = _state.themes.find((t) => t.id === themeId);
            if (!theme) {
                return Promise.reject(new Error(`ThÃ¯Â¿Â½me introuvable: ${themeId}`));
            }

            if (Log) Log.debug("[ThemeSelector] setTheme:", themeId);

            // Appliquer le thÃ¯Â¿Â½me
            return _ThemeApplier.applyTheme(theme)
                .then(() => {
                    _state.currentTheme = themeId;

                    // Mettre Ã¯Â¿Â½ jour l'UI
                    this._updateUIState(themeId);

                    if (Log) Log.debug("[ThemeSelector] ThÃ¯Â¿Â½me activÃ¯Â¿Â½:", themeId);
                })
                .catch((err) => {
                    if (Log) Log.warn("[ThemeSelector] Erreur activation thÃ¯Â¿Â½me:", err.message);
                    throw err;
                });
        },

        /**
         * Met Ã¯Â¿Â½ jour l'Ã¯Â¿Â½tat visuel de l'UI aprÃ¯Â¿Â½s un changement de thÃ¯Â¿Â½me
         * @param {string} themeId - ID du thÃ¯Â¿Â½me actif
         * @private
         */
        _updateUIState(themeId) {
            // Mettre Ã¯Â¿Â½ jour les boutons principaux
            if (_state.primaryContainer) {
                const buttons = _state.primaryContainer.querySelectorAll(".gl-theme-btn");
                buttons.forEach((btn) => {
                    if (btn.dataset.themeId === themeId) {
                        btn.classList.add("gl-theme-btn--active");
                    } else {
                        btn.classList.remove("gl-theme-btn--active");
                    }
                });
            }

            // Mettre Ã¯Â¿Â½ jour le dropdown
            if (_state.dropdown) {
                const isSecondary = _state.secondaryThemes.some((t) => t.id === themeId);
                if (isSecondary) {
                    _state.dropdown.value = themeId;
                } else {
                    _state.dropdown.value = "";
                }
            }
        },

        /**
         * Active le thÃ¯Â¿Â½me secondaire suivant
         */
        nextTheme() {
            if (!_state.initialized || _state.secondaryThemes.length === 0) {
                return;
            }

            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
            let nextIndex = 0;

            if (currentIsSecondary) {
                const currentIndex = _state.secondaryThemes.findIndex(
                    (t) => t.id === _state.currentTheme
                );
                nextIndex = (currentIndex + 1) % _state.secondaryThemes.length;
            }

            const nextTheme = _state.secondaryThemes[nextIndex];
            if (nextTheme) {
                this.setTheme(nextTheme.id);
            }
        },

        /**
         * Active le thÃ¯Â¿Â½me secondaire prÃ¯Â¿Â½cÃ¯Â¿Â½dent
         */
        previousTheme() {
            if (!_state.initialized || _state.secondaryThemes.length === 0) {
                return;
            }

            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
            let prevIndex = _state.secondaryThemes.length - 1;

            if (currentIsSecondary) {
                const currentIndex = _state.secondaryThemes.findIndex(
                    (t) => t.id === _state.currentTheme
                );
                prevIndex =
                    (currentIndex - 1 + _state.secondaryThemes.length) % _state.secondaryThemes.length;
            }

            const prevTheme = _state.secondaryThemes[prevIndex];
            if (prevTheme) {
                this.setTheme(prevTheme.id);
            }
        },

        /**
         * RÃ¯Â¿Â½cupÃ¯Â¿Â½re le thÃ¯Â¿Â½me actuellement actif
         * @returns {string|null}
         */
        getCurrentTheme() {
            return _state.currentTheme;
        },

        /**
         * RÃ¯Â¿Â½cupÃ¯Â¿Â½re tous les thÃ¯Â¿Â½mes
         * @returns {Array}
         */
        getThemes() {
            return _state.themes;
        },

        /**
         * RÃ¯Â¿Â½cupÃ¯Â¿Â½re les thÃ¯Â¿Â½mes principaux
         * @returns {Array}
         */
        getPrimaryThemes() {
            return _state.primaryThemes;
        },

        /**
         * RÃ¯Â¿Â½cupÃ¯Â¿Â½re les thÃ¯Â¿Â½mes secondaires
         * @returns {Array}
         */
        getSecondaryThemes() {
            return _state.secondaryThemes;
        },

        /**
         * VÃ¯Â¿Â½rifie si le module est initialisÃ¯Â¿Â½
         * @returns {boolean}
         */
        isInitialized() {
            return _state.initialized;
        },

        /**
         * Cleanup method for event listeners
         * Call this when destroying the theme selector
         */
        destroy() {
            if (Log) Log.debug("[ThemeSelector] Cleaning up event listeners");

            if (_state._eventCleanups) {
                _state._eventCleanups.forEach((cleanup) => {
                    if (typeof cleanup === "function") {
                        cleanup();
                    }
                });
                _state._eventCleanups = [];
            }

            _state.initialized = false;
        },
    };

    /**
     * GeoLeaf Theme Applier - Deferred
     * Chargement différé de couches, résolution de profil, gestion du cache
     *
     * @module themes/theme-applier/deferred
     */

    /**
     * Programme l'application d'une configuration de couche pour plus tard
     * @param {string} layerId - ID de la couche
     * @param {boolean} visible - Visibilité souhaitée
     * @param {string} styleId - ID du style à appliquer
     * @returns {Promise<void>}
     * @private
     */
    _ThemeApplier._scheduleLayerConfig = function (layerId, visible, styleId) {
        if (!_ThemeApplier._pendingLayerConfigs) {
            _ThemeApplier._pendingLayerConfigs = new Map();
        }

        _ThemeApplier._pendingLayerConfigs.set(layerId, { visible, styleId });

        // Programmer une vérification périodique
        _ThemeApplier._schedulePendingCheck();

        return Promise.resolve();
    };

    /**
     * Planifie une vérification des couches en attente
     * @private
     */
    _ThemeApplier._schedulePendingCheck = function () {
        if (_ThemeApplier._pendingCheckTimer) {
            return; // Déjà planifié
        }

        _ThemeApplier._pendingCheckTimer = setTimeout(() => {
            _ThemeApplier._checkPendingLayerConfigs();
            _ThemeApplier._pendingCheckTimer = null;
        }, 1000);
    };

    /**
     * Vérifie et applique les configurations de couches en attente
     * @private
     */
    _ThemeApplier._checkPendingLayerConfigs = function () {
        if (!_ThemeApplier._pendingLayerConfigs || _ThemeApplier._pendingLayerConfigs.size === 0) {
            return;
        }

        const appliedLayers = [];

        for (const [layerId, config] of _ThemeApplier._pendingLayerConfigs) {
            const layerData = GeoJSONShared.state.layers?.get(layerId);
            if (layerData) {
                _ThemeApplier._setLayerVisibilityAndStyle(layerId, config.visible, config.styleId);
                appliedLayers.push(layerId);
            }
        }

        // Supprimer les couches traitées
        appliedLayers.forEach((layerId) => {
            _ThemeApplier._pendingLayerConfigs.delete(layerId);
        });

        // S'il reste des couches en attente, programmer une nouvelle vérification
        if (_ThemeApplier._pendingLayerConfigs.size > 0) {
            _ThemeApplier._schedulePendingCheck();
        }
    };

    /**
     * Charge une couche depuis le profil actif (avec tolérance aux erreurs)
     * @param {string} layerId - ID de la couche à charger
     * @returns {Promise<Object|null>} - Couche chargée ou null si erreur
     * @private
     */
    _ThemeApplier._loadLayerFromProfile = async function (layerId) {
        if (!Config || typeof Config.getActiveProfile !== "function") {
            return null;
        }

        try {
            const activeProfile = Config.getActiveProfile();

            if (!activeProfile || typeof activeProfile !== "object") {
                return null;
            }

            const profileId = activeProfile.id || null;

            // Get layers config from profile
            let profileLayersConfig = [];
            if (Array.isArray(activeProfile.geojsonLayers)) {
                profileLayersConfig = activeProfile.geojsonLayers;
            } else if (activeProfile.geojson && Array.isArray(activeProfile.geojson.layers)) {
                profileLayersConfig = activeProfile.geojson.layers;
            } else if (Array.isArray(activeProfile.layers)) {
                profileLayersConfig = activeProfile.layers;
            } else if (Array.isArray(activeProfile.Layers)) {
                profileLayersConfig = activeProfile.Layers;
            }

            if (!Array.isArray(profileLayersConfig) || profileLayersConfig.length === 0) {
                return null;
            }

            const layerConfig = profileLayersConfig.find((config) => config.id === layerId);

            if (!layerConfig) {
                return null;
            }

            const dataUrl = _ThemeApplier._resolveDataFilePath(layerConfig);

            if (!dataUrl) {
                return null;
            }

            const layerLabel = layerConfig.label || layerId;
            const baseOptions = {};

            const loader = Loader._loadSingleLayer;

            if (!loader) {
                return null;
            }

            // Tentative cache avant réseau
            let cachedData = null;
            if (ThemeCache?.get) {
                cachedData = await ThemeCache.get(layerId, profileId);
            }

            // Transmettre TOUTE la configuration de la couche
            const layerDef = {
                ...layerConfig,
                url: dataUrl,
                type: layerConfig.geometryType || layerConfig.type || "geojson",
                _profileId: profileId,
                _layerDirectory: layerConfig._layerDirectory,
            };

            // Normaliser les champs popup/tooltip/sidepanel
            const normalizedDef = { ...layerDef };

            if (layerDef.popup && layerDef.popup.fields) {
                normalizedDef.popupFields = layerDef.popup.fields;
            }

            if (layerDef.tooltip && layerDef.tooltip.fields) {
                normalizedDef.tooltipFields = layerDef.tooltip.fields;
            }

            if (layerDef.sidepanel && layerDef.sidepanel.detailLayout) {
                normalizedDef.sidepanelFields = layerDef.sidepanel.detailLayout;
            }

            // Normaliser clustering (objet → booléen + champs top-level)
            // Alignement avec la normalisation faite dans profile.js loadFromActiveProfile
            if (layerDef.clustering && typeof layerDef.clustering === "object") {
                normalizedDef.clustering = layerDef.clustering.enabled !== false;
                if (typeof layerDef.clustering.maxClusterRadius === "number") {
                    normalizedDef.maxClusterRadius = layerDef.clustering.maxClusterRadius;
                    normalizedDef.clusterRadius = layerDef.clustering.maxClusterRadius;
                }
                if (typeof layerDef.clustering.disableClusteringAtZoom === "number") {
                    normalizedDef.disableClusteringAtZoom = layerDef.clustering.disableClusteringAtZoom;
                }
            }

            if (cachedData) {
                normalizedDef._cachedData = cachedData;
            }

            try {
                const layer = await loader.call(
                    Loader,
                    layerId,
                    layerLabel,
                    normalizedDef,
                    baseOptions
                );
                // Rafraîchir le cache pour prolonger la durée de vie
                if (cachedData && ThemeCache?.store) {
                    ThemeCache.store(layerId, profileId, cachedData);
                }
                return layer;
            } catch (err) {
                if (Log) Log.warn(`[ThemeApplier._loadLayerFromProfile] Erreur chargement couche "${layerId}":`, err && err.message);
                return null;
            }
        } catch (error) {
            if (Log) Log.warn(`[ThemeApplier._loadLayerFromProfile] Erreur inattendue pour "${layerId}":`, error && error.message);
            return null;
        }
    };

    /**
     * Résout le chemin du fichier de données d'une couche
     * @param {Object} layerConfig - Configuration de la couche
     * @returns {string|null} - URL complète du fichier de données
     * @private
     */
    _ThemeApplier._resolveDataFilePath = function (layerConfig) {
        if (!layerConfig.dataFile || !layerConfig._layerDirectory) {
            return null;
        }

        if (!Config || !Config.getActiveProfile) {
            return null;
        }

        const activeProfile = Config.getActiveProfile();
        if (!activeProfile) {
            return null;
        }

        const profileId = activeProfile.id;
        const profileBasePath = _ThemeApplier._getProfilesBasePath(activeProfile);

        return `${profileBasePath}/${profileId}/${layerConfig._layerDirectory}/${layerConfig.dataFile}`;
    };

    /**
     * Résout le chemin de base des profils
     * @private
     */
    _ThemeApplier._getProfilesBasePath = function (activeProfile) {
        const configured = Config?.get?.("data.profilesBasePath");

        if (typeof configured === "string" && configured.trim().length > 0) {
            return _ThemeApplier._normalizeBasePath(configured);
        }

        if (activeProfile && typeof activeProfile.profilesBasePath === "string") {
            return _ThemeApplier._normalizeBasePath(activeProfile.profilesBasePath);
        }

        return "profiles";
    };

    /**
     * Normalise un chemin (trim + supprime le / final)
     * @private
     */
    _ThemeApplier._normalizeBasePath = function (path) {
        const trimmed = path.trim();
        return trimmed.endsWith("/") ? trimmed.slice(0, -1) : trimmed;
    };

    /** GeoLeaf Route API - implementation deplacee depuis geoleaf.route.js */
    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    const _g$f =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$f.GeoLeaf = _g$f.GeoLeaf || {};

    /**
     * Namespace global GeoLeaf
     */

    /**
     * Logger unifié (défini par geoleaf.log.js / logger-shim)
     */

    /**
     * Module GeoLeaf.Route
     * - Charge et affiche des itinéraires (GPX, GeoJSON, profils GeoLeaf)
     * - Gère une couche dédiée (polyline + points éventuels)
     * - Offre une API de visibilité pour la Légende (getLayer)
     * - Prend en compte les styles et les points départ/arrivée définis
     *   dans le profil actif (profile.json).
     */
    const RouteModule = {
        _map: null,
        _layerGroup: null,
        _routeLayer: null,

        _initialized: false,
        _visible: true,

        /**
         * Options par défaut
         */
        _options: {
            lineStyle: {
                color: "#1E88E5",
                weight: 4,
                opacity: 0.9,
                interactive: false,
            },
            waypointStyle: {
                radius: 5,
                color: "#0D47A1",
                fillColor: "#42A5F5",
                fillOpacity: 0.9,
                weight: 2,
            },
            // Affichage des points de départ / arrivée
            showStart: true,
            showEnd: true,
            startWaypointStyle: null, // si null => waypointStyle
            endWaypointStyle: null, // si null => waypointStyle

            fitBoundsOnLoad: true,
            maxZoomOnFit: 14,
        },

        /**
         * Valide les options passées à init()
         * @param {Object} options
         * @private
         */
        _validateOptions(options) {
            if (options.map && typeof options.map.addLayer !== "function") {
                Log.warn("[GeoLeaf.Route] options.map ne semble pas être une carte Leaflet valide.");
            }

            if (options.lineStyle && typeof options.lineStyle !== "object") {
                Log.warn("[GeoLeaf.Route] options.lineStyle doit être un objet.");
                delete options.lineStyle;
            }

            if (options.waypointStyle && typeof options.waypointStyle !== "object") {
                Log.warn("[GeoLeaf.Route] options.waypointStyle doit être un objet.");
                delete options.waypointStyle;
            }

            if (
                options.maxZoomOnFit !== undefined &&
                (typeof options.maxZoomOnFit !== "number" ||
                    options.maxZoomOnFit < 1 ||
                    options.maxZoomOnFit > 20)
            ) {
                Log.warn("[GeoLeaf.Route] options.maxZoomOnFit doit être entre 1 et 20.");
                options.maxZoomOnFit = 14;
            }

            return options;
        },

        /**
         * Retourne le layerGroup contenant les itinéraires
         * (utilisé par la Légende pour afficher/masquer la couche)
         * @returns {L.LayerGroup|null}
         */
        getLayer() {
            return this._layerGroup || null;
        },

        /**
         * Initialisation du module Route
         * @param {Object} options
         * @param {L.Map} [options.map] - Carte Leaflet
         * @returns {L.LayerGroup|null}
         */
        init(options = {}) {
            options = this._validateOptions(options);

            if (typeof _g$f.L === "undefined") {
                Log.error("[GeoLeaf.Route] Leaflet introuvable.");
                return null;
            }

            // Utilise un helper commun si disponible
            let map = options.map || null;
            if (!map && _g$f.GeoLeaf.Core && typeof _g$f.GeoLeaf.Core.getMap === "function") {
                map = _g$f.GeoLeaf.Core.getMap();
            }
            if (_g$f.GeoLeaf.Utils && typeof _g$f.GeoLeaf.Utils.ensureMap === "function") {
                map = _g$f.GeoLeaf.Utils.ensureMap(map);
            }

            if (!map) {
                Log.error("[GeoLeaf.Route] Aucune carte disponible pour init().");
                return null;
            }

            this._map = map;

            // Fusion des options
            if (_g$f.GeoLeaf.Utils && typeof _g$f.GeoLeaf.Utils.mergeOptions === "function") {
                this._options = _g$f.GeoLeaf.Utils.mergeOptions(this._options, options);
            } else {
                this._options = Object.assign({}, this._options, options);
            }

            // Applique le paramètre interactiveShapes de la config
            const interactiveShapes = _g$f.GeoLeaf.Config.get("ui.interactiveShapes", false);
            if (this._options.lineStyle) {
                this._options.lineStyle.interactive = interactiveShapes;
            }

            this._layerGroup = _g$f.L.layerGroup().addTo(this._map);
            this._routeLayer = _g$f.L.polyline([], this._options.lineStyle).addTo(this._layerGroup);

            this._initialized = true;
            this._visible = true;

            return this._layerGroup;
        },

        /**
         * Indique si le module est initialisé.
         * @returns {boolean}
         */
        isInitialized() {
            return this._initialized === true && !!this._map && !!this._layerGroup;
        },

        /**
         * Indique si la couche d'itinéraires est actuellement visible.
         * @returns {boolean}
         */
        isVisible() {
            return this._visible === true;
        },

        /**
         * Affiche la couche d'itinéraires.
         */
        show() {
            if (!this._map || !this._layerGroup) return;
            if (!this._map.hasLayer(this._layerGroup)) {
                this._layerGroup.addTo(this._map);
            }
            this._visible = true;
        },

        /**
         * Masque la couche d'itinéraires.
         */
        hide() {
            if (!this._map || !this._layerGroup) return;
            if (this._map.hasLayer(this._layerGroup)) {
                this._map.removeLayer(this._layerGroup);
            }
            this._visible = false;
        },

        /**
         * Bascule la visibilité (utile éventuellement en dehors de la Légende).
         */
        toggleVisibility() {
            if (!this.isInitialized()) {
                Log.warn("[GeoLeaf.Route] toggleVisibility() appelé sans init().");
                return;
            }
            if (this.isVisible()) {
                this.hide();
            } else {
                this.show();
            }
        },

        /**
         * Vider tous les itinéraires de la couche
         */
        clear() {
            if (this._layerGroup) {
                this._layerGroup.clearLayers();
            }
            if (this._map && this._layerGroup) {
                this._routeLayer = _g$f.L.polyline([], this._options.lineStyle).addTo(this._layerGroup);
            } else {
                this._routeLayer = null;
            }
        },

        /**
         * Charger un fichier GPX (via fetch)
         * @param {string} url
         * @returns {Promise<void>}
         */
        loadGPX(url) {
            if (!url) {
                Log.warn("[GeoLeaf.Route] URL GPX manquante.");
                return Promise.resolve();
            }

            // Sprint 3.3: Use unified FetchHelper with timeout for GPX loading
            const FetchHelper = _g$f.GeoLeaf.Utils?.FetchHelper;

            if (FetchHelper) {
                return FetchHelper.fetch(url, {
                    timeout: 15000, // GPX files can be larger, allow more time
                    retries: 2,
                    parseResponse: false, // We need raw text
                })
                    .then((response) => response.text())
                    .then((xmlText) => new DOMParser().parseFromString(xmlText, "application/xml"))
                    .then((gpx) => {
                        const coords = Array.from(gpx.getElementsByTagName("trkpt")).map((pt) => [
                            parseFloat(pt.getAttribute("lat") || "0"),
                            parseFloat(pt.getAttribute("lon") || "0"),
                        ]);
                        this._applyRoute(coords);
                    })
                    .catch((err) => Log.error("[GeoLeaf.Route] Erreur GPX :", err));
            }

            // Fallback to raw fetch
            return fetch(url)
                .then((res) => res.text())
                .then((xmlText) => new DOMParser().parseFromString(xmlText, "application/xml"))
                .then((gpx) => {
                    const coords = Array.from(gpx.getElementsByTagName("trkpt")).map((pt) => [
                        parseFloat(pt.getAttribute("lat") || "0"),
                        parseFloat(pt.getAttribute("lon") || "0"),
                    ]);
                    this._applyRoute(coords);
                })
                .catch((err) => Log.error("[GeoLeaf.Route] Erreur GPX :", err));
        },

        /**
         * Charger un itinéraire GeoJSON (LineString)
         * @param {Object} geojson
         */
        loadGeoJSON(geojson) {
            RouteLoaders.loadGeoJSON(geojson, this._applyRoute.bind(this));
        },

        /**
         * Charge un tableau d’itinéraires déjà normalisés depuis cfg.routes
         * (profil GeoLeaf) et les dessine sur la carte.
         *
         * Format attendu pour chaque item :
         * {
         *   id: "route-id",
         *   label: "Nom",
         *   type: "walking" | "trekking" | ... (optionnel)
         *   geometry: [ [lat, lng], ... ]  // OU GeoJSON LineString
         *   properties: {
         *     type?: "walking" | "trekking" | ...,
         *     color?: "#hex",
         *     weight?: number,
         *     opacity?: number,
         *     dashArray?: string,
         *     showStart?: boolean,
         *     showEnd?: boolean,
         *     startStyle?: {...},
         *     endStyle?: {...},
         *     ...
         *   }
         * }
         *
         * Les styles et endpoints par défaut peuvent être définis
         * dans le profil actif (profile.json) :
         *
         * "defaultSettings": {
         *   "routeConfig": {
         *     "default": { "color": "#ff6600", "weight": 4, "opacity": 0.9 },
         *     "endpoints": {
         *       "showStart": true,
         *       "showEnd": true,
         *       "start": { "radius": 6, "color": "#ffffff", "fillColor": "#2b7cff" },
         *       "end":   { "radius": 6, "color": "#ffffff", "fillColor": "#ff7b32" }
         *     }
         *   }
         * }
         *
         * La couleur des routes est déterminée par priorité :
         * 1. colorRoute de la sous-catégorie (taxonomy.categories[cat].subcategories[subcat].colorRoute)
         * 2. colorRoute de la catégorie (taxonomy.categories[cat].colorRoute)
         * 3. defaultSettings.routeConfig.default.color
         *
         * @param {Array} routes
         */
        loadFromConfig(routes) {
            if (!this.isInitialized()) {
                Log.warn(
                    "[GeoLeaf.Route] loadFromConfig() appelé alors que le module n'est pas initialisé."
                );
                return;
            }

            if (!Array.isArray(routes) || routes.length === 0) {
                this.clear();
                Log.info("[GeoLeaf.Route] Aucun itinéraire dans cfg.routes ; couche vidée.");
                return;
            }

            this.clear();

            const allCoords = [];
            const defaultStyle = this._options.lineStyle || {};

            // Récupérer config + endpoints définis dans le profil actif
            let activeProfile = null;
            let routeConfigDefault = null;
            let profileEndpoints = null;

            try {
                if (_g$f.GeoLeaf.Config && typeof _g$f.GeoLeaf.Config.getActiveProfile === "function") {
                    activeProfile = _g$f.GeoLeaf.Config.getActiveProfile();
                    if (
                        activeProfile &&
                        activeProfile.defaultSettings &&
                        activeProfile.defaultSettings.routeConfig
                    ) {
                        if (
                            activeProfile.defaultSettings.routeConfig.default &&
                            typeof activeProfile.defaultSettings.routeConfig.default === "object" &&
                            !Array.isArray(activeProfile.defaultSettings.routeConfig.default)
                        ) {
                            routeConfigDefault = activeProfile.defaultSettings.routeConfig.default;
                        }
                        if (
                            activeProfile.defaultSettings.routeConfig.endpoints &&
                            typeof activeProfile.defaultSettings.routeConfig.endpoints === "object" &&
                            !Array.isArray(activeProfile.defaultSettings.routeConfig.endpoints)
                        ) {
                            profileEndpoints = activeProfile.defaultSettings.routeConfig.endpoints;
                        }
                    }
                }
            } catch (e) {
                Log.warn(
                    "[GeoLeaf.Route] Impossible de lire la config/endpoints depuis le profil actif.",
                    e
                );
            }

            routes.forEach((route) => {
                if (!route || typeof route !== "object") {
                    return;
                }

                const coords = this._extractCoordsFromRouteItem(route);
                if (!coords || coords.length === 0) {
                    return;
                }

                // Style de la polyline
                const routeStyle = this._resolveRouteStyle(
                    route,
                    activeProfile,
                    routeConfigDefault,
                    defaultStyle
                );

                // Applique le paramètre interactiveShapes
                const interactiveShapes = _g$f.GeoLeaf.Config.get("ui.interactiveShapes", false);
                routeStyle.interactive = interactiveShapes;

                const polyline = _g$f.L.polyline(coords, routeStyle).addTo(this._layerGroup);

                // Assign routeId for filterVisibility() lookups
                if (!polyline.options) polyline.options = {};
                polyline.options.routeId = route.id;

                // Attach route data to polyline for popup/tooltip access
                polyline._geoleafRouteData = route;

                // Add tooltip with route label
                this._addRouteTooltip(polyline, route);

                // Add popup with route details
                this._addRoutePopup(polyline, route);

                // Première polyline = "routeLayer" principal
                if (!this._routeLayer) {
                    this._routeLayer = polyline;
                }

                allCoords.push(...coords);

                // Points de départ / arrivée
                const endpointCfg = this._resolveEndpointConfig(route, profileEndpoints, this._options);

                if (coords.length > 0) {
                    const startLatLng = coords[0];
                    const endLatLng = coords[coords.length - 1];

                    if (endpointCfg.showStart) {
                        const startStyle = Object.assign({}, endpointCfg.startStyle, {
                            interactive: interactiveShapes,
                            routeId: route.id,
                        });
                        _g$f.L.circleMarker(startLatLng, startStyle).addTo(this._layerGroup);
                    }

                    if (
                        endpointCfg.showEnd &&
                        endLatLng &&
                        (endLatLng[0] !== startLatLng[0] || endLatLng[1] !== startLatLng[1])
                    ) {
                        const endStyle = Object.assign({}, endpointCfg.endStyle, {
                            interactive: interactiveShapes,
                            routeId: route.id,
                        });
                        _g$f.L.circleMarker(endLatLng, endStyle).addTo(this._layerGroup);
                    }
                }
            });

            if (allCoords.length === 0) {
                Log.warn(
                    "[GeoLeaf.Route] loadFromConfig() n'a trouvé aucun itinéraire valide dans cfg.routes."
                );
                return;
            }

            // Ajuster l'emprise globale si option activée
            if (this._options.fitBoundsOnLoad) {
                try {
                    const bounds = this._layerGroup.getBounds();
                    const fitOpt = {};
                    if (this._options.maxZoomOnFit) {
                        fitOpt.maxZoom = this._options.maxZoomOnFit;
                    }
                    this._map.fitBounds(bounds, fitOpt);
                } catch (e) {
                    Log.warn("[GeoLeaf.Route] Erreur lors du fitBounds sur les itinéraires :", e);
                }
            }

            // Événements "route loaded" (Leaflet + DOM)
            this._fireRouteLoadedEvents(allCoords);
        },

        /**
         * Filtrer la visibilité des routes déjà chargées sans les recharger.
         * Préserve les styles originaux des routes.
         * @param {Array<Object>} filteredRoutes - Liste des routes à afficher (après filtrage)
         * @public
         */
        filterVisibility: function (filteredRoutes) {
            if (!this._initialized) {
                Log.warn("[GeoLeaf.Route] Module non initialisé - filterVisibility ignoré.");
                return;
            }

            if (!Array.isArray(filteredRoutes)) {
                Log.warn("[GeoLeaf.Route] filterVisibility : filteredRoutes doit être un tableau.");
                return;
            }

            // Créer un Set des IDs des routes à afficher pour une recherche rapide
            const visibleRouteIds = new Set(filteredRoutes.map((r) => r.id));

            // Parcourir toutes les couches actuellement affichées
            this._layerGroup.eachLayer(
                function (layer) {
                    // Vérifier si cette couche a un ID de route
                    const routeId =
                        (layer.options && layer.options.routeId) ||
                        (layer.feature && layer.feature.properties && layer.feature.properties.id);

                    if (routeId !== undefined) {
                        // Afficher ou masquer selon si l'ID est dans la liste filtrée
                        if (visibleRouteIds.has(routeId)) {
                            if (!this._map.hasLayer(layer)) {
                                this._map.addLayer(layer);
                            }
                        } else {
                            if (this._map.hasLayer(layer)) {
                                this._map.removeLayer(layer);
                            }
                        }
                    }
                }.bind(this)
            );

            Log.info(
                "[GeoLeaf.Route] Visibilité filtrée : " + filteredRoutes.length + " routes visibles."
            );
        },

        /**
         * Extraire un tableau de [lat, lng] à partir d'un item de cfg.routes.
         * @param {Object} route
         * @returns {number[][]}
         * @private
         */
        _extractCoordsFromRouteItem(route) {
            return RouteLoaders.extractCoordsFromRouteItem(route);
        },

        /**
         * Détermine la couleur d'un itinéraire selon la priorité :
         *  1. colorRoute de la sous-catégorie (si définie)
         *  2. colorRoute de la catégorie (si définie)
         *  3. couleur par défaut de routeConfig.default.color
         *
         * @param {Object} route - L'itinéraire
         * @param {Object} profile - Le profil actif
         * @param {Object} routeConfigDefault - La config par défaut (defaultSettings.routeConfig.default)
         * @returns {string|null} La couleur à utiliser ou null
         * @private
         */
        _getRouteColor(route, profile, routeConfigDefault) {
            return RouteStyleResolver.getRouteColor(route, profile, routeConfigDefault);
        },

        /**
         * Calcule le style final d'un itinéraire en combinant :
         *  - le style par défaut du module,
         *  - la config par défaut du profil (defaultSettings.routeConfig.default),
         *  - la couleur basée sur la taxonomie (colorRoute),
         *  - les surcharges au niveau de l'itinéraire (properties.*).
         *
         * @private
         */
        _resolveRouteStyle(route, activeProfile, routeConfigDefault, defaultStyle) {
            return RouteStyleResolver.resolveRouteStyle(
                route,
                activeProfile,
                routeConfigDefault,
                defaultStyle
            );
        },

        /**
         * Calcule la configuration d'affichage des points départ / arrivée
         * en combinant :
         *  - les options par défaut du module (_options),
         *  - les endpoints définis dans le profil actif (defaultSettings.routeConfig.endpoints),
         *  - les surcharges éventuelles au niveau de l'itinéraire
         *    (properties.showStart, properties.showEnd, startStyle, endStyle).
         *
         * @private
         */
        _resolveEndpointConfig(route, profileEndpoints, moduleOptions) {
            return RouteStyleResolver.resolveEndpointConfig(route, profileEndpoints, moduleOptions);
        },

        /**
         * Ajouter un waypoint manuel
         * @param {number[]} latlng
         */
        addWaypoint(latlng) {
            RouteLayerManager.addWaypoint(this._layerGroup, latlng, this._options.waypointStyle);
        },

        /**
         * Ajouter un segment manuel
         * @param {number[][]} coords
         */
        addSegment(coords) {
            if (!this._routeLayer) return;
            const current = this._routeLayer.getLatLngs();
            this._routeLayer.setLatLngs([...current, ...coords]);
        },

        /**
         * Appliquer un itinéraire complet (remplacement)
         * @param {number[][]} coords
         * @private
         */
        _applyRoute(coords) {
            const context = {
                map: this._map,
                layerGroup: this._layerGroup,
                routeLayer: this._routeLayer,
                options: this._options,
            };
            RouteLayerManager.applyRoute(
                context,
                coords,
                this.clear.bind(this),
                this._fireRouteLoadedEvents.bind(this)
            );
            this._routeLayer = context.routeLayer;
        },

        /**
         * Add tooltip to route polyline
         * @param {L.Polyline} polyline
         * @param {Object} route
         * @private
         */
        _addRouteTooltip(polyline, route) {
            RoutePopupBuilder.addRouteTooltip(polyline, route);
        },

        /**
         * Add popup to route polyline with "Voir plus" button
         * @param {L.Polyline} polyline
         * @param {Object} route
         * @private
         */
        _addRoutePopup(polyline, route) {
            RoutePopupBuilder.addRoutePopup(polyline, route, this);
        },

        /**
         * Build popup content for route (same structure as POI popup)
         * @param {Object} route
         * @returns {string} HTML content
         * @private
         */
        _buildRoutePopupContent(route) {
            return RoutePopupBuilder.buildRoutePopupContent(route);
        } /**
         * Open side panel with route details
         * @param {Object} route
         * @private
         */,
        _openRouteSidePanel(route) {
            RoutePopupBuilder.openRouteSidePanel(route);
        },

        /**
         * Phase 4 dedup: delegates to _RouteLayerManager.fireRouteLoadedEvents
         * @param {number[][]} coords
         * @private
         */
        _fireRouteLoadedEvents(coords) {
            RouteLayerManager.fireRouteLoadedEvents(this._map, this._routeLayer, coords);
        },
    };

    const Route = RouteModule;

    /**
     * GeoLeaf Contract — Route (lazy-chunk boundary)
     *
     * Interface ESM pure pour accéder au module Route depuis les modules core.
     *
     * Phase 10-D — Pattern C : contrat de chunk Route.
     *
     * USAGE :
     *   import { RouteContract } from '../../../contracts/route.contract.js';
     *
     *   const routeGroup = RouteContract.getLayerGroup();
     *   if (routeGroup) tempGroup.addLayer(routeGroup);
     */

    /**
     * Contrat d'interface pour le module Route.
     * @namespace RouteContract
     */
    const RouteContract = {
        /**
         * Retourne true si Route est initialisé.
         * @returns {boolean}
         */
        isAvailable() {
            return !!Route && Route._initialized === true;
        },

        /**
         * Retourne le LayerGroup contenant les itinéraires.
         * Note : la méthode dans geoleaf.route.js est `getLayer()`.
         * Ce contrat uniformise l'API sous `getLayerGroup()`.
         * @returns {L.LayerGroup|null}
         */
        getLayerGroup() {
            if (typeof Route.getLayer === "function") {
                return Route.getLayer();
            }
            return null;
        },
    };

    /**
     * GeoLeaf Theme Applier - UI Sync
     * Synchronisation de l'UI : sélecteur de style, légende, fitBounds
     *
     * @module themes/theme-applier/ui-sync
     */

    /**
     * Met à jour le sélecteur de style dans l'UI
     * @param {string} layerId - Identifiant de la couche
     * @param {string} styleId - Identifiant du style
     * @private
     */
    _ThemeApplier._updateStyleSelector = function (layerId, styleId) {
        const selectId = "style-selector-" + layerId;
        const select = document.getElementById(selectId);

        if (select) {
            select.value = styleId;
        }
    };

    /**
     * Charge la légende correspondant au style appliqué
     * @param {string} layerId - ID de la couche
     * @param {string} styleId - ID du style
     * @private
     */
    _ThemeApplier._loadLegendForStyle = function (layerId, styleId) {
        if (!LegendContract.isAvailable()) {
            return;
        }

        // Récupérer les informations de la couche
        const layersMap = GeoJSONShared.state.layers;
        const layerInfo = layersMap instanceof Map ? layersMap.get(layerId) : layersMap?.[layerId];

        if (!layerInfo || !layerInfo.config) {
            return;
        }

        // Utiliser la nouvelle API qui génère la légende depuis le style
        LegendContract.loadLayerLegend(layerId, styleId, layerInfo.config);
    };

    /**
     * Zoom sur l'emprise de toutes les couches chargées
     * @private
     */
    _ThemeApplier._fitBoundsOnAllLayers = function () {
        const map = Core?.getMap();
        if (!map) {
            return;
        }

        // Mettre à jour la progression (99%)
        if (window._glLoadingScreen && typeof window._glLoadingScreen.updateProgress === "function") {
            window._glLoadingScreen.updateProgress(99);
        }

        // Créer un groupe temporaire avec toutes les couches pour calculer les bounds
        const tempGroup = globalThis.L.featureGroup();
        let layerCount = 0;

        // Ajouter les couches GeoJSON
        if (GeoJSONShared.getLayers) {
            GeoJSONShared.getLayers().forEach((layerData, _layerId) => {
                if (layerData.layer) {
                    try {
                        tempGroup.addLayer(layerData.layer);
                        layerCount++;
                    } catch (e) {
                        // Silencieux
                    }
                }
            });
        }

        // Ajouter les POI s'ils existent
        if (POIShared?.getMarkerLayer) {
            const markerLayer = POIShared.getMarkerLayer();
            if (markerLayer) {
                try {
                    tempGroup.addLayer(markerLayer);
                    layerCount++;
                } catch (e) {
                    // Silencieux
                }
            }
        }

        // Ajouter les Routes s'elles existent
        if (RouteContract.isAvailable()) {
            try {
                const routeGroup = RouteContract.getLayerGroup();
                if (routeGroup) {
                    tempGroup.addLayer(routeGroup);
                    layerCount++;
                }
            } catch (e) {
                // Silencieux
            }
        }

        // Zoomer sur l'emprise
        if (layerCount > 0) {
            const bounds = tempGroup.getBounds();
            if (bounds.isValid()) {
                // Afficher la carte AVANT le fitBounds pour éviter l'écran noir
                const mapContainer =
                    document.getElementById("geoleaf-map") ||
                    document.querySelector(".leaflet-container")?.parentElement;
                if (mapContainer) {
                    mapContainer.style.opacity = "1";
                }

                map.fitBounds(bounds, { maxZoom: 12, padding: [50, 50], animate: false });

                // Attendre que les tuiles soient chargées avant de fermer le spinner
                setTimeout(() => {
                    try {
                        const event = new CustomEvent("geoleaf:map:ready", {
                            detail: { time: Date.now() },
                        });
                        document.dispatchEvent(event);
                    } catch (e) {
                        // fallback
                    }
                }, 800);
            }
        }
    };

    /**
     * Synchronise l'état de visibilité de toutes les couches dans la légende
     * @private
     */
    _ThemeApplier._syncLegendVisibility = function () {
        if (!LegendContract.isAvailable()) {
            return;
        }

        if (!GeoJSONShared.getLayers) {
            return;
        }

        const VisibilityManager$1 = VisibilityManager;
        if (!VisibilityManager$1) {
            return;
        }

        // Parcourir toutes les couches et synchroniser leur état
        GeoJSONShared.getLayers().forEach((layerData, layerId) => {
            const visState = VisibilityManager$1.getVisibilityState(layerId);
            const isVisible = visState ? visState.current : layerData.visible;
            LegendContract.setLayerVisibility(layerId, isVisible);
        });
    };

    /**
     * GeoLeaf Theme Applier - Visibility
     * Gestion de la visibilité des couches et application des styles
     *
     * @module themes/theme-applier/visibility
     */

    /**
     * Désactive toutes les couches GeoJSON
     * @private
     */
    _ThemeApplier._hideAllLayers = function () {
        if (!GeoJSONShared.state.layers) {
            return;
        }

        const VisibilityManager$1 = VisibilityManager;
        if (!VisibilityManager$1) {
            return;
        }

        // Réinitialiser tous les overrides utilisateur pour laisser le thème prendre le contrôle
        VisibilityManager$1.resetAllUserOverrides();

        // Parcourir toutes les couches enregistrées
        GeoJSONShared.getLayers().forEach((layerData, layerId) => {
            VisibilityManager$1.setVisibility(layerId, false, VisibilityManager$1.VisibilitySource.THEME);
        });
    };

    /**
     * Applique la configuration d'une couche (visible/masquée + style)
     * @param {Object} layerConfig - Configuration { id, visible, style }
     * @returns {Promise<void>}
     * @private
     */
    _ThemeApplier._applyLayerConfig = function (layerConfig) {
        if (!layerConfig?.id) {
            return Promise.resolve();
        }

        const layerId = layerConfig.id;
        const visible = layerConfig.visible !== false;
        const styleId = layerConfig.style ? String(layerConfig.style).trim() : undefined;

        // Récupérer la couche depuis le registre
        const layerData = GeoJSONShared.state.layers?.get(layerId);

        // Si la couche n'existe pas, essayer de la charger automatiquement
        if (!layerData) {
            return _ThemeApplier._loadLayerFromProfile(layerId).then((loadedLayer) => {
                if (loadedLayer) {
                    return _ThemeApplier._setLayerVisibilityAndStyle(layerId, visible, styleId);
                } else {
                    return _ThemeApplier._scheduleLayerConfig(layerId, visible, styleId);
                }
            });
        }

        // La couche existe déjà, appliquer directement la visibilité
        return _ThemeApplier._setLayerVisibilityAndStyle(layerId, visible, styleId);
    };

    /**
     * Définit la visibilité et le style d'une couche
     * @param {string} layerId - ID de la couche
     * @param {boolean} visible - Visibilité souhaitée
     * @param {string} styleId - ID du style à appliquer
     * @returns {Promise<void>}
     * @private
     */
    _ThemeApplier._setLayerVisibilityAndStyle = function (layerId, visible, styleId) {
        const layerData = GeoJSONShared.state.layers?.get(layerId);
        if (!layerData) {
            return Promise.resolve();
        }

        const VisibilityManager$1 = VisibilityManager;
        if (!VisibilityManager$1) {
            return Promise.resolve();
        }

        if (visible) {
            // Utiliser le gestionnaire centralisé avec source THEME
            VisibilityManager$1.setVisibility(layerId, true, VisibilityManager$1.VisibilitySource.THEME);

            // Appliquer le style si spécifié
            if (styleId && LayerManager$2?.setLayerStyle) {
                const availableStyles = layerData.config?.styles?.available || [];
                let effectiveStyleId = styleId;
                let styleExists = availableStyles.some((s) => s.id === styleId);

                // Fallback: si 'default' n'existe pas, essayer 'défaut' (et vice-versa)
                if (!styleExists) {
                    const fallbackMap = {
                        default: "défaut",
                        défaut: "default",
                    };
                    const fallbackStyleId = fallbackMap[styleId];
                    if (fallbackStyleId) {
                        const fallbackExists = availableStyles.some((s) => s.id === fallbackStyleId);
                        if (fallbackExists) {
                            effectiveStyleId = fallbackStyleId;
                            styleExists = true;
                        }
                    }
                }

                if (styleExists) {
                    const styleFile = availableStyles.find((s) => s.id === effectiveStyleId)?.file;
                    if (styleFile) {
                        let profileId = "default";
                        if (Config && typeof Config.getActiveProfile === "function") {
                            const activeProfile = Config.getActiveProfile();
                            profileId = activeProfile?.id || "default";
                        }

                        const layerDirectory = layerData._layerDirectory || layerId;

                        const localStyleLoader = StyleLoader;
                        if (!localStyleLoader) {
                            if (Log) Log.error(`[ThemeApplier] StyleLoader non disponible`);
                            return Promise.resolve();
                        }

                        return localStyleLoader
                            .loadAndValidateStyle(
                                profileId,
                                layerId,
                                effectiveStyleId,
                                styleFile,
                                `layers/${layerDirectory}`
                            )
                            .then((result) => {
                                const styleConfig = result.styleData;
                                LayerManager$2.setLayerStyle(layerId, styleConfig);

                                // Stocker currentStyle pour les labels
                                const layerDataForStyle = GeoJSONShared.state.layers?.get(layerId);
                                if (layerDataForStyle) {
                                    layerDataForStyle.currentStyle = styleConfig;
                                }

                                // Initialiser les labels si configurés
                                if (Labels && typeof Labels.initializeLayerLabels === "function") {
                                    Labels.initializeLayerLabels(layerId);
                                }

                                // Mettre à jour l'état du bouton des labels
                                if (LabelButtonManager) {
                                    LabelButtonManager.syncImmediate(layerId);
                                }

                                // Synchroniser l'UI du Layer Manager
                                if (LayerManager && typeof LayerManager.refresh === "function") {
                                    LayerManager.refresh();
                                }

                                // Mettre à jour le style actuel dans le sélecteur
                                if (StyleSelector) {
                                    StyleSelector.setCurrentStyle(layerId, styleId);
                                }

                                // Rafraîchir le sélecteur dans l'UI
                                _ThemeApplier._updateStyleSelector(layerId, styleId);

                                // Charger la légende correspondante
                                _ThemeApplier._loadLegendForStyle(layerId, styleId);

                                return result;
                            })
                            .catch((_err) => {
                                // Silencieux — erreur déjà loguée par StyleLoader
                            });
                    }
                }
            }
        } else {
            // Masquer la couche avec source THEME
            VisibilityManager$1.setVisibility(layerId, false, VisibilityManager$1.VisibilitySource.THEME);

            // Désactiver les labels et mettre à jour le bouton
            if (Labels) {
                Labels.disableLabels(layerId);
            }
            if (LabelButtonManager) {
                LabelButtonManager.syncImmediate(layerId);
            }
        }

        return Promise.resolve();
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    /**
     * Module GeoLeaf.UI.Branding
     *
     * Rôle :
     * - Afficher un texte de branding personnalisable
     * - Positionner le contrôle selon la configuration
     * - Permettre l'activation/désactivation via configuration
     */
    const Branding = {
        /**
         * Référence à la carte Leaflet.
         * @type {L.Map|null}
         * @private
         */
        _map: null,

        /**
         * Référence au contrôle Leaflet de branding.
         * @type {L.Control|null}
         * @private
         */
        _control: null,

        /**
         * Options du module
         * @type {Object}
         * @private
         */
        _options: {
            position: "bottomleft",
            text: "Propulsé par © GeoLeaf with Leaflet",
        },

        /**
         * Initialise le module de branding
         * @param {L.Map} map - Instance de la carte Leaflet
         * @param {Object} options - Options de configuration
         */
        init(map, options = {}) {
            const context = "[GeoLeaf.UI.Branding]";

            try {
                if (!map) {
                    throw new Error("Une instance de carte Leaflet est requise.");
                }

                this._map = map;
                this._options = Object.assign({}, this._options, options);

                // Source unique : geoleaf.config.json → clé "branding"
                // Aucun fallback vers profile.json (brandingConfig ignoré)
                const branding = Config?.get("branding");

                if (branding === undefined || branding === null) {
                    // Clé absente → avertissement visible sur la carte
                    console.warn("[GeoLeaf] branding key missing in geoleaf.config.json");
                    this._options.text = "⚠ Branding non configuré";
                    this._createControl();
                    return;
                }

                if (branding === false || (branding && branding.enabled === false)) {
                    Log.info(`${context} Branding désactivé dans la configuration.`);
                    return;
                }

                // text vide → silencieux
                if (branding.text === "") {
                    Log.info(`${context} Branding text vide — rien affiché.`);
                    return;
                }

                // Appliquer les options depuis geoleaf.config.json
                if (branding && typeof branding === "object") {
                    if (branding.text) {
                        this._options.text = branding.text;
                    }
                    if (branding.position) {
                        this._options.position = branding.position;
                    }
                }

                // Créer le contrôle Leaflet
                this._createControl();

                Log.info(`${context} Module initialisé avec succès.`);
            } catch (err) {
                Log.error(`${context} Erreur lors de l'initialisation :`, err.message);
            }
        },

        /**
         * Crée le contrôle Leaflet pour l'affichage du branding
         * @private
         */
        _createControl() {
            const context = "[GeoLeaf.UI.Branding]";

            try {
                // Définir le contrôle Leaflet personnalisé
                const BrandingControl = L.Control.extend({
                    options: {
                        position: this._options.position,
                    },

                    onAdd: () => {
                        // Créer le conteneur principal
                        const container = L.DomUtil.create("div", "geoleaf-branding");

                        // Empêcher les événements de la carte sur ce contrôle
                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);

                        // Créer l'élément d'affichage du texte
                        const brandingElement = L.DomUtil.create("div", "branding-content", container);
                        // SAFE: Utilisation de textContent pour éviter XSS
                        brandingElement.textContent = this._options.text;

                        return container;
                    },

                    onRemove: () => {
                        // Rien à nettoyer pour ce contrôle
                    },
                });

                // Créer et ajouter le contrôle à la carte
                this._control = new BrandingControl();
                this._control.addTo(this._map);

                Log.info(`${context} Contrôle de branding créé et ajouté à la carte.`);
            } catch (err) {
                Log.error(`${context} Erreur lors de la création du contrôle :`, err.message);
            }
        },

        /**
         * Détruit le contrôle et nettoie les ressources
         */
        destroy() {
            const context = "[GeoLeaf.UI.Branding]";

            try {
                if (this._control && this._map) {
                    this._map.removeControl(this._control);
                    this._control = null;
                }

                Log.info(`${context} Module détruit avec succès.`);
            } catch (err) {
                Log.error(`${context} Erreur lors de la destruction :`, err.message);
            }
        },

        /**
         * Active l'affichage du branding
         */
        show() {
            if (this._control && !this._map.hasControl(this._control)) {
                this._control.addTo(this._map);
            }
        },

        /**
         * Désactive l'affichage du branding
         */
        hide() {
            if (this._control && this._map) {
                this._map.removeControl(this._control);
            }
        },

        /**
         * Met à jour le texte du branding
         * @param {string} text - Nouveau texte
         */
        setText(text) {
            if (this._control) {
                const container = this._control.getContainer();
                if (container) {
                    const brandingElement = container.querySelector(".branding-content");
                    if (brandingElement) {
                        // SAFE: Utilisation de textContent pour éviter XSS
                        brandingElement.textContent = text;
                    }
                }
            }
        },
    };

    /**
     * @module ui/geolocation-state
     * @description ESM singleton store for geolocation UI state — Phase 10-B Pattern D
     *
     * ESM singleton replacing the mutable UI properties _geolocationActive / _geolocationWatchId /
     * _userPosition / _userPositionAccuracy.
     *
     * All reads and writes go through this module: consumers import GeoLocationState
     * and access/mutate its properties directly.
     *
     * The globals bridge (geoleaf.ui.js) keeps the UMD / CDN namespace aliases
     * in sync with this ESM singleton.
     *
     * @example
     * import { GeoLocationState } from '../geolocation-state.js';
     *
     * // Read
     * if (GeoLocationState.active) { ... }
     *
     * // Write
     * GeoLocationState.active = true;
     * GeoLocationState.watchId = navigator.geolocation.watchPosition(onSuccess, onError);
     * GeoLocationState.userPosition = { lat, lng, timestamp: Date.now(), accuracy };
     */

    /**
     * Mutable singleton holding geolocation tracking state.
     * @type {{
     *   active: boolean,
     *   watchId: number|null,
     *   userPosition: {lat: number, lng: number, timestamp: number, accuracy?: number}|null,
     *   userPositionAccuracy: number|null
     * }}
     */
    const GeoLocationState = {
        /** Whether the geolocation watch is currently active */
        active: false,

        /** ID returned by navigator.geolocation.watchPosition(), or null */
        watchId: null,

        /**
         * Last known user position, or null if geolocation has never succeeded.
         * @type {{ lat: number, lng: number, timestamp: number, accuracy?: number }|null}
         */
        userPosition: null,

        /** Last known accuracy in metres, or null */
        userPositionAccuracy: null,
    };

    /**
     * GeoLeaf Contract — POI AddForm (lazy-chunk boundary)
     *
     * Interface ESM pure pour accéder à AddFormOrchestrator et POIPlacementMode
     * depuis les modules UI (controls.js, fields-manager.js) sans couplage runtime.
     *
     * Phase 10-D — Pattern C : contrat de chunk POI AddForm.
     *
     * USAGE :
     *   import { POIAddFormContract } from '../contracts/poi-addform.contract.js';
     *
     *   if (POIAddFormContract.isAddFormAvailable()) {
     *       POIAddFormContract.openAddForm(latlng, null);
     *   }
     *
     *   POIAddFormContract.activatePlacementMode(map, callback);
     */

    /**
     * Phase 7 — Premium Separation:
     * AddFormOrchestrator and POIPlacementMode are now in GeoLeaf-Plugins/plugin-addpoi.
     * Access them only via globalThis.GeoLeaf at runtime (after the plugin is loaded).
     */
    function _getOrchestrator() {
        return (typeof globalThis !== "undefined" ? globalThis : window)?.GeoLeaf?.POI?.AddForm ?? null;
    }
    function _getPlacementMode() {
        return (
            (typeof globalThis !== "undefined" ? globalThis : window)?.GeoLeaf?.POI?.PlacementMode ??
            null
        );
    }

    /**
     * Contrat d'interface pour le module POI AddForm + PlacementMode.
     * @namespace POIAddFormContract
     */
    const POIAddFormContract = {
        /**
         * Retourne true si AddFormOrchestrator est disponible.
         * @returns {boolean}
         */
        isAddFormAvailable() {
            const orch = _getOrchestrator();
            return !!(orch && typeof orch.openAddForm === "function");
        },

        /**
         * Retourne true si PlacementMode est disponible.
         * @returns {boolean}
         */
        isPlacementModeAvailable() {
            const pm = _getPlacementMode();
            return !!(pm && typeof pm.activate === "function");
        },

        /**
         * Ouvre le formulaire d'ajout de POI.
         * @param {L.LatLng} latlng - Position initiale (optionnelle)
         * @param {Object|null} options - Options supplémentaires
         * @returns {Promise<void>}
         */
        async openAddForm(latlng, options) {
            return _getOrchestrator()?.openAddForm(latlng, options);
        },

        /**
         * Active le mode placement pour choisir une position sur la carte.
         * @param {L.Map} map - Instance de la carte Leaflet
         * @param {Function} callback - callback(result) avec result.latlng
         */
        activatePlacementMode(map, callback) {
            const pm = _getPlacementMode();
            if (pm && typeof pm.activate === "function") {
                pm.activate(map, callback);
            }
        },

        /**
         * Accès direct à AddFormOrchestrator (pour les cas où l'API complète est nécessaire).
         * @type {Object}
         */
        get orchestrator() {
            return _getOrchestrator();
        },

        /**
         * Accès direct à POIPlacementMode.
         * @type {Object}
         */
        get placementMode() {
            return _getPlacementMode();
        },
    };

    /*!
     * GeoLeaf Core
     * Ã‚Â© 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ========================================
    //   FULLSCREEN CONTROL
    // ========================================

    /**
     * Gestion du plein ÃƒÂ©cran pour la carte
     * @param {L.Map} map - Instance de la carte Leaflet
     * @param {HTMLElement} mapContainer - Le conteneur de la carte ÃƒÂ  mettre en plein ÃƒÂ©cran
     */
    function initFullscreenControl(map, mapContainer) {
        if (!map || !mapContainer) {
            if (Log) Log.warn("[UI.Controls] initFullscreenControl: carte ou conteneur manquant");
            return;
        }

        // VÃƒÂ©rifier que Leaflet est disponible
        if (typeof L === "undefined" || !L.Control) {
            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
            return;
        }

        // ContrÃƒÂ´le Leaflet personnalisÃƒÂ©
        L.Control.Fullscreen = L.Control.extend({
            options: {
                position: "topleft",
            },

            onAdd: function (map) {
                const container = L.DomUtil.create(
                    "div",
                    "leaflet-control-fullscreen leaflet-bar leaflet-control"
                );
                const link = L.DomUtil.create("a", "", container);

                link.href = "#";
                link.title = "Plein ÃƒÂ©cran";
                link.setAttribute("role", "button");
                link.setAttribute("aria-label", "Activer le mode plein ÃƒÂ©cran");

                // Fullscreen ENTER icon (static SVG)
                // SAFE: SVG statique hardcodÃƒÂ©
                const svgEnter = DOMSecurity.createSVGIcon(
                    18,
                    18,
                    "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3",
                    {
                        stroke: "currentColor",
                        strokeWidth: "2",
                        fill: "none",
                    }
                );
                svgEnter.classList.add("fullscreen-enter-icon");

                // Fullscreen EXIT icon (static SVG)
                // SAFE: SVG statique hardcodÃƒÂ©
                const svgExit = DOMSecurity.createSVGIcon(
                    18,
                    18,
                    "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3",
                    {
                        stroke: "currentColor",
                        strokeWidth: "2",
                        fill: "none",
                    }
                );
                svgExit.classList.add("fullscreen-exit-icon");
                svgExit.style.display = "none"; // CachÃƒÂ© par dÃƒÂ©faut

                link.appendChild(svgEnter);
                link.appendChild(svgExit);

                // Ãƒâ€°viter la propagation vers la carte
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                // Debounce pour invalidateSize
                const debouncedInvalidateSize = debounce
                    ? debounce(() => map.invalidateSize(), 200)
                    : () => map.invalidateSize();

                // Fonction pour mettre ÃƒÂ  jour l'icÃƒÂ´ne
                const updateIcon = (isFullscreen) => {
                    if (isFullscreen) {
                        svgEnter.style.display = "none";
                        svgExit.style.display = "block";
                    } else {
                        svgEnter.style.display = "block";
                        svgExit.style.display = "none";
                    }
                };

                const toggleFullscreen = (e) => {
                    L.DomEvent.preventDefault(e);

                    if (!document.fullscreenElement) {
                        // Entrer en plein ÃƒÂ©cran
                        mapContainer
                            .requestFullscreen()
                            .then(() => {
                                link.classList.add("is-fullscreen");
                                link.title = "Quitter le plein ÃƒÂ©cran";
                                link.setAttribute("aria-label", "Quitter le mode plein ÃƒÂ©cran");
                                updateIcon(true);
                                debouncedInvalidateSize();
                            })
                            .catch((err) => {
                                if (Log) Log.error("[UI.Controls] Erreur plein ÃƒÂ©cran:", err);
                            });
                    } else {
                        // Quitter le plein ÃƒÂ©cran
                        document
                            .exitFullscreen()
                            .then(() => {
                                link.classList.remove("is-fullscreen");
                                link.title = "Plein ÃƒÂ©cran";
                                link.setAttribute("aria-label", "Activer le mode plein ÃƒÂ©cran");
                                updateIcon(false);
                                debouncedInvalidateSize();
                            })
                            .catch((err) => {
                                if (Log) Log.error("[UI.Controls] Erreur sortie plein ÃƒÂ©cran:", err);
                            });
                    }
                };

                const fullscreenChangeHandler = () => {
                    if (!document.fullscreenElement) {
                        link.classList.remove("is-fullscreen");
                        link.title = "Plein ÃƒÂ©cran";
                        link.setAttribute("aria-label", "Activer le mode plein ÃƒÂ©cran");
                        updateIcon(false);
                        debouncedInvalidateSize();
                    }
                };

                L.DomEvent.on(link, "click", toggleFullscreen);
                L.DomEvent.on(link, "keydown", (e) => {
                    if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
                        toggleFullscreen(e);
                    }
                });

                document.addEventListener("fullscreenchange", fullscreenChangeHandler);

                this._fullscreenChangeHandler = fullscreenChangeHandler;
                this._toggleFullscreen = toggleFullscreen;
                this._link = link;
                this._mapContainer = mapContainer;
                this._debouncedInvalidateSize = debouncedInvalidateSize;

                return container;
            },

            onRemove: function (_map) {
                // MEMORY LEAK FIX (Phase 2): Clean up circular references in closures
                if (this._fullscreenChangeHandler) {
                    document.removeEventListener("fullscreenchange", this._fullscreenChangeHandler);
                    this._fullscreenChangeHandler = null;
                }

                if (this._link) {
                    L.DomEvent.off(this._link, "click", this._toggleFullscreen);
                    L.DomEvent.off(this._link, "keydown");
                    this._link = null;
                }

                // Clean up closure references to prevent memory leaks
                this._toggleFullscreen = null;
                this._mapContainer = null;
                this._debouncedInvalidateSize = null;
            },
        });

        new L.Control.Fullscreen().addTo(map);
        if (Log) Log.info("[UI.Controls] ContrÃƒÂ´le plein ÃƒÂ©cran ajoutÃƒÂ© ÃƒÂ  la carte");
    }

    // ========================================
    //   GEOLOCATION CONTROL
    // ========================================

    /**
     * Gestion de la gÃƒÂ©olocalisation pour centrer la carte sur la position de l'utilisateur
     * @param {L.Map} map - Instance de la carte Leaflet
     * @param {Object} config - Configuration incluant ui.enableGeolocation
     */
    function initGeolocationControl(map, config) {
        if (!map) {
            if (Log) Log.warn("[UI.Controls] initGeolocationControl: carte manquante");
            return;
        }

        // VÃƒÂ©rifier si la gÃƒÂ©olocalisation est activÃƒÂ©e dans la config
        if (!config?.ui?.enableGeolocation) {
            if (Log)
                Log.info("[UI.Controls] GÃƒÂ©olocalisation dÃƒÂ©sactivÃƒÂ©e dans la configuration");
            return;
        }

        // VÃƒÂ©rifier que Leaflet est disponible
        if (typeof L === "undefined" || !L.Control) {
            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
            return;
        }

        // VÃƒÂ©rifier que l'API de gÃƒÂ©olocalisation est disponible
        if (!navigator.geolocation) {
            if (Log)
                Log.warn(
                    "[UI.Controls] La gÃƒÂ©olocalisation n'est pas supportÃƒÂ©e par ce navigateur"
                );
            return;
        }

        // Marqueur de position utilisateur (stockÃƒÂ© pour pouvoir le supprimer/mettre ÃƒÂ  jour)
        let userMarker = null;
        let accuracyCircle = null;

        // ContrÃƒÂ´le Leaflet personnalisÃƒÂ©
        L.Control.Geolocation = L.Control.extend({
            options: {
                position: "topleft",
            },

            onAdd: function (map) {
                const container = L.DomUtil.create(
                    "div",
                    "leaflet-control-geolocation leaflet-bar leaflet-control"
                );
                const link = L.DomUtil.create("a", "", container);

                link.href = "#";
                link.title = "GÃƒÂ©olocalisation ON/OFF";
                link.setAttribute("role", "button");
                link.setAttribute("aria-label", "Activer/DÃƒÂ©sactiver le suivi GPS");

                // IcÃƒÂ´ne de gÃƒÂ©olocalisation (utilisation d'un SVG ou Unicode)
                // SAFE: SVG statique hardcodÃƒÂ©, pas de donnÃƒÂ©es utilisateur
                const geoSvg = DOMSecurity.createSVGIcon(
                    18,
                    18,
                    "M12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 C 22 6.5 17.5 2 12 2 M12 9 C 10.3 9 9 10.3 9 12 C 9 13.7 10.3 15 12 15 C 13.7 15 15 13.7 15 12 C 15 10.3 13.7 9 12 9",
                    {
                        stroke: "currentColor",
                        strokeWidth: "2",
                        fill: "none",
                    }
                );
                link.appendChild(geoSvg);

                // Ãƒâ€°viter la propagation vers la carte
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                const toggleGeolocation = (e) => {
                    L.DomEvent.preventDefault(e);

                    // Si déjà actif, désactiver
                    if (GeoLocationState.active) {
                        // Désactiver le tracking
                        if (GeoLocationState.watchId !== null) {
                            navigator.geolocation.clearWatch(GeoLocationState.watchId);
                            GeoLocationState.watchId = null;
                        }

                        // Retirer les marqueurs et cercles
                        if (userMarker) {
                            map.removeLayer(userMarker);
                            userMarker = null;
                        }
                        if (accuracyCircle) {
                            map.removeLayer(accuracyCircle);
                            accuracyCircle = null;
                        }

                        // Réinitialiser l'état
                        GeoLocationState.active = false;
                        GeoLocationState.userPosition = null;

                        link.classList.remove("is-active");
                        link.classList.remove("is-locating");

                        if (Log) Log.info("[UI.Controls] GÃƒÂ©olocalisation dÃƒÂ©sactivÃƒÂ©e");
                        return;
                    }

                    // Activer le mode gÃƒÂ©olocalisation
                    link.classList.add("is-locating");

                    // Utiliser watchPosition pour un tracking continu
                    GeoLocationState.watchId = navigator.geolocation.watchPosition(
                        (position) => {
                            const { latitude, longitude, accuracy } = position.coords;

                            // Première activation : centrer la carte
                            if (!GeoLocationState.active) {
                                map.setView([latitude, longitude], 16, {
                                    animate: true,
                                    duration: 0.5,
                                });
                            }

                            // Supprimer l'ancien marqueur et cercle s'ils existent
                            if (userMarker) {
                                map.removeLayer(userMarker);
                            }
                            if (accuracyCircle) {
                                map.removeLayer(accuracyCircle);
                            }

                            // CrÃƒÂ©er un nouveau marqueur pour la position de l'utilisateur
                            userMarker = L.marker([latitude, longitude], {
                                icon: L.divIcon({
                                    className:
                                        "gl-user-location-marker gl-user-location-marker--active",
                                    html: `<div class="gl-user-location-dot gl-user-location-dot--active"></div>`,
                                    iconSize: [22, 22],
                                    iconAnchor: [11, 11],
                                }),
                                zIndexOffset: 1000,
                            }).addTo(map);

                            // Ajouter un cercle de prÃƒÂ©cision
                            if (accuracy && accuracy < 1000) {
                                const interactiveShapes = Config.get("ui.interactiveShapes", false);
                                accuracyCircle = L.circle([latitude, longitude], {
                                    radius: accuracy,
                                    className: "gl-user-location-accuracy",
                                    fillColor: "#4285F4",
                                    fillOpacity: 0.1,
                                    stroke: true,
                                    color: "#4285F4",
                                    opacity: 0.3,
                                    weight: 1,
                                    interactive: interactiveShapes,
                                }).addTo(map);
                            }

                            // Mettre à jour l'état
                            GeoLocationState.active = true;
                            link.classList.remove("is-locating");
                            link.classList.add("is-active");

                            // Stocker la position GPS pour utilisation par d'autres fonctionnalités (ex: recherche par proximité)
                            GeoLocationState.userPosition = {
                                lat: latitude,
                                lng: longitude,
                                accuracy: accuracy,
                                timestamp: Date.now(),
                            };

                            if (Log)
                                Log.debug(
                                    "[UI.Controls] Position GPS mise ÃƒÂ  jour:",
                                    latitude,
                                    longitude
                                );
                        },
                        (error) => {
                            link.classList.remove("is-locating");
                            link.classList.remove("is-active");
                            GeoLocationState.active = false;

                            let errorMessage = "Impossible d'obtenir votre position";
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMessage = "Permission de gÃƒÂ©olocalisation refusÃƒÂ©e";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMessage = "Position indisponible";
                                    break;
                                case error.TIMEOUT:
                                    errorMessage = "DÃƒÂ©lai de gÃƒÂ©olocalisation dÃƒÂ©passÃƒÂ©";
                                    break;
                            }

                            if (Log) Log.error("[UI.Controls] Erreur de gÃƒÂ©olocalisation:", error);

                            // Afficher un message ÃƒÂ  l'utilisateur via le systÃƒÂ¨me de notifications
                            if (_UINotifications && typeof _UINotifications.error === "function") {
                                _UINotifications.error(errorMessage);
                            } else {
                                Log.warn("[UI.Controls] " + errorMessage);
                            }
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0,
                        }
                    );
                };

                L.DomEvent.on(link, "click", toggleGeolocation);
                L.DomEvent.on(link, "keydown", (e) => {
                    if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
                        toggleGeolocation(e);
                    }
                });

                this._link = link;
                this._userMarker = userMarker;

                return container;
            },

            onRemove: function (map) {
                if (this._link) {
                    L.DomEvent.off(this._link, "click");
                    L.DomEvent.off(this._link, "keydown");
                    this._link = null;
                }

                if (this._userMarker) {
                    map.removeLayer(this._userMarker);
                    this._userMarker = null;
                }
            },
        });

        new L.Control.Geolocation().addTo(map);
        if (Log) Log.info("[UI.Controls] ContrÃƒÂ´le de gÃƒÂ©olocalisation ajoutÃƒÂ© ÃƒÂ  la carte");
    }

    // ========================================
    //   POI ADD CONTROL
    // ========================================

    /**
     * Gestion du bouton d'ajout de POI sur la carte
     * Permet aux utilisateurs d'ajouter de nouveaux points d'intÃƒÂ©rÃƒÂªt
     * @param {L.Map} map - Instance de la carte Leaflet
     * @param {Object} config - Configuration incluant ui.showAddPoi et poi.*
     */
    function initPoiAddControl(map, config) {
        if (!map) {
            if (Log) Log.warn("[UI.Controls] initPoiAddControl: carte manquante");
            return;
        }

        // VÃƒÂ©rifier si le bouton POI Add est activÃƒÂ©
        if (!config?.ui?.showAddPoi) {
            if (Log) Log.debug("[UI.Controls] Bouton POI Add dÃƒÂ©sactivÃƒÂ© dans la configuration");
            return;
        }

        // VÃƒÂ©rifier que Leaflet est disponible
        if (typeof L === "undefined" || !L.Control) {
            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
            return;
        }

        // VÃƒÂ©rifier que les modules POI sont chargÃƒÂ©s
        if (
            !POIAddFormContract.isAddFormAvailable() ||
            !POIAddFormContract.isPlacementModeAvailable()
        ) {
            if (Log) Log.warn("[UI.Controls] Modules POI non chargÃƒÂ©s");
            return;
        }

        // ContrÃƒÂ´le Leaflet personnalisÃƒÂ© pour l'ajout de POI
        L.Control.PoiAdd = L.Control.extend({
            options: {
                position: "topleft",
            },

            onAdd: function (map) {
                const container = L.DomUtil.create(
                    "div",
                    "leaflet-control-poi-add leaflet-bar leaflet-control"
                );
                const link = L.DomUtil.create("a", "", container);

                link.href = "#";
                link.title = "Ajouter un POI";
                link.setAttribute("role", "button");
                link.setAttribute("aria-label", "Ajouter un nouveau point d'intÃƒÂ©rÃƒÂªt");

                // IcÃƒÂ´ne d'ajout de POI (SVG statique)
                // SAFE: SVG statique hardcodÃƒÂ©, pas de donnÃƒÂ©es utilisateur
                const poiSvg = DOMSecurity.createSVGIcon(
                    18,
                    18,
                    "M12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 C 22 6.5 17.5 2 12 2 M12 8 L12 16 M8 12 L16 12",
                    {
                        stroke: "currentColor",
                        strokeWidth: "2",
                        fill: "none",
                    }
                );
                link.appendChild(poiSvg);

                // Ãƒâ€°viter la propagation vers la carte
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                const handleAddPoi = (e) => {
                    L.DomEvent.preventDefault(e);

                    // DÃƒÂ©sactiver le bouton temporairement
                    link.classList.add("disabled");

                    // Fonction pour ouvrir le formulaire
                    const openForm = (latlng) => {
                        link.classList.remove("disabled");

                        if (!POIAddFormContract.isAddFormAvailable()) {
                            if (Log) Log.error("[UI.Controls] AddForm.openAddForm non disponible");
                            return;
                        }

                        POIAddFormContract.openAddForm(latlng, null);
                    };

                    // VÃƒÂ©rifier si la gÃƒÂ©olocalisation est disponible et si elle est le mode par dÃƒÂ©faut
                    const userPosition = GeoLocationState.userPosition;
                    const defaultPosition = config?.poiAddConfig?.defaultPosition || "placement-mode";

                    if (userPosition && defaultPosition === "geolocation") {
                        // Utiliser la position GPS
                        if (Log)
                            Log.debug(
                                "[UI.Controls] Utilisation de la position GPS pour l'ajout de POI"
                            );
                        openForm(userPosition);
                    } else {
                        // Activer le mode placement
                        if (Log)
                            Log.debug("[UI.Controls] Activation du mode placement pour l'ajout de POI");
                        POIAddFormContract.activatePlacementMode(map, (result) => {
                            if (result?.latlng) {
                                openForm(result.latlng);
                            } else {
                                link.classList.remove("disabled");
                                if (Log) Log.warn("[UI.Controls] Mode placement cancelled");
                            }
                        });
                    }
                };

                L.DomEvent.on(link, "click", handleAddPoi);
                L.DomEvent.on(link, "keydown", (e) => {
                    if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
                        handleAddPoi(e);
                    }
                });

                this._link = link;

                return container;
            },

            onRemove: function (_map) {
                if (this._link) {
                    L.DomEvent.off(this._link, "click");
                    L.DomEvent.off(this._link, "keydown");
                    this._link = null;
                }
            },
        });

        new L.Control.PoiAdd().addTo(map);
        if (Log) Log.info("[UI.Controls] ContrÃƒÂ´le POI Add ajoutÃƒÂ© ÃƒÂ  la carte");
    }

    // ========================================
    //   EXPORT
    // ========================================

    const _UIControls = {
        initFullscreenControl,
        initGeolocationControl,
        initPoiAddControl,
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        /**
         * Contexte pour les logs
         * @const
         */
        const CONTEXT = "[GeoLeaf.UI.CoordinatesDisplay]";

        /**
         * Texte par défaut des coordonnées
         * @const
         */
        const DEFAULT_COORDS_TEXT = "Lat: --, Lng: --";

        /**
         * Module GeoLeaf.UI.CoordinatesDisplay
         *
         * Rôle :
         * - Afficher les coordonnées du curseur en temps réel
         * - Positionner le contrôle en bas à droite à côté de la légende
         * - Permettre l'activation/désactivation via configuration
         */
        const CoordinatesDisplay = {
            /**
             * Référence à la carte Leaflet.
             * @type {L.Map|null}
             * @private
             */
            _map: null,

            /**
             * Référence au contrôle Leaflet des coordonnées.
             * @type {L.Control|null}
             * @private
             */
            _control: null,

            /**
             * Element DOM pour l'affichage des coordonnées
             * @type {HTMLElement|null}
             * @private
             */
            _coordsElement: null,

            /**
             * Référence bound du listener mousemove (pour pouvoir le retirer)
             * @type {Function|null}
             * @private
             */
            _boundMouseMoveHandler: null,

            /**
             * Options du module
             * @type {Object}
             * @private
             */
            _options: {
                position: "bottomleft",
                decimals: 6
            },

            /**
             * Initialise le module de coordonnées
             * @param {L.Map} map - Instance de la carte Leaflet
             * @param {Object} options - Options de configuration
             */
            init(map, options = {}) {
                try {
                    if (!map) {
                        throw new Error("Une instance de carte Leaflet est requise.");
                    }

                    this._map = map;
                    this._options = Object.assign({}, this._options, options);

                    // Vérifier si le module est activé dans la config
                    const showCoordinates = Config?.get("ui.showCoordinates");

                    if (showCoordinates === false) {
                        Log.info(`${CONTEXT} Affichage des coordonnées désactivé dans la configuration.`);
                        return;
                    }

                    // Stocker la référence bound du listener
                    this._boundMouseMoveHandler = this._onMouseMove.bind(this);

                    // Créer le contrôle Leaflet
                    this._createControl();

                    Log.info(`${CONTEXT} Module initialisé avec succès.`);

                } catch (err) {
                    Log.error(`${CONTEXT} Erreur lors de l'initialisation :`, err.message);
                }
            },

            /**
             * Crée le contrôle Leaflet pour l'affichage des coordonnées
             * @private
             */
            _createControl() {
                try {
                    // Perf 6.2.4: MutationObserver instead of setTimeout(100) for robustness
                    // Wait for .gl-scale-main-wrapper to appear in DOM without a fixed delay
                    const scaleWrapper = document.querySelector('.gl-scale-main-wrapper');

                    if (scaleWrapper) {
                        this._attachToScaleWrapper(scaleWrapper);
                    } else {
                        // Wrapper not yet in DOM: observe body until it appears
                        const observer = new MutationObserver((_mutations, obs) => {
                            const el = document.querySelector('.gl-scale-main-wrapper');
                            if (el) {
                                obs.disconnect();
                                this._attachToScaleWrapper(el);
                            }
                        });
                        observer.observe(document.body || document.documentElement, {
                            childList: true,
                            subtree: true
                        });
                        // Safety timeout: fallback to standalone after 5s if wrapper never appears
                        setTimeout(() => {
                            observer.disconnect();
                            if (!this._coordsElement) {
                                Log.warn(`${CONTEXT} Wrapper d'échelle non trouvé après 5s, utilisation du mode classique.`);
                                this._createStandaloneControl();
                            }
                        }, 5000);
                    }

                } catch (err) {
                    Log.error(`${CONTEXT} Erreur lors de la création du contrôle :`, err.message);
                }
            },

            /**
             * Attache les coordonnées au wrapper d'échelle existant
             * @param {HTMLElement} scaleWrapper - Wrapper d'échelle
             * @private
             */
            _attachToScaleWrapper(scaleWrapper) {
                // Ajouter un séparateur avant les coordonnées
                L.DomUtil.create('div', 'gl-scale-separator', scaleWrapper);

                // Créer l'élément d'affichage des coordonnées directement dans le wrapper
                this._coordsElement = L.DomUtil.create('div', 'gl-scale-coordinates', scaleWrapper);
                this._coordsElement.textContent = DEFAULT_COORDS_TEXT;

                // Ajouter l'écouteur d'événement mousemove avec référence stockée
                this._map.on('mousemove', this._boundMouseMoveHandler);

                Log.info(`${CONTEXT} Coordonnées intégrées au wrapper d'échelle.`);
            },

            /**
             * Crée un contrôle standalone en fallback
             * @private
             */
            _createStandaloneControl() {
                const CoordinatesControl = L.Control.extend({
                    options: {
                        position: this._options.position
                    },

                    onAdd: (map) => {
                        const container = L.DomUtil.create("div", "geoleaf-coordinates-display");
                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);
                        this._coordsElement = L.DomUtil.create("div", "coordinates-content", container);
                        this._coordsElement.textContent = DEFAULT_COORDS_TEXT;
                        map.on("mousemove", this._boundMouseMoveHandler);
                        return container;
                    },

                    onRemove: (map) => {
                        map.off("mousemove", this._boundMouseMoveHandler);
                    }
                });

                this._control = new CoordinatesControl();
                this._control.addTo(this._map);
            },

            /**
             * Gestionnaire d'événement pour le mouvement de la souris
             * @param {Object} e - Événement Leaflet
             * @private
             */
            _onMouseMove(e) {
                if (!this._coordsElement) return;

                const lat = e.latlng.lat.toFixed(this._options.decimals);
                const lng = e.latlng.lng.toFixed(this._options.decimals);

                this._coordsElement.textContent = `Lat: ${lat}, Lng: ${lng}`;
            },

            /**
             * Détruit le contrôle et nettoie les ressources
             */
            destroy() {
                try {
                    // Nettoyer l'écouteur d'événements avec la référence stockée
                    if (this._map && this._boundMouseMoveHandler) {
                        this._map.off('mousemove', this._boundMouseMoveHandler);
                        this._boundMouseMoveHandler = null;
                    }

                    // Retirer l'élément du DOM s'il existe
                    if (this._coordsElement && this._coordsElement.parentNode) {
                        this._coordsElement.parentNode.removeChild(this._coordsElement);
                        this._coordsElement = null;
                    }

                    // Retirer le contrôle standalone s'il existe
                    if (this._control && this._map) {
                        this._map.removeControl(this._control);
                        this._control = null;
                    }

                    Log.info(`${CONTEXT} Module détruit avec succès.`);

                } catch (err) {
                    Log.error(`${CONTEXT} Erreur lors de la destruction :`, err.message);
                }
            }
        };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const _UIDomUtils = {};

    // Delegate resolveField to canonical import (Phase 4 dedup)
    _UIDomUtils.resolveField = resolveField$1;

    /**
     * Attache le comportement d'accordéon (toggle open/close) à un conteneur.
     * Évite les attachements multiples avec un flag.
     * @param {HTMLElement} container - Conteneur parent avec des éléments .gl-accordion
     */
    _UIDomUtils.attachAccordionBehavior = function (container) {
        if (!container || container._glAccordionBound) return;
        container._glAccordionBound = true;

        container.addEventListener("click", function (evt) {
            const header = evt.target.closest(".gl-accordion__header");
            if (!header || !container.contains(header)) {
                return;
            }
            const section = header.closest(".gl-accordion");
            if (!section) return;

            section.classList.toggle("is-open");
        });
    };

    /**
     * Récupère le profil actif depuis GeoLeaf.Config.
     * @returns {Object|null} Objet profil ou null si indisponible
     */
    _UIDomUtils.getActiveProfileConfig = function () {
        if (
            !Config ||
            typeof Config.getActiveProfile !== "function"
        ) {
            Log.warn(
                "[UIDomUtils] GeoLeaf.Config.getActiveProfile() indisponible. Impossible de récupérer le profil actif."
            );
            return null;
        }
        const profile = Config.getActiveProfile();
        if (!profile) {
            Log.warn(
                "[UIDomUtils] Aucun profil actif retourné par GeoLeaf.Config.getActiveProfile()."
            );
        }
        return profile || null;
    };

    /**
     * Construit les <option> d'un select à partir de la taxonomie et d'un chemin optionsFrom.
     * @param {HTMLSelectElement} selectEl - Élément <select> à peupler
     * @param {Object} profile - Objet profil contenant la taxonomie
     * @param {string} optionsFrom - Chemin vers les options (ex: "taxonomy.categories")
     */
    _UIDomUtils.populateSelectOptionsFromTaxonomy = function (
        selectEl,
        profile,
        optionsFrom
    ) {
        if (!selectEl || !profile || !profile.taxonomy) return;

        const taxonomy = profile.taxonomy;
        const emptyOpt = createElement$1("option", {
            value: "",
            textContent: "— Tous —"
        });
        selectEl.appendChild(emptyOpt);

        if (optionsFrom === "taxonomy.categories") {
            const categories = taxonomy.categories || {};
            Object.keys(categories).forEach(function (catId) {
                const cat = categories[catId];
                const opt = createElement$1("option", {
                    value: catId,
                    textContent: cat.label || catId
                });
                selectEl.appendChild(opt);
            });
            return;
        }

        if (optionsFrom === "taxonomy.categories[*].subcategories") {
            const categories = taxonomy.categories || {};
            Object.keys(categories).forEach(function (catId) {
                const cat = categories[catId];
                const subs = (cat && cat.subcategories) || {};
                Object.keys(subs).forEach(function (subId) {
                    const sub = subs[subId];
                    const catLabel = cat.label || catId;
                    const subLabel = sub.label || subId;
                    const opt = createElement$1("option", {
                        value: subId,
                        textContent: catLabel + " – " + subLabel,
                        attributes: { "data-category-id": catId }
                    });
                    selectEl.appendChild(opt);
                });
            });
        }
    };

    /**
     * GeoLeaf UI Module - Event Delegation
     * Centralisation de la gestion des événements UI avec patterns de délégation efficaces
     *
     * @module ui/event-delegation
     * @author Assistant
     * @version 1.0.0
     */

    // ========================================
    //   CONSTANTES & ÉTAT
    // ========================================

    /**
     * Map des listeners actifs pour cleanup
     * @type {Map<string, {element: HTMLElement, event: string, handler: Function}>}
     */
    const _activeListeners = new Map();

    /**
     * Compteur pour identifiants uniques des listeners
     * @type {number}
     */
    let _listenerIdCounter = 0;

    // ========================================
    //   UTILITAIRES DE DÉLÉGATION
    // ========================================

    /**
     * Attache un event listener avec tracking automatique pour cleanup
     * @param {HTMLElement} element - Élément DOM
     * @param {string} event - Type d'événement
     * @param {Function} handler - Handler de l'événement
     * @param {Object} options - Options pour addEventListener
     * @returns {string} ID unique du listener pour cleanup
     */
    function attachTrackedListener(element, event, handler, options = {}) {
        if (!element || typeof handler !== 'function') {
            if (Log) Log.warn("[UI.EventDelegation] attachTrackedListener: élement ou handler manquant");
            return null;
        }

        const listenerId = `listener_${++_listenerIdCounter}`;

        // Wrapper pour tracking automatique des erreurs
        const wrappedHandler = function(e) {
            try {
                return handler.call(this, e);
            } catch (error) {
                if (Log) Log.error("[UI.EventDelegation] Erreur dans handler:", error);
            }
        };

        element.addEventListener(event, wrappedHandler, options);

        _activeListeners.set(listenerId, {
            element,
            event,
            handler: wrappedHandler,
            originalHandler: handler
        });

        return listenerId;
    }

    /**
     * Détache un listener trackée
     * @param {string} listenerId - ID retourné par attachTrackedListener
     * @returns {boolean} True si succès
     */
    function detachTrackedListener(listenerId) {
        if (!listenerId || !_activeListeners.has(listenerId)) {
            return false;
        }

        const { element, event, handler } = _activeListeners.get(listenerId);
        element.removeEventListener(event, handler);
        _activeListeners.delete(listenerId);
        return true;
    }

    /**
     * Nettoie tous les listeners trackées
     * @returns {number} Nombre de listeners nettoyées
     */
    function cleanupAllListeners() {
        let cleaned = 0;
        for (const [listenerId, { element, event, handler }] of _activeListeners) {
            element.removeEventListener(event, handler);
            cleaned++;
        }
        _activeListeners.clear();
        if (Log && cleaned > 0) {
            Log.info(`[UI.EventDelegation] ${cleaned} listeners nettoyées`);
        }
        return cleaned;
    }

    // ========================================
    //   DÉLÉGATION PAR TYPES UI SPÉCIFIQUES
    // ========================================

    /**
     * Gère les événements des inputs de filtre avec debouncing
     * @param {HTMLElement} filterContainer - Conteneur des filtres
     * @param {Function} onFilterChange - Callback appelé lors des changements
     * @param {number} debounceMs - Délai de debounce (défaut: 300ms)
     * @returns {string[]} IDs des listeners créés
     */
    function attachFilterInputEvents(filterContainer, onFilterChange, debounceMs = 300) {
        if (!filterContainer || typeof onFilterChange !== 'function') {
            if (Log) Log.warn("[UI.EventDelegation] attachFilterInputEvents: paramètres manquants");
            return [];
        }

        const listenerIds = [];
        let debounceTimer = null;

        // Fonction debounce pour les inputs
        const debouncedHandler = function() {
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                onFilterChange();
            }, debounceMs);
        };

        // Délégation pour tous les inputs de type text/range
        const textInputHandler = function(e) {
            if (e.target.matches('input[type="text"], input[type="range"]')) {
                debouncedHandler();
            }
        };

        // Délégation pour les checkboxes (pas de debounce)
        const checkboxHandler = function(e) {
            if (e.target.matches('input[type="checkbox"]')) {
                onFilterChange();
            }
        };

        // Délégation pour les selects
        const selectHandler = function(e) {
            if (e.target.matches('select')) {
                onFilterChange();
            }
        };

        listenerIds.push(attachTrackedListener(filterContainer, 'input', textInputHandler));
        listenerIds.push(attachTrackedListener(filterContainer, 'change', checkboxHandler));
        listenerIds.push(attachTrackedListener(filterContainer, 'change', selectHandler));

        return listenerIds.filter(id => id !== null);
    }

    /**
     * Gère les événements d'accordéon avec délégation
     * @param {HTMLElement} container - Conteneur des accordéons
     * @returns {string} ID du listener créé
     */
    function attachAccordionEvents(container) {
        if (!container) {
            if (Log) Log.warn("[UI.EventDelegation] attachAccordionEvents: conteneur manquant");
            return null;
        }

        const accordionHandler = function(e) {
            // Cherche le bouton d'accordéon dans la hiérarchie
            const accordionButton = e.target.closest('.gl-accordion-toggle, .accordion-arrow');
            if (!accordionButton) return;

            e.preventDefault();
            e.stopPropagation();

            // Trouve le panel associé
            const panel = accordionButton.closest('.gl-accordion')?.querySelector('.gl-accordion-content');
            if (!panel) return;

            // Toggle accordéon
            const isExpanded = panel.style.display !== 'none';
            panel.style.display = isExpanded ? 'none' : 'block';

            // Met à jour l'aria-expanded
            accordionButton.setAttribute('aria-expanded', !isExpanded);

            // Met à jour l'icône si présente
            const icon = accordionButton.querySelector('.accordion-icon, .accordion-arrow');
            if (icon) {
                icon.classList.toggle('expanded', !isExpanded);
            }
        };

        return attachTrackedListener(container, 'click', accordionHandler);
    }

    /**
     * Gère les événements des contrôles de carte (delegation pour les boutons)
     * @param {HTMLElement} mapContainer - Conteneur de la carte
     * @param {Object} handlers - Map des handlers { selectorPattern: handlerFunction }
     * @returns {string[]} IDs des listeners créés
     */
    function attachMapControlEvents(mapContainer, handlers) {
        if (!mapContainer || !handlers || typeof handlers !== 'object') {
            if (Log) Log.warn("[UI.EventDelegation] attachMapControlEvents: paramètres manquants");
            return [];
        }

        const listenerIds = [];

        const controlHandler = function(e) {
            for (const [selector, handler] of Object.entries(handlers)) {
                if (e.target.matches(selector) || e.target.closest(selector)) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (typeof handler === 'function') {
                        handler.call(this, e);
                    }
                    break;
                }
            }
        };

        listenerIds.push(attachTrackedListener(mapContainer, 'click', controlHandler));
        return listenerIds.filter(id => id !== null);
    }

    // ========================================
    //   API PUBLIQUE
    // ========================================

    /**
     * Obtient le nombre de listeners actifs enregistrés
     * Utile pour le debugging et le monitoring des fuites mémoire
     * @returns {number} Nombre de listeners actifs
     */
    function getActiveListenersCount() {
        return _activeListeners.size;
    }

    /**
     * Récupère la liste complète des listeners actifs avec leurs métadonnées
     * @returns {string[]} Liste des IDs de listeners actifs
     */
    function getActiveListeners() {
        return Array.from(_activeListeners.keys());
    }

    const _UIEventDelegation = {
        attachTrackedListener,
        detachTrackedListener,
        cleanupAllListeners,
        attachFilterInputEvents,
        attachAccordionEvents,
        attachMapControlEvents,
        getActiveListenersCount,
        getActiveListeners
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        /**
         * Construit un contrôle de filtre individuel
         * @param {Object} filterDef - Définition du filtre
         * @param {Object} profile - Configuration du profil
         * @param {boolean} skipLabel - Sauter la création du label (défaut: false)
         * @returns {HTMLElement|null}
         */
        const _buildFilterControl = function(filterDef, profile, skipLabel) {
            if (!filterDef || !filterDef.id || !filterDef.type) return null;

            const wrapper = createElement$1("div", {
                className: "gl-filter-panel__group",
                attributes: { "data-gl-filter-id": filterDef.id }
            });

            let labelEl = null;
            // Ne pas créer de label si skipLabel est true (pour les accordéons qui ont leur propre titre)
            if (filterDef.label && !skipLabel) {
                labelEl = createElement$1("label", {
                    className: "gl-filter-panel__label",
                    textContent: filterDef.label
                });
                wrapper.appendChild(labelEl);
            }

            let control = null;

            // 1) SELECT / MULTISELECT classiques
            if (filterDef.type === "select" || filterDef.type === "multiselect") {
                const selectEl = createElement$1("select", {
                    className: "gl-filter-panel__control gl-filter-panel__control--select",
                    name: filterDef.id,
                    id: "gl-filter-" + filterDef.id
                });

                if (labelEl) {
                    labelEl.setAttribute("for", selectEl.id);
                }

                if (filterDef.type === "multiselect") {
                    selectEl.multiple = true;
                }

                control = selectEl;
            }

            // 2) SLIDER (range)
            else if (filterDef.type === "range") {
                const container = createElement$1("div", { className: "gl-filter-panel__range-wrapper" });

                const input = createElement$1("input", {
                    type: "range",
                    className: "gl-filter-panel__control gl-filter-panel__control--range",
                    id: "gl-filter-" + filterDef.id,
                    name: filterDef.id
                });

                if (labelEl) {
                    labelEl.setAttribute("for", input.id);
                }

                if (typeof filterDef.min === "number") input.min = String(filterDef.min);
                if (typeof filterDef.max === "number") input.max = String(filterDef.max);
                if (typeof filterDef.step === "number") input.step = String(filterDef.step);

                const valueLabel = createElement$1("span", { className: "gl-filter-panel__range-value" });

                let initialValue;
                if (typeof filterDef.default === "number") {
                    initialValue = filterDef.default;
                } else if (input.min && input.max) {
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);
                    initialValue = (min + max) / 2;
                } else {
                    initialValue = input.min ? parseFloat(input.min) : 0;
                }

                if (!isNaN(initialValue)) {
                    input.value = String(initialValue);
                    valueLabel.textContent = initialValue.toString().replace(".", ",");
                }

                input.addEventListener("input", function() {
                    const val = parseFloat(input.value);
                    if (!isNaN(val)) {
                        valueLabel.textContent = val.toString().replace(".", ",");
                    }
                });

                container.appendChild(input);
                container.appendChild(valueLabel);
                control = container;
            }

            // 3) TREE-VIEW catégories / sous-catégories
            else if (filterDef.type === "tree" || filterDef.type === "tree-category" || filterDef.type === "categoryTree") {
                // LAZY LOADING: Retourner un container vide avec marqueur
                const treeContainer = createElement$1("div", {
                    className: "gl-filter-panel__tree gl-filter-panel__tree--lazy",
                    attributes: {
                        "data-lazy-type": "categories",
                        "data-filter-id": filterDef.id
                    }
                });

                control = treeContainer;
            }

            // 4) CHECKBOX GROUP
            else if (filterDef.type === "checkbox-group") {
                const groupContainer = createElement$1("div", { className: "gl-filter-panel__checkbox-group" });

                if (Array.isArray(filterDef.options)) {
                    filterDef.options.forEach(function(opt) {
                        const label = createElement$1("label", { className: "gl-filter-panel__checkbox-label" });

                        const checkbox = createElement$1("input", {
                            type: "checkbox",
                            className: "gl-filter-panel__checkbox",
                            name: filterDef.id,
                            value: opt.id,
                            checked: !!opt.checked,
                            attributes: { "data-filter-option-id": opt.id }
                        });

                        const text = createElement$1("span", {
                            className: "gl-filter-panel__checkbox-text",
                            textContent: opt.label || opt.id
                        });

                        label.appendChild(checkbox);
                        label.appendChild(text);
                        groupContainer.appendChild(label);
                    });
                }
                control = groupContainer;
            }

            // 5) SEARCH
            else if (filterDef.type === "search") {
                const searchInput = createElement$1("input", {
                    type: "text",
                    className: "gl-filter-panel__control gl-filter-panel__control--search",
                    name: filterDef.id,
                    placeholder: filterDef.placeholder || "Filtrer..."
                });

                if (Array.isArray(filterDef.searchFields)) {
                    searchInput.setAttribute("data-search-fields", filterDef.searchFields.join(","));
                }

                control = searchInput;
            }

            // 6) PROXIMITY
            else if (filterDef.type === "proximity") {
                const proximityContainer = createElement$1("div", { className: "gl-filter-panel__proximity" });

                if (filterDef.label) {
                    const title = createElement$1("h3", {
                        className: "gl-filter-panel__proximity-title",
                        textContent: filterDef.label
                    });
                    proximityContainer.appendChild(title);
                }

                const button = createElement$1("button", {
                    type: "button",
                    className: "gl-btn gl-btn--secondary gl-filter-panel__proximity-btn",
                    attributes: { "data-filter-proximity-btn": "true" },
                    textContent: filterDef.buttonLabel || "Activer"
                });
                proximityContainer.appendChild(button);

                const rangeWrapper = createElement$1("div", {
                    className: "gl-filter-panel__proximity-range",
                    style: { display: "none" }
                });

                const rangeLabel = createElement$1("label", {
                    className: "gl-filter-panel__label",
                    textContent: "Rayon (km)",
                    attributes: { "for": "gl-filter-proximity-radius" }
                });
                rangeWrapper.appendChild(rangeLabel);

                const rangeContainer = createElement$1("div", { className: "gl-filter-panel__range-wrapper" });

                let minRadius = 1;
                let maxRadius = 50;
                let stepRadius = 1;
                let defaultRadius = 10;
                try {
                    const activeProfile = Config?.getActiveProfile?.();
                    if (activeProfile) {
                        const searchConfig = (activeProfile.panels && activeProfile.panels.search) || activeProfile.search;
                        if (searchConfig) {
                            if (typeof searchConfig.radiusMin === "number" && searchConfig.radiusMin > 0) {
                                minRadius = searchConfig.radiusMin;
                            }
                            if (typeof searchConfig.radiusMax === "number" && searchConfig.radiusMax > 0) {
                                maxRadius = searchConfig.radiusMax;
                            }
                            if (typeof searchConfig.radiusStep === "number" && searchConfig.radiusStep > 0) {
                                stepRadius = searchConfig.radiusStep;
                            }
                            if (typeof searchConfig.radiusDefault === "number" && searchConfig.radiusDefault > 0) {
                                defaultRadius = searchConfig.radiusDefault;
                            }
                            defaultRadius = Math.max(minRadius, Math.min(defaultRadius, maxRadius));
                        }
                    }
                } catch (err) {
                    Log?.warn?.("[GeoLeaf.UI] Erreur lecture radius config:", err);
                }

                const rangeInput = createElement$1("input", {
                    type: "range",
                    className: "gl-filter-panel__control gl-filter-panel__control--range",
                    id: "gl-filter-proximity-radius",
                    name: filterDef.id + "_radius",
                    min: String(minRadius),
                    max: String(maxRadius),
                    step: String(stepRadius),
                    value: String(defaultRadius),
                    attributes: { "data-filter-proximity-radius": "true" }
                });

                const rangeValue = createElement$1("span", {
                    className: "gl-filter-panel__range-value",
                    textContent: String(defaultRadius)
                });

                rangeInput.addEventListener("input", function() {
                    rangeValue.textContent = rangeInput.value;
                });

                rangeContainer.appendChild(rangeInput);
                rangeContainer.appendChild(rangeValue);
                rangeWrapper.appendChild(rangeContainer);

                const instruction = createElement$1("p", {
                    className: "gl-filter-panel__proximity-instruction",
                    textContent: filterDef.instructionText || "Cliquez sur la carte",
                    style: { display: "none" }
                });
                rangeWrapper.appendChild(instruction);

                proximityContainer.appendChild(rangeWrapper);
                control = proximityContainer;
            }

            // 7) TAGS
            else if (filterDef.type === "multiselect-tags" || filterDef.id === "tags") {
                const tagsContainer = createElement$1("div", {
                    className: "gl-filter-panel__tags-container",
                    attributes: {
                        "data-lazy-type": "tags",
                        "data-filter-id": filterDef.id
                    }
                });
                control = tagsContainer;
            }

            // Aucun type reconnu
            if (!control) {
                return null;
            }

            if (labelEl && control instanceof HTMLElement && !control.id) {
                const controlId = "gl-filter-" + filterDef.id;
                control.id = controlId;
                labelEl.setAttribute("for", controlId);
            }

            wrapper.appendChild(control);
            return wrapper;
        };

    /**
     * Fonctions globales pour le chargement lazy des filtres
     * Utilisées par le lazy-loader pour construire le contenu à la demande
     */

    /**
     * Construit le contenu HTML de l'arbre de catégories
     * @param {Object} scanResult - Résultat du scan ({usedIds: Set, visibleLayerIds: Array})
     * @returns {string} HTML string
     */
    function buildCategoryTreeContent(scanResult) {
        // Récupérer le profil actif via l'API Config (enrichedProfile contient taxonomy)
        const profile = (Config && typeof Config.getActiveProfile === "function")
            ? Config.getActiveProfile()
            : null;
        if (!profile || !profile.taxonomy || !profile.taxonomy.categories) {
            return '<div class="gl-empty-state">Aucune catégorie disponible</div>';
        }

        const categories = profile.taxonomy.categories;
        const usedCategoryIds = scanResult.usedIds;

        // Sécurité : échapper les valeurs dynamiques injectées dans le HTML
        const esc = (Security && typeof Security.escapeHtml === 'function')
            ? function(s) { return Security.escapeHtml(s); }
            : function(s) { return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); };

        // Comparaison insensible à la casse : normaliser les IDs scannés
        const usedLower = new Set();
        usedCategoryIds.forEach(function(id) { usedLower.add(id.toLowerCase()); });

        // Filtrer les catégories pour afficher celles utilisées (comparaison case-insensitive)
        const catIds = Object.keys(categories).filter(catId => usedLower.has(catId.toLowerCase()));

        if (catIds.length === 0) {
            return '<div class="gl-empty-state">ND - Non disponible</div>';
        }

        let html = '<ul class="gl-filter-tree gl-filter-tree--root">';

        catIds.forEach(function(catId) {
            const cat = categories[catId] || {};

            // Filtrer aussi les sous-catégories (comparaison case-insensitive)
            const subs = cat.subcategories || {};
            const subKeys = Object.keys(subs).filter(subId => usedLower.has(subId.toLowerCase()));
            const hasSubcategories = subKeys.length > 0;

            html += '<li class="gl-filter-tree__item gl-filter-tree__item--category">';
            html += '<div class="gl-filter-tree__row">';

            if (hasSubcategories) {
                html += '<span class="gl-filter-tree__arrow" data-category-id="' + esc(catId) + '">▶</span>';
            } else {
                html += '<span class="gl-filter-tree__spacer"></span>';
            }

            html += '<label class="gl-filter-tree__label gl-filter-tree__label--category">';
            html += '<input type="checkbox" class="gl-filter-tree__checkbox gl-filter-tree__checkbox--category" ';
            html += 'name="categories_category" value="' + esc(catId) + '" ';
            html += 'data-gl-filter-category-id="' + esc(catId) + '">';
            html += '<span class="gl-filter-tree__text">' + esc(cat.label || catId) + '</span>';
            html += '</label>';
            html += '</div>';

            if (hasSubcategories) {
                html += '<ul class="gl-filter-tree gl-filter-tree--subcategories">';

                subKeys.forEach(function(subId) {
                    const sub = subs[subId] || {};
                    html += '<li class="gl-filter-tree__item gl-filter-tree__item--subcategory">';
                    html += '<label class="gl-filter-tree__label gl-filter-tree__label--subcategory">';
                    html += '<input type="checkbox" class="gl-filter-tree__checkbox gl-filter-tree__checkbox--subcategory" ';
                    html += 'name="categories_subcategory" value="' + esc(subId) + '" ';
                    html += 'data-gl-filter-category-id="' + esc(catId) + '" ';
                    html += 'data-gl-filter-subcategory-id="' + esc(subId) + '">';
                    html += '<span class="gl-filter-tree__text">' + esc(sub.label || subId) + '</span>';
                    html += '</label>';
                    html += '</li>';
                });

                html += '</ul>';
            }

            html += '</li>';
        });

        html += '</ul>';
        return html;
    }

    /**
     * Construit le contenu HTML de la liste de tags
     * @param {Array} tags - Array de tags uniques triés
     * @returns {string} HTML string
     */
    function buildTagsListContent(tags) {
        if (!tags || tags.length === 0) {
            return '<div class="gl-empty-state">ND - Non disponible</div>';
        }

        // Sécurité : échapper les valeurs dynamiques
        const esc = (Security && typeof Security.escapeHtml === 'function')
            ? function(s) { return Security.escapeHtml(s); }
            : function(s) { return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); };

        let html = '';
        tags.forEach(function(tag) {
            html += '<span class="gl-filter-panel__tag-badge" data-tag-value="' + esc(tag) + '">' + esc(tag) + '</span>';
        });

        return html;
    }

    /**
     * Attache les event listeners pour l'arbre de catégories après rendering
     * Perf 6.2.2: Délégation d'événements — 3 listeners sur le container au lieu de N listeners individuels
     * @param {HTMLElement} container - Container de l'arbre
     */
    function attachCategoryTreeListeners(container) {
        // Délégation: 1 seul listener 'click' pour toutes les flèches
        container.addEventListener('click', function(e) {
            const arrow = e.target.closest('.gl-filter-tree__arrow');
            if (!arrow) return;
            e.stopPropagation();
            const li = arrow.closest('.gl-filter-tree__item--category');
            if (!li) return;
            const subList = li.querySelector('.gl-filter-tree--subcategories');
            if (subList) {
                const isExpanded = li.classList.contains('is-expanded');
                if (isExpanded) {
                    li.classList.remove('is-expanded');
                    arrow.textContent = '▶';
                } else {
                    li.classList.add('is-expanded');
                    arrow.textContent = '▼';
                }
            }
        });

        // Délégation: 1 seul listener 'change' pour toutes les checkboxes (catégories + sous-catégories)
        container.addEventListener('change', function(e) {
            const target = e.target;
            if (!target.matches('.gl-filter-tree__checkbox')) return;

            if (target.classList.contains('gl-filter-tree__checkbox--category')) {
                // Checkbox catégorie cochée → propager aux sous-catégories
                const li = target.closest('.gl-filter-tree__item--category');
                if (!li) return;
                const subCheckboxes = li.querySelectorAll('.gl-filter-tree__checkbox--subcategory');
                subCheckboxes.forEach(function(subCb) {
                    subCb.checked = target.checked;
                });
                target.indeterminate = false;
            } else if (target.classList.contains('gl-filter-tree__checkbox--subcategory')) {
                // Checkbox sous-catégorie cochée → mettre à jour l'état parent
                const liCat = target.closest('.gl-filter-tree__item--category');
                if (!liCat) return;
                const categoryCheckbox = liCat.querySelector('.gl-filter-tree__checkbox--category');
                const subCheckboxes = liCat.querySelectorAll('.gl-filter-tree__checkbox--subcategory');

                const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
                const totalCount = subCheckboxes.length;

                if (checkedCount === 0) {
                    categoryCheckbox.checked = false;
                    categoryCheckbox.indeterminate = false;
                } else if (checkedCount === totalCount) {
                    categoryCheckbox.checked = true;
                    categoryCheckbox.indeterminate = false;
                } else {
                    categoryCheckbox.checked = false;
                    categoryCheckbox.indeterminate = true;
                }
            }
        });
    }

    /**
     * Attache les event listeners pour les tags après rendering
     * Perf 6.2.2: Délégation d'événements — 1 listener sur le container au lieu de N badges
     * @param {HTMLElement} container - Container des tags
     */
    function attachTagsListeners(container) {
        container.addEventListener('click', function(e) {
            const badge = e.target.closest('.gl-filter-panel__tag-badge');
            if (badge) {
                badge.classList.toggle('is-selected');
            }
        });
    }

    /**
     * GeoLeaf UI Module - Filter State Manager
     * Gestion centralisée de l'état des filtres avec patterns observateur
     *
     * @module ui/filter-state-manager
     * @author Assistant
     * @version 1.0.0
     */

    // ========================================
    //   ÉTAT CENTRALISÉ DES FILTRES
    // ========================================

    /**
     * État actuel des filtres
     * @type {Object}
     * @private
     */
    let _filterState = {
        // État des filtres par ID
        values: new Map(),

        // Métadonnées des filtres
        metadata: new Map(),

        // Profil actuel
        activeProfile: null,

        // Callbacks observers
        observers: new Set()
    };

    /**
     * Timestamps pour debouncing
     * @type {Map<string, number>}
     * @private
     */
    const _debounceTimers = new Map();

    // ========================================
    //   GESTION DE L'ÉTAT DES FILTRES
    // ========================================

    /**
     * Initialise l'état des filtres depuis un profil
     * @param {Object} profile - Configuration du profil
     * @returns {boolean} Succès de l'initialisation
     */
    function initializeFromProfile(profile) {
        if (!profile || !profile.filters) {
            if (Log) Log.warn("[UI.FilterStateManager] Profil ou filtres manquants");
            return false;
        }

        // Réinitialise l'état
        _filterState.values.clear();
        _filterState.metadata.clear();
        _filterState.activeProfile = profile;

        // Configure chaque filtre avec ses valeurs par défaut
        profile.filters.forEach(filter => {
            if (!filter.id) return;

            const metadata = {
                type: filter.type,
                label: filter.label,
                required: !!filter.required,
                min: filter.min,
                max: filter.max,
                options: filter.options || [],
                optionsFrom: filter.optionsFrom
            };

            _filterState.metadata.set(filter.id, metadata);

            // Valeur par défaut selon le type
            let defaultValue = null;
            switch (filter.type) {
                case 'select':
                case 'multiselect':
                    defaultValue = filter.default || (filter.type === 'multiselect' ? [] : '');
                    break;
                case 'range':
                    defaultValue = filter.default ?? ((filter.min + filter.max) / 2);
                    break;
                case 'tree':
                case 'tree-category':
                case 'categoryTree':
                    defaultValue = filter.default || [];
                    break;
                default:
                    defaultValue = filter.default || '';
            }

            _filterState.values.set(filter.id, defaultValue);
        });

        // Notifie les observateurs
        _notifyObservers('init', null, _filterState.values);

        if (Log) {
            Log.info(`[UI.FilterStateManager] Initialisé avec ${_filterState.values.size} filtres`);
        }

        return true;
    }

    /**
     * Met à jour la valeur d'un filtre
     * @param {string} filterId - ID du filtre
     * @param {*} value - Nouvelle valeur
     * @param {boolean} skipNotify - Éviter la notification (défaut: false)
     * @returns {boolean} Succès de la mise à jour
     */
    function updateFilterValue(filterId, value, skipNotify = false) {
        if (!filterId || !_filterState.metadata.has(filterId)) {
            if (Log) Log.warn(`[UI.FilterStateManager] Filtre inconnu: ${filterId}`);
            return false;
        }

        const metadata = _filterState.metadata.get(filterId);
        const oldValue = _filterState.values.get(filterId);

        // Validation selon le type
        const validatedValue = _validateFilterValue(value, metadata);
        if (validatedValue === null && value !== null) {
            if (Log) Log.warn(`[UI.FilterStateManager] Valeur invalide pour ${filterId}:`, value);
            return false;
        }

        // Mise à jour
        _filterState.values.set(filterId, validatedValue);

        // Notification avec debouncing pour les ranges
        if (!skipNotify) {
            if (metadata.type === 'range') {
                _notifyWithDebounce(filterId, 'change', oldValue, validatedValue, 200);
            } else {
                _notifyObservers('change', filterId, validatedValue, oldValue);
            }
        }

        return true;
    }

    /**
     * Récupère la valeur d'un filtre
     * @param {string} filterId - ID du filtre
     * @returns {*} Valeur du filtre ou null si inexistant
     */
    function getFilterValue(filterId) {
        return _filterState.values.get(filterId) || null;
    }

    /**
     * Récupère toutes les valeurs de filtres
     * @returns {Object} Object avec filterId -> value
     */
    function getAllFilterValues() {
        return Object.fromEntries(_filterState.values);
    }

    /**
     * Récupère les métadonnées d'un filtre
     * @param {string} filterId - ID du filtre
     * @returns {Object|null} Métadonnées ou null
     */
    function getFilterMetadata(filterId) {
        return _filterState.metadata.get(filterId) || null;
    }

    /**
     * Remet à zéro tous les filtres
     * @param {boolean} skipNotify - Éviter la notification (défaut: false)
     */
    function resetAllFilters(skipNotify = false) {
        const oldState = new Map(_filterState.values);

        _filterState.values.forEach((value, filterId) => {
            const metadata = _filterState.metadata.get(filterId);
            if (!metadata) return;

            // Remise à zéro selon le type
            let resetValue = null;
            switch (metadata.type) {
                case 'multiselect':
                case 'tree':
                case 'tree-category':
                case 'categoryTree':
                    resetValue = [];
                    break;
                case 'range':
                    resetValue = (metadata.min + metadata.max) / 2;
                    break;
                default:
                    resetValue = '';
            }

            _filterState.values.set(filterId, resetValue);
        });

        if (!skipNotify) {
            _notifyObservers('reset', null, _filterState.values, oldState);
        }
    }

    // ========================================
    //   SYSTÈME D'OBSERVATEURS
    // ========================================

    /**
     * Ajoute un observateur pour les changements d'état
     * @param {Function} callback - Fonction appelée lors des changements
     * @returns {Function} Fonction pour désabonner l'observateur
     */
    function addObserver(callback) {
        if (typeof callback !== 'function') {
            if (Log) Log.warn("[UI.FilterStateManager] Observateur doit être une fonction");
            return () => {};
        }

        _filterState.observers.add(callback);

        // Retourne fonction de désabonnement
        return function unsubscribe() {
            _filterState.observers.delete(callback);
        };
    }

    /**
     * Notifie tous les observateurs
     * @param {string} type - Type de changement ('init', 'change', 'reset')
     * @param {string|null} filterId - ID du filtre changé (null pour global)
     * @param {*} newValue - Nouvelle valeur
     * @param {*} oldValue - Ancienne valeur
     * @private
     */
    function _notifyObservers(type, filterId, newValue, oldValue) {
        const event = {
            type,
            filterId,
            newValue,
            oldValue,
            timestamp: Date.now(),
            allValues: Object.fromEntries(_filterState.values)
        };

        _filterState.observers.forEach(callback => {
            try {
                callback(event);
            } catch (error) {
                if (Log) Log.error("[UI.FilterStateManager] Erreur dans observateur:", error);
            }
        });
    }

    /**
     * Notification avec debouncing
     * @param {string} filterId - ID du filtre
     * @param {string} type - Type d'événement
     * @param {*} oldValue - Ancienne valeur
     * @param {*} newValue - Nouvelle valeur
     * @param {number} delay - Délai de debounce
     * @private
     */
    function _notifyWithDebounce(filterId, type, oldValue, newValue, delay) {
        // Clear existing timer
        if (_debounceTimers.has(filterId)) {
            clearTimeout(_debounceTimers.get(filterId));
        }

        // Set new timer
        const timer = setTimeout(() => {
            _notifyObservers(type, filterId, newValue, oldValue);
            _debounceTimers.delete(filterId);
        }, delay);

        _debounceTimers.set(filterId, timer);
    }

    // ========================================
    //   VALIDATION DE VALEURS
    // ========================================

    /**
     * Valide une valeur selon les métadonnées du filtre
     * @param {*} value - Valeur à valider
     * @param {Object} metadata - Métadonnées du filtre
     * @returns {*} Valeur validée ou null si invalide
     * @private
     */
    function _validateFilterValue(value, metadata) {
        if (!metadata) return null;

        switch (metadata.type) {
            case 'select':
                return typeof value === 'string' ? value : '';

            case 'multiselect':
                return Array.isArray(value) ? value : [];

            case 'range':
                const num = parseFloat(value);
                if (isNaN(num)) return metadata.min || 0;
                if (metadata.min !== undefined && num < metadata.min) return metadata.min;
                if (metadata.max !== undefined && num > metadata.max) return metadata.max;
                return num;

            case 'tree':
            case 'tree-category':
            case 'categoryTree':
                return Array.isArray(value) ? value : [];

            default:
                return value;
        }
    }

    // ========================================
    //   UTILITAIRES DE REQUÊTES
    // ========================================

    /**
     * Vérifie si des filtres sont actuellement actifs
     * @returns {boolean} True si au moins un filtre est actif
     */
    function hasActiveFilters() {
        for (const [filterId, value] of _filterState.values) {
            const metadata = _filterState.metadata.get(filterId);
            if (!metadata) continue;

            // Vérifie selon le type si la valeur est "active"
            switch (metadata.type) {
                case 'multiselect':
                case 'tree':
                case 'tree-category':
                case 'categoryTree':
                    if (Array.isArray(value) && value.length > 0) return true;
                    break;
                case 'select':
                    if (value && value !== '') return true;
                    break;
                case 'range':
                    // Considère actif si différent de la valeur par défaut
                    const defaultVal = (metadata.min + metadata.max) / 2;
                    if (Math.abs(value - defaultVal) > 0.01) return true;
                    break;
            }
        }
        return false;
    }

    /**
     * Récupère un résumé des filtres actifs
     * @returns {Array} Liste des filtres actifs avec leurs valeurs
     */
    function getActiveFiltersSummary() {
        const summary = [];

        for (const [filterId, value] of _filterState.values) {
            const metadata = _filterState.metadata.get(filterId);
            if (!metadata) continue;

            let isActive = false;
            let displayValue = '';

            switch (metadata.type) {
                case 'multiselect':
                case 'tree':
                case 'tree-category':
                case 'categoryTree':
                    if (Array.isArray(value) && value.length > 0) {
                        isActive = true;
                        displayValue = `${value.length} sélectionné(s)`;
                    }
                    break;
                case 'select':
                    if (value && value !== '') {
                        isActive = true;
                        displayValue = value;
                    }
                    break;
                case 'range':
                    const defaultVal = (metadata.min + metadata.max) / 2;
                    if (Math.abs(value - defaultVal) > 0.01) {
                        isActive = true;
                        displayValue = value.toString().replace('.', ',');
                    }
                    break;
            }

            if (isActive) {
                summary.push({
                    id: filterId,
                    label: metadata.label || filterId,
                    value: displayValue,
                    type: metadata.type
                });
            }
        }

        return summary;
    }

    // ========================================
    //   API PUBLIQUE
    // ========================================

    const _UIFilterStateManager = {
        initializeFromProfile,
        updateFilterValue,
        getFilterValue,
        getAllFilterValues,
        getFilterMetadata,
        resetAllFilters,
        addObserver,
        hasActiveFilters,
        getActiveFiltersSummary
    };

    // Propriétés en lecture seule
    Object.defineProperty(_UIFilterStateManager, 'activeProfile', {
        get: () => _filterState.activeProfile,
        enumerable: true
    });

    Object.defineProperty(_UIFilterStateManager, 'filterCount', {
        get: () => _filterState.values.size,
        enumerable: true
    });

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        /**
         * Crée un bloc section simple (sans accordéon).
         *
         * @param {string} label - Titre de la section.
         * @param {Node|string} innerContent - Contenu de la section (Node ou texte).
         * @param {string} extraClass - Classes CSS additionnelles.
         * @returns {HTMLElement} Élément section.
         */
        function createPlainSection(label, innerContent, extraClass) {
            const section = createElement$1("section", {
                className: "gl-poi-panel__section" + (extraClass ? " " + extraClass : "")
            });

            if (label) {
                const header = createElement$1("h3", {
                    className: "gl-poi-panel__section-title",
                    textContent: label
                });
                section.appendChild(header);
            }

            const body = createElement$1("div", {
                className: "gl-poi-panel__section-body"
            });
            if (innerContent instanceof Node) {
                body.appendChild(innerContent);
            } else if (innerContent != null) {
                body.textContent = String(innerContent);
            }
            section.appendChild(body);

            return section;
        }

        /**
         * Crée un bloc section accordéon (panneau repliable).
         *
         * @param {string} label - Titre de l'accordéon.
         * @param {Node|string} innerContent - Contenu de l'accordéon.
         * @param {object} options - Options { defaultOpen: boolean }.
         * @returns {HTMLElement} Élément section accordéon.
         */
        function createAccordionSection(label, innerContent, options) {
            const opts = options || {};
            const isOpen = Boolean(opts.defaultOpen);

            const section = createElement$1("section", {
                className: "gl-accordion gl-poi-panel__section" + (isOpen ? " is-open" : "")
            });

            const header = createElement$1("button", {
                type: "button",
                className: "gl-accordion__header"
            });

            const titleSpan = createElement$1("span", {
                className: "gl-accordion__title",
                textContent: label || ""
            });
            header.appendChild(titleSpan);

            const iconSpan = createElement$1("span", {
                className: "gl-accordion__icon",
                attributes: { "aria-hidden": "true" },
                textContent: "▾"
            });
            header.appendChild(iconSpan);

            section.appendChild(header);

            const body = createElement$1("div", {
                className: "gl-accordion__body"
            });

            if (innerContent instanceof Node) {
                body.appendChild(innerContent);
            } else if (innerContent != null) {
                const p = createElement$1("p", {
                    textContent: String(innerContent)
                });
                body.appendChild(p);
            }

            section.appendChild(body);
            return section;
        }

        /**
         * Construit le rendu d'un item de type "text".
         *
         * @param {*} value - Valeur à afficher.
         * @param {string} variant - Variant ("multiline" ou autre).
         * @returns {HTMLElement|null} Élément div ou null.
         */
        function renderText(value, variant) {
            const div = createElement$1("div", {
                className: "gl-poi-panel__text" +
                    (variant === "multiline" ? " gl-poi-panel__text--multiline" : ""),
                textContent: String(value)
            });
            return div;
        }

        /**
         * Construit le rendu d'un item de type "list".
         *
         * @param {*} value - Array ou string (lignes séparées).
         * @returns {HTMLElement|null} Élément ul ou null.
         */
        function renderList(value) {
            const items = [];

            if (Array.isArray(value)) {
                value.forEach(function (entry) {
                    if (entry == null) return;

                    if (typeof entry === "string" || typeof entry === "number") {
                        items.push(String(entry));
                    } else if (typeof entry === "object") {
                        const label =
                            typeof entry.label === "string"
                                ? entry.label
                                : typeof entry.text === "string"
                                ? entry.text
                                : null;
                        const val = entry.value != null ? String(entry.value) : null;

                        if (label && val) {
                            items.push(label + " : " + val);
                        } else if (label) {
                            items.push(label);
                        } else if (val) {
                            items.push(val);
                        }
                    }
                });
            } else if (typeof value === "string") {
                value.split(/\r?\n/).forEach(function (line) {
                    const trimmed = line.trim();
                    if (trimmed) {
                        items.push(trimmed);
                    }
                });
            }

            if (!items.length) {
                return null;
            }

            const ul = createElement$1("ul", {
                className: "gl-poi-panel__list"
            });

            items.forEach(function (text) {
                const li = createElement$1("li", {
                    className: "gl-poi-panel__list-item",
                    textContent: text
                });
                ul.appendChild(li);
            });

            return ul;
        }

        /**
         * Construit le rendu d'un item de type "table".
         *
         * @param {Array} value - Tableau d'objets représentant les lignes.
         * @param {object} item - Configuration du tableau (columns, borders).
         * @returns {HTMLElement|null} Wrapper de tableau ou null.
         */
        function renderTable(value, item) {
            if (!Array.isArray(value) || !value.length) {
                return null;
            }

            const columns = Array.isArray(item.columns) ? item.columns : [];
            if (!columns.length) {
                return null;
            }

            const wrapper = createElement$1("div", {
                className: "gl-poi-panel__table-wrapper"
            });

            const borders = item.borders || {};
            const borderClasses = [];
            if (borders.outer) borderClasses.push("gl-poi-panel__table--border-outer");
            if (borders.row) borderClasses.push("gl-poi-panel__table--border-row");
            if (borders.column) borderClasses.push("gl-poi-panel__table--border-column");

            const table = createElement$1("table", {
                className: "gl-poi-panel__table" + (borderClasses.length ? " " + borderClasses.join(" ") : ""),
                attributes: borders.color ? { "data-gl-border-color": borders.color } : {}
            });

            // En-tête
            const thead = createElement$1("thead");
            const headRow = createElement$1("tr", {
                className: "gl-poi-panel__table-row gl-poi-panel__table-row--head"
            });

            columns.forEach(function (col) {
                const th = createElement$1("th", {
                    className: "gl-poi-panel__table-cell gl-poi-panel__table-cell--head",
                    textContent: col.label || col.key || ""
                });
                headRow.appendChild(th);
            });

            thead.appendChild(headRow);
            table.appendChild(thead);

            // Corps
            const tbody = createElement$1("tbody");

            value.forEach(function (rowObj) {
                if (!rowObj || typeof rowObj !== "object") {
                    return;
                }

                const tr = createElement$1("tr", {
                    className: "gl-poi-panel__table-row"
                });

                columns.forEach(function (col) {
                    const cellVal = rowObj[col.key];
                    const td = createElement$1("td", {
                        className: "gl-poi-panel__table-cell",
                        textContent: cellVal == null ? "" : String(cellVal)
                    });

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            wrapper.appendChild(table);
            return wrapper;
        }

        /**
         * Construit le rendu d'un item de type "gallery".
         *
         * @param {Array} value - Tableau d'images { url, alt, caption }.
         * @returns {HTMLElement|null} Container galerie ou null.
         */
        function renderGallery(value) {
            if (!Array.isArray(value)) {
                return null;
            }

            const container = createElement$1("div", {
                className: "gl-poi-panel__gallery"
            });

            value.forEach(function (img) {
                if (!img) return;

                const figure = createElement$1("figure", {
                    className: "gl-poi-panel__gallery-item"
                });

                const imgEl = createElement$1("img", {
                    src: img.url || img,
                    alt: img.alt || ""
                });
                figure.appendChild(imgEl);

                if (img.caption) {
                    const figCap = createElement$1("figcaption", {
                        textContent: img.caption
                    });
                    figure.appendChild(figCap);
                }

                container.appendChild(figure);
            });

            return container;
        }

        /**
         * Construit le rendu d'un item de type "reviews" (avis voyageurs).
         *
         * @param {*} value - Array ou objet avec propriété 'recent'.
         * @returns {HTMLElement|null} Container d'avis ou null.
         */
        function renderReviews(value) {
            // Si value est un objet avec une propriété 'recent', utiliser celle-ci
            let reviewsArray = value;
            if (value && typeof value === 'object' && !Array.isArray(value) && Array.isArray(value.recent)) {
                reviewsArray = value.recent;
            }

            if (!Array.isArray(reviewsArray)) {
                return null;
            }

            const container = createElement$1("div", {
                className: "gl-poi-panel__reviews gl-poi-sidepanel__reviews"
            });

            reviewsArray.forEach(function (review) {
                if (!review) return;

                const itemEl = createElement$1("article", {
                    className: "gl-poi-panel__review"
                });

                const header = createElement$1("header", {
                    className: "gl-poi-panel__review-header"
                });

                const nameSpan = createElement$1("span", {
                    className: "gl-poi-panel__review-author",
                    textContent: review.authorName || ""
                });
                header.appendChild(nameSpan);

                if (typeof review.rating === "number") {
                    const ratingSpan = createElement$1("span", {
                        className: "gl-poi-panel__review-rating",
                        textContent: review.rating.toFixed(1) + "/5"
                    });
                    header.appendChild(ratingSpan);
                }

                if (review.source) {
                    const sourceSpan = createElement$1("span", {
                        className: "gl-poi-panel__review-source",
                        textContent: review.source
                    });
                    header.appendChild(sourceSpan);
                }

                itemEl.appendChild(header);

                if (review.title) {
                    const titleEl = createElement$1("h4", {
                        className: "gl-poi-panel__review-title",
                        textContent: review.title
                    });
                    itemEl.appendChild(titleEl);
                }

                // Gérer à la fois 'text' (ancien format) et 'comment' (nouveau format)
                const reviewText = review.text || review.comment;
                if (reviewText) {
                    const textEl = createElement$1("p", {
                        className: "gl-poi-panel__review-text",
                        textContent: reviewText
                    });
                    itemEl.appendChild(textEl);
                }

                // Gérer à la fois 'date' (ancien format) et 'createdAt' (nouveau format)
                const reviewDate = review.date || review.createdAt;
                if (reviewDate) {
                    const dateEl = createElement$1("time", {
                        className: "gl-poi-panel__review-date",
                        textContent: reviewDate
                    });
                    itemEl.appendChild(dateEl);
                }

                const footer = createElement$1("footer", {
                    className: "gl-poi-panel__review-footer"
                });

                if (typeof review.helpfulCount === "number") {
                    const helpfulSpan = createElement$1("span", {
                        className: "gl-poi-panel__review-helpful",
                        textContent: review.helpfulCount + " personnes ont trouvé cet avis utile"
                    });
                    footer.appendChild(helpfulSpan);
                }

                if (review.url) {
                    const link = createElement$1("a", {
                        href: review.url,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "gl-poi-panel__review-link",
                        textContent: "Voir l'avis"
                    });
                    footer.appendChild(link);
                }

                itemEl.appendChild(footer);
                container.appendChild(itemEl);
            });

            return container;
        }

        /**
         * Construit le contenu interne pour un item de layout.
         * Dispatcher principal vers les fonctions de rendu spécialisées.
         *
         * @param {object} poi - Objet POI source.
         * @param {object} item - Configuration du layout item (type, field, variant, etc).
         * @returns {HTMLElement|null} Élément construit ou null.
         */
        function buildLayoutItemContent(poi, item) {
            const type = item.type;
            const value = resolveField$1(poi, item.field);

            if (value == null || value === "") {
                if (!Array.isArray(value)) {
                    return null;
                }
            }

            // Dispatch par type
            if (type === "text") {
                return renderText(value, item.variant);
            }

            if (type === "list") {
                return renderList(value);
            }

            if (type === "table") {
                return renderTable(value, item);
            }

            if (type === "gallery") {
                return renderGallery(value);
            }

            if (type === "reviews") {
                return renderReviews(value);
            }

            // Fallback : texte simple
            const defaultDiv = createElement$1("div", {
                className: "gl-poi-panel__text",
                textContent: String(value)
            });
            return defaultDiv;
        }

        // ── ESM Export ──

        const PanelBuilder = {
            resolveField: resolveField$1,
            createPlainSection,
            createAccordionSection,
            renderText,
            renderList,
            renderTable,
            renderGallery,
            renderReviews,
            buildLayoutItemContent
        };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        /**
         * Module de contrôle d'échelle
         * Affiche l'échelle de la carte en mode graphique (Leaflet) ou numérique (1:25000)
         */
        const ScaleControl = {
            _map: null,
            _control: null,
            _scaleElement: null,
            _options: {
                position: "bottomleft",
                scaleType: "graphic", // "graphic" (Leaflet) ou "numeric" (1:25000)
                metric: true,
                imperial: false,
                maxWidth: 150
            },

            /**
             * Initialise le contrôle d'échelle
             *
             * @param {L.Map} map - Instance de la carte Leaflet
             * @param {Object} [options={}] - Options de configuration
             * @param {string} [options.position='bottomleft'] - Position du contrôle
             * @param {string} [options.scaleType='graphic'] - Type d'échelle ('graphic' ou 'numeric')
             * @param {boolean} [options.metric=true] - Afficher échelle métrique
             * @param {boolean} [options.imperial=false] - Afficher échelle impériale
             * @param {number} [options.maxWidth=150] - Largeur max de l'échelle graphique
             *
             * @example
             * GeoLeaf.UI.ScaleControl.init(map, {
             *   scaleType: 'numeric',
             *   position: 'bottomright'
             * });
             */
            init(map, options = {}) {
                const context = "[GeoLeaf.UI.ScaleControl]";
                try {
                    if (!map) {
                        throw new Error("Une instance de carte Leaflet est requise.");
                    }
                    this._map = map;
                    this._options = { ...this._options, ...options };

                    const showScale = Config?.get("ui.showScale");
                    if (showScale === false) {
                        Log.info(`${context} Affichage de l'échelle désactivé dans la configuration.`);
                        return;
                    }

                    // Récupérer le type d'échelle depuis la config
                    const scaleType = Config?.get("ui.scaleType");
                    if (scaleType) {
                        this._options.scaleType = scaleType;
                    }

                    this._createControl();
                    Log.info(`${context} Module initialisé avec succès (type: ${this._options.scaleType}).`);
                } catch (err) {
                    Log.error(`${context} Erreur lors de l'initialisation :`, err.message);
                }
            },

            _createControl() {
                const context = "[GeoLeaf.UI.ScaleControl]";
                try {
                    if (this._options.scaleType === "numeric") {
                        // Créer un contrôle personnalisé pour l'échelle numérique
                        this._createNumericScale();
                    } else {
                        // Utiliser le contrôle Leaflet par défaut (graphique)
                        this._control = L.control.scale({
                            position: this._options.position,
                            metric: this._options.metric,
                            imperial: this._options.imperial,
                            maxWidth: this._options.maxWidth
                        });
                        this._control.addTo(this._map);
                    }
                    Log.info(`${context} Contrôle d'échelle créé et ajouté à la carte.`);
                } catch (err) {
                    Log.error(`${context} Erreur lors de la création du contrôle :`, err.message);
                }
            },

            _createNumericScale() {
                const NumericScaleControl = L.Control.extend({
                    options: {
                        position: this._options.position
                    },

                    onAdd: (map) => {
                        const container = L.DomUtil.create("div", "geoleaf-scale-numeric leaflet-control");

                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);

                        // Créer un conteneur flex pour aligner échelle et zoom
                        const flexContainer = L.DomUtil.create("div", "scale-flex-container", container);
                        flexContainer.style.cssText = "display: flex; align-items: center; gap: 8px;";

                        // Élément pour l'échelle numérique (suit le thème)
                        this._scaleElement = L.DomUtil.create("div", "scale-content gl-scale-numeric", flexContainer);
                        this._scaleElement.textContent = "1:0";

                        // Élément pour le niveau de zoom (suit le thème)
                        this._zoomElement = L.DomUtil.create("div", "zoom-level gl-zoom-badge", flexContainer);
                        this._zoomElement.textContent = "Z0";

                        // MEMORY LEAK FIX (Phase 2): Store bound function references
                        // to use same reference in onRemove
                        this._boundUpdateNumericScale = this._updateNumericScale.bind(this);

                        this._updateNumericScale();
                        map.on("zoomend", this._boundUpdateNumericScale);
                        // Perf 6.2.1: 'moveend' instead of 'move' — fires once per pan, not per pixel
                        map.on("moveend", this._boundUpdateNumericScale);

                        return container;
                    },

                    onRemove: (map) => {
                        // MEMORY LEAK FIX (Phase 2): Use stored bound function references
                        // instead of creating new bind() which would not match
                        if (this._boundUpdateNumericScale) {
                            map.off("zoomend", this._boundUpdateNumericScale);
                            // Perf 6.2.1: matches 'moveend' listener registered in onAdd
                            map.off("moveend", this._boundUpdateNumericScale);
                            this._boundUpdateNumericScale = null; // Clean up reference
                        }
                    }
                });

                this._control = new NumericScaleControl();
                this._control.addTo(this._map);
            },

            _updateNumericScale() {
                if (!this._scaleElement || !this._map) return;

                // Obtenir le centre de la carte
                const center = this._map.getCenter();
                const zoom = this._map.getZoom();

                // Mettre à jour le niveau de zoom
                if (this._zoomElement) {
                    this._zoomElement.textContent = `Z${Number(zoom).toFixed(2)}`;
                }

                // Calculer la résolution en mètres par pixel au centre de la carte
                // Formule : résolution = (40075016.686 * Math.abs(Math.cos(center.lat * Math.PI / 180))) / Math.pow(2, zoom + 8)
                const metersPerPixel = 156543.03392 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);

                // Calculer l'échelle (1 pixel écran = X mètres réels)
                // Échelle = distance réelle / distance carte
                // Supposons 96 DPI (standard), donc 1 pouce = 96 pixels = 0.0254 mètres
                const scale = Math.round(metersPerPixel * 96 / 0.0254);

                // Formater l'échelle de manière lisible
                let scaleText;
                if (scale >= 1000000) {
                    scaleText = `1:${(scale / 1000000).toFixed(1)}M`;
                } else if (scale >= 1000) {
                    scaleText = `1:${(scale / 1000).toFixed(0)}K`;
                } else {
                    scaleText = `1:${scale}`;
                }

                this._scaleElement.textContent = scaleText;
            },

            /**
             * Détruit le contrôle d'échelle et libère les ressources
             *
             * @example
             * GeoLeaf.UI.ScaleControl.destroy();
             */
            destroy() {
                const context = "[GeoLeaf.UI.ScaleControl]";
                try {
                    if (this._control && this._map) {
                        this._map.removeControl(this._control);
                        this._control = null;
                    }
                    this._scaleElement = null;
                    this._map = null;
                } catch (err) {
                    Log.error(`${context} Erreur lors de la destruction :`, err.message);
                }
            },

            /**
             * Affiche le contrôle d'échelle (le crée s'il n'existe pas)
             *
             * @example
             * GeoLeaf.UI.ScaleControl.show();
             */
            show() {
                if (!this._control && this._map) {
                    this._createControl();
                }
            },

            /**
             * Masque le contrôle d'échelle
             *
             * @example
             * GeoLeaf.UI.ScaleControl.hide();
             */
            hide() {
                if (this._control && this._map) {
                    this._map.removeControl(this._control);
                    this._control = null;
                    this._scaleElement = null;
                }
            }
        };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ========================================
    //   CONSTANTES
    // ========================================

    const THEME_KEY = "geoleaf_theme";
    const THEME_LIGHT = "light";
    const THEME_DARK = "dark";

    // ========================================
    //   ÉTAT INTERNE
    // ========================================

    /**
     * Source de vérité unique pour le thème actuel
     * @type {string|null}
     * @private
     */
    let _currentTheme = null;

    // ========================================
    //   FONCTIONS PUBLIQUES
    // ========================================

    /**
     * Retourne le thème courant ("light" ou "dark").
     * @returns {string} Theme actuel
     */
    function getCurrentTheme() {
        // Si déjà en mémoire, retourner directement
        if (_currentTheme) {
            return _currentTheme;
        }

        // Sinon, fallback sur le DOM
        if (document.body.classList.contains("gl-theme-dark")) {
            _currentTheme = THEME_DARK;
            return THEME_DARK;
        }
        if (document.body.classList.contains("gl-theme-light")) {
            _currentTheme = THEME_LIGHT;
            return THEME_LIGHT;
        }

        // Fallback final
        _currentTheme = THEME_DARK;
        return THEME_DARK;
    }

    /**
     * Applique un thème au <body> et synchronise le bouton.
     * @param {string} theme - "light" ou "dark"
     */
    function applyTheme(theme) {
        const normalized =
            theme === THEME_LIGHT || theme === THEME_DARK
                ? theme
                : THEME_DARK;

        Log.debug('[UI.Theme] applyTheme:', theme, '→', normalized);

        // Mettre à jour l'état centralisé AVANT le DOM
        _currentTheme = normalized;

        // Mise à jour du DOM sur body
        document.body.classList.remove("gl-theme-light", "gl-theme-dark");
        document.body.classList.add(
            normalized === THEME_DARK ? "gl-theme-dark" : "gl-theme-light"
        );

        // Appliquer aussi le thème au conteneur de carte (pour support fullscreen)
        const mapContainer = document.getElementById("geoleaf-map");
        if (mapContainer) {
            mapContainer.classList.remove("gl-theme-light", "gl-theme-dark");
            mapContainer.classList.add(
                normalized === THEME_DARK ? "gl-theme-dark" : "gl-theme-light"
            );
        }

        // Sauvegarde locale
        try {
            localStorage.setItem(THEME_KEY, normalized);
        } catch (e) {
            // Gérer explicitement l'absence de localStorage
            if (Log) Log.warn("[UI.Theme] localStorage non disponible, thème non persisté.");
        }

        // Synchronise le bouton si présent
        updateToggleButton(normalized);

        // Évènement global pour les autres modules
        if (globalThis.dispatchEvent) {
            globalThis.dispatchEvent(
                new CustomEvent("geoleaf:ui-theme-changed", {
                    detail: { theme: normalized }
                })
            );
        }
    }

    /**
     * Bascule le thème courant (light <-> dark).
     */
    function toggleTheme() {
        const current = getCurrentTheme();
        const next = current === THEME_DARK ? THEME_LIGHT : THEME_DARK;
        Log.debug('[UI.Theme] toggleTheme:', current, '→', next);
        applyTheme(next);
    }

    /**
     * Détermine le thème initial :
     * 1) localStorage si disponible
     * 2) class du <body> si déjà définie
     * 3) sinon, "dark"
     * @returns {string} Theme initial
     * @private
     */
    function resolveInitialTheme() {
        let stored = null;

        try {
            stored = localStorage.getItem(THEME_KEY);
        } catch (e) {
            stored = null;
        }

        if (stored === THEME_LIGHT || stored === THEME_DARK) {
            return stored;
        }

        const bodyTheme = getCurrentTheme();
        if (bodyTheme === THEME_LIGHT || bodyTheme === THEME_DARK) {
            return bodyTheme;
        }

        return THEME_DARK;
    }

    /**
     * Récupère le bouton de thème dans le DOM.
     * Par convention on utilise l'attribut data-gl-role="theme-toggle".
     * @returns {HTMLElement|null}
     * @private
     */
    function getToggleButton() {
        return document.querySelector('[data-gl-role="theme-toggle"]');
    }

    /**
     * Met à jour l'état visuel/ARIA du bouton de thème.
     * @param {string} theme - "light" ou "dark"
     * @private
     */
    function updateToggleButton(theme) {
        const btn = getToggleButton();
        if (!btn) return;

        const isDark = theme === THEME_DARK;

        btn.setAttribute("data-gl-theme-state", isDark ? "dark" : "light");
        btn.setAttribute("aria-pressed", String(isDark));
        btn.setAttribute(
            "aria-label",
            isDark ? "Basculer en thème clair" : "Basculer en thème sombre"
        );
        btn.title = isDark ? "Thème clair" : "Thème sombre";
    }

    /**
     * Initialise la gestion du bouton de thème.
     * @param {object} [options] - Options de configuration
     * @param {string} [options.buttonSelector] - Sélecteur custom du bouton
     * @param {boolean} [options.autoInitOnDomReady] - Si true, attend DOMContentLoaded
     */
    function initThemeToggle(options = {}) {
        const cfg = {
            buttonSelector: options.buttonSelector || '[data-gl-role="theme-toggle"]',
            autoInitOnDomReady:
                typeof options.autoInitOnDomReady === "boolean"
                    ? options.autoInitOnDomReady
                    : false
        };

        const doInit = () => {
            const initialTheme = resolveInitialTheme();
            Log.debug('[UI.Theme] initThemeToggle:', initialTheme);
            applyTheme(initialTheme);

            const btn = document.querySelector(cfg.buttonSelector);
            if (!btn) {
                Log.warn('[UI.Theme] Bouton de thème introuvable:', cfg.buttonSelector);
                return;
            }

            Log.debug('[UI.Theme] Bouton de thème trouvé');

            // Accessibilité : <button> natif ou rôle "button"
            const tag = (btn.tagName || "").toLowerCase();
            if (tag === "button") {
                try {
                    btn.type = btn.type || "button";
                } catch (e) {
                    // Certains éléments custom peuvent lever une erreur
                }
            } else {
                btn.setAttribute("role", "button");
                btn.setAttribute("tabindex", "0");
            }

            // Première synchro de l'état visuel
            updateToggleButton(initialTheme);

            // Clic souris
            btn.addEventListener("click", (evt) => {
                evt.preventDefault();
                toggleTheme();
            });

            // Clavier (Enter / Space)
            btn.addEventListener("keydown", (evt) => {
                if (evt.key === "Enter" || evt.key === " " || evt.key === "Spacebar") {
                    evt.preventDefault();
                    toggleTheme();
                }
            });
        };    if (cfg.autoInitOnDomReady) {
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", doInit, { once: true });
            } else {
                doInit();
            }
        } else {
            doInit();
        }
    }

    // ========================================
    //   EXPORT
    // ========================================

    const _UITheme = {
        initThemeToggle,
        toggleTheme,
        applyTheme,
        getCurrentTheme,
        // Constantes exposées
        THEME_LIGHT,
        THEME_DARK
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


        // ========================================
        //   CLASSES CSS STANDARDS
        // ========================================

        const CSS_CLASSES = {
            // Container classes
            text: 'gl-content__text',
            longtext: 'gl-content__longtext',
            number: 'gl-content__number',
            metric: 'gl-content__metric',
            badge: 'gl-poi-badge',
            rating: 'gl-content__rating',
            image: 'gl-content__image',
            link: 'gl-content__link',
            list: 'gl-content__list',
            table: 'gl-content__table',
            tags: 'gl-content__tags',
            tag: 'gl-content__tag',
            coordinates: 'gl-content__coordinates',
            gallery: 'gl-content__gallery',

            // Badge variants
            badgeDefault: 'gl-poi-badge--default',
            badgeStatus: 'gl-poi-badge--status',
            badgePriority: 'gl-poi-badge--priority',
            badgeCategory: 'gl-poi-badge--category',

            // Rating
            star: 'gl-star',
            starFull: 'gl-star--full',
            starHalf: 'gl-star--half',
            starEmpty: 'gl-star--empty'
        };

        // ========================================
        //   TEMPLATE BUILDERS
        // ========================================

        /**
         * Construit un attribut HTML class="..." avec classes de base et personnalisées.
         *
         * Combine baseClass (obligatoire) + customClass (optionnel) en un seul attribut.
         *
         * @function buildClassAttr
         * @param {string} baseClass - Classe CSS de base (ex: 'gl-content__badge')
         * @param {string} [customClass] - Classe personnalisée optionnelle
         * @returns {string} Attribut HTML class (ex: ' class="gl-content__badge custom"')
         *
         * @example
         * // Classe de base uniquement
         * const attr1 = buildClassAttr('gl-content__badge');
         * // Retourne: ' class="gl-content__badge"'
         *
         * @example
         * // Classe de base + classe personnalisée
         * const attr2 = buildClassAttr('gl-content__badge', 'my-custom-badge');
         * // Retourne: ' class="gl-content__badge my-custom-badge"'
         */
        function buildClassAttr(baseClass, customClass) {
            const classes = [baseClass];
            if (customClass) classes.push(customClass);
            return ' class="' + classes.join(' ') + '"';
        }

        /**
         * Construit un attribut HTML style="..." si un style est fourni.
         *
         * Retourne une chaîne vide si style est null/undefined/vide.
         *
         * @function buildStyleAttr
         * @param {string} [style] - Style CSS inline (ex: 'color: red; background: blue;')
         * @returns {string} Attribut HTML style (ex: ' style="color: red;"') ou chaîne vide
         *
         * @example
         * // Avec style
         * const attr1 = buildStyleAttr('color: red; font-weight: bold;');
         * // Retourne: ' style="color: red; font-weight: bold;"'
         *
         * @example
         * // Sans style
         * const attr2 = buildStyleAttr('');
         * // Retourne: ''
         */
        function buildStyleAttr(style) {
            return style ? ' style="' + style + '"' : '';
        }

        /**
         * Construit un label HTML avec gestion d'icône et échappement.
         *
         * Utilisé dans les templates pour afficher un label avec icône optionnelle.
         *
         * @function buildLabel
         * @param {string} label - Texte du label (sera échappé)
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @param {string} [icon] - Icône optionnelle (HTML non échappé)
         * @returns {string} HTML du label avec icône si fournie
         *
         * @example
         * // Label simple
         * const html1 = buildLabel('Restaurant', escapeHtml);
         * // Retourne: '<span>Restaurant</span>'
         *
         * @example
         * // Label avec icône
         * const html2 = buildLabel('Restaurant', escapeHtml, '<i class="fa fa-utensils"></i>');
         * // Retourne: '<i class="fa fa-utensils"></i><span>Restaurant</span>'
         */
        function buildLabel(label, escapeHtml, icon) {
            if (!label) return '';
            return '<strong>' + escapeHtml(label) + ':</strong> ';
        }

        /**
         * Enveloppe du contenu HTML dans un paragraphe <p> avec classes.
         *
         * @function wrapInParagraph
         * @param {string} content - Contenu HTML (déjà échappé ou non)
         * @param {string} className - Classe CSS de base
         * @param {string} [customClass] - Classe personnalisée optionnelle
         * @returns {string} HTML paragraphe avec classes
         *
         * @example
         * const html = wrapInParagraph('Restaurant', 'gl-content__text');
         * // Retourne: '<p class="gl-content__text">Restaurant</p>'
         *
         * @example
         * const html2 = wrapInParagraph('Restaurant', 'gl-content__text', 'my-custom');
         * // Retourne: '<p class="gl-content__text my-custom">Restaurant</p>'
         */
        function wrapInParagraph(content, className, customClass) {
            return '<p' + buildClassAttr(className, customClass) + '>' + content + '</p>';
        }

        /**
         * Enveloppe du contenu HTML dans un div <div> avec classes.
         *
         * @function wrapInDiv
         * @param {string} content - Contenu HTML (déjà échappé ou non)
         * @param {string} className - Classe CSS de base
         * @param {string} [customClass] - Classe personnalisée optionnelle
         * @returns {string} HTML div avec classes
         *
         * @example
         * const html = wrapInDiv('Content', 'gl-content__longtext');
         * // Retourne: '<div class="gl-content__longtext">Content</div>'
         */
        function wrapInDiv(content, className, customClass) {
            return '<div' + buildClassAttr(className, customClass) + '>' + content + '</div>';
        }

        /**
         * Crée un élément de texte simple <p> avec label optionnel.
         *
         * Format: <p class="gl-content__text"><strong>Label:</strong> Value</p>
         *
         * @function createTextElement
         * @param {string} value - Valeur texte (à échapper)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec texte
         *
         * @example
         * // Avec label
         * const html1 = createTextElement('Restaurant', { label: 'Nom' }, escapeHtml);
         * // Retourne: '<p class="gl-content__text"><strong>Nom:</strong> Restaurant</p>'
         *
         * @example
         * // Sans label
         * const html2 = createTextElement('Restaurant', {}, escapeHtml);
         * // Retourne: '<p class="gl-content__text">Restaurant</p>'
         */
        function createTextElement(value, config, escapeHtml) {
            const label = buildLabel(config.label, escapeHtml);
            const content = label + escapeHtml(value);
            return wrapInParagraph(content, CSS_CLASSES.text, config.className);
        }

        /**
         * Crée un élément de texte long <div> avec label séparé.
         *
         * Format: <div><p><strong>Label</strong></p><p>Value</p></div>
         * Utilisé pour descriptions, commentaires, textes longs.
         *
         * @function createLongtextElement
         * @param {string} value - Valeur texte longue (à échapper)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML div avec texte long
         *
         * @example
         * // Avec label
         * const html1 = createLongtextElement(
         *   'Une longue description...',
         *   { label: 'Description' },
         *   escapeHtml
         * );
         * // Retourne: '<div class="gl-content__longtext">
         * //   <p><strong>Description</strong></p>
         * //   <p>Une longue description...</p>
         * // </div>'
         */
        function createLongtextElement(value, config, escapeHtml) {
            const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
            const content = label + '<p>' + escapeHtml(value) + '</p>';
            return wrapInDiv(content, CSS_CLASSES.longtext, config.className);
        }

        /**
         * Crée un élément numérique <p> avec formatage locale FR.
         *
         * Formate le nombre avec toLocaleString('fr-FR').
         * Supporte prefix, suffix, label.
         *
         * @function createNumberElement
         * @param {number} value - Valeur numérique
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.prefix] - Préfixe (ex: "~")
         * @param {string} [config.suffix] - Suffixe (ex: "m²", "habitants")
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec nombre formaté
         *
         * @example
         * // Nombre simple avec suffix
         * const html1 = createNumberElement(1234567, { suffix: 'habitants' }, escapeHtml);
         * // Retourne: '<p class="gl-content__number">1\u202f234\u202f567 habitants</p>'
         *
         * @example
         * // Avec label + prefix + suffix
         * const html2 = createNumberElement(120, { label: 'Surface', prefix: '~', suffix: 'm²' }, escapeHtml);
         * // Retourne: '<p class="gl-content__number"><strong>Surface:</strong> ~120 m²</p>'
         */
        function createNumberElement(value, config, escapeHtml) {
            const formatted = value.toLocaleString('fr-FR');
            const label = buildLabel(config.label, escapeHtml);
            const suffix = config.suffix ? ' ' + escapeHtml(config.suffix) : '';
            const prefix = config.prefix ? escapeHtml(config.prefix) + ' ' : '';
            const content = label + prefix + formatted + suffix;
            return wrapInParagraph(content, CSS_CLASSES.number, config.className);
        }

        /**
         * Crée un élément métrique <p> avec formatage (similaire à number).
         *
         * Identique à createNumberElement mais utilise CSS_CLASSES.metric.
         * Utilisé pour métriques spécifiques (KPI, statistiques, etc.).
         *
         * @function createMetricElement
         * @param {number} value - Valeur numérique
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.prefix] - Préfixe (ex: "+", "-")
         * @param {string} [config.suffix] - Suffixe (ex: "%", "€")
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec métrique formatée
         *
         * @example
         * // Métrique avec pourcentage
         * const html1 = createMetricElement(95.5, { label: 'Satisfaction', suffix: '%' }, escapeHtml);
         * // Retourne: '<p class="gl-content__metric"><strong>Satisfaction:</strong> 95,5%</p>'
         */
        function createMetricElement(value, config, escapeHtml) {
            const formatted = value.toLocaleString('fr-FR');
            const label = buildLabel(config.label, escapeHtml);
            const suffix = config.suffix ? escapeHtml(config.suffix) : '';
            const prefix = config.prefix ? escapeHtml(config.prefix) : '';
            const content = label + prefix + formatted + suffix;
            return wrapInParagraph(content, CSS_CLASSES.metric, config.className);
        }

        /**
         * Crée un badge <span> avec variante et style inline.
         *
         * Variantes disponibles:
         * - 'default': gl-poi-badge--default
         * - 'status': gl-poi-badge--status
         * - 'priority': gl-poi-badge--priority
         * - 'category': gl-poi-badge--category
         *
         * @function createBadge
         * @param {string} value - Texte du badge (à échapper)
         * @param {string} [variant='default'] - Variante du badge (default, status, priority, category)
         * @param {string} [style] - Style CSS inline optionnel (ex: 'background-color: #e74c3c;')
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML span badge
         *
         * @example
         * // Badge default
         * const html1 = createBadge('Restaurant', 'default', '', escapeHtml);
         * // Retourne: '<span class="gl-poi-badge gl-poi-badge--default">Restaurant</span>'
         *
         * @example
         * // Badge category avec style
         * const html2 = createBadge(
         *   'Gastronomique',
         *   'category',
         *   'background-color: #e74c3c; color: white;',
         *   escapeHtml
         * );
         * // Retourne: '<span class="gl-poi-badge gl-poi-badge--category" style="...">Gastronomique</span>'
         */
        function createBadge(value, variant, style, escapeHtml) {
            variant = variant || 'default';
            const badgeClass = CSS_CLASSES.badge + ' ' + CSS_CLASSES['badge' + variant.charAt(0).toUpperCase() + variant.slice(1)];
            const styleAttr = buildStyleAttr(style);
            return '<span class="' + badgeClass + '"' + styleAttr + '>' + escapeHtml(value) + '</span>';
        }

        /**
         * Crée une étoile <span> de notation avec classe CSS.
         *
         * Types disponibles:
         * - 'full': gl-star--full (★ plein)
         * - 'half': gl-star--half (½ étoile)
         * - 'empty': gl-star--empty (☆ vide)
         *
         * @function createStar
         * @param {string} type - Type d'étoile ('full', 'half', 'empty')
         * @returns {string} HTML span étoile
         *
         * @example
         * const html1 = createStar('full');
         * // Retourne: '<span class="gl-star gl-star--full">★</span>'
         *
         * @example
         * const html2 = createStar('empty');
         * // Retourne: '<span class="gl-star gl-star--empty">★</span>'
         */
        function createStar(type) {
            const starClass = CSS_CLASSES.star + ' ' + CSS_CLASSES['star' + type.charAt(0).toUpperCase() + type.slice(1)];
            return '<span class="' + starClass + '">★</span>';
        }

        /**
         * Crée un élément de notation <p> avec étoiles (0-5).
         *
         * Génère automatiquement les étoiles pleines, demi et vides.
         * Logique:
         * - rating = 4.7 => 4 full + 1 half + 0 empty
         * - rating = 3.2 => 3 full + 0 half + 2 empty
         *
         * @function createRatingElement
         * @param {number} rating - Note (0-5)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {number} [config.max=5] - Note maximale (généralement 5)
         * @param {boolean} [config.showValue=true] - Afficher la valeur numérique
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec étoiles
         *
         * @example
         * // Rating 4.5/5 avec label
         * const html1 = createRatingElement(4.5, { label: 'Note', showValue: true }, escapeHtml);
         * // Retourne: '<p class="gl-content__rating">
         * //   <strong>Note:</strong> ★★★★½ (4.5/5)
         * // </p>'
         *
         * @example
         * // Rating sans valeur numérique
         * const html2 = createRatingElement(3, { showValue: false }, escapeHtml);
         * // Retourne: '<p class="gl-content__rating">★★★☆☆</p>'
         */
        function createRatingElement(rating, config, escapeHtml) {
            let stars = '';
            const fullStars = Math.floor(rating);
            const hasHalfStar = (rating % 1) >= 0.5;

            // Étoiles pleines
            for (let i = 0; i < fullStars; i++) {
                stars += createStar('full');
            }

            // Demi-étoile
            if (hasHalfStar) {
                stars += createStar('half');
            }

            // Étoiles vides
            const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
            for (let i = 0; i < emptyStars; i++) {
                stars += createStar('empty');
            }

            const ratingText = ' (' + rating.toFixed(1) + '/5)';
            const label = buildLabel(config.label, escapeHtml);
            const content = label + stars + ratingText;
            return wrapInDiv(content, CSS_CLASSES.rating, config.className);
        }

        /**
         * Crée un élément image <img> avec classe et alt.
         *
         * @function createImageElement
         * @param {string} src - URL de l'image (sera échappée)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.alt] - Texte alternatif optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML img
         *
         * @example
         * // Image avec alt
         * const html1 = createImageElement(
         *   'https://example.com/photo.jpg',
         *   { alt: 'Photo du restaurant' },
         *   escapeHtml
         * );
         * // Retourne: '<img class="gl-content__image" src="https://example.com/photo.jpg" alt="Photo du restaurant">'
         *
         * @example
         * // Image sans alt
         * const html2 = createImageElement('https://example.com/photo.jpg', {}, escapeHtml);
         * // Retourne: '<img class="gl-content__image" src="https://example.com/photo.jpg" alt="">'
         */
        function createImageElement(src, config, escapeHtml) {
            const alt = config.alt ? escapeHtml(config.alt) : '';
            const classAttr = buildClassAttr(CSS_CLASSES.image, config.className);
            return '<img' + classAttr + ' src="' + escapeHtml(src) + '" alt="' + alt + '">';
        }

        /**
         * Crée un élément lien <a> avec target="_blank" et sécurité.
         *
         * Sécurité: rel="noopener noreferrer" pour éviter tabnabbing.
         *
         * @function createLinkElement
         * @param {string} href - URL du lien (sera échappée)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.text] - Texte du lien (défaut: URL)
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec lien
         *
         * @example
         * // Lien avec texte personnalisé
         * const html1 = createLinkElement(
         *   'https://example.com',
         *   { text: 'Visiter le site', label: 'Site web' },
         *   escapeHtml
         * );
         * // Retourne: '<p class="gl-content__link">
         * //   <strong>Site web:</strong>
         * //   <a href="https://example.com" target="_blank" rel="noopener noreferrer">Visiter le site</a>
         * // </p>'
         *
         * @example
         * // Lien sans texte (affiche URL)
         * const html2 = createLinkElement('https://example.com', {}, escapeHtml);
         * // Retourne: '<p class="gl-content__link">
         * //   <a href="https://example.com" target="_blank" rel="noopener noreferrer">https://example.com</a>
         * // </p>'
         */
        function createLinkElement(href, config, escapeHtml) {
            const text = config.text ? escapeHtml(config.text) : escapeHtml(href);
            const label = buildLabel(config.label, escapeHtml);
            const link = '<a href="' + escapeHtml(href) + '" target="_blank" rel="noopener noreferrer">' + text + '</a>';
            const content = label + link;
            return wrapInParagraph(content, CSS_CLASSES.link, config.className);
        }

        /**
         * Crée un élément liste <ul> avec items.
         *
         * Convertit automatiquement les items en string via String(item).
         *
         * @function createListElement
         * @param {Array<string|number|*>} items - Items de la liste
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML div avec liste ul
         *
         * @example
         * // Liste avec label
         * const html1 = createListElement(
         *   ['Pizza', 'Pasta', 'Risotto'],
         *   { label: 'Spécialités' },
         *   escapeHtml
         * );
         * // Retourne: '<div class="gl-content__list">
         * //   <p><strong>Spécialités</strong></p>
         * //   <ul><li>Pizza</li><li>Pasta</li><li>Risotto</li></ul>
         * // </div>'
         *
         * @example
         * // Liste simple sans label
         * const html2 = createListElement(['Item 1', 'Item 2'], {}, escapeHtml);
         * // Retourne: '<div class="gl-content__list"><ul><li>Item 1</li><li>Item 2</li></ul></div>'
         */
        function createListElement(items, config, escapeHtml) {
            const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
            let list = '<ul>';
            items.forEach(item => {
                list += '<li>' + escapeHtml(String(item)) + '</li>';
            });
            list += '</ul>';
            const content = label + list;
            return wrapInDiv(content, CSS_CLASSES.list, config.className);
        }

        /**
         * Crée un élément table <table> à partir d'un objet clé/valeur.
         *
         * Génère une table HTML avec <th> pour les clés et <td> pour les valeurs.
         *
         * @function createTableElement
         * @param {Object} data - Données de la table (clé/valeur)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.label] - Label optionnel
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML div avec table
         *
         * @example
         * // Table avec label
         * const html1 = createTableElement(
         *   { 'Ouverture': '9h-18h', 'Fermeture': 'Dimanche' },
         *   { label: 'Horaires' },
         *   escapeHtml
         * );
         * // Retourne: '<div class="gl-content__table">
         * //   <p><strong>Horaires</strong></p>
         * //   <table><tbody>
         * //     <tr><th>Ouverture</th><td>9h-18h</td></tr>
         * //     <tr><th>Fermeture</th><td>Dimanche</td></tr>
         * //   </tbody></table>
         * // </div>'
         */
        function createTableElement(data, config, escapeHtml) {
            const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
            let table = '<table><tbody>';

            Object.keys(data).forEach(key => {
                const keyLabel = escapeHtml(String(key));
                const value = escapeHtml(String(data[key]));
                table += '<tr><th>' + keyLabel + '</th><td>' + value + '</td></tr>';
            });

            table += '</tbody></table>';
            const content = label + table;
            return wrapInDiv(content, CSS_CLASSES.table, config.className);
        }

        /**
         * Crée un tag <span> unique avec classe gl-content__tag.
         *
         * Utilisé par createTagsElement pour générer des tags individuels.
         *
         * @function createTag
         * @param {string|number} tag - Texte du tag (à échapper)
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML span tag
         *
         * @example
         * const html = createTag('Restaurant', escapeHtml);
         * // Retourne: '<span class="gl-content__tag">Restaurant</span>'
         */
        function createTag(tag, escapeHtml) {
            return '<span class="' + CSS_CLASSES.tag + '">' + escapeHtml(String(tag)) + '</span>';
        }

        /**
         * Crée un élément cloud de tags <div> avec plusieurs tags.
         *
         * Génère un nuage de tags (tag cloud) avec chaque tag séparé par un espace.
         *
         * @function createTagsElement
         * @param {Array<string|number>} tags - Liste de tags
         * @param {Object} config - Configuration renderer
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML div avec tags
         *
         * @example
         * // Tags multiples
         * const html = createTagsElement(
         *   ['Pizza', 'Italien', 'Gastronomique'],
         *   {},
         *   escapeHtml
         * );
         * // Retourne: '<div class="gl-content__tags">
         * //   <span class="gl-content__tag">Pizza</span>
         * //   <span class="gl-content__tag">Italien</span>
         * //   <span class="gl-content__tag">Gastronomique</span>
         * // </div>'
         */
        function createTagsElement(tags, config, escapeHtml) {
            let content = '';
            tags.forEach(tag => {
                content += createTag(tag, escapeHtml) + ' ';
            });
            return wrapInDiv(content.trim(), CSS_CLASSES.tags, config.className);
        }

        /**
         * Crée un élément coordonnées <p> avec lat, lng.
         *
         * Formate automatiquement avec 6 décimales de précision.
         *
         * @function createCoordinatesElement
         * @param {number} lat - Latitude (∈ [-90, 90])
         * @param {number} lng - Longitude (∈ [-180, 180])
         * @param {Object} config - Configuration renderer
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML paragraphe avec coordonnées
         *
         * @example
         * const html = createCoordinatesElement(45.7578137, 4.8320114, {}, escapeHtml);
         * // Retourne: '<p class="gl-content__coordinates">
         * //   <strong>Coordonnées:</strong> 45.757814, 4.832011
         * // </p>'
         */
        function createCoordinatesElement(lat, lng, config, escapeHtml) {
            const latFixed = lat.toFixed(6);
            const lngFixed = lng.toFixed(6);
            const content = '<strong>Coordonnées:</strong> ' + latFixed + ', ' + lngFixed;
            return wrapInParagraph(content, CSS_CLASSES.coordinates, config.className);
        }

        /**
         * Crée un élément galerie <div> avec plusieurs images.
         *
         * Génère une galerie d'images sans balises <img> individuelles.
         * Les URLs doivent être validées avant via validateImageUrl.
         *
         * @function createGalleryElement
         * @param {Array<string>} photos - URLs des photos (déjà validées)
         * @param {Object} config - Configuration renderer
         * @param {string} [config.className] - Classe personnalisée
         * @param {Function} escapeHtml - Fonction d'échappement HTML
         * @returns {string} HTML div galerie avec images
         *
         * @example
         * const html = createGalleryElement(
         *   [
         *     'https://example.com/photo1.jpg',
         *     'https://example.com/photo2.jpg'
         *   ],
         *   {},
         *   escapeHtml
         * );
         * // Retourne: '<div class="gl-content__gallery">
         * //   <img src="https://example.com/photo1.jpg" alt="Photo">
         * //   <img src="https://example.com/photo2.jpg" alt="Photo">
         * // </div>'
         */
        function createGalleryElement(photos, config, escapeHtml) {
            let gallery = '';
            photos.forEach(photo => {
                gallery += '<img src="' + escapeHtml(photo) + '" alt="Photo">';
            });
            return wrapInDiv(gallery, CSS_CLASSES.gallery, config.className);
        }

        // ========================================
        //   EXPORT
        // ========================================

        const Templates = {
            // Classes CSS
            CSS_CLASSES,

            // Helpers de base
            buildClassAttr,
            buildStyleAttr,
            buildLabel,
            wrapInParagraph,
            wrapInDiv,

            // Template builders
            createTextElement,
            createLongtextElement,
            createNumberElement,
            createMetricElement,
            createBadge,
            createStar,
            createRatingElement,
            createImageElement,
            createLinkElement,
            createListElement,
            createTableElement,
            createTag,
            createTagsElement,
            createCoordinatesElement,
            createGalleryElement
        };

    /**
     * GeoLeaf UI Filter Panel - Shared Helpers
     * Fonctions utilitaires partagées pour le panneau de filtres
     *
     * @module ui/filter-panel/shared
     */
    const _runtime = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});
    // _runtime used only for legacy demo fallback (_runtime.cfg)

    const FilterPanelShared = {};

    // ========================================
    //   CONVERSION DE FEATURES
    // ========================================

    /**
     * Convertit une feature GeoJSON Point en objet POI-like
     * @param {Object} feature - Feature GeoJSON
     * @returns {Object|null} - POI-like ou null
     */
    FilterPanelShared.featureToPoiLike = function(feature) {
        if (!feature || !feature.geometry || !feature.properties) return null;

        const geom = feature.geometry;
        if (!geom || geom.type?.toLowerCase().indexOf("point") === -1) return null;

        const coords = Array.isArray(geom.coordinates) ? geom.coordinates : null;
        const latlng = coords && coords.length >= 2 ? [coords[1], coords[0]] : null;
        const props = feature.properties || {};
        const poi = Object.assign({}, props);

        if (!poi.title && props.name) poi.title = props.name;
        if (!poi.id && feature.id) poi.id = feature.id;
        if (!poi.latlng && latlng) poi.latlng = latlng;
        if (!poi.attributes && props.attributes) poi.attributes = props.attributes;

        return poi;
    };

    /**
     * Convertit une feature GeoJSON LineString en objet Route-like
     * @param {Object} feature - Feature GeoJSON
     * @returns {Object|null} - Route-like ou null
     */
    FilterPanelShared.featureToRouteLike = function(feature) {
        if (!feature || !feature.geometry || !feature.properties) return null;

        const geom = feature.geometry;
        if (!geom || geom.type?.toLowerCase().indexOf("line") === -1) return null;

        const props = feature.properties || {};

        // Exclude protected areas (aires_protégées_nationales) - they should not be treated as routes/itineraries
        // Protected areas have minimal properties: fid, Name, region only
        const hasOtherProperties = Object.keys(props).some(key =>
            !['fid', 'name', 'Name', 'region', 'REGION', 'Region'].includes(key)
        );
        if (!hasOtherProperties && (props.fid !== undefined || props.Name)) {
            // Likely a protected area, not an itinerary
            return null;
        }

        const route = Object.assign({}, props);

        if (!route.title && props.name) route.title = props.name;
        if (!route.id && feature.id) route.id = feature.id;
        route.geometry = geom;

        return route;
    };

    // ========================================
    //   RÉCUPÉRATION DES DONNÉES
    // ========================================

    /**
     * Récupère tous les POI depuis les différentes sources
     * @returns {Array} - Liste des POI
     */
    FilterPanelShared.getBasePois = function() {
        const Log = getLog();
        const featureToPoiLike = FilterPanelShared.featureToPoiLike;

        // 1) Prendre depuis GeoJSON (mode layers-only) si dispo
        try {
            if (GeoJSONCore && typeof GeoJSONCore.getFeatures === "function") {
                const feats = GeoJSONCore.getFeatures({ geometryTypes: ["point"] }) || [];
                const pois = feats.map(featureToPoiLike).filter(Boolean);
                if (pois.length) return pois;
            }
        } catch (err) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération POI via GeoJSON:", err);
        }

        // 2) Config active (legacy)
        try {
            if (Config) {
                if (typeof Config.get === "function") {
                    const fromGet = Config.get("poi");
                    if (Array.isArray(fromGet)) return fromGet;
                }
                if (Array.isArray(Config._activeProfileData?.poi)) {
                    return Config._activeProfileData.poi;
                }
            }
        } catch (err) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération POI via Config:", err);
        }

        // 3) Fallback démo
        if (_runtime.cfg && Array.isArray(_runtime.cfg.poi)) {
            return _runtime.cfg.poi;
        }

        return [];
    };

    /**
     * Récupère toutes les routes depuis les différentes sources
     * @returns {Array} - Liste des routes
     */
    FilterPanelShared.getBaseRoutes = function() {
        const Log = getLog();
        const featureToRouteLike = FilterPanelShared.featureToRouteLike;

        // 1) Via GeoJSON (layers-only)
        try {
            if (GeoJSONCore && typeof GeoJSONCore.getFeatures === "function") {
                const feats = GeoJSONCore.getFeatures({ geometryTypes: ["line", "linestring", "multilinestring"] }) || [];
                const routes = feats.map(featureToRouteLike).filter(Boolean);
                if (routes.length) return routes;
            }
        } catch (err) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération routes via GeoJSON:", err);
        }

        // 2) Config active (legacy)
        try {
            if (Config) {
                if (typeof Config.get === "function") {
                    const fromGet = Config.get("routes");
                    if (Array.isArray(fromGet)) return fromGet;
                }
                if (Array.isArray(Config._activeProfileData?.routes)) {
                    return Config._activeProfileData.routes;
                }
            }
        } catch (err) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération routes via Config:", err);
        }

        // 3) Fallback démo
        if (_runtime.cfg && Array.isArray(_runtime.cfg.routes)) {
            return _runtime.cfg.routes;
        }

        return [];
    };

    // ========================================
    //   UTILITAIRES
    // ========================================

    /**
     * Retourne l'élément DOM du panneau de filtres.
     * Priorité au conteneur flottant #gl-filter-panel, puis fallback #gl-left-panel.
     * @returns {HTMLElement|null}
     */
    FilterPanelShared.getFilterPanelElement = function() {
        let el = document.getElementById("gl-filter-panel");
        if (el) return el;

        el = document.getElementById("gl-left-panel");
        if (el) return el;

        const Log = getLog();
        Log.warn("[GeoLeaf.UI.FilterPanel] Aucun conteneur de panneau de filtres trouvé (#gl-filter-panel / #gl-left-panel).");

        return null;
    };

    /**
     * Accède à une propriété imbriquée (Phase 4 dedup: delegates to Utils)
     */
    FilterPanelShared.getNestedValue = getNestedValue$1;

    /**
     * Extrait un point représentatif d'une géométrie (pour calcul de distance)
     * @param {Object} geometry - Géométrie GeoJSON
     * @returns {Object|null} - { lat, lng } ou null
     */
    FilterPanelShared.getRepresentativePoint = function(geometry) {
        if (!geometry || !geometry.coordinates) return null;

        if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
            // Pour un polygone, utiliser le premier point du premier anneau
            const coords = geometry.type === 'Polygon'
                ? geometry.coordinates[0][0]
                : geometry.coordinates[0][0][0];
            return coords ? { lng: coords[0], lat: coords[1] } : null;

        } else if (geometry.type === 'LineString') {
            // Pour une ligne, utiliser le point du milieu
            const coords = geometry.coordinates;
            if (coords && coords.length > 0) {
                const midIndex = Math.floor(coords.length / 2);
                return { lng: coords[midIndex][0], lat: coords[midIndex][1] };
            }

        } else if (geometry.type === 'MultiLineString') {
            // Pour multi-ligne, utiliser le point du milieu de la première ligne
            const coords = geometry.coordinates[0];
            if (coords && coords.length > 0) {
                const midIndex = Math.floor(coords.length / 2);
                return { lng: coords[midIndex][0], lat: coords[midIndex][1] };
            }

        } else if (geometry.type === 'Point') {
            return { lng: geometry.coordinates[0], lat: geometry.coordinates[1] };

        } else if (geometry.type === 'MultiPoint') {
            // Pour multi-point, utiliser le premier point
            const coords = geometry.coordinates[0];
            return coords ? { lng: coords[0], lat: coords[1] } : null;
        }

        return null;
    };

    /**
     * Collecte tous les tags uniques depuis une liste d'items
     * @param {Array} items - Liste d'items (POI, routes)
     * @returns {Array} - Tags uniques triés
     */
    FilterPanelShared.collectAllTags = function(items) {
        const tagSet = new Set();

        items.forEach(function(item) {
            // Support GeoJSON properties.attributes.tags, item.attributes.tags, et item.tags
            const props = item.properties || item;
            const attrs = props.attributes || item.attributes || {};
            const tags = attrs.tags || props.tags || item.tags;

            if (Array.isArray(tags) && tags.length > 0) {
                tags.forEach(function(t) {
                    if (t && typeof t === "string") {
                        tagSet.add(t);
                    }
                });
            }
        });

        const arr = Array.from(tagSet);
        arr.sort();
        return arr;
    };

    /**
     * GeoLeaf UI Filter Panel - Proximity
     * Gestion des filtres de proximité (GPS, manuel, cercle)
     *
     * @module ui/filter-panel/proximity
     */

    // Direct ESM bindings (P3-DEAD-01 complete — module-local state + globalThis)
    // Proximity state — module-local (previously stored on GeoLeaf.UI.*)
    let _proximityMode = false;
    let _proximityCircle = null;
    let _proximityMarker = null;
    let _proximityMap = null;
    let _proximityClickHandler = null;

    const FilterPanelProximity = {};
    FilterPanelProximity._eventCleanups = [];

    /**
     * Initialise la fonctionnalité de proximité
     * @param {L.Map} map - Instance de carte Leaflet
     */
    FilterPanelProximity.initProximityFilter = function (map) {
        const Log = getLog();

        if (!map) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Carte non disponible pour le filtre de proximité");
            return;
        }

        // Initialiser l'état du module de proximité
        _proximityMode = false;
        _proximityCircle = null;
        _proximityMarker = null;
        _proximityMap = map;
        _proximityClickHandler = null;

        // Écouter les changements sur le slider de rayon - avec cleanup tracking
        if (events) {
            const inputHandler = function (evt) {
                const slider = evt.target.closest("[data-filter-proximity-radius]");
                if (!slider) return;

                const proximityControl = slider.closest(".gl-filter-panel__proximity");
                if (!proximityControl) return;

                const wrapper = proximityControl.closest("[data-gl-filter-id='proximity']");
                if (!wrapper) return;

                const newRadius = parseFloat(slider.value);

                // Mettre à jour l'attribut sur le wrapper
                wrapper.setAttribute("data-proximity-radius", newRadius);

                // Si un cercle existe, le mettre à jour visuellement
                if (_proximityCircle) {
                    const radiusMeters = newRadius * 1000;
                    _proximityCircle.setRadius(radiusMeters);
                }
            };

            const clickHandler = function (evt) {
                const btn = evt.target.closest("[data-filter-proximity-btn]");
                if (!btn) return;

                evt.preventDefault();
                FilterPanelProximity.toggleProximityMode(btn, map);
            };

            FilterPanelProximity._eventCleanups.push(
                events.on(document, "input", inputHandler, false, "ProximityFilter.radiusInput")
            );
            FilterPanelProximity._eventCleanups.push(
                events.on(document, "click", clickHandler, false, "ProximityFilter.buttonClick")
            );
        } else {
            // Fallback sans cleanup
            Log.warn(
                "[ProximityFilter] EventListenerManager not available - listeners will not be cleaned up"
            );
            document.addEventListener("input", function (evt) {
                const slider = evt.target.closest("[data-filter-proximity-radius]");
                if (!slider) return;
                const proximityControl = slider.closest(".gl-filter-panel__proximity");
                if (!proximityControl) return;
                const wrapper = proximityControl.closest("[data-gl-filter-id='proximity']");
                if (!wrapper) return;
                const newRadius = parseFloat(slider.value);
                wrapper.setAttribute("data-proximity-radius", newRadius);
                if (_proximityCircle) {
                    const radiusMeters = newRadius * 1000;
                    _proximityCircle.setRadius(radiusMeters);
                }
            });
            document.addEventListener("click", function (evt) {
                const btn = evt.target.closest("[data-filter-proximity-btn]");
                if (!btn) return;
                evt.preventDefault();
                FilterPanelProximity.toggleProximityMode(btn, map);
            });
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Filtre de proximité initialisé");
    };

    /**
     * Cleanup du filtre de proximité
     */
    FilterPanelProximity.destroy = function () {
        const Log = getLog();

        // Cleanup event listeners
        if (FilterPanelProximity._eventCleanups && FilterPanelProximity._eventCleanups.length > 0) {
            FilterPanelProximity._eventCleanups.forEach((cleanup) => {
                if (typeof cleanup === "function") cleanup();
            });
            FilterPanelProximity._eventCleanups = [];
            Log.info("[ProximityFilter] Event listeners cleaned up");
        }

        // Cleanup map references
        if (_proximityCircle) {
            _proximityMap.removeLayer(_proximityCircle);
            _proximityCircle = null;
        }
        if (_proximityMarker) {
            _proximityMap.removeLayer(_proximityMarker);
            _proximityMarker = null;
        }

        _proximityMap = null;
        _proximityMode = false;
    };

    /**
     * Bascule le mode de proximité
     * @param {HTMLElement} btn - Bouton de proximité
     * @param {L.Map} map - Instance de carte
     */
    FilterPanelProximity.toggleProximityMode = function (btn, map) {
        _proximityMode = !_proximityMode;

        const container = btn.closest(".gl-filter-panel__proximity");
        const rangeWrapper = container.querySelector(".gl-filter-panel__proximity-range");
        const instruction = container.querySelector(".gl-filter-panel__proximity-instruction");

        if (_proximityMode) {
            btn.textContent = "Désactiver";
            btn.classList.add("is-active");
            if (rangeWrapper) rangeWrapper.style.display = "block";
            if (instruction) instruction.style.display = "block";

            // Vérifier si la position GPS est disponible et récente (< 5 minutes)
            const hasRecentGPS =
                GeoLocationState.userPosition &&
                Date.now() - GeoLocationState.userPosition.timestamp < 300000;

            if (hasRecentGPS) {
                FilterPanelProximity.activateGPSMode(container, map);
            } else {
                FilterPanelProximity.activateManualMode(container, map);
            }
        } else {
            // Désactiver le mode proximité
            FilterPanelProximity.deactivateProximityMode(btn, container, map);
        }
    };

    /**
     * Active le mode GPS automatique
     * @param {HTMLElement} container - Container de proximité
     * @param {L.Map} map - Instance de carte
     */
    FilterPanelProximity.activateGPSMode = function (container, map) {
        const Log = getLog();

        Log.info(
            "[GeoLeaf.UI.FilterPanel] Utilisation de la position GPS pour la recherche par proximité"
        );

        const radiusInput = container.querySelector("[data-filter-proximity-radius]");
        const radius = radiusInput ? parseFloat(radiusInput.value) : 10;
        const radiusMeters = radius * 1000;

        const wrapper = container.closest("[data-gl-filter-id='proximity']");
        if (!wrapper) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Wrapper proximity non trouvé");
            return;
        }

        // Supprimer les éléments existants
        if (_proximityCircle) {
            map.removeLayer(_proximityCircle);
        }
        if (_proximityMarker) {
            map.removeLayer(_proximityMarker);
        }

        // Créer le cercle à la position GPS
        const gpsLatLng = globalThis.L.latLng(
            GeoLocationState.userPosition.lat,
            GeoLocationState.userPosition.lng
        );

        const interactiveShapes = Config.get("ui.interactiveShapes", false);
        _proximityCircle = globalThis.L.circle(gpsLatLng, {
            radius: radiusMeters,
            color: "#c2410c",
            fillColor: "#c2410c",
            fillOpacity: 0.2,
            weight: 2,
            interactive: interactiveShapes,
        }).addTo(map);

        // Ne pas créer de marqueur supplémentaire si la géolocalisation est active
        if (!GeoLocationState.active) {
            // Mode GPS mais géolocalisation pas en tracking continu : créer un marqueur draggable
            _proximityMarker = globalThis.L.marker(gpsLatLng, {
                draggable: true,
                icon: globalThis.L.divIcon({
                    className: "gl-proximity-gps-marker",
                    html: '<div style="width: 20px; height: 20px; background: #2563eb; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10],
                }),
            }).addTo(map);

            // Gérer le déplacement du marqueur
            _proximityMarker.on("dragend", function () {
                const newLatLng = _proximityMarker.getLatLng();
                if (_proximityCircle) {
                    _proximityCircle.setLatLng(newLatLng);
                }
                wrapper.setAttribute("data-proximity-lat", newLatLng.lat);
                wrapper.setAttribute("data-proximity-lng", newLatLng.lng);
                Log.info("[GeoLeaf.UI.FilterPanel] Point de proximité GPS déplacé:", {
                    lat: newLatLng.lat,
                    lng: newLatLng.lng,
                    radius: radius,
                });
            });
        } else {
            _proximityMarker = null;
            Log.info("[GeoLeaf.UI.FilterPanel] Cercle de proximité affiché autour du marqueur GPS");
        }

        // Définir les attributs sur le wrapper
        wrapper.setAttribute("data-proximity-lat", gpsLatLng.lat);
        wrapper.setAttribute("data-proximity-lng", gpsLatLng.lng);
        wrapper.setAttribute("data-proximity-radius", radius);
        wrapper.setAttribute("data-proximity-active", "true");

        // Centrer la carte sur la position GPS
        map.setView(gpsLatLng, Math.max(map.getZoom(), 14), {
            animate: true,
            duration: 0.5,
        });

        Log.info("[GeoLeaf.UI.FilterPanel] Point de proximité GPS défini:", {
            lat: gpsLatLng.lat,
            lng: gpsLatLng.lng,
            radius: radius,
        });

        // Pas de handler de clic nécessaire en mode GPS
        _proximityClickHandler = null;
    };

    /**
     * Active le mode manuel (clic sur la carte)
     * @param {HTMLElement} container - Container de proximité
     * @param {L.Map} map - Instance de carte
     */
    FilterPanelProximity.activateManualMode = function (container, map) {
        const Log = getLog();

        Log.info(
            "[GeoLeaf.UI.FilterPanel] Mode manuel : cliquez sur la carte pour définir le point de recherche"
        );

        map.getContainer().style.cursor = "crosshair";

        // Créer le handler pour pouvoir le retirer plus tard
        _proximityClickHandler = function (e) {
            const radiusInput = container.querySelector("[data-filter-proximity-radius]");
            const radius = radiusInput ? parseFloat(radiusInput.value) : 10;
            const radiusMeters = radius * 1000;

            const wrapper = container.closest("[data-gl-filter-id='proximity']");
            if (!wrapper) {
                Log.warn("[GeoLeaf.UI.FilterPanel] Wrapper proximity non trouvé");
                return;
            }

            if (_proximityCircle) {
                map.removeLayer(_proximityCircle);
            }
            if (_proximityMarker) {
                map.removeLayer(_proximityMarker);
            }

            const interactiveShapes = Config.get("ui.interactiveShapes", false);
            _proximityCircle = globalThis.L.circle(e.latlng, {
                radius: radiusMeters,
                color: "#c2410c",
                fillColor: "#c2410c",
                fillOpacity: 0.2,
                weight: 2,
                interactive: interactiveShapes,
            }).addTo(map);

            _proximityMarker = globalThis.L.marker(e.latlng, {
                draggable: true,
            }).addTo(map);

            // Gérer le déplacement du marqueur
            _proximityMarker.on("dragend", function () {
                const newLatLng = _proximityMarker.getLatLng();

                if (_proximityCircle) {
                    _proximityCircle.setLatLng(newLatLng);
                }

                wrapper.setAttribute("data-proximity-lat", newLatLng.lat);
                wrapper.setAttribute("data-proximity-lng", newLatLng.lng);

                Log.info("[GeoLeaf.UI.FilterPanel] Point de proximité déplacé:", {
                    lat: newLatLng.lat,
                    lng: newLatLng.lng,
                    radius: radius,
                });
            });

            // Définir les attributs sur le wrapper
            wrapper.setAttribute("data-proximity-lat", e.latlng.lat);
            wrapper.setAttribute("data-proximity-lng", e.latlng.lng);
            wrapper.setAttribute("data-proximity-radius", radius);
            wrapper.setAttribute("data-proximity-active", "true");

            map.getContainer().style.cursor = "";

            Log.info("[GeoLeaf.UI.FilterPanel] Point de proximité défini:", {
                lat: e.latlng.lat,
                lng: e.latlng.lng,
                radius: radius,
            });

            // Nettoyer le handler après le premier clic
            map.off("click", _proximityClickHandler);
            _proximityClickHandler = null;
        };

        // Attacher le handler à la carte
        map.on("click", _proximityClickHandler);
    };

    /**
     * Désactive le mode de proximité
     * @param {HTMLElement} btn - Bouton de proximité
     * @param {HTMLElement} container - Container de proximité
     * @param {L.Map} map - Instance de carte
     */
    FilterPanelProximity.deactivateProximityMode = function (btn, container, map) {
        const Log = getLog();

        btn.textContent = "Activer";
        btn.classList.remove("is-active");

        const rangeWrapper = container.querySelector(".gl-filter-panel__proximity-range");
        const instruction = container.querySelector(".gl-filter-panel__proximity-instruction");

        if (rangeWrapper) rangeWrapper.style.display = "none";
        if (instruction) instruction.style.display = "none";

        map.getContainer().style.cursor = "";

        // Retirer le handler de clic
        if (_proximityClickHandler) {
            map.off("click", _proximityClickHandler);
            _proximityClickHandler = null;
        }

        // Retirer le cercle et le marqueur
        if (_proximityCircle) {
            map.removeLayer(_proximityCircle);
            _proximityCircle = null;
        }
        if (_proximityMarker) {
            map.removeLayer(_proximityMarker);
            _proximityMarker = null;
        }

        // Retirer les attributs du wrapper
        const wrapper = container.closest("[data-gl-filter-id='proximity']");
        if (wrapper) {
            wrapper.removeAttribute("data-proximity-active");
            wrapper.removeAttribute("data-proximity-lat");
            wrapper.removeAttribute("data-proximity-lng");
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Mode proximité désactivé");
    };

    /**
     * Réinitialise complètement le mode proximité depuis l'extérieur (ex. bouton "Réinitialiser").
     * Utilise les variables module-locales (_proximityMap, _proximityMarker, _proximityCircle,
     * _proximityClickHandler) migrées en P3-DEAD-01 — les anciens accès _g.GeoLeaf.UI.* sont morts.
     */
    FilterPanelProximity.resetProximity = function () {
        if (!_proximityMap) return;

        // Retirer le handler de clic sur la carte si présent
        if (_proximityClickHandler) {
            _proximityMap.off("click", _proximityClickHandler);
            _proximityClickHandler = null;
        }

        // Remettre le curseur par défaut
        _proximityMap.getContainer().style.cursor = "";

        // Retirer le cercle de la carte
        if (_proximityCircle) {
            _proximityMap.removeLayer(_proximityCircle);
            _proximityCircle = null;
        }

        // Retirer le marqueur de la carte
        if (_proximityMarker) {
            _proximityMap.removeLayer(_proximityMarker);
            _proximityMarker = null;
        }

        _proximityMode = false;
    };

    /**
     * GeoLeaf UI Filter Panel - State Reader
     * Lecture de l'état des filtres depuis le DOM
     *
     * @module ui/filter-panel/state-reader
     */
    // _g.GeoLeaf.UI.* proximity globals removed — using FilterPanelProximity.resetProximity() (module-local state)

    const FilterPanelStateReader = {};

    /**
     * Structure par défaut de l'état des filtres
     * @returns {Object}
     */
    FilterPanelStateReader.getDefaultState = function () {
        return {
            categoriesTree: [],
            subCategoriesTree: [],
            minRating: NaN,
            hasMinRating: false,
            selectedTags: [],
            hasTags: false,
            dataTypes: { poi: true, routes: true },
            searchText: "",
            hasSearchText: false,
            proximity: {
                active: false,
                center: null,
                radius: 10,
            },
        };
    };

    /**
     * Lit l'état actuel des filtres depuis le panneau DOM
     * @param {HTMLElement} panelEl - Élément du panneau de filtres
     * @returns {Object} - État des filtres
     */
    FilterPanelStateReader.readFiltersFromPanel = function (panelEl) {
        const state = FilterPanelStateReader.getDefaultState();

        if (!panelEl) return state;

        // Types de données (POI / Routes)
        const poiCheckbox = panelEl.querySelector("[data-gl-filter-id='dataTypes'] input[value='poi']");
        const routesCheckbox = panelEl.querySelector(
            "[data-gl-filter-id='dataTypes'] input[value='routes']"
        );
        if (poiCheckbox) state.dataTypes.poi = poiCheckbox.checked;
        if (routesCheckbox) state.dataTypes.routes = routesCheckbox.checked;

        // Recherche textuelle
        const searchInput = panelEl.querySelector(
            "[data-gl-filter-id='searchText'] input[type='text']"
        );
        if (searchInput && searchInput.value.trim() !== "") {
            state.searchText = searchInput.value.trim().toLowerCase();
            state.hasSearchText = true;
        }

        // Proximité
        const proximityContainer = panelEl.querySelector("[data-gl-filter-id='proximity']");
        if (proximityContainer) {
            const isActive = proximityContainer.getAttribute("data-proximity-active") === "true";
            const lat = parseFloat(proximityContainer.getAttribute("data-proximity-lat"));
            const lng = parseFloat(proximityContainer.getAttribute("data-proximity-lng"));
            const radius = parseFloat(proximityContainer.getAttribute("data-proximity-radius"));

            if (isActive && !isNaN(lat) && !isNaN(lng) && !isNaN(radius)) {
                state.proximity.active = true;
                state.proximity.center = { lat: lat, lng: lng };
                state.proximity.radius = radius;
            }
        }

        // Tree-view : catégories cochées
        panelEl
            .querySelectorAll("input.gl-filter-tree__checkbox--category:checked")
            .forEach(function (input) {
                const val = input.value;
                if (val) {
                    state.categoriesTree.push(String(val));
                }
            });

        // Tree-view : sous-catégories cochées
        panelEl
            .querySelectorAll("input.gl-filter-tree__checkbox--subcategory:checked")
            .forEach(function (input) {
                const subId = input.getAttribute("data-gl-filter-subcategory-id");
                if (subId) {
                    state.subCategoriesTree.push(String(subId));
                }
            });

        // Slider de note minimale
        const ratingInput = panelEl.querySelector(
            "[data-gl-filter-id='minRating'] input[type='range']"
        );
        if (ratingInput && ratingInput.value !== "") {
            const val = parseFloat(ratingInput.value);
            if (!isNaN(val)) {
                state.minRating = val;
                state.hasMinRating = val > 0;
            }
        }

        // Tags sélectionnés (badges)
        const tagsContainer = panelEl.querySelector(
            "[data-gl-filter-id='tags'] .gl-filter-panel__tags-container"
        );
        if (tagsContainer) {
            const selectedBadges = tagsContainer.querySelectorAll(
                ".gl-filter-panel__tag-badge.is-selected"
            );
            const selected = Array.from(selectedBadges)
                .map(function (badge) {
                    return badge.getAttribute("data-tag-value");
                })
                .filter(Boolean);
            state.selectedTags = selected;
            state.hasTags = selected.length > 0;
        }

        return state;
    };

    /**
     * Réinitialise les contrôles du panneau de filtres à leur état par défaut
     * @param {HTMLElement} panelEl - Élément du panneau de filtres
     */
    FilterPanelStateReader.resetControls = function (panelEl) {
        if (!panelEl) return;

        // Checkbox-group (POI/Routes) - reset to checked by default
        const dataTypesCheckboxes = panelEl.querySelectorAll(
            "[data-gl-filter-id='dataTypes'] input[type='checkbox']"
        );
        dataTypesCheckboxes.forEach(function (input) {
            input.checked = true;
        });

        // Search text input
        const searchInput = panelEl.querySelector(
            "[data-gl-filter-id='searchText'] input[type='text']"
        );
        if (searchInput) {
            searchInput.value = "";
        }

        // Proximité
        const proximityWrapper = panelEl.querySelector("[data-gl-filter-id='proximity']");
        if (proximityWrapper) {
            proximityWrapper.removeAttribute("data-proximity-active");
            proximityWrapper.removeAttribute("data-proximity-lat");
            proximityWrapper.removeAttribute("data-proximity-lng");
            proximityWrapper.removeAttribute("data-proximity-radius");

            const btn = proximityWrapper.querySelector(".gl-filter-panel__proximity-btn");
            if (btn) {
                btn.classList.remove("is-active");
                btn.textContent = btn.getAttribute("data-label-inactive") || "Activer";
            }

            const rangeWrapper = proximityWrapper.querySelector(".gl-filter-panel__proximity-range");
            if (rangeWrapper) {
                rangeWrapper.style.display = "none";
            }

            const instruction = proximityWrapper.querySelector(
                ".gl-filter-panel__proximity-instruction"
            );
            if (instruction) {
                instruction.style.display = "none";
            }

            // Supprimer le cercle, le marqueur et le handler de clic via l'état module-local
            // (les anciens _g.GeoLeaf.UI._proximityMarker/Circle/Map sont morts depuis P3-DEAD-01)
            FilterPanelProximity.resetProximity();
        }

        // Checkboxes du tree-view (catégories & sous-catégories)
        panelEl.querySelectorAll(".gl-filter-tree__checkbox").forEach(function (input) {
            input.checked = false;
        });

        // Tags - désélectionner tous les badges
        const tagBadges = panelEl.querySelectorAll(".gl-filter-panel__tag-badge.is-selected");
        tagBadges.forEach(function (badge) {
            badge.classList.remove("is-selected");
        });

        // Select classiques
        panelEl.querySelectorAll("select.gl-filter-panel__control--select").forEach(function (sel) {
            if (sel.multiple) {
                Array.from(sel.options).forEach(function (opt) {
                    opt.selected = false;
                });
            } else {
                sel.value = "";
            }
        });

        // Slider note
        const ratingInput = panelEl.querySelector(
            "[data-gl-filter-id='minRating'] input[type='range']"
        );
        const ratingLabel = panelEl.querySelector(
            "[data-gl-filter-id='minRating'] .gl-filter-panel__range-value"
        );
        if (ratingInput) {
            const min = ratingInput.min !== "" ? ratingInput.min : "0";
            ratingInput.value = min;
            if (ratingLabel) {
                ratingLabel.textContent = String(min).replace(".", ",");
            }
        }
    };

    /**
     * GeoLeaf POI API (assemblage namespace POI)
     *
     * Assemble GeoLeaf.POI depuis les sous-modules refactorisés :
     *   - poi/core.js      : Fonctions principales (init, load, display)
     *   - poi/sidepanel.js : Panneau latéral
     *   - poi/shared.js    : État partagé et constantes
     *
     * Note : POI.Renderers est injecté séparément par globals.api.js après Object.assign.
     *
     * @module poi/poi-api
     */

    /**
     * API publique du module POI
     * Toutes les fonctions délèguent aux sous-modules appropriés
     */
    // NOTE: POI.Renderers is set explicitly by globals.js after Object.assign — do not set it here.
    const POI = {
        /**
         * Initialise le module POI avec la carte et la configuration.
         * Supporte deux signatures: init(map, config) et init({map, config}).
         */
        init: function (mapOrOptions, config) {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return;
            }
            POICore.init(mapOrOptions, config);
        },

        loadAndDisplay: function () {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return;
            }
            POICore.loadAndDisplay();
        },

        displayPois: function (pois) {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return;
            }
            POICore.displayPois(pois);
        },

        addPoi: function (poi) {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return null;
            }
            return POICore.addPoi(poi);
        },

        add: function (poi) {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return false;
            }
            return POICore.addPoi(poi);
        },

        getAllPois: function () {
            if (!POICore) return [];
            return POICore.getAllPois();
        },

        getPoiById: function (id) {
            if (!POICore) return null;
            return POICore.getPoiById(id);
        },

        reload: function (pois) {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return;
            }
            POICore.reload(pois);
        },

        showPoiDetails: async function (poi, customLayout) {
            if (!POISidepanel) {
                if (Log) Log.error("[POI] Module SidePanel non chargé.");
                return;
            }
            await POISidepanel.openSidePanel(poi, customLayout);
        },

        hideSidePanel: function () {
            if (!POISidepanel) {
                if (Log) Log.error("[POI] Module SidePanel non chargé.");
                return;
            }
            POISidepanel.closeSidePanel();
        },

        openSidePanelWithLayout: function (poi, customLayout) {
            this.showPoiDetails(poi, customLayout);
        },

        getLayer: function () {
            if (!POIShared) return null;
            const state = POIShared.state;
            return state.poiClusterGroup || state.poiLayerGroup;
        },

        getDisplayedPoisCount: function () {
            if (!POICore) {
                if (Log) Log.error("[POI] Module Core non chargé.");
                return 0;
            }
            return POICore.getDisplayedPoisCount();
        },

        /** @private */
        _clearAllForTests: function () {
            if (!POIShared) return;
            const state = POIShared.state;
            if (Log)
                Log.info(
                    "[POI] _clearAllForTests: Suppression de",
                    state.allPois.length,
                    "POI(s) et",
                    state.poiMarkers.size,
                    "marqueur(s)"
                );
            state.allPois = [];
            state.poiMarkers.clear();
            if (state.poiClusterGroup) state.poiClusterGroup.clearLayers();
            if (state.poiLayerGroup) state.poiLayerGroup.clearLayers();
        },
    };

    /*!
     * GeoLeaf Core – Filters / Utils
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$e =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    /**
     * Extrait une valeur depuis un chemin (ex: "attributes.shortDescription").
     * @param {object} obj
     * @param {string} path
     * @returns {*}
     */
    function getNestedValue(obj, path) {
        return path
            .split(".")
            .reduce(
                (current, prop) => (current && current[prop] !== undefined ? current[prop] : null),
                obj
            );
    }

    /**
     * Récupère les champs de recherche depuis le profil actif.
     * Priorité : layouts (search:true) → searchFields → défauts.
     * @returns {Array<string>}
     */
    function getSearchFieldsFromProfile() {
        try {
            if (_g$e.GeoLeaf?.Config && typeof _g$e.GeoLeaf.Config.getActiveProfile === "function") {
                const profile = _g$e.GeoLeaf.Config.getActiveProfile();
                const searchableFieldsSet = new Set();

                if (profile?.panels?.detail?.layout) {
                    profile.panels.detail.layout
                        .filter((item) => item.search === true && item.field)
                        .forEach((item) => searchableFieldsSet.add(item.field));
                }
                if (profile?.panels?.route?.layout) {
                    profile.panels.route.layout
                        .filter((item) => item.search === true && item.field)
                        .forEach((item) => searchableFieldsSet.add(item.field));
                }

                if (searchableFieldsSet.size > 0) {
                    const fields = Array.from(searchableFieldsSet);
                    Log.debug("[Filters] Champs de recherche depuis layouts (search:true):", fields);
                    return fields;
                }

                if (Array.isArray(profile?.panels?.search?.filters)) {
                    const searchFilter = profile.panels.search.filters.find((f) => f.type === "search");
                    if (searchFilter?.searchFields?.length > 0) {
                        Log.debug(
                            "[Filters] Champs de recherche depuis searchFields (fallback):",
                            searchFilter.searchFields
                        );
                        return searchFilter.searchFields;
                    }
                }
            }
        } catch (err) {
            Log.warn("[Filters] Erreur extraction searchFields du profil:", err);
        }

        const defaultFields = ["title", "label", "name"];
        Log.debug("[Filters] Champs de recherche par défaut:", defaultFields);
        return defaultFields;
    }

    /**
     * Extrait les coordonnées [lat, lng] d'un objet route (multi-format).
     * @param {object} route
     * @returns {Array<[number, number]>}
     */
    function extractRouteCoords(route) {
        if (Array.isArray(route.geometry) && route.geometry.length > 0) {
            if (Array.isArray(route.geometry[0]) && typeof route.geometry[0][0] === "number") {
                return route.geometry.map((pair) => [pair[0], pair[1]]);
            }
            if (
                route.geometry[0]?.type === "LineString" &&
                Array.isArray(route.geometry[0].coordinates)
            ) {
                return route.geometry[0].coordinates.map((c) => [c[1], c[0]]);
            }
        }
        if (route.geometry?.type === "LineString" && Array.isArray(route.geometry.coordinates)) {
            return route.geometry.coordinates.map((c) => [c[1], c[0]]);
        }
        return [];
    }

    /*!
     * GeoLeaf Core – Filters / POI Filter
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$d =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    /**
     * Fallback Haversine distance (metres) — used when GeoLeaf.Utils is not loaded.
     * @param {number} lat1 @param {number} lng1 @param {number} lat2 @param {number} lng2
     * @returns {number}
     */
    function _haversine$1(lat1, lng1, lat2, lng2) {
        const R = 6371000;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
            Math.sin(dLat / 2) ** 2 +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    /**
     * Extrait la note moyenne d'un objet (POI ou route).
     * @param {object} attrs - attributes
     * @param {object} item  - objet racine
     * @param {object} props - properties
     * @returns {{ avg: number, hasRating: boolean }}
     */
    function _extractRating$1(attrs, item, props) {
        let avg = 0;
        let hasRating = false;

        const reviewsObj = attrs.reviews || item.reviews || props.reviews;
        if (reviewsObj && typeof reviewsObj === "object" && !Array.isArray(reviewsObj)) {
            if (typeof reviewsObj.rating === "number") {
                avg = reviewsObj.rating;
                hasRating = true;
            }
        } else if (Array.isArray(reviewsObj) && reviewsObj.length > 0) {
            const sum = reviewsObj.reduce((acc, r) => acc + (Number(r.rating) || 0), 0);
            avg = sum / reviewsObj.length;
            hasRating = avg > 0;
        } else if (typeof attrs.rating === "number") {
            avg = attrs.rating;
            hasRating = true;
        } else if (typeof item.rating === "number") {
            avg = item.rating;
            hasRating = true;
        } else if (typeof props.rating === "number") {
            avg = props.rating;
            hasRating = true;
        }
        return { avg, hasRating };
    }

    /**
     * Normalise un tableau de tags (string CSV, tableau ou autre).
     * @param {*} rawTags
     * @returns {string[]}
     */
    function _normalizeTags$1(rawTags) {
        if (Array.isArray(rawTags)) return rawTags.map((t) => String(t).trim()).filter(Boolean);
        if (typeof rawTags === "string")
            return rawTags
                .split(/[,;]+/)
                .map((t) => t.trim())
                .filter(Boolean);
        return [];
    }

    /**
     * Filtre une liste de POI selon les critères fournis.
     * @param {Array} basePois
     * @param {object} filterState
     * @returns {Array}
     */
    function filterPoiList(basePois, filterState) {
        const catsSel = filterState.categoriesTree || [];
        const subsSel = filterState.subCategoriesTree || [];
        const hasCats = catsSel.length > 0;
        const hasSubs = subsSel.length > 0;
        const hasMinRating = !!filterState.hasMinRating;
        const minRating = filterState.minRating;
        const selectedTags = filterState.selectedTags || [];
        const hasTags = filterState.hasTags;
        const dataTypes = filterState.dataTypes || { poi: true, routes: true };
        const searchText = (filterState.searchText || "").toLowerCase();
        const hasSearchText = filterState.hasSearchText || false;
        const proximity = filterState.proximity || { active: false };

        if (!Array.isArray(basePois) || basePois.length === 0) {
            Log.debug("[Filters] Aucun POI à filtrer");
            return [];
        }

        Log.debug("[Filters] Début filtrage POI:", {
            totalPOI: basePois.length,
            hasCats,
            hasSubs,
            hasSearchText,
            proximityActive: proximity.active,
        });

        const getDistance = _g$d.GeoLeaf?.Utils?.getDistance ?? _haversine$1;

        return basePois.filter((poi) => {
            const attrs = poi.attributes || {};
            const props = poi.properties || {};

            // Filtre type de données
            const poiType = poi.type || attrs.type || props.type || "poi";
            if (poiType === "route" || poiType === "routes") {
                if (!dataTypes.routes) return false;
            } else {
                if (!dataTypes.poi) return false;
            }

            // Filtre recherche textuelle
            if (hasSearchText) {
                const searchFields =
                    filterState.searchFields?.length > 0
                        ? filterState.searchFields
                        : getSearchFieldsFromProfile();
                const matchFound = searchFields.some((fieldPath) => {
                    const value = getNestedValue(poi, fieldPath);
                    if (Array.isArray(value)) {
                        return value.some((v) => String(v).toLowerCase().includes(searchText));
                    }
                    return value && String(value).toLowerCase().includes(searchText);
                });
                if (!matchFound) return false;
            }

            // Filtre proximité
            if (proximity.active && proximity.center) {
                let lat, lng;
                if (poi.latlng && Array.isArray(poi.latlng) && poi.latlng.length === 2) {
                    [lat, lng] = poi.latlng;
                } else {
                    lat =
                        poi.lat ??
                        poi.latitude ??
                        attrs.latitude ??
                        props.latitude ??
                        poi.coordinates?.[1] ??
                        poi.geometry?.coordinates?.[1];
                    lng =
                        poi.lng ??
                        poi.longitude ??
                        attrs.longitude ??
                        props.longitude ??
                        poi.coordinates?.[0] ??
                        poi.geometry?.coordinates?.[0];
                }
                if (lat && lng) {
                    if (
                        getDistance(proximity.center.lat, proximity.center.lng, lat, lng) >
                        proximity.radius
                    )
                        return false;
                } else {
                    return false;
                }
            }

            // Résolution catégorie / sous-catégorie
            const catId = String(
                attrs.categoryId ??
                    poi.categoryId ??
                    poi.category ??
                    props.categoryId ??
                    props.category ??
                    ""
            );
            const subId = String(
                attrs.subCategoryId ??
                    poi.subCategoryId ??
                    poi.subCategory ??
                    poi.sub_category ??
                    props.subCategoryId ??
                    props.sub_category ??
                    ""
            );

            if (hasCats || hasSubs) {
                if (hasSubs) {
                    if (!subId || !subsSel.includes(subId)) return false;
                } else if (hasCats) {
                    if (!catId || !catsSel.includes(catId)) return false;
                }
            }

            // Filtre note minimale
            if (hasMinRating) {
                const { avg, hasRating } = _extractRating$1(attrs, poi, props);
                if (!hasRating || avg < minRating) return false;
            }

            // Filtre tags
            if (hasTags) {
                const poiTags = _normalizeTags$1(attrs.tags ?? poi.tags ?? props.tags);
                if (!selectedTags.some((tag) => poiTags.includes(tag))) return false;
            }

            return true;
        });
    }

    /*!
     * GeoLeaf Core – Filters / Route Filter
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const _g$c =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    function _haversine(lat1, lng1, lat2, lng2) {
        const R = 6371000;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
            Math.sin(dLat / 2) ** 2 +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    function _extractRating(attrs, item, props) {
        let avg = 0;
        let hasRating = false;

        const reviewsObj = attrs.reviews || item.reviews || props.reviews;
        if (reviewsObj && typeof reviewsObj === "object" && !Array.isArray(reviewsObj)) {
            if (typeof reviewsObj.rating === "number") {
                avg = reviewsObj.rating;
                hasRating = true;
            }
        } else if (Array.isArray(reviewsObj) && reviewsObj.length > 0) {
            const sum = reviewsObj.reduce((acc, r) => acc + (Number(r.rating) || 0), 0);
            avg = sum / reviewsObj.length;
            hasRating = avg > 0;
        } else if (typeof attrs.rating === "number") {
            avg = attrs.rating;
            hasRating = true;
        } else if (typeof item.rating === "number") {
            avg = item.rating;
            hasRating = true;
        } else if (typeof props.rating === "number") {
            avg = props.rating;
            hasRating = true;
        }
        return { avg, hasRating };
    }

    function _normalizeTags(rawTags) {
        if (Array.isArray(rawTags)) return rawTags.map((t) => String(t).trim()).filter(Boolean);
        if (typeof rawTags === "string")
            return rawTags
                .split(/[,;]+/)
                .map((t) => t.trim())
                .filter(Boolean);
        return [];
    }

    /**
     * Filtre une liste de routes selon les critères fournis.
     * @param {Array} baseRoutes
     * @param {object} filterState
     * @returns {Array}
     */
    function filterRouteList(baseRoutes, filterState) {
        const catsSel = filterState.categoriesTree || [];
        const subsSel = filterState.subCategoriesTree || [];
        const hasCats = catsSel.length > 0;
        const hasSubs = subsSel.length > 0;
        const selectedTags = filterState.selectedTags || [];
        const hasTags = filterState.hasTags;
        const hasMinRating = !!filterState.hasMinRating;
        const minRating = filterState.minRating;
        const searchText = (filterState.searchText || "").toLowerCase();
        const hasSearchText = filterState.hasSearchText || false;
        const proximity = filterState.proximity || { active: false };

        if (!Array.isArray(baseRoutes) || baseRoutes.length === 0) {
            Log.debug("[Filters] Aucune route à filtrer");
            return [];
        }

        Log.debug("[Filters] Début filtrage routes:", {
            totalRoutes: baseRoutes.length,
            hasCats,
            hasSubs,
            hasMinRating,
            minRating,
            hasSearchText,
            proximityActive: proximity.active,
        });

        const getDistance = _g$c.GeoLeaf?.Utils?.getDistance ?? _haversine;

        return baseRoutes.filter((route) => {
            const attrs = route.attributes || {};
            const props = route.properties || {};

            // Filtre recherche textuelle
            if (hasSearchText) {
                const searchFields =
                    filterState.searchFields?.length > 0
                        ? filterState.searchFields
                        : getSearchFieldsFromProfile();
                const matchFound = searchFields.some((fieldPath) => {
                    const value = getNestedValue(route, fieldPath);
                    return value && String(value).toLowerCase().includes(searchText);
                });
                if (!matchFound) return false;
            }

            // Résolution catégorie / sous-catégorie
            const catId = String(
                attrs.categoryId ??
                    route.categoryId ??
                    route.category ??
                    props.categoryId ??
                    props.category ??
                    ""
            );
            const subId = String(
                attrs.subCategoryId ??
                    route.subCategoryId ??
                    route.subCategory ??
                    route.sub_category ??
                    props.subCategoryId ??
                    props.sub_category ??
                    ""
            );

            if (hasCats || hasSubs) {
                if (hasSubs) {
                    if (!subId || !subsSel.includes(subId)) return false;
                } else if (hasCats) {
                    if (!catId || !catsSel.includes(catId)) return false;
                }
            }

            // Filtre tags
            if (hasTags) {
                const routeTags = _normalizeTags(attrs.tags ?? route.tags ?? props.tags);
                if (!selectedTags.some((tag) => routeTags.includes(tag))) return false;
            }

            // Filtre note minimale
            if (hasMinRating) {
                const { avg, hasRating } = _extractRating(attrs, route, props);
                if (!hasRating || avg < minRating) return false;
            }

            // Filtre proximité (au moins un point de l'itinéraire dans le rayon)
            if (proximity.active && proximity.center) {
                const coords = extractRouteCoords(route);
                if (coords.length === 0) return false;

                const isInRadius = coords.some(
                    ([lat, lng]) =>
                        getDistance(proximity.center.lat, proximity.center.lng, lat, lng) <=
                        proximity.radius
                );
                if (!isInRadius) return false;
            }

            return true;
        });
    }

    /*!
     * GeoLeaf Core – Filters / Index (barrel)
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */


    const Filters = {
        filterPoiList,
        filterRouteList,
    };

    /**
     * GeoLeaf UI Filter Panel - Applier
     * Application des filtres aux couches POI, Routes, GeoJSON
     *
     * @module ui/filter-panel/applier
     */

    // Direct ESM bindings (P3-DEAD-01 complete)
    const getShared$2 = () => FilterPanelShared;
    const getStateReader$2 = () => FilterPanelStateReader;

    const FilterPanelApplier = {};
    let _lastApplyTime = 0;
    const APPLY_DEBOUNCE_DELAY = 300; // 300ms

    // Fonction debounce pour l'application des filtres
    let _applyFiltersTimeout = null;
    let _lastSkipRoutes = false; // Store skipRoutes flag for debounced call
    const _debouncedApplyFilters = function(panelEl, skipRoutes) {
        if (_applyFiltersTimeout) {
            clearTimeout(_applyFiltersTimeout);
        }
        _lastSkipRoutes = skipRoutes || false;
        _applyFiltersTimeout = setTimeout(() => {
            FilterPanelApplier._applyFiltersImmediate(panelEl, _lastSkipRoutes);
        }, APPLY_DEBOUNCE_DELAY);
    };

    /**
     * MEMORY LEAK FIX (Phase 2): Cleanup timeout on destroy
     */
    FilterPanelApplier.destroy = function() {
        if (_applyFiltersTimeout) {
            clearTimeout(_applyFiltersTimeout);
            _applyFiltersTimeout = null;
        }
    };

    /**
     * Rafraîchit la visibilité des POI selon la liste filtrée.
     * IMPORTANT: Cette fonction filtre UNIQUEMENT les POI du système POI traditionnel.
     * Les couches GeoJSON (point, line, polygon) sont gérées par filterGeoJSONLayers().
     * On n'appelle PAS filterFeatures() ici pour éviter de masquer les couches GeoJSON.
     *
     * @param {Array} filteredPois - Liste des POI à afficher
     */
    FilterPanelApplier.refreshPoiLayer = function(filteredPois) {
        const Log = getLog();

        // Vérifier si le système POI est activé dans la config
        const poiConfig = (typeof Config.get === 'function') ? Config.get('poiConfig') : null;
        if (poiConfig && poiConfig.enabled === false) {
            Log.debug("[GeoLeaf.UI.FilterPanel] Système POI désactivé, pas de rafraîchissement de la couche POI.");
            return;
        }

        if (!POI) {
            Log.warn("[GeoLeaf.UI.FilterPanel] GeoLeaf.POI indisponible, pas de rafraîchissement de la couche POI.");
            return;
        }

        if (typeof POI._clearAllForTests === "function") {
            POI._clearAllForTests();
        } else {
            Log.warn("[GeoLeaf.UI.FilterPanel] GeoLeaf.POI._clearAllForTests indisponible.");
        }

        filteredPois.forEach(function(p) {
            try {
                POI.addPoi(p);
            } catch (err) {
                Log.warn("[GeoLeaf.UI.FilterPanel] Impossible d'ajouter un POI filtré:", p, err);
            }
        });

        Log.debug(`[GeoLeaf.UI.FilterPanel] refreshPoiLayer: ${filteredPois.length} POI visibles`);
    };

    /**
     * Applique les filtres aux couches GeoJSON (polygones et polylignes)
     * @param {Object} state - État des filtres
     */
    FilterPanelApplier.filterGeoJSONLayers = function(state) {
        const Log = getLog();
        const Shared = getShared$2();
        const GeoJSON = GeoJSONCore;

        if (!GeoJSON || typeof GeoJSON.filterFeatures !== 'function') {
            return;
        }

        const hasCats = state.categoriesTree && state.categoriesTree.length > 0;
        const hasSubs = state.subCategoriesTree && state.subCategoriesTree.length > 0;
        const hasTags = state.hasTags && state.selectedTags && state.selectedTags.length > 0;
        const selectedTags = state.selectedTags || [];
        const hasProximity = state.proximity && state.proximity.active;
        const hasSearchText = state.hasSearchText && state.searchText;
        const searchText = state.searchText || '';
        // getDistance imported from general-utils.js

        // Helper pour obtenir les champs de recherche depuis la config de la couche
        const getLayerSearchFields = (layerId) => {
            try {
                const layerData = GeoJSON.getLayerData(layerId);
                if (layerData && layerData.config) {
                    // Priorité 1: search.indexingFields (format standard des configs de couches)
                    if (layerData.config.search && Array.isArray(layerData.config.search.indexingFields)) {
                        return layerData.config.search.indexingFields;
                    }
                    // Priorité 2: indexingFields à la racine (legacy)
                    if (Array.isArray(layerData.config.indexingFields)) {
                        return layerData.config.indexingFields;
                    }
                    // Priorité 3: searchFields (legacy)
                    if (Array.isArray(layerData.config.searchFields)) {
                        return layerData.config.searchFields;
                    }
                }
            } catch (err) {
                Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération champs de recherche:", err);
            }

            // Fallback: champs par défaut du profil
            try {
                const activeProfile = Config._activeProfileData;
                if (activeProfile && activeProfile.search && activeProfile.search.filters) {
                    const searchFilter = activeProfile.search.filters.find(f => f.type === 'search');
                    if (searchFilter && Array.isArray(searchFilter.searchFields)) {
                        return searchFilter.searchFields;
                    }
                }
            } catch (err) {
                Log.warn("[GeoLeaf.UI.FilterPanel] Erreur récupération champs par défaut:", err);
            }

            // Fallback ultime
            return ['title', 'description', 'properties.title', 'properties.name', 'properties.description', 'attributes.nom'];
        };

        // Helper pour tester la recherche textuelle sur une feature
        const matchesSearchText = (feature, layerId) => {
            if (!hasSearchText) return true;

            const searchFields = getLayerSearchFields(layerId);
            const searchLower = searchText.toLowerCase();

            for (let i = 0; i < searchFields.length; i++) {
                let fieldPath = searchFields[i];
                let value = null;

                // Normaliser le chemin: si commence par "properties.", on le supprime
                // puisque on va chercher directement dans feature.properties
                let propertiesFieldPath = fieldPath;
                if (fieldPath.startsWith('properties.')) {
                    propertiesFieldPath = fieldPath.substring('properties.'.length);
                }

                // Tester d'abord dans properties
                if (feature.properties) {
                    value = Shared.getNestedValue(feature.properties, propertiesFieldPath);
                }

                // Si pas trouvé, tester à la racine avec le chemin original
                if (!value) {
                    value = Shared.getNestedValue(feature, fieldPath);
                }

                if (value && String(value).toLowerCase().includes(searchLower)) {
                    return true;
                }
            }

            return false;
        };

        // Fonction de filtre commune pour polygones et lignes
        const createFilterFunction = (geometryType) => (feature, layerId) => {
            const props = feature.properties || {};

            // Filtrage par recherche textuelle
            if (hasSearchText && !matchesSearchText(feature, layerId)) {
                return false;
            }

            // Filtrage par catégorie/sous-catégorie
            if (hasCats || hasSubs) {
                const catId = props.categoryId || props.category || null;
                const subId = props.subcategoryId || props.subCategoryId || props.subcategory || props.sub_category || null;

                // Si pas de catégorie sur cette feature, masquer quand filtre actif
                if (!catId && !subId) return false;

                // Si des sous-catégories sont sélectionnées
                if (hasSubs) {
                    if (!subId || !state.subCategoriesTree.includes(String(subId))) {
                        return false;
                    }
                }

                // Si seulement des catégories (pas de sous-cat)
                if (hasCats && !hasSubs) {
                    if (!catId || !state.categoriesTree.includes(String(catId))) {
                        return false;
                    }
                }
            }

            // Filtrage par tags (au moins UN des tags sélectionnés doit être présent)
            if (hasTags) {
                let featureTags = props.tags || [];
                if (!Array.isArray(featureTags)) {
                    if (typeof featureTags === 'string') {
                        featureTags = featureTags.split(/[,;]+/);
                    } else {
                        featureTags = [];
                    }
                }
                featureTags = featureTags.map(t => String(t).trim()).filter(Boolean);

                const hasAtLeastOneTag = selectedTags.some(tag => featureTags.includes(tag));
                if (!hasAtLeastOneTag) {
                    return false;
                }
            }

            // Filtrage par proximité
            if (hasProximity && state.proximity.center && getDistance) {
                const point = Shared.getRepresentativePoint(feature.geometry);
                if (point) {
                    const distance = getDistance(
                        state.proximity.center.lat,
                        state.proximity.center.lng,
                        point.lat,
                        point.lng
                    );
                    if (distance > state.proximity.radius) {
                        return false;
                    }
                }
            }

            return true;
        };

        // Filtrer les polygones (zones)
        GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'polygon' });

        // Filtrer les polylignes (routes GeoJSON)
        GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'line' });

        // Filtrer les points (POI GeoJSON - MultiPoint, Point, etc.)
        GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'point' });
    };

    /**
     * Applique tous les filtres actifs avec debounce
     * @param {HTMLElement} panelEl - Élément du panneau de filtres
     */
    FilterPanelApplier.applyFiltersNow = function(panelEl, skipRoutes) {
        _debouncedApplyFilters(panelEl, skipRoutes);
    };

    /**
     * Applique tous les filtres actifs immédiatement (interne, avec protection contre les appels répétés)
     * @private
     * @param {HTMLElement} panelEl - Élément du panneau de filtres
     * @param {boolean} skipRoutes - Si true, skip le traitement des routes (preserve leurs styles)
     */
    FilterPanelApplier._applyFiltersImmediate = function(panelEl, skipRoutes) {
        const Log = getLog();
        const Shared = getShared$2();
        const StateReader = getStateReader$2();

        // Éviter les appels répétés trop rapprochés
        const now = Date.now();
        if (now - _lastApplyTime < 100) return; // 100ms minimum entre les appels
        _lastApplyTime = now;

        const basePois = Shared.getBasePois();
        const baseRoutes = Shared.getBaseRoutes();
        const state = StateReader.readFiltersFromPanel(panelEl);

        // Filtrage des couches GeoJSON (polygones, polylignes)
        FilterPanelApplier.filterGeoJSONLayers(state);

        if (!basePois.length && !baseRoutes.length) {
            Log.info("[GeoLeaf.UI.FilterPanel] Aucun POI ni route source trouvé.");
            return;
        }

        // Gérer le filtrage et l'affichage des itinéraires via GeoLeaf.Route
        if (Route && typeof Route.isInitialized === 'function' && Route.isInitialized()) {
            if (state.dataTypes.routes) {
                // Si skipRoutes=true, on affiche juste les routes existantes sans les recharger
                if (skipRoutes) {
                    Route.show();
                } else {
                    // Filtrer les routes
                    let filteredRoutes = baseRoutes;
                    filteredRoutes = Filters && typeof Filters.filterRouteList === 'function'
                        ? Filters.filterRouteList(baseRoutes, state)
                        : baseRoutes;

                    Log.info("[GeoLeaf.UI.FilterPanel] Filtres appliqués sur les routes.", {
                        total: baseRoutes.length,
                        result: filteredRoutes.length
                    });

                    // Utiliser filterVisibility() si disponible pour préserver les styles
                    // Sinon, utiliser loadFromConfig() (comportement par défaut)
                    if (typeof Route.filterVisibility === 'function') {
                        Route.filterVisibility(filteredRoutes);
                    } else if (typeof Route.loadFromConfig === 'function') {
                        Route.loadFromConfig(filteredRoutes);
                    }
                    Route.show();
                }
            } else {
                Route.hide();
            }
        }

        // Filtrer les POI
        const filtered = FilterPanelApplier.filterPoiList(basePois, state);

        Log.info("[GeoLeaf.UI.FilterPanel] Filtres appliqués sur les POI.", {
            total: basePois.length,
            result: filtered.length,
            filters: state
        });

        FilterPanelApplier.refreshPoiLayer(filtered);
    };

    /**
     * Filtre une liste de POI selon les critères fournis
     * Délègue vers GeoLeaf.Filters.filterPoiList()
     *
     * @param {Array} basePois - Liste complète des POI
     * @param {Object} filterState - État des filtres
     * @returns {Array} POI filtrés
     */
    FilterPanelApplier.filterPoiList = function(basePois, filterState) {
        if (Filters && typeof Filters.filterPoiList === 'function') {
            return Filters.filterPoiList(basePois, filterState);
        }

        const Log = getLog();
        Log.warn('[GeoLeaf.UI.FilterPanel] Module Filters non chargé, retour liste complète');
        return basePois || [];
    };

    /**
     * Filtre une liste de routes selon les critères fournis
     * Délègue vers GeoLeaf.Filters.filterRouteList()
     *
     * @param {Array} baseRoutes - Liste complète des routes
     * @param {Object} filterState - État des filtres
     * @returns {Array} Routes filtrées
     */
    FilterPanelApplier.filterRouteList = function(baseRoutes, filterState) {
        if (Filters && typeof Filters.filterRouteList === 'function') {
            return Filters.filterRouteList(baseRoutes, filterState);
        }

        const Log = getLog();
        Log.warn('[GeoLeaf.UI.FilterPanel] Module Filters non chargé, retour liste complète');
        return baseRoutes || [];
    };

    /**
     * Applique les filtres initiaux au chargement
     */
    FilterPanelApplier.applyFiltersInitial = function() {
        const Log = getLog();
        const Shared = getShared$2();
        const StateReader = getStateReader$2();

        const panelEl = Shared.getFilterPanelElement();
        if (!panelEl) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Panneau de filtres non trouvé, impossible d'appliquer les filtres initiaux.");
            return;
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Application des filtres initiaux...");

        const state = StateReader.readFiltersFromPanel(panelEl);
        const basePois = Shared.getBasePois();
        const baseRoutes = Shared.getBaseRoutes();

        if (!basePois.length && !baseRoutes.length) {
            Log.info("[GeoLeaf.UI.FilterPanel] Aucun POI ni route source trouvé.");
            return;
        }

        // Gérer les itinéraires
        if (Route && typeof Route.isInitialized === 'function' && Route.isInitialized()) {
            if (state.dataTypes.routes) {
                let filteredRoutes = FilterPanelApplier.filterRouteList(baseRoutes, state);
                if (typeof Route.loadFromConfig === 'function') {
                    Route.loadFromConfig(filteredRoutes);
                }
                Route.show();
            } else {
                Route.hide();
            }
        }

        // Filtrer et charger les POI
        const filtered = FilterPanelApplier.filterPoiList(basePois, state);
        Log.info("[GeoLeaf.UI.FilterPanel] POI filtrés pour chargement initial.", {
            total: basePois.length,
            result: filtered.length
        });

        FilterPanelApplier.refreshPoiLayer(filtered);
    };

    /**
     * GeoLeaf UI Filter Panel - SVG Helpers
     * Fonctions SVG pour les icônes du panneau de filtres
     *
     * @module ui/filter-panel/svg-helpers
     */

    /**
     * Met à jour une icône de toggle pour l'état "panneau ouvert" (flèche gauche)
     * @param {HTMLElement} icon - L'élément icône à mettre à jour
     */
    function setToggleIconOpen(icon) {
        // SAFE: SVG statique hardcodé
        DOMSecurity.clearElementFast(icon);
        const svg = DOMSecurity.createSVGIcon(16, 16, 'M15 18l-6-6 6-6', {
            stroke: 'currentColor',
            strokeWidth: '6',
            fill: 'none'
        });
        icon.appendChild(svg);
    }

    /**
     * Met à jour une icône de toggle pour l'état "panneau fermé" (flèche droite)
     * @param {HTMLElement} icon - L'élément icône à mettre à jour
     */
    function setToggleIconClosed(icon) {
        // SAFE: SVG statique hardcodé
        DOMSecurity.clearElementFast(icon);
        const svg = DOMSecurity.createSVGIcon(16, 16, 'M9 6l6 6-6 6', {
            stroke: 'currentColor',
            strokeWidth: '6',
            fill: 'none'
        });
        icon.appendChild(svg);
    }

    /**
     * GeoLeaf UI Filter Panel - Lazy Loader
     * Chargement à la demande des filtres catégories et tags
     *
     * @module ui/filter-panel/lazy-loader
     */

    const FilterPanelLazyLoader = {
        _cache: {},
        _openAccordions: new Set(),

        /**
         * Charge les catégories pour le thème actif
         * @param {string} themeId - ID du thème
         * @returns {Array} - Array de catégories avec leurs sous-catégories
         */
        loadCategories(themeId) {
            const cacheKey = `categories_${themeId}`;

            if (this._cache[cacheKey]) {
                Log.debug("[LazyLoader] Cache HIT pour catégories:", themeId);
                return this._cache[cacheKey];
            }

            Log.debug("[LazyLoader] Cache MISS pour catégories, scan en cours...");
            const result = this._scanCategories(themeId);
            this._cache[cacheKey] = result;
            return result;
        },

        /**
         * Charge les tags pour le thème actif
         * @param {string} themeId - ID du thème
         * @returns {Array} - Array de tags uniques
         */
        loadTags(themeId) {
            const cacheKey = `tags_${themeId}`;

            if (this._cache[cacheKey]) {
                Log.debug("[LazyLoader] Cache HIT pour tags:", themeId);
                return this._cache[cacheKey];
            }

            Log.debug("[LazyLoader] Cache MISS pour tags, scan en cours...");
            const result = this._scanTags(themeId);
            this._cache[cacheKey] = result;
            return result;
        },

        /**
         * Scanne les features pour extraire les catégories utilisées
         * @private
         * @param {string} themeId - ID du thème
         * @returns {Object} - {categories: Map, usedIds: Set}
         */
        _scanCategories(themeId) {
            const startTime = performance.now();

            // Récupérer les couches visibles du thème
            const visibleLayerIds = this._getVisibleLayerIds(themeId);

            // Récupérer toutes les features
            let allFeatures = [];
            try {
                if (GeoJSONCore && typeof GeoJSONCore.getFeatures === "function") {
                    allFeatures = GeoJSONCore.getFeatures() || [];
                }
            } catch (err) {
                Log.warn("[LazyLoader] Erreur récupération features:", err);
                return { categories: new Map(), usedIds: new Set() };
            }

            // Filtrer par couches visibles
            const visibleFeatures = allFeatures.filter((feature) => {
                const layerId =
                    feature.properties?._layerId || feature.properties?.layerId || feature._layerId;
                return visibleLayerIds.includes(layerId);
            });

            Log.debug(
                `[LazyLoader] Scan catégories: ${visibleFeatures.length} features sur ${visibleLayerIds.length} couches actives`
            );

            // Extraire les catégories uniques (normalisation lowercase + variantes camelCase)
            const usedCategoryIds = new Set();
            visibleFeatures.forEach((feature) => {
                const props = feature.properties || {};
                if (props.categoryId) {
                    usedCategoryIds.add(props.categoryId);
                }
                if (props.subcategoryId) {
                    usedCategoryIds.add(props.subcategoryId);
                }
                // Variante camelCase (subCategoryId) présente dans certains GeoJSON
                if (props.subCategoryId) {
                    usedCategoryIds.add(props.subCategoryId);
                }
            });

            const elapsed = (performance.now() - startTime).toFixed(2);
            Log.info(
                `[LazyLoader] Scan catégories terminé en ${elapsed}ms: ${usedCategoryIds.size} catégories trouvées`
            );

            return {
                usedIds: usedCategoryIds,
                visibleLayerIds: visibleLayerIds,
            };
        },

        /**
         * Scanne les features pour extraire les tags utilisés
         * @private
         * @param {string} themeId - ID du thème
         * @returns {Array} - Array de tags triés
         */
        _scanTags(themeId) {
            const startTime = performance.now();

            // Récupérer les couches visibles du thème
            const visibleLayerIds = this._getVisibleLayerIds(themeId);

            // Récupérer toutes les features
            let allFeatures = [];
            try {
                if (GeoJSONCore && typeof GeoJSONCore.getFeatures === "function") {
                    allFeatures = GeoJSONCore.getFeatures() || [];
                }
            } catch (err) {
                Log.warn("[LazyLoader] Erreur récupération features:", err);
                return [];
            }

            // Filtrer par couches visibles
            const visibleFeatures = allFeatures.filter((feature) => {
                const layerId =
                    feature.properties?._layerId || feature.properties?.layerId || feature._layerId;
                return visibleLayerIds.includes(layerId);
            });

            // Extraire les tags uniques
            const tagSet = new Set();
            visibleFeatures.forEach((feature) => {
                const props = feature.properties || {};
                const attrs = props.attributes || {};
                const tags = attrs.tags || props.tags;

                if (Array.isArray(tags)) {
                    tags.forEach((tag) => {
                        if (tag && typeof tag === "string") {
                            tagSet.add(tag);
                        }
                    });
                }
            });

            const tagsArray = Array.from(tagSet).sort();
            const elapsed = (performance.now() - startTime).toFixed(2);

            Log.info(`[LazyLoader] Scan tags terminé en ${elapsed}ms:`, {
                totalFeatures: allFeatures.length,
                visibleFeatures: visibleFeatures.length,
                tagsFound: tagsArray.length,
            });

            return tagsArray;
        },

        /**
         * Récupère les IDs des couches réellement visibles sur la carte
         * @private
         * @param {string} _themeId - ID du thème (non utilisé, mais conservé pour compatibilité)
         * @returns {Array} - Array d'IDs de couches avec visible: true
         */
        _getVisibleLayerIds(_themeId) {
            let visibleLayerIds = [];

            try {
                if (GeoJSONCore && typeof GeoJSONCore.getAllLayers === "function") {
                    const allLayers = GeoJSONCore.getAllLayers();
                    // Filtrer uniquement celles qui sont visibles (ON dans layer manager)
                    visibleLayerIds = allLayers
                        .filter((layer) => layer.visible === true)
                        .map((layer) => layer.id);

                    Log.debug(
                        `[LazyLoader] ${visibleLayerIds.length} couches visibles trouvées:`,
                        visibleLayerIds
                    );
                }
            } catch (err) {
                Log.warn("[LazyLoader] Erreur récupération couches visibles:", err);
            }

            return visibleLayerIds;
        },

        /**
         * Marque un accordéon comme ouvert
         * @param {string} type - 'categories' ou 'tags'
         * @param {HTMLElement} element - Element de l'accordéon
         */
        markAccordionOpen(type, element) {
            this._openAccordions.add({ type, element });
            Log.debug(`[LazyLoader] Accordéon "${type}" marqué comme ouvert`);
        },

        /**
         * Marque un accordéon comme fermé
         * @param {HTMLElement} element - Element de l'accordéon
         */
        markAccordionClosed(element) {
            this._openAccordions.forEach((item) => {
                if (item.element === element) {
                    this._openAccordions.delete(item);
                    Log.debug(`[LazyLoader] Accordéon "${item.type}" marqué comme fermé`);
                }
            });
        },

        /**
         * Invalide le cache pour un thème spécifique
         * @param {string} themeId - ID du thème
         */
        invalidateCacheForTheme(themeId) {
            delete this._cache[`categories_${themeId}`];
            delete this._cache[`tags_${themeId}`];
            Log.info(`[LazyLoader] Cache invalidé pour thème: ${themeId}`);
        },

        /**
         * Invalide tout le cache (changement de thème)
         */
        clearCache() {
            this._cache = {};
            Log.info("[LazyLoader] Cache complètement vidé");
        },

        /**
         * Rafraîchit les accordéons ouverts
         * Utilisé après un changement de thème ou toggle de couche
         */
        refreshOpenAccordions() {
            if (this._openAccordions.size === 0) {
                Log.debug("[LazyLoader] Aucun accordéon ouvert à rafraîchir");
                return;
            }

            Log.info(
                `[LazyLoader] Rafraîchissement de ${this._openAccordions.size} accordéon(s) ouvert(s)`
            );
            const currentTheme = ThemeSelector.getCurrentTheme();

            if (!currentTheme) {
                Log.warn("[LazyLoader] Impossible de récupérer le thème actif");
                return;
            }

            this._openAccordions.forEach(({ type, element }) => {
                // Sauvegarder l'état des checkboxes / tags sélectionnés
                const savedStates = this._saveCheckboxStates(element);

                // Cibler la zone [data-lazy-type] qui reçoit le innerHTML
                const contentArea = element.querySelector("[data-lazy-type]");

                if (!contentArea) {
                    Log.warn("[LazyLoader] Zone [data-lazy-type] introuvable dans l'accordéon");
                    return;
                }

                // Réinitialiser le flag lazyLoaded pour permettre un futur rechargement
                element.dataset.lazyLoaded = "false";

                // Appeler la fonction de render appropriée
                if (type === "categories") {
                    this._rerenderCategories(contentArea, currentTheme, savedStates);
                } else if (type === "tags") {
                    this._rerenderTags(contentArea, currentTheme, savedStates);
                }

                // Re-marquer comme chargé après le re-render
                element.dataset.lazyLoaded = "true";
            });
        },

        /**
         * Re-render les catégories dans un accordéon
         * @private
         */
        _rerenderCategories(contentArea, themeId, savedStates) {
            const result = this.loadCategories(themeId);

            // Construction du contenu via import ESM direct (P3-DEAD-02)
            const content = buildCategoryTreeContent(result);
            // Les valeurs utilisateur sont échappées à la source par buildCategoryTreeContent.
            // On utilise createContextualFragment (suppression scripts uniquement) pour préserver
            // tous les attributs sûrs (class, data-*, type, value, name, checked) — la whitelist
            // de sanitizeHTML supprimait <input> et <label>, cassant les checkboxes.
            contentArea.textContent = "";
            const catFrag = document
                .createRange()
                .createContextualFragment(content.replace(/<script[\s\S]*?<\/script>/gi, ""));
            contentArea.appendChild(catFrag);

            // NE PAS réattacher attachCategoryTreeListeners ici :
            // le listener sur contentArea (ajouté par _loadAccordionContentIfNeeded)
            // survit au remplacement des enfants. Réattacher causerait des duplicatas
            // qui annuleraient les toggles de checkbox (toggle pair = zéro net).

            // Restaurer les états des checkboxes
            this._restoreCheckboxStates(contentArea, savedStates);
        },

        /**
         * Re-render les tags dans un accordéon
         * @private
         */
        _rerenderTags(contentArea, themeId, savedStates) {
            const tags = this.loadTags(themeId);

            // Construction du contenu via import ESM direct (P3-DEAD-02)
            const content = buildTagsListContent(tags);
            // Les valeurs utilisateur sont échappées à la source par buildTagsListContent.
            // On utilise createContextualFragment (suppression scripts uniquement) pour préserver
            // class et data-tag-value sur les <span> badges — la whitelist supprimait ces attributs,
            // rendant les tags non sélectionnables.
            contentArea.textContent = "";
            const tagFrag = document
                .createRange()
                .createContextualFragment(content.replace(/<script[\s\S]*?<\/script>/gi, ""));
            contentArea.appendChild(tagFrag);

            // NE PAS réattacher attachTagsListeners ici :
            // le listener sur contentArea (ajouté par _loadAccordionContentIfNeeded)
            // survit au remplacement des enfants. Réattacher causerait des duplicatas
            // qui annuleraient les toggles (toggle pair = zéro net, badge
            // semblant inactif même après clic).

            // Restaurer les états des checkboxes
            this._restoreCheckboxStates(contentArea, savedStates);
        },

        /**
         * Sauvegarde l'état des checkboxes avant re-render
         * @private
         */
        _saveCheckboxStates(element) {
            const states = {};
            const checkboxes = element.querySelectorAll('input[type="checkbox"]');

            checkboxes.forEach((cb) => {
                const categoryId = cb.dataset.glFilterCategoryId;
                const subcategoryId = cb.dataset.glFilterSubcategoryId;
                const value = cb.value;

                let key;
                if (subcategoryId) {
                    key = `${categoryId}:${subcategoryId}`;
                } else if (categoryId) {
                    key = categoryId;
                } else if (value) {
                    key = value;
                }

                if (key) {
                    states[key] = cb.checked;
                }
            });

            return states;
        },

        /**
         * Restaure l'état des checkboxes après re-render
         * @private
         */
        _restoreCheckboxStates(element, savedStates) {
            if (!savedStates || Object.keys(savedStates).length === 0) return;

            const checkboxes = element.querySelectorAll('input[type="checkbox"]');
            let restoredCount = 0;

            checkboxes.forEach((cb) => {
                const categoryId = cb.dataset.glFilterCategoryId;
                const subcategoryId = cb.dataset.glFilterSubcategoryId;
                const value = cb.value;

                let key;
                if (subcategoryId) {
                    key = `${categoryId}:${subcategoryId}`;
                } else if (categoryId) {
                    key = categoryId;
                } else if (value) {
                    key = value;
                }

                if (key && savedStates[key] !== undefined) {
                    cb.checked = savedStates[key];
                    restoredCount++;
                }
            });

            Log.debug(`[LazyLoader] ${restoredCount} états de checkbox restaurés`);
        },
    };

    // Écouter les événements de changement de thème
    document.addEventListener("geoleaf:theme:applied", () => {
        Log.info("[LazyLoader] Événement theme:applied détecté — invalidation complète");

        // 1. Vider le cache de données (scan catégories/tags)
        FilterPanelLazyLoader.clearCache();

        // 2. Réinitialiser TOUS les flags data-lazy-loaded sur les accordéons
        //    (fermés ou ouverts) pour forcer un rechargement au prochain expand
        const allAccordions = document.querySelectorAll(
            ".gl-filter-panel__group--accordion[data-lazy-loaded]"
        );
        allAccordions.forEach((acc) => {
            acc.dataset.lazyLoaded = "false";
        });
        Log.debug(`[LazyLoader] ${allAccordions.length} flag(s) data-lazy-loaded réinitialisé(s)`);

        // 3. Rafraîchir les accordéons actuellement ouverts (re-render immédiat)
        FilterPanelLazyLoader.refreshOpenAccordions();
    });

    // Écouter l'événement de changement de visibilité de couche
    document.addEventListener("geoleaf:geojson:visibility-changed", (e) => {
        const detail = e.detail || {};
        Log.info("[LazyLoader] Visibilité couche changée:", detail.layerId, detail.visible);

        // Invalider le cache du thème actif
        const currentTheme = ThemeSelector.getCurrentTheme();
        if (currentTheme) {
            FilterPanelLazyLoader.invalidateCacheForTheme(currentTheme);
            // Rafraîchir les accordéons ouverts
            FilterPanelLazyLoader.refreshOpenAccordions();
        }
    });

    /**
     * GeoLeaf UI Filter Panel - Renderer
     * Construction du panneau HTML de filtres
     *
     * @module ui/filter-panel/renderer
     */

    // Direct ESM bindings (P3-DEAD-01 complete)
    const getShared$1 = () => FilterPanelShared;
    const getStateReader$1 = () => FilterPanelStateReader;
    const getApplier$1 = () => FilterPanelApplier;

    const FilterPanelRenderer = {};
    FilterPanelRenderer._eventCleanups = [];

    /**
     * Construit le panneau de filtres depuis la configuration du profil actif
     * @param {Object} options - Options
     * @param {HTMLElement} [options.container] - Conteneur cible
     */
    FilterPanelRenderer.buildFilterPanelFromActiveProfile = function (options) {
        const Log = getLog();
        const Shared = getShared$1();
        const StateReader = getStateReader$1();
        const Applier = getApplier$1();

        if (Log) Log.debug("[FilterPanel] buildFilterPanelFromActiveProfile APPELÉ, options:", options);

        const profile = getActiveProfile();
        if (Log) Log.debug("[FilterPanel] Profile récupéré:", profile);

        if (!profile) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Aucun profil actif trouvé");
            return;
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Profil actif:", profile.id || "unknown");

        // Support both profile.panels.search (old) and profile.search (new)
        const searchPanel = (profile.panels && profile.panels.search) || profile.search;
        if (Log) Log.debug("[FilterPanel] searchPanel:", searchPanel);

        if (!searchPanel) {
            Log.warn(
                "[GeoLeaf.UI.FilterPanel] Aucune configuration search/panels.search dans le profil"
            );
            return;
        }

        const filters = searchPanel && Array.isArray(searchPanel.filters) ? searchPanel.filters : null;
        if (Log) Log.debug("[FilterPanel] Filters:", filters);

        if (!filters || !filters.length) {
            Log.warn(
                "[GeoLeaf.UI.FilterPanel] Aucun filtre défini dans profile.search.filters pour le profil actif. Filters:",
                filters
            );
            return;
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Nombre de filtres trouvés:", filters.length);

        const container = (options && options.container) || Shared.getFilterPanelElement();
        if (!container) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Conteneur de panneau introuvable");
            return;
        }

        // ---------------------------------------------------------
        // Vider le conteneur existant
        // ---------------------------------------------------------
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }

        container.classList.add("gl-filter-panel");

        // ---------------------------------------------------------
        // Header
        // ---------------------------------------------------------
        const header = createElement$1("div", {
            className: "gl-filter-panel__header",
        });

        const title = createElement$1("h2", {
            className: "gl-filter-panel__title",
            textContent: searchPanel.title || "Filtres",
        });
        header.appendChild(title);

        // Bouton toggle avec flèche (comme le tableau)
        const toggleBtn = createElement$1("button", {
            type: "button",
            className: "gl-filter-panel__toggle-btn",
            attributes: {
                "data-gl-action": "filter-close",
                "aria-label": "Fermer le panneau",
            },
        });
        const toggleIcon = createElement$1("span", {
            className: "gl-filter-panel__toggle-icon",
            textContent: "◀",
        });
        toggleBtn.appendChild(toggleIcon);
        header.appendChild(toggleBtn);

        container.appendChild(header);

        // ---------------------------------------------------------
        // Body : champs de filtre
        // ---------------------------------------------------------
        const body = createElement$1("div", {
            className: "gl-filter-panel__body",
        });

        // Sprint 3.2: Use DocumentFragment for batch DOM operations
        const bodyFragment = document.createDocumentFragment();

        filters.forEach(function (filterDef) {
            // Passer skipLabel=true pour les filtres avec accordéon (categories et tags) et proximity (qui gère son propre label)
            const skipLabel =
                filterDef.id === "categories" ||
                filterDef.id === "tags" ||
                filterDef.type === "proximity";
            const groupEl = _buildFilterControl(filterDef, profile, skipLabel);

            if (groupEl) {
                // Wrapper avec accordéon pour categories et tags
                if (filterDef.id === "categories" || filterDef.id === "tags") {
                    const accordionGroup = createElement$1("div", {
                        className: "gl-filter-panel__group--accordion",
                        attributes: { "data-accordion-for": filterDef.id },
                    });

                    const accordionHeader = createElement$1("div", {
                        className: "gl-filter-panel__accordion-header",
                    });

                    const accordionTitle = createElement$1("h3", {
                        className: "gl-filter-panel__accordion-title",
                        textContent:
                            filterDef.label ||
                            (filterDef.id === "categories"
                                ? "Afficher les catégories"
                                : "Afficher les tags"),
                    });

                    const accordionArrow = createElement$1("span", {
                        className: "gl-filter-panel__accordion-arrow",
                        textContent: "▶",
                    });

                    accordionHeader.appendChild(accordionTitle);
                    accordionHeader.appendChild(accordionArrow);

                    const accordionBody = createElement$1("div", {
                        className: "gl-filter-panel__accordion-body",
                    });

                    // Wrapper nécessaire pour la technique CSS Grid
                    const accordionWrapper = createElement$1("div");
                    accordionWrapper.appendChild(groupEl);
                    accordionBody.appendChild(accordionWrapper);

                    const accordionClickHandler = function () {
                        requestAnimationFrame(function () {
                            accordionGroup.classList.toggle("is-expanded");

                            const isExpanded = accordionGroup.classList.contains("is-expanded");

                            // LAZY LOADING: Charger le contenu à la demande si nécessaire
                            if (isExpanded) {
                                FilterPanelRenderer._loadAccordionContentIfNeeded(
                                    accordionGroup,
                                    filterDef
                                );
                            } else {
                                // Marquer comme fermé
                                const LazyLoader = FilterPanelLazyLoader;
                                if (LazyLoader) {
                                    LazyLoader.markAccordionClosed(accordionGroup);
                                }
                            }
                        });
                    };

                    if (events) {
                        FilterPanelRenderer._eventCleanups.push(
                            events.on(
                                accordionHeader,
                                "click",
                                accordionClickHandler,
                                false,
                                "FilterPanel.accordionToggle"
                            )
                        );
                    } else {
                        accordionHeader.addEventListener("click", accordionClickHandler);
                    }

                    accordionGroup.appendChild(accordionHeader);
                    accordionGroup.appendChild(accordionBody);
                    bodyFragment.appendChild(accordionGroup);
                } else {
                    bodyFragment.appendChild(groupEl);
                }
            }
        });

        body.appendChild(bodyFragment);

        container.appendChild(body);

        // ---------------------------------------------------------
        // Footer : boutons Appliquer / Réinitialiser
        // ---------------------------------------------------------
        const footer = createElement$1("div", {
            className: "gl-filter-panel__footer",
        });

        const applyBtn = createElement$1("button", {
            type: "button",
            className: "gl-btn gl-btn--accent gl-filter-panel__btn-apply",
            textContent: (searchPanel.actions && searchPanel.actions.applyLabel) || "Appliquer",
        });
        footer.appendChild(applyBtn);

        const resetBtn = createElement$1("button", {
            type: "button",
            className: "gl-btn gl-btn--subtle gl-filter-panel__btn-reset",
            textContent: (searchPanel.actions && searchPanel.actions.resetLabel) || "Réinitialiser",
        });
        footer.appendChild(resetBtn);

        container.appendChild(footer);

        // ---------------------------------------------------------
        // Wiring évènements (fermer / reset / appliquer)
        // ---------------------------------------------------------
        if (!container._glFilterHandlersBound) {
            // Déclarer events une seule fois pour tout le bloc

            const containerClickHandler = function (evt) {
                const target = evt.target;

                // Fermer le panneau (utilise closest pour gérer les clics sur les enfants du bouton)
                if (target.closest("[data-gl-action='filter-close']")) {
                    evt.preventDefault();
                    FilterPanelRenderer.toggleFilterPanelVisibility(false);
                    return;
                }

                // Réinitialiser les filtres + réafficher tous les POI
                if (target.classList.contains("gl-filter-panel__btn-reset")) {
                    evt.preventDefault();
                    StateReader.resetControls(container);
                    Applier.applyFiltersNow(container, true); // skipRoutes=true to preserve route styling
                    return;
                }

                // Appliquer les filtres
                if (target.classList.contains("gl-filter-panel__btn-apply")) {
                    evt.preventDefault();
                    Applier.applyFiltersNow(container);
                    return;
                }
            };

            if (events) {
                FilterPanelRenderer._eventCleanups.push(
                    events.on(
                        container,
                        "click",
                        containerClickHandler,
                        false,
                        "FilterPanel.containerClick"
                    )
                );
            } else {
                container.addEventListener("click", containerClickHandler);
            }

            // Gestionnaire pour la touche Entrée dans l'input de recherche textuelle
            const containerKeydownHandler = function (evt) {
                if (evt.key === "Enter" || evt.keyCode === 13) {
                    const target = evt.target;
                    const searchInput = target.closest(
                        "[data-gl-filter-id='searchText'] input[type='text']"
                    );
                    if (searchInput) {
                        evt.preventDefault();
                        Applier.applyFiltersNow(container);
                        return;
                    }
                }
            };

            if (events) {
                FilterPanelRenderer._eventCleanups.push(
                    events.on(
                        container,
                        "keydown",
                        containerKeydownHandler,
                        false,
                        "FilterPanel.enterKey"
                    )
                );
            } else {
                container.addEventListener("keydown", containerKeydownHandler);
            }

            container._glFilterHandlersBound = true;
        }

        // Le panneau doit être masqué par défaut au démarrage
        // Il ne s'affichera que lorsque l'utilisateur cliquera sur le bouton toggle
        container.classList.remove("is-open");
    };

    /**
     * Bascule la visibilité du panneau de filtres.
     * @param {boolean} [forceState] - Force l'état (true = ouvert, false = fermé)
     */
    FilterPanelRenderer.toggleFilterPanelVisibility = function (forceState) {
        const Shared = getShared$1();
        const container = Shared.getFilterPanelElement();
        if (!container) return;

        const isOpen = container.classList.contains("is-open");
        let nextState;

        if (typeof forceState === "boolean") {
            nextState = forceState;
        } else {
            nextState = !isOpen;
        }

        if (nextState) {
            container.classList.add("is-open");
        } else {
            container.classList.remove("is-open");
        }

        // Mettre à jour l'icône du bouton toggle externe
        const toggleBtn = document.getElementById("gl-filter-toggle");
        if (toggleBtn) {
            const icon = toggleBtn.querySelector(".gl-filter-toggle__icon");
            if (icon) {
                if (nextState) {
                    // Panneau ouvert : flèche vers la gauche (pour fermer)
                    setToggleIconOpen(icon);
                    toggleBtn.setAttribute("aria-label", "Fermer le panneau de filtres");
                } else {
                    // Panneau fermé : flèche vers la droite (pour ouvrir)
                    setToggleIconClosed(icon);
                    toggleBtn.setAttribute("aria-label", "Ouvrir le panneau de filtres");
                }
            }
        }
    };

    /**
     * Initialise le bouton toggle du panneau de filtres
     */
    FilterPanelRenderer.initFilterToggle = function () {
        const Log = getLog();
        const Shared = getShared$1();

        const toggleBtn = document.getElementById("gl-filter-toggle");
        const panel = Shared.getFilterPanelElement();

        if (!toggleBtn || !panel) {
            Log.info("[GeoLeaf.UI.FilterPanel] Bouton toggle ou panneau filtres introuvable");
            return;
        }

        const toggleClickHandler = function () {
            const isOpen = panel.classList.contains("is-open");
            const icon = toggleBtn.querySelector(".gl-filter-toggle__icon");

            if (isOpen) {
                panel.classList.remove("is-open");
                if (icon) {
                    setToggleIconClosed(icon);
                }
                toggleBtn.setAttribute("aria-label", "Ouvrir le panneau de filtres");
            } else {
                panel.classList.add("is-open");
                if (icon) {
                    setToggleIconOpen(icon);
                }
                toggleBtn.setAttribute("aria-label", "Fermer le panneau de filtres");
            }
        };

        if (events) {
            FilterPanelRenderer._eventCleanups.push(
                events.on(toggleBtn, "click", toggleClickHandler, false, "FilterPanel.toggleButton")
            );
        } else {
            toggleBtn.addEventListener("click", toggleClickHandler);
        }

        Log.info("[GeoLeaf.UI.FilterPanel] Bouton toggle filtres initialisé");
    };

    /**
     * Rafraîchit les badges de tags dans le panneau de filtres.
     * Doit être appelé APRÈS que les POI ont été chargés.
     */
    FilterPanelRenderer.refreshFilterTags = function () {
        const Log = getLog();
        const Shared = getShared$1();

        const container = Shared.getFilterPanelElement();
        if (!container) {
            Log.warn("[GeoLeaf.UI.FilterPanel.refreshFilterTags] Panneau de filtres non trouvé");
            return;
        }

        // Récupérer POI et routes
        const basePois = Shared.getBasePois();
        const baseRoutes = Shared.getBaseRoutes();
        const allItems = basePois.concat(baseRoutes);

        Log.debug(
            "[GeoLeaf.UI.FilterPanel.refreshFilterTags] Items:",
            basePois.length,
            "POI,",
            baseRoutes.length,
            "routes"
        );

        // Collecter tous les tags
        const allTags = Shared.collectAllTags(allItems);

        // Peupler les badges
        FilterPanelRenderer.populateTagsBadges(container, allTags);
    };

    /**
     * Peuple le conteneur de badges avec les tags fournis
     * @param {HTMLElement} panelEl - Élément du panneau de filtres
     * @param {Array} allTags - Liste des tags uniques
     */
    FilterPanelRenderer.populateTagsBadges = function (panelEl, allTags) {
        const Log = getLog();
        const wrapper = panelEl.querySelector("[data-gl-filter-id='tags']");
        if (!wrapper) {
            Log.debug(
                "[GeoLeaf.UI.FilterPanel] Wrapper tags non trouvé - probablement pas utilisé dans ce profil"
            );
            return;
        }

        const tagsContainer = wrapper.querySelector(".gl-filter-panel__tags-container");
        if (!tagsContainer) {
            Log.warn("[GeoLeaf.UI.FilterPanel] Container tags non trouvé");
            return;
        }

        // Trouver l'accordéon parent par l'attribut data-accordion-for
        const accordionGroup = panelEl.querySelector("[data-accordion-for='tags']");
        Log.debug("[GeoLeaf.UI.FilterPanel] Recherche accordéon avec [data-accordion-for='tags']");
        Log.debug("[GeoLeaf.UI.FilterPanel] Accordéon trouvé:", accordionGroup);

        // Vider le container
        while (tagsContainer.firstChild) {
            tagsContainer.removeChild(tagsContainer.firstChild);
        }

        // Si pas de tags, cacher complètement l'accordéon parent
        if (!allTags.length) {
            Log.debug("[GeoLeaf.UI.FilterPanel] Pas de tags (count:", allTags.length, ")");
            if (accordionGroup) {
                accordionGroup.style.display = "none";
                Log.info("[GeoLeaf.UI.FilterPanel] Accordéon tags CACHÉ (display: none)");
            } else {
                Log.warn("[GeoLeaf.UI.FilterPanel] Accordéon tags non trouvé pour le cacher");
            }
            return;
        }

        // S'il y a des tags, s'assurer que l'accordéon est visible
        Log.debug("[GeoLeaf.UI.FilterPanel] Tags détectés (count:", allTags.length, ")");
        if (accordionGroup) {
            accordionGroup.style.display = "";
            Log.info("[GeoLeaf.UI.FilterPanel] Accordéon tags AFFICHÉ");
        }

        // Créer les badges
        // Sprint 3.2: Use DocumentFragment for batch DOM operations
        const tagsFragment = document.createDocumentFragment();

        allTags.forEach(function (tag) {
            const badgeClickHandler = function () {
                this.classList.toggle("is-selected");
            };

            const badge = createElement$1("span", {
                className: "gl-filter-panel__tag-badge",
                textContent: tag,
                attributes: { "data-tag-value": tag },
                onClick: badgeClickHandler,
            });

            if (events) {
                FilterPanelRenderer._eventCleanups.push(
                    events.on(badge, "click", badgeClickHandler, false, "FilterPanel.tagBadge")
                );
            } else {
                badge.addEventListener("click", badgeClickHandler);
            }

            tagsFragment.appendChild(badge);
        });

        tagsContainer.appendChild(tagsFragment);
    };

    /**
     * Cleanup method for event listeners
     * Call this when destroying the filter panel
     * MEMORY LEAK FIX (Phase 2): Also cleanup timeouts in applier
     */
    FilterPanelRenderer.destroy = function () {
        const Log = getLog();
        if (Log) Log.debug("[FilterPanel] Cleaning up event listeners");

        if (FilterPanelRenderer._eventCleanups) {
            FilterPanelRenderer._eventCleanups.forEach((cleanup) => {
                if (typeof cleanup === "function") {
                    cleanup();
                }
            });
            FilterPanelRenderer._eventCleanups = [];
        }

        // MEMORY LEAK FIX (Phase 2): Cleanup applier timeouts
        if (FilterPanelApplier && FilterPanelApplier.destroy) {
            FilterPanelApplier.destroy();
        }
    };

    /**
     * Charge le contenu d'un accordéon à la demande (lazy loading)
     * @param {HTMLElement} accordionGroup - Element de l'accordéon
     * @param {Object} _filterDef - Définition du filtre (réservée pour usage futur)
     */
    FilterPanelRenderer._loadAccordionContentIfNeeded = function (accordionGroup, _filterDef) {
        const Log = getLog();
        const LazyLoader = FilterPanelLazyLoader;

        if (!LazyLoader) {
            Log.warn("[FilterPanel] LazyLoader non disponible");
            return;
        }

        // Vérifier si le contenu a déjà été chargé (le flag est reset à "false" lors d'un changement de thème)
        if (accordionGroup.dataset.lazyLoaded === "true") {
            Log.debug("[FilterPanel] Accordéon déjà chargé pour ce thème, skip");
            return;
        }

        // Trouver le container de contenu
        const contentArea = accordionGroup.querySelector("[data-lazy-type]");
        if (!contentArea) {
            Log.debug("[FilterPanel] Pas de zone lazy dans cet accordéon");
            return;
        }

        const lazyType = contentArea.dataset.lazyType;
        Log.info(`[FilterPanel] Chargement lazy du contenu: ${lazyType}`);

        // Récupérer le thème actif (avec fallback sur le thème par défaut du profil)
        let currentTheme = ThemeSelector.getCurrentTheme();
        if (!currentTheme) {
            // Fallback : récupérer le thème par défaut depuis le profil
            const profile =
                Config && typeof Config.getActiveProfile === "function"
                    ? Config.getActiveProfile()
                    : null;
            if (
                profile &&
                profile.themes &&
                profile.themes.config &&
                profile.themes.config.defautTheme
            ) {
                currentTheme = profile.themes.config.defautTheme;
                Log.info("[FilterPanel] Fallback sur le thème par défaut:", currentTheme);
            }
        }
        if (!currentTheme) {
            // Dernier fallback : utiliser "defaut" comme ID générique
            currentTheme = "defaut";
            Log.warn("[FilterPanel] Thème actif introuvable, utilisation de 'defaut'");
        }

        // Afficher un spinner pendant le chargement
        // Perf 6.2.3: Use DocumentFragment instead of innerHTML to avoid DOM re-parse
        (function setLoading(area) {
            while (area.firstChild) area.removeChild(area.firstChild);
            const loader = document.createElement("div");
            loader.className = "gl-filter-panel__loading";
            loader.textContent = "Chargement...";
            area.appendChild(loader);
        })(contentArea);

        /**
         * Helper: remplace le contenu d'un élément via un fragment HTML parsé et inséré.
         * Le contenu est généré en interne par buildCategoryTreeContent / buildTagsListContent
         * qui échappent toutes les valeurs utilisateur via Security.escapeHtml.
         * On utilise createContextualFragment avec suppression des scripts (défense en profondeur)
         * afin de préserver TOUS les attributs sûrs (class, data-*, type, value, name, checked)
         * que la whitelist de DOMSecurity.setSafeHTML supprimait, rendant les checkboxes et
         * les tags non fonctionnels.
         * @param {HTMLElement} area - Conteneur cible
         * @param {string} html - HTML string à insérer (déjà échappé à la source)
         */
        function _setHtmlContent(area, html) {
            // Supprimer les scripts uniquement (les valeurs user sont déjà échappées à la source)
            while (area.firstChild) area.removeChild(area.firstChild);
            const safe = (typeof html === "string" ? html : String(html || "")).replace(
                /<script[\s\S]*?<\/script>/gi,
                ""
            );
            const frag = document.createRange().createContextualFragment(safe);
            area.appendChild(frag);
        }

        /**
         * Helper: affiche un message simple (état vide, erreur)
         * @param {HTMLElement} area - Conteneur cible
         * @param {string} className - Classe CSS du div
         * @param {string} text - Texte du message
         */
        function _setMessage(area, className, text) {
            while (area.firstChild) area.removeChild(area.firstChild);
            const div = document.createElement("div");
            div.className = className;
            div.textContent = text;
            area.appendChild(div);
        }

        // Charger de manière asynchrone pour ne pas bloquer l'UI
        setTimeout(() => {
            try {
                if (lazyType === "categories") {
                    const result = LazyLoader.loadCategories(currentTheme);

                    // Vérifier s'il y a des catégories
                    if (!result.usedIds || result.usedIds.size === 0) {
                        _setMessage(
                            contentArea,
                            "gl-filter-panel__empty",
                            "Aucune catégorie disponible sur les couches visibles"
                        );
                        accordionGroup.dataset.lazyLoaded = "true";
                        return;
                    }

                    // Construction ESM directe (P3-DEAD-02 — window._buildCategoryTreeContent supprimé)
                    const htmlContent = buildCategoryTreeContent(result);
                    _setHtmlContent(contentArea, htmlContent);
                    attachCategoryTreeListeners(contentArea);

                    // Marquer l'accordéon comme ouvert
                    LazyLoader.markAccordionOpen("categories", accordionGroup);
                } else if (lazyType === "tags") {
                    const tags = LazyLoader.loadTags(currentTheme);

                    // Vérifier s'il y a des tags
                    if (!tags || tags.length === 0) {
                        _setMessage(
                            contentArea,
                            "gl-filter-panel__empty",
                            "Aucun tag disponible sur les couches visibles"
                        );
                        accordionGroup.dataset.lazyLoaded = "true";
                        return;
                    }

                    // Construction ESM directe (P3-DEAD-02 — window._buildTagsListContent supprimé)
                    const htmlContent = buildTagsListContent(tags);
                    _setHtmlContent(contentArea, htmlContent);
                    attachTagsListeners(contentArea);

                    // Marquer l'accordéon comme ouvert
                    LazyLoader.markAccordionOpen("tags", accordionGroup);
                }

                // Marquer comme chargé
                accordionGroup.dataset.lazyLoaded = "true";
            } catch (err) {
                Log.error("[FilterPanel] Erreur durant le chargement lazy:", err);
                _setMessage(contentArea, "gl-filter-panel__error", "Erreur: " + err.message);
            }
        }, 10); // 10ms delay pour laisser l'accordéon s'ouvrir
    };

    /**
     * GeoLeaf UI Filter Panel - Core
     * API publique et délégation vers les sous-modules
     *
     * @module ui/filter-panel/core
     */

    // Direct ESM bindings (P3-DEAD-01 complete)
    const getShared = () => FilterPanelShared;
    const getStateReader = () => FilterPanelStateReader;
    const getApplier = () => FilterPanelApplier;
    const getRenderer = () => FilterPanelRenderer;
    const getProximity = () => FilterPanelProximity;

    const FilterPanel = {};

    // ========================================
    //   API PUBLIQUE - Délégation vers sous-modules
    // ========================================

    /**
     * Construit le panneau de filtres depuis la configuration du profil actif
     * @param {Object} options - Options
     */
    FilterPanel.buildFilterPanelFromActiveProfile = function(options) {
        const Renderer = getRenderer();
        if (Renderer && Renderer.buildFilterPanelFromActiveProfile) {
            return Renderer.buildFilterPanelFromActiveProfile(options);
        }
        getLog().error("[GeoLeaf.UI.FilterPanel] Module Renderer non chargé");
    };

    /**
     * Bascule la visibilité du panneau de filtres
     * @param {boolean} [forceState]
     */
    FilterPanel.toggleFilterPanelVisibility = function(forceState) {
        const Renderer = getRenderer();
        if (Renderer && Renderer.toggleFilterPanelVisibility) {
            return Renderer.toggleFilterPanelVisibility(forceState);
        }
    };

    /**
     * Initialise le bouton toggle du panneau de filtres
     */
    FilterPanel.initFilterToggle = function() {
        const Renderer = getRenderer();
        if (Renderer && Renderer.initFilterToggle) {
            return Renderer.initFilterToggle();
        }
    };

    /**
     * Rafraîchit les badges de tags
     */
    FilterPanel.refreshFilterTags = function() {
        const Renderer = getRenderer();
        if (Renderer && Renderer.refreshFilterTags) {
            return Renderer.refreshFilterTags();
        }
    };

    /**
     * Applique les filtres initiaux
     */
    FilterPanel.applyFiltersInitial = function() {
        const Applier = getApplier();
        if (Applier && Applier.applyFiltersInitial) {
            return Applier.applyFiltersInitial();
        }
    };

    /**
     * Initialise le filtre de proximité
     * @param {L.Map} map
     */
    FilterPanel.initProximityFilter = function(map) {
        const Proximity = getProximity();
        if (Proximity && Proximity.initProximityFilter) {
            return Proximity.initProximityFilter(map);
        }
    };

    /**
     * Retourne l'élément DOM du panneau de filtres
     * @returns {HTMLElement|null}
     */
    FilterPanel._getFilterPanelElement = function() {
        const Shared = getShared();
        if (Shared && Shared.getFilterPanelElement) {
            return Shared.getFilterPanelElement();
        }
        return null;
    };

    /**
     * Récupère les POI de base
     * @returns {Array}
     */
    FilterPanel._getBasePois = function() {
        const Shared = getShared();
        if (Shared && Shared.getBasePois) {
            return Shared.getBasePois();
        }
        return [];
    };

    /**
     * Récupère les routes de base
     * @returns {Array}
     */
    FilterPanel._getBaseRoutes = function() {
        const Shared = getShared();
        if (Shared && Shared.getBaseRoutes) {
            return Shared.getBaseRoutes();
        }
        return [];
    };

    /**
     * Lit l'état des filtres depuis le panneau
     * @param {HTMLElement} panelEl
     * @returns {Object}
     */
    FilterPanel._readFiltersFromPanel = function(panelEl) {
        const StateReader = getStateReader();
        if (StateReader && StateReader.readFiltersFromPanel) {
            return StateReader.readFiltersFromPanel(panelEl);
        }
        return {};
    };

    /**
     * Filtre une liste de POI
     * @param {Array} basePois
     * @param {Object} filterState
     * @returns {Array}
     */
    FilterPanel._filterPoiList = function(basePois, filterState) {
        const Applier = getApplier();
        if (Applier && Applier.filterPoiList) {
            return Applier.filterPoiList(basePois, filterState);
        }
        return basePois || [];
    };

    /**
     * Filtre une liste de routes
     * @param {Array} baseRoutes
     * @param {Object} filterState
     * @returns {Array}
     */
    FilterPanel._filterRouteList = function(baseRoutes, filterState) {
        const Applier = getApplier();
        if (Applier && Applier.filterRouteList) {
            return Applier.filterRouteList(baseRoutes, filterState);
        }
        return baseRoutes || [];
    };

    /**
     * Rafraîchit la couche POI
     * @param {Array} filteredPois
     */
    FilterPanel._refreshPoiLayer = function(filteredPois) {
        const Applier = getApplier();
        if (Applier && Applier.refreshPoiLayer) {
            return Applier.refreshPoiLayer(filteredPois);
        }
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const FilterPanelAggregator = FilterPanel;

    /**
     * globals.ui.js — Bridge UMD/ESM : B6 + B7 + B9 — labels, legend, layer-manager, themes, ui
     *
     * @see globals.js (orchestrateur)
     */


    const _g$b =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    _g$b.GeoLeaf = _g$b.GeoLeaf || {};

    // ── B6 assignations ──────────────────────────────────────────────────────────
    _g$b.GeoLeaf._LabelButtonManager = LabelButtonManager;
    _g$b.GeoLeaf._LabelRenderer = _LabelRenderer;
    _g$b.GeoLeaf.Labels = Labels;
    _g$b.GeoLeaf._LegendControl = LegendControl;
    _g$b.GeoLeaf._LegendGenerator = LegendGenerator;
    _g$b.GeoLeaf._LegendRenderer = LegendRenderer;
    _g$b.GeoLeaf._LayerManagerBasemapSelector = BasemapSelector;
    _g$b.GeoLeaf._LayerManagerCacheSection = CacheSection;
    _g$b.GeoLeaf._LayerManagerControl = LMControl;
    _g$b.GeoLeaf._LayerManagerRenderer = LMRenderer;
    _g$b.GeoLeaf._LayerManagerShared = LMShared;
    _g$b.GeoLeaf._LayerManagerStyleSelector = StyleSelector;

    // ── B7 assignations ──────────────────────────────────────────────────────────
    _g$b.GeoLeaf.ThemeCache = ThemeCache;
    _g$b.GeoLeaf._ThemeLoader = _ThemeLoader;
    _g$b.GeoLeaf.ThemeSelector = ThemeSelector;
    _g$b.GeoLeaf._ThemeApplier = Object.assign(
        {},
        _ThemeApplier,
        _ThemeApplier,
        _ThemeApplier,
        _ThemeApplier
    );

    // ── B9 assignations : ui ─────────────────────────────────────────────────────
    if (!_g$b.GeoLeaf.UI) _g$b.GeoLeaf.UI = {};
    _g$b.GeoLeaf.UI.Branding = Branding;
    _g$b.GeoLeaf._UIComponents = _UIComponents;
    _g$b.GeoLeaf._UIControls = _UIControls;
    _g$b.GeoLeaf.UI.CoordinatesDisplay = CoordinatesDisplay;
    _g$b.GeoLeaf._UIDomUtils = _UIDomUtils;
    _g$b.GeoLeaf._UIEventDelegation = _UIEventDelegation;
    _g$b.GeoLeaf.UI._buildFilterControl = _buildFilterControl;
    _g$b.GeoLeaf._UIFilterStateManager = _UIFilterStateManager;
    _g$b.GeoLeaf._UINotifications = _UINotifications;
    _g$b.GeoLeaf.NotificationSystem = NotificationSystem;
    // Alias UI.notify → _UINotifications (utilisé par boot-info.js et les intégrateurs)
    // GeoLeaf.UI est déjà initialisé plus haut, on complète sans écraser
    if (!_g$b.GeoLeaf.UI) _g$b.GeoLeaf.UI = {};
    _g$b.GeoLeaf.UI.notify = {
        info: (msg, opts) => _UINotifications?.info?.(msg, opts),
        warn: (msg, opts) => _UINotifications?.warn?.(msg, opts),
        error: (msg, opts) => _UINotifications?.error?.(msg, opts),
        success: (msg, opts) => _UINotifications?.success?.(msg, opts),
        dismiss: (id) => _UINotifications?.dismiss?.(id),
    };
    _g$b.GeoLeaf.UI.PanelBuilder = PanelBuilder;
    _g$b.GeoLeaf.UI.ScaleControl = ScaleControl;
    _g$b.GeoLeaf._UITheme = _UITheme;
    // Wire theme methods directly onto UI (geoleaf.ui.js body runs at import time,
    // before globals.js body assigns _g.GeoLeaf._UITheme, so its conditional block
    // was skipped — we re-apply here to ensure applyTheme/setTheme exist at boot)
    _g$b.GeoLeaf.UI.applyTheme = _UITheme.applyTheme;
    _g$b.GeoLeaf.UI.setTheme = _UITheme.applyTheme;
    _g$b.GeoLeaf.UI.toggleTheme = _UITheme.toggleTheme;
    _g$b.GeoLeaf.UI.initThemeToggle = _UITheme.initThemeToggle;
    _g$b.GeoLeaf.UI.getCurrentTheme = _UITheme.getCurrentTheme;
    // content-builder
    if (!_g$b.GeoLeaf._ContentBuilder) _g$b.GeoLeaf._ContentBuilder = {};
    _g$b.GeoLeaf._ContentBuilder.Core = ContentBuilderCore;
    _g$b.GeoLeaf._ContentBuilder.Helpers = Helpers$1;
    _g$b.GeoLeaf._ContentBuilder.Shared = ContentBuilderShared;
    _g$b.GeoLeaf._ContentBuilder.Templates = Templates;
    _g$b.GeoLeaf._ContentBuilder.Assemblers = Assemblers;
    // filter-panel
    _g$b.GeoLeaf._UIFilterPanelShared = FilterPanelShared;
    _g$b.GeoLeaf._UIFilterPanelStateReader = FilterPanelStateReader;
    _g$b.GeoLeaf._UIFilterPanelApplier = FilterPanelApplier;
    _g$b.GeoLeaf._UIFilterPanelRenderer = FilterPanelRenderer;
    _g$b.GeoLeaf._UIFilterPanelProximity = FilterPanelProximity;
    _g$b.GeoLeaf._UIFilterPanelLazyLoader = FilterPanelLazyLoader;
    _g$b.GeoLeaf._UIFilterPanel = FilterPanel;
    _g$b.GeoLeaf.FilterPanel = FilterPanelAggregator;

    /*!
     * GeoLeaf Core
     * � 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */






    /**
     * Module de d�tection online/offline
     */
    const OfflineDetector = {
        /**
         * �tat de connexion actuel
         * @private
         */
        _isOnline: navigator.onLine,

        /**
         * Badge UI (si activ�)
         * @private
         */
        _badge: null,

        /**
         * Contr�le Leaflet pour le badge
         * @private
         */
        _badgeControl: null,

        /**
         * Configuration
         * @private
         */
        _config: {
            showBadge: false,
            badgePosition: 'topleft',
            checkInterval: 30000,
            pingUrl: null
        },

        /**
         * Timer de v�rification p�riodique
         * @private
         */
        _checkTimer: null,

        /**
         * Event cleanup functions
         * @private
         */
        _eventCleanups: [],

        /**
         * Initialise le d�tecteur
         * @param {Object} options - Options de configuration
         * @param {boolean} options.showBadge - Afficher le badge UI
         * @param {string} options.badgePosition - Position du badge (top-right, top-left, etc.)
         * @param {number} options.checkInterval - Intervalle de v�rification en ms
         * @param {string} options.pingUrl - URL pour ping de connectivit�
         * @returns {void}
         */
        init(options = {}) {
            // Fusionner config
            this._config = { ...this._config, ...options };

            Log.info(`[OfflineDetector] Initializing (badge: ${this._config.showBadge ? 'enabled' : 'disabled'})`);

            // �tat initial
            this._isOnline = navigator.onLine;
            Log.info(`[OfflineDetector] Initial state: ${this._isOnline ? "ONLINE" : "OFFLINE"}`);

            // Le badge sera cr�� de mani�re lazy :
            // - Lors du premier �v�nement offline si showBadge=true
            // - Ou via un appel manuel si la carte devient disponible plus tard

            // �couter les �v�nements navigateur
            this._attachEventListeners();

            // V�rification p�riodique
            this._startPeriodicCheck();

            // V�rifier imm�diatement l'�tat r�el
            this.checkConnectivity();
        },

        /**
         * Cr�e le badge UI comme contr�le Leaflet
         * @private
         */
        _createBadge() {
            if (this._badge) return; // D�j� cr��

            const map = ensureMap$1();
            if (!map) {
                Log.warn('[OfflineDetector] Cannot create badge: map not available');
                return;
            }

            // Cr�er un contr�le Leaflet personnalis�
            const L = globalThis.L;
            if (!L || !L.Control) {
                Log.warn('[OfflineDetector] Leaflet not available');
                return;
            }

            const OfflineBadgeControl = L.Control.extend({
                options: {
                    position: 'topleft'
                },

                onAdd: function(map) {
                    const container = L.DomUtil.create('div', 'leaflet-bar geoleaf-offline-badge-control');
                    container.style.cssText = `
                    background: #ff6b6b;
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-family: system-ui, -apple-system, sans-serif;
                    font-size: 13px;
                    font-weight: 500;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    cursor: default;
                    display: none;
                    white-space: nowrap;
                    position: absolute;
                    left: 54px;
                    top: 0;
                    margin: 0 !important;
                    border: none;
                `;
                    container.textContent = '?? Hors ligne';
                    container.title = 'Mode hors ligne actif';

                    // Emp�cher les �v�nements de propagation
                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.disableScrollPropagation(container);

                    return container;
                }
            });

            this._badgeControl = new OfflineBadgeControl();
            this._badgeControl.addTo(map);
            this._badge = this._badgeControl.getContainer();

            Log.debug('[OfflineDetector] Badge control created on map');
        },

        /**
         * Affiche le badge
         * @private
         */
        _showBadge() {
            // Cr�er le badge si pas encore cr�� (lazy creation)
            if (!this._badge && this._config.showBadge) {
                this._createBadge();
            }

            if (this._badge) {
                this._badge.style.display = 'block';
            }
        },

        /**
         * Masque le badge
         * @private
         */
        _hideBadge() {
            if (this._badge) {
                this._badge.style.display = 'none';
            }
        },

        /**
         * Attache les event listeners
         * @private
         */
        _attachEventListeners() {
            // �v�nements natifs du navigateur - avec cleanup tracking

            if (events) {
                this._eventCleanups.push(
                    events.on(
                        window,
                        "online",
                        () => this._handleOnline(),
                        false,
                        'OfflineDetector.online'
                    )
                );
                this._eventCleanups.push(
                    events.on(
                        window,
                        "offline",
                        () => this._handleOffline(),
                        false,
                        'OfflineDetector.offline'
                    )
                );
            } else {
                // Fallback sans cleanup
                Log.warn('[OfflineDetector] EventListenerManager not available - listeners will not be cleaned up');
                window.addEventListener("online", () => this._handleOnline());
                window.addEventListener("offline", () => this._handleOffline());
            }

            Log.debug("[OfflineDetector] Event listeners attached");
        },

        /**
         * Cleanup event listeners
         */
        destroy() {
            // Cleanup event listeners
            if (this._eventCleanups && this._eventCleanups.length > 0) {
                this._eventCleanups.forEach(cleanup => {
                    if (typeof cleanup === 'function') cleanup();
                });
                this._eventCleanups = [];
                Log.info('[OfflineDetector] Event listeners cleaned up');
            }

            // Clear check timer
            if (this._checkTimer) {
                clearInterval(this._checkTimer);
                this._checkTimer = null;
            }

            // Remove badge control if present
            if (this._badgeControl && this._badgeControl._map) {
                this._badgeControl._map.removeControl(this._badgeControl);
                this._badgeControl = null;
            }
            this._badge = null;
        },

        /**
         * G�re le passage en ligne
         * @private
         */
        _handleOnline() {
            if (this._isOnline) return; // D�j� online

            Log.info("[OfflineDetector] Connection restored ? ONLINE");
            this._isOnline = true;

            // Masquer le badge
            if (this._config.showBadge) {
                this._hideBadge();
            }

            // �mettre �v�nement personnalis�
            document.dispatchEvent(new CustomEvent("geoleaf:online", {
                detail: { timestamp: Date.now() }
            }));

            // V�rifier avec ping si n�cessaire
            this.checkConnectivity();
        },

        /**
         * G�re le passage hors ligne
         * @private
         */
        _handleOffline() {
            if (!this._isOnline) return; // D�j� offline

            Log.warn("[OfflineDetector] Connection lost ? OFFLINE");
            this._isOnline = false;

            // Afficher le badge
            if (this._config.showBadge) {
                this._showBadge();
            }

            // �mettre �v�nement personnalis�
            document.dispatchEvent(new CustomEvent("geoleaf:offline", {
                detail: { timestamp: Date.now() }
            }));
        },

        /**
         * V�rifie la connectivit� r�elle (avec ping si configur�)
         *
         * @returns {Promise<boolean>}
         * @example
         * const isOnline = await GeoLeaf.Storage.OfflineDetector.checkConnectivity();
         */
        async checkConnectivity() {
            // Si pas d'URL de ping, utiliser l'�tat navigateur
            if (!this._config.pingUrl) {
                return this._isOnline;
            }

            try {
                // Tenter un ping vers l'URL configur�e
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout 5s

                const response = await fetch(this._config.pingUrl, {
                    method: "HEAD",
                    cache: "no-cache",
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                const isOnline = response.ok;

                // Mettre � jour l'�tat si diff�rent
                if (isOnline !== this._isOnline) {
                    if (isOnline) {
                        this._handleOnline();
                    } else {
                        this._handleOffline();
                    }
                }

                return isOnline;

            } catch (error) {
                // Erreur = probablement offline
                Log.debug(`[OfflineDetector] Ping failed: ${error.message}`);

                if (this._isOnline) {
                    this._handleOffline();
                }

                return false;
            }
        },

        /**
         * D�marre la v�rification p�riodique
         * @private
         */
        _startPeriodicCheck() {
            if (this._checkTimer) {
                clearInterval(this._checkTimer);
            }

            this._checkTimer = setInterval(() => {
                this.checkConnectivity();
            }, this._config.checkInterval);

            Log.debug(`[OfflineDetector] Periodic check started (every ${this._config.checkInterval}ms)`);
        },

        /**
         * Arr�te la v�rification p�riodique
         */
        stopPeriodicCheck() {
            if (this._checkTimer) {
                clearInterval(this._checkTimer);
                this._checkTimer = null;
                Log.debug("[OfflineDetector] Periodic check stopped");
            }
        },

        /**
         * Retourne l'�tat de connexion actuel
         *
         * @returns {boolean}
         * @example
         * if (GeoLeaf.Storage.OfflineDetector.isOnline()) {
         *   // Effectuer requ�te r�seau
         * }
         */
        isOnline() {
            return this._isOnline;
        },

        /**
         * Nettoie les ressources
         */
        destroy() {
            this.stopPeriodicCheck();

            // Supprimer le contr�le de la carte
            if (this._badgeControl) {
                const map = ensureMap$1();
                if (map) {
                    map.removeControl(this._badgeControl);
                }
                this._badgeControl = null;
                this._badge = null;
            }

            Log.info("[OfflineDetector] Destroyed");
        }
    };

    /**
     * @file sw-register.js
     * @description Service Worker registration module for GeoLeaf offline support.
     *              Handles SW lifecycle: register, update, unregister.
     *              The core/lite SW (sw-core.js) is registered unconditionally at boot.
     *              The premium SW (sw.js) replaces it when the Storage plugin is loaded
     *              and storage.enableServiceWorker = true in the profile.
     * @module Storage/SWRegister
     * @requires GeoLeaf
     *
     * Copyright (c) 2025 GeoLeaf Contributors
     * Licensed under the MIT License
     * SPDX-License-Identifier: MIT
     */



    /**
     * Service Worker registration helper.
     *
     * @namespace GeoLeaf._SWRegister
     * @example
     * // Automatic registration via Storage.init({ enableServiceWorker: true })
     * // Or manual:
     * await GeoLeaf._SWRegister.register();
     */
    const SWRegister = {

        /** @type {ServiceWorkerRegistration|null} */
        _registration: null,

        /** @type {string} Default SW script path — core/lite, always registered at boot */
        _swPath: "sw-core.js",

        /**
         * Register the Service Worker.
         * No-op in environments that don't support Service Workers.
         *
         * @param {Object}  [options]
         * @param {string}  [options.path="sw.js"] - Path to the SW script
         * @param {string}  [options.scope="/"]     - SW scope
         * @returns {Promise<ServiceWorkerRegistration|null>}
         * @example
         * const reg = await GeoLeaf._SWRegister.register();
         */
        async register(options = {}) {
            if (!("serviceWorker" in navigator)) {
                Log.warn("[SWRegister] Service Workers not supported in this browser.");
                return null;
            }

            const swPath = options.path || this._swPath;
            const scope  = options.scope || "/";

            try {
                const registration = await navigator.serviceWorker.register(swPath, { scope });
                this._registration = registration;

                Log.info(`[SWRegister] Service Worker registered (scope: ${registration.scope})`);

                // Listen for updates
                registration.addEventListener("updatefound", () => {
                    const newWorker = registration.installing;
                    if (newWorker) {
                        newWorker.addEventListener("statechange", () => {
                            if (newWorker.state === "activated") {
                                Log.info("[SWRegister] New Service Worker activated.");
                                document.dispatchEvent(new CustomEvent("geoleaf:sw:updated"));
                            }
                        });
                    }
                });

                return registration;

            } catch (error) {
                Log.error(`[SWRegister] Registration failed: ${error.message}`);
                throw error;
            }
        },

        /**
         * Force an update check on the registered Service Worker.
         *
         * @returns {Promise<void>}
         */
        async update() {
            if (this._registration) {
                await this._registration.update();
                Log.info("[SWRegister] Update check triggered.");
            } else {
                Log.warn("[SWRegister] No active registration — call register() first.");
            }
        },

        /**
         * Unregister the Service Worker.
         *
         * @returns {Promise<boolean>} true if successfully unregistered
         */
        async unregister() {
            if (!this._registration) {
                Log.warn("[SWRegister] No active registration to unregister.");
                return false;
            }

            const result = await this._registration.unregister();
            if (result) {
                Log.info("[SWRegister] Service Worker unregistered.");
                this._registration = null;
            }
            return result;
        },

        /**
         * Get the current registration (if any).
         *
         * @returns {ServiceWorkerRegistration|null}
         */
        getRegistration() {
            return this._registration;
        }
    };

    /**
     * globals.storage.js — Core only (MIT)
     *
     * Après Phase 7 : seuls offline-detector et sw-register restent dans le core.
     * Tout le reste → GeoLeaf-Plugins/plugin-storage
     *
     * @see globals.js
     */

    const _g$a =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    _g$a.GeoLeaf = _g$a.GeoLeaf || {};

    _g$a.GeoLeaf._OfflineDetector = OfflineDetector;
    _g$a.GeoLeaf._SWRegister = SWRegister;
    // Namespace stub — enrichi par le plugin Storage au chargement
    if (!_g$a.GeoLeaf.Storage) _g$a.GeoLeaf.Storage = {};

    /**
     * globals.poi.js — Bridge UMD/ESM : B10 — poi, add-form, renderers
     *
     * @see globals.js (orchestrateur)
     */


    const _g$9 =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    _g$9.GeoLeaf = _g$9.GeoLeaf || {};

    // ── B10 assignations : poi ───────────────────────────────────────────────────
    if (!_g$9.GeoLeaf.POI) _g$9.GeoLeaf.POI = {};
    _g$9.GeoLeaf._POIShared = POIShared;
    _g$9.GeoLeaf._POINormalizers = POINormalizers;
    _g$9.GeoLeaf._POIMarkers = POIMarkers;
    _g$9.GeoLeaf._POIPopup = POIPopup;
    _g$9.GeoLeaf._POISidePanel = POISidepanel;
    _g$9.GeoLeaf._POIRenderers = POIRenderers;
    _g$9.GeoLeaf._POICore = POICore;
    // poi/renderers/
    _g$9.GeoLeaf.ComponentRenderers = ComponentRenderers;
    _g$9.GeoLeaf._POIRenderersCore = RendererCore;
    _g$9.GeoLeaf.LightboxManager = LightboxManager;
    _g$9.GeoLeaf._lightboxManager = new LightboxManager();
    _g$9.GeoLeaf._POIRendererLinks = RendererLinks;
    _g$9.GeoLeaf.SectionOrchestrator = SectionOrchestrator;
    _g$9.GeoLeaf._POIUIBehaviors = UIBehaviors;

    // ── Enregistrer showPoiDetails dans POICoreContract (utilisé par markers.js) ──
    // Permet à POICoreContract.showPoiDetails(poi) de déléguer vers le side panel.
    POICoreContract.register({
        showPoiDetails: (poi, customLayout) => POISidepanel.openSidePanel(poi, customLayout)
    });

    /**
     * API Controller - Sprint 4.3 (Version Robuste)
     * Orchestrateur principal pour les opérations API GeoLeaf
     * Architecture modulaire avec validation renforcée
     * @module APIController
     */
    const _g$8 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : {};
    _g$8.GeoLeaf = _g$8.GeoLeaf || {};


    /**
     * Contrôleur principal pour l'API GeoLeaf
     * Gère l'orchestration des managers spécialisés
     */
    class APIController {
        constructor() {
            this.isInitialized = false;
            this.managers = {};
            this.moduleAccessFn = null;

            // État de sanité du contrôleur
            this.healthStatus = {
                managers: 0,
                errors: [],
                lastUpdate: null
            };
        }

        /**
         * Initialise le contrôleur et tous ses managers
         * @returns {boolean} Succès de l'initialisation
         */
        init() {
            try {
                if (this.isInitialized) {
                    if (Log) Log.debug('[APIController] Already initialized');
                    return true;
                }

                if (Log) Log.info('[APIController] Initializing API controller (Sprint 4.3 - Robust)');

                // Initialiser les managers dans l'ordre
                this._initializeManagers();

                // Configurer l'accès aux modules
                const success = this._setupModuleAccess();
                if (!success) {
                    throw new Error('Module access setup failed');
                }

                // Valider l'état final
                this._validateInitialization();

                this.isInitialized = true;
                this.healthStatus.lastUpdate = new Date().toISOString();

                if (Log) Log.info('[APIController] API controller initialized successfully');
                return true;

            } catch (error) {
                this.healthStatus.errors.push({
                    message: error.message,
                    timestamp: new Date().toISOString(),
                    stack: error.stack
                });

                if (Log) Log.error('[APIController] Initialization failed:', error);
                return false;
            }
        }

        /**
         * Initialise tous les managers disponibles
         * @private
         */
        _initializeManagers() {
            const managerTypes = ['module', 'initialization', 'factory'];

            managerTypes.forEach(type => {
                const ManagerClass = this._getManagerClass(type);
                if (ManagerClass) {
                    try {
                        this.managers[type] = new ManagerClass();
                        this.healthStatus.managers++;
                        if (Log) Log.debug(`[APIController] ${type} manager loaded`);
                    } catch (error) {
                        if (Log) Log.warn(`[APIController] Failed to load ${type} manager:`, error);
                        this.healthStatus.errors.push({
                            manager: type,
                            error: error.message
                        });
                    }
                }
            });

            if (Log) Log.info(`[APIController] Loaded ${this.healthStatus.managers} managers`);
        }

        /**
         * Obtient la classe d'un manager
         * @private
         */
        _getManagerClass(type) {
            const classNames = {
                module: 'APIModuleManager',
                initialization: 'APIInitializationManager',
                factory: 'APIFactoryManager'
            };

            const className = classNames[type];
            return _g$8.GeoLeaf.API && _g$8.GeoLeaf.API[className] ? _g$8.GeoLeaf.API[className] : null;
        }

        /**
         * Configure l'accès aux modules
         * @private
         */
        _setupModuleAccess() {
            // Le module manager doit être initialisé en premier
            if (!this.managers.module) {
                if (Log) Log.error('[APIController] Module manager not available');
                return false;
            }

            // Initialiser le module manager avec les modules existants
            const initSuccess = this.managers.module.init ? this.managers.module.init() : true;
            if (!initSuccess) {
                if (Log) Log.error('[APIController] Module manager initialization failed');
                return false;
            }

            // Créer la fonction d'accès aux modules avec validation
            this.moduleAccessFn = (name) => {
                try {
                    if (!name || typeof name !== 'string') {
                        if (Log) Log.warn('[APIController] Invalid module name:', name);
                        return null;
                    }

                    if (this.managers.module && typeof this.managers.module.getModule === 'function') {
                        return this.managers.module.getModule(name);
                    }

                    // Fallback vers l'accès global
                    if (_g$8.GeoLeaf && _g$8.GeoLeaf[name]) {
                        return _g$8.GeoLeaf[name];
                    }

                    return null;
                } catch (error) {
                    if (Log) Log.warn(`[APIController] Error accessing module ${name}:`, error);
                    return null;
                }
            };

            if (Log) Log.info('[APIController] Module access configured');
            return true;
        }

        /**
         * Valide l'état de l'initialisation
         * @private
         */
        _validateInitialization() {
            const checks = [
                { name: 'moduleAccessFn', value: this.moduleAccessFn, type: 'function' },
                { name: 'managers', value: this.managers, type: 'object' },
                { name: 'moduleManager', value: this.managers.module, type: 'object' }
            ];

            const failures = checks.filter(check => {
                return !check.value || typeof check.value !== check.type;
            });

            if (failures.length > 0) {
                const failureNames = failures.map(f => f.name).join(', ');
                throw new Error(`Validation failed for: ${failureNames}`);
            }

            if (Log) Log.debug('[APIController] Validation passed');
        }

        /**
         * _g.GeoLeaf.init() - Initialisation de carte
         */
        geoleafInit(options) {
            if (!this._ensureInitialized()) return null;

            try {
                if (!this.managers.initialization) {
                    throw new Error('Initialization manager not available');
                }

                return this.managers.initialization.init(options, this.moduleAccessFn);
            } catch (error) {
                if (Log) Log.error('[APIController] geoleafInit failed:', error);
                return null;
            }
        }

        /**
         * _g.GeoLeaf.loadConfig() - Chargement configuration
         */
        geoleafLoadConfig(input) {
            if (!this._ensureInitialized()) return Promise.resolve(null);

            try {
                if (!this.managers.initialization) {
                    throw new Error('Initialization manager not available');
                }

                return this.managers.initialization.loadConfig(input, this.moduleAccessFn);
            } catch (error) {
                if (Log) Log.error('[APIController] geoleafLoadConfig failed:', error);
                return Promise.resolve(null);
            }
        }

        /**
         * _g.GeoLeaf.setTheme() - Changement de thème
         */
        geoleafSetTheme(theme) {
            if (!this._ensureInitialized()) return false;

            try {
                if (!this.managers.initialization) {
                    throw new Error('Initialization manager not available');
                }

                return this.managers.initialization.setTheme(theme, this.moduleAccessFn);
            } catch (error) {
                if (Log) Log.error('[APIController] geoleafSetTheme failed:', error);
                return false;
            }
        }

        /**
         * _g.GeoLeaf.createMap() - Création multi-cartes
         */
        geoleafCreateMap(targetId, options) {
            if (!this._ensureInitialized()) return null;

            try {
                if (!this.managers.factory) {
                    throw new Error('Factory manager not available');
                }

                return this.managers.factory.createMap(targetId, options, this.moduleAccessFn);
            } catch (error) {
                if (Log) Log.error('[APIController] geoleafCreateMap failed:', error);
                return null;
            }
        }

        /**
         * S'assure que le contrôleur est initialisé
         * @private
         */
        _ensureInitialized() {
            if (!this.isInitialized) {
                if (Log) Log.error('[APIController] Controller not initialized');
                return false;
            }
            return true;
        }

        /**
         * Obtient l'état de santé du contrôleur
         */
        getHealthStatus() {
            return {
                ...this.healthStatus,
                isInitialized: this.isInitialized,
                managersCount: Object.keys(this.managers).length,
                hasModuleAccess: !!this.moduleAccessFn
            };
        }

        /**
         * Réinitialise le contrôleur
         */
        reset() {
            this.isInitialized = false;
            this.managers = {};
            this.moduleAccessFn = null;
            this.healthStatus = {
                managers: 0,
                errors: [],
                lastUpdate: null
            };

            if (Log) Log.info('[APIController] Controller reset');
        }
    }


    // perf 5.9 : Instanciation lazy — création au premier accès via getter
    // (évite init synchrone coûteuse de _initializeManagers à l'import)
    let _apiControllerInstance = null;

    function _getAPIController() {
        if (!_apiControllerInstance) {
            _apiControllerInstance = new APIController();
            // Init différée : les managers ne sont résolus qu'une fois le namespace GeoLeaf.API peuplé
            _apiControllerInstance.init();
        }
        return _apiControllerInstance;
    }

    if (!Object.getOwnPropertyDescriptor(_g$8.GeoLeaf, '_APIController') ||
        !Object.getOwnPropertyDescriptor(_g$8.GeoLeaf, '_APIController').get) {
        Object.defineProperty(_g$8.GeoLeaf, '_APIController', {
            get: _getAPIController,
            configurable: true,
            enumerable: true
        });
    }

    /**
     * API Factory Manager - Sprint 4.3 (Version Robuste)
     * Gestionnaire pour la création d'instances multi-cartes
     * @module APIFactoryManager
     */
    const _g$7 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : {};
    _g$7.GeoLeaf = _g$7.GeoLeaf || {};


    /**
     * Gestionnaire de factory pour multi-cartes
     */
    class APIFactoryManager {
        constructor() {
            this.isReady = true;
            this.mapInstances = new Map();
            this.stats = {
                mapsCreated: 0,
                errors: 0
            };
        }

        /**
         * Initialise le gestionnaire avec la fonction d'accès aux modules
         * @param {Function} getModule - Fonction d'accès aux modules
         * @returns {boolean} Succès
         */
        init(getModule) {
            try {
                if (!getModule || typeof getModule !== 'function') {
                    throw new Error('getModule function is required');
                }

                this.getModule = getModule;

                if (Log) Log.info('[APIFactoryManager] Factory manager initialized');
                return true;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error('[APIFactoryManager] Initialization failed:', error);
                return false;
            }
        }

        /**
         * Crée une nouvelle instance de carte
         * @param {string} targetId - ID de l'élément cible
         * @param {Object} options - Options de configuration
         * @param {Function} getModule - Fonction d'accès aux modules
         * @returns {*} Instance de carte ou null
         */
        createMap(targetId, options, getModule) {
            try {
                this.stats.mapsCreated++;

                if (!targetId) {
                    throw new Error('Target ID is required');
                }

                const Core = getModule('Core');
                if (!Core || typeof Core.init !== 'function') {
                    throw new Error('Core module not available for map creation');
                }

                // Créer la carte avec les options fournies
                const mapOptions = {
                    target: targetId,
                    ...options
                };

                const mapInstance = Core.init(mapOptions);

                if (mapInstance) {
                    this.mapInstances.set(targetId, mapInstance);
                    if (Log) Log.info(`[APIFactoryManager] Map created for target: ${targetId}`);
                }

                return mapInstance;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error(`[APIFactoryManager] Failed to create map for ${targetId}:`, error);
                return null;
            }
        }

        /**
         * Obtient une instance de carte par ID
         * @param {string} targetId - ID de l'élément cible
         * @returns {*} Instance de carte ou null
         */
        getMapInstance(targetId) {
            return this.mapInstances.get(targetId) || null;
        }

        /**
         * Obtient toutes les instances de carte
         * @returns {Array} Liste des instances
         */
        getAllMapInstances() {
            return Array.from(this.mapInstances.values());
        }

        /**
         * Supprime une instance de carte par ID
         * @param {string} targetId - ID de l'élément cible
         * @returns {boolean} Succès de la suppression
         */
        removeMapInstance(targetId) {
            if (!this.mapInstances.has(targetId)) {
                if (Log) Log.warn(`[APIFactoryManager] No map instance found for: ${targetId}`);
                return false;
            }
            this.mapInstances.delete(targetId);
            if (Log) Log.info(`[APIFactoryManager] Map instance removed for: ${targetId}`);
            return true;
        }

        /**
         * Obtient les statistiques
         */
        getStats() {
            return {
                ...this.stats,
                activeInstances: this.mapInstances.size,
                isReady: this.isReady
            };
        }

        /**
         * Réinitialise le gestionnaire
         */
        reset() {
            this.mapInstances.clear();
            this.getModule = null;
            this.stats = {
                mapsCreated: 0,
                errors: 0
            };

            if (Log) Log.info('[APIFactoryManager] Manager reset');
        }
    }

    /**
     * API Initialization Manager - Sprint 4.3 (Version Robuste)
     * Gestionnaire des opérations d'initialisation GeoLeaf
     * @module APIInitializationManager
     */
    const _g$6 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : {};
    _g$6.GeoLeaf = _g$6.GeoLeaf || {};


    /**
     * Gestionnaire d'initialisation pour GeoLeaf
     */
    class APIInitializationManager {
        constructor() {
            this.isReady = true; // Manager prêt sans init séparée
            this.pendingPromise = null;
            this.cancelled = false;
            this.stats = {
                initCalls: 0,
                configLoads: 0,
                errors: 0
            };
        }

        /**
         * Initialise GeoLeaf avec les options fournies
         * @param {Object} options - Options d'initialisation
         * @param {Function} getModule - Fonction d'accès aux modules
         * @returns {*} Résultat de l'initialisation
         */
        init(options, getModule) {
            try {
                this.stats.initCalls++;

                if (Log) Log.info('[APIInitializationManager] Initializing GeoLeaf');

                // Validation des paramètres
                const validationResult = this._validateInitParams(options, getModule);
                if (!validationResult.valid) {
                    throw new Error(validationResult.error);
                }

                // Obtenir le module Core
                const Core = getModule("Core");
                if (!Core || typeof Core.init !== "function") {
                    throw new Error("[GeoLeaf.init] GeoLeaf.Core.init() is not available. Core module must be loaded before API.");
                }

                // Normaliser les options
                const normalizedOptions = this._normalizeInitOptions(options);
                if (Log) Log.info('[APIInitializationManager] Initializing with options:', normalizedOptions);

                // Appeler l'initialisation du Core
                const result = Core.init(normalizedOptions);

                if (Log) Log.info('[APIInitializationManager] Initialization completed successfully');
                return result;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error('[APIInitializationManager] Initialization failed:', error);
                throw error;
            }
        }

        /**
         * Charge une configuration depuis URL ou données
         * @param {string|Object} input - Source de configuration
         * @param {Function} getModule - Fonction d'accès aux modules
         * @returns {Promise<Object>} Données de configuration
         */
        async loadConfig(input, getModule) {
            try {
                this.stats.configLoads++;

                if (Log) Log.info('[APIInitializationManager] Loading configuration');

                // Validation des paramètres
                if (!input) {
                    throw new Error('Configuration input is required');
                }

                if (!getModule || typeof getModule !== 'function') {
                    throw new Error('getModule function is required');
                }

                // Obtenir le module Config
                const Config = getModule("Config");
                if (!Config || typeof Config.init !== "function") {
                    throw new Error("[GeoLeaf.loadConfig] GeoLeaf.Config.init() is not available. Config module must be loaded.");
                }

                // Normaliser les options de configuration
                const options = this._normalizeConfigOptions(input);

                // Annuler la requête précédente si elle existe
                if (this.pendingPromise) {
                    this.cancelled = true;
                    if (Log) Log.info('[APIInitializationManager] Cancelling previous config load request');
                }

                this.cancelled = false;

                // Charger la configuration
                this.pendingPromise = Config.init(options);
                const result = await this.pendingPromise;

                this.pendingPromise = null;

                if (this.cancelled) {
                    if (Log) Log.info('[APIInitializationManager] Config load was cancelled');
                    return null;
                }

                if (Log) Log.info('[APIInitializationManager] Configuration loaded successfully');
                return result;

            } catch (error) {
                this.stats.errors++;
                this.pendingPromise = null;
                if (Log) Log.error('[APIInitializationManager] Config loading failed:', error);
                throw error;
            }
        }

        /**
         * Change le thème de l'interface
         * @param {string} theme - Nom du thème
         * @param {Function} getModule - Fonction d'accès aux modules
         * @returns {boolean} Succès du changement
         */
        setTheme(theme, getModule) {
            try {
                if (Log) Log.info(`[APIInitializationManager] Setting theme: ${theme}`);

                // Validation
                if (!theme || typeof theme !== 'string') {
                    throw new Error('Theme name must be a non-empty string');
                }

                if (!getModule || typeof getModule !== 'function') {
                    throw new Error('getModule function is required');
                }

                // Obtenir le module UI
                const UI = getModule("UI");
                if (!UI) {
                    throw new Error("[GeoLeaf.setTheme] GeoLeaf.UI is not available. UI module must be loaded.");
                }

                // Appliquer le thème - utilise applyTheme comme dans geoleaf.ui.js
                let result = false;
                if (typeof UI.applyTheme === 'function') {
                    result = UI.applyTheme(theme);
                } else if (typeof UI.setTheme === 'function') {
                    result = UI.setTheme(theme);
                } else if (typeof UI.theme === 'function') {
                    result = UI.theme(theme);
                } else {
                    throw new Error('UI module does not provide applyTheme, setTheme or theme method');
                }

                if (Log) Log.info(`[APIInitializationManager] Theme '${theme}' applied successfully`);
                return result;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error(`[APIInitializationManager] Failed to set theme '${theme}':`, error);
                return false;
            }
        }

        /**
         * Valide les paramètres d'initialisation
         * @private
         */
        _validateInitParams(options, getModule) {
            if (!options || typeof options !== "object") {
                return { valid: false, error: "[GeoLeaf.init] An options object is required." };
            }

            if (!getModule || typeof getModule !== 'function') {
                return { valid: false, error: "getModule function is required" };
            }

            return { valid: true };
        }

        /**
         * Normalise les options d'initialisation
         * @private
         */
        _normalizeInitOptions(options) {
            // Mode "structuré" (recommandé) : options.map / options.ui
            let mapOpts = options.map || {};
            let uiOpts = options.ui || {};

            // Mode "aplati" (legacy) : target/mapId / center / zoom / theme à la racine
            if (!options.map) {
                mapOpts = {
                    target: options.target || options.mapId,
                    center: options.center,
                    zoom: options.zoom
                };
                uiOpts = {
                    theme: options.theme
                };
            }

            // Validation du target
            const target = mapOpts.target || mapOpts.mapId;
            if (!target) {
                throw new Error("[GeoLeaf.init] The 'map.target' (or 'target'/'mapId') option is required.");
            }

            // Récupérer les constantes par défaut
            const CONSTANTS = _g$6.GeoLeaf.CONSTANTS || {};
            const center = Array.isArray(mapOpts.center) ? mapOpts.center : CONSTANTS.DEFAULT_CENTER || [0, 0];
            const zoom = Number.isFinite(mapOpts.zoom) ? mapOpts.zoom : CONSTANTS.DEFAULT_ZOOM || 12;
            const theme = uiOpts.theme || mapOpts.theme || "light";

            // Adapter à la signature Core.init
            return {
                mapId: String(target), // Core.init attend 'mapId' pas 'target'
                center,
                zoom,
                theme,
                mapOptions: mapOpts.mapOptions || {} // Forward raw Leaflet options (maxBounds, etc.)
            };
        }

        /**
         * Normalise les options de configuration
         * @private
         */
        _normalizeConfigOptions(input) {
            if (typeof input === 'string') {
                // URL string
                return {
                    source: 'url',
                    url: input,
                    autoEvent: true
                };
            } else if (input && typeof input === 'object') {
                // Configuration object
                return {
                    source: input.url ? 'url' : 'data',
                    url: input.url,
                    data: input.data,
                    profileId: input.profileId,
                    autoEvent: input.autoEvent !== false, // true par défaut
                    ...input
                };
            } else {
                throw new Error('Configuration input must be a URL string or options object');
            }
        }

        /**
         * Obtient les statistiques du manager
         * @returns {Object}
         */
        getStats() {
            return {
                ...this.stats,
                isReady: this.isReady,
                hasPendingRequest: !!this.pendingPromise
            };
        }

        /**
         * Réinitialise le manager
         */
        reset() {
            if (this.pendingPromise) {
                this.cancelled = true;
            }

            this.pendingPromise = null;
            this.cancelled = false;
            this.stats = {
                initCalls: 0,
                configLoads: 0,
                errors: 0
            };

            if (Log) Log.info('[APIInitializationManager] Manager reset');
        }
    }

    /**
     * API Module Manager - Sprint 4.3 (Version Robuste)
     * Gestionnaire centralisé d'accès aux modules GeoLeaf
     * @module APIModuleManager
     */
    const _g$5 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : {};
    _g$5.GeoLeaf = _g$5.GeoLeaf || {};


    /**
     * Gestionnaire d'accès aux modules GeoLeaf
     */
    class APIModuleManager {
        constructor() {
            this.modules = new Map();
            this.aliases = new Map();
            this.isInitialized = false;
            this.stats = {
                totalModules: 0,
                accessCount: 0,
                errors: 0
            };
        }

        /**
         * Initialise le gestionnaire avec les modules existants
         * @returns {boolean} Succès de l'initialisation
         */
        init() {
            try {
                if (this.isInitialized) {
                    if (Log) Log.debug('[APIModuleManager] Already initialized');
                    return true;
                }

                if (Log) Log.info('[APIModuleManager] Initializing module manager');

                // Scanner tous les modules disponibles dans le namespace GeoLeaf
                this._scanExistingModules();

                // Configurer les alias pour compatibilité
                this._setupAliases();

                this.isInitialized = true;

                if (Log) Log.info(`[APIModuleManager] Initialized with ${this.stats.totalModules} modules`);
                return true;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error('[APIModuleManager] Initialization failed:', error);
                return false;
            }
        }

        /**
         * Scanner les modules existants dans GeoLeaf
         * @private
         */
        _scanExistingModules() {
            if (!_g$5.GeoLeaf) return;

            const moduleList = [
                'Core', 'UI', 'Config', 'Baselayers', 'BaseLayers',
                'POI', 'GeoJSON', 'Route', 'Legend', 'LayerManager',
                'Storage', 'Filters', 'Log', 'Security', 'Utils',
                'Constants', 'Validators', 'Errors'
            ];

            moduleList.forEach(name => {
                if (_g$5.GeoLeaf[name]) {
                    this.modules.set(name, _g$5.GeoLeaf[name]);
                    this.stats.totalModules++;
                }
            });

            // Scanner les modules privés (préfixe _)
            Object.keys(_g$5.GeoLeaf).forEach(key => {
                if (key.startsWith('_') && !this.modules.has(key)) {
                    this.modules.set(key, _g$5.GeoLeaf[key]);
                    this.stats.totalModules++;
                }
            });
        }

        /**
         * Configure les alias pour compatibilité
         * @private
         */
        _setupAliases() {
            const aliases = {
                'Baselayers': 'BaseLayers',
                'BaseLayers': 'Baselayers',
                'Logger': 'Log',
                'Log': 'Logger'
            };

            Object.entries(aliases).forEach(([alias, target]) => {
                if (this.modules.has(target)) {
                    this.aliases.set(alias, target);
                }
            });
        }

        /**
         * Obtient un module par nom
         * @param {string} name - Nom du module
         * @returns {*} Module ou null si non trouvé
         */
        getModule(name) {
            try {
                this.stats.accessCount++;

                if (!name || typeof name !== 'string') {
                    if (Log) Log.warn(`[APIModuleManager] Invalid module name:`, name);
                    this.stats.errors++;
                    return null;
                }

                // Recherche directe
                if (this.modules.has(name)) {
                    return this.modules.get(name);
                }

                // Recherche par alias
                if (this.aliases.has(name)) {
                    const targetName = this.aliases.get(name);
                    return this.modules.get(targetName);
                }

                // Fallback vers accès global direct
                if (_g$5.GeoLeaf && _g$5.GeoLeaf[name]) {
                    // Ajouter à notre cache pour les prochains accès
                    this.modules.set(name, _g$5.GeoLeaf[name]);
                    this.stats.totalModules++;
                    return _g$5.GeoLeaf[name];
                }

                // Module non trouvé
                if (Log) Log.debug(`[APIModuleManager] Module '${name}' not found`);
                return null;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error(`[APIModuleManager] Error accessing module '${name}':`, error);
                return null;
            }
        }

        /**
         * Enregistre manuellement un module
         * @param {string} name - Nom du module
         * @param {*} module - Instance du module
         */
        registerModule(name, module) {
            try {
                if (!name || typeof name !== 'string') {
                    throw new Error('Module name must be a non-empty string');
                }

                if (!module) {
                    throw new Error('Module cannot be null or undefined');
                }

                this.modules.set(name, module);
                this.stats.totalModules++;

                if (Log) Log.debug(`[APIModuleManager] Module '${name}' registered`);
                return true;

            } catch (error) {
                this.stats.errors++;
                if (Log) Log.error(`[APIModuleManager] Failed to register module '${name}':`, error);
                return false;
            }
        }

        /**
         * Vérifie si un module existe
         * @param {string} name - Nom du module
         * @returns {boolean}
         */
        hasModule(name) {
            try {
                return this.modules.has(name) ||
                       this.aliases.has(name) ||
                       !!(_g$5.GeoLeaf && _g$5.GeoLeaf[name]);
            } catch (error) {
                if (Log) Log.error(`[APIModuleManager] Error checking module '${name}':`, error);
                return false;
            }
        }

        /**
         * Obtient la liste des modules disponibles
         * @returns {Array<string>}
         */
        getModuleList() {
            // Perf 6.3.2: O(n) via Set instead of O(n²) via Array.includes() in forEach loop
            const moduleNameSet = new Set(this.modules.keys());

            // Ajouter les modules du namespace global non encore dans notre cache
            if (_g$5.GeoLeaf) {
                Object.keys(_g$5.GeoLeaf).forEach(key => {
                    moduleNameSet.add(key);
                });
            }

            return Array.from(moduleNameSet).sort();
        }

        /**
         * Obtient les statistiques d'usage
         * @returns {Object}
         */
        getStats() {
            return {
                ...this.stats,
                cachedModules: this.modules.size,
                aliases: this.aliases.size,
                isInitialized: this.isInitialized
            };
        }

        /**
         * Rafraîchit le cache des modules
         */
        refresh() {
            if (Log) Log.info('[APIModuleManager] Refreshing module cache');

            this.modules.clear();
            this.aliases.clear();
            this.stats.totalModules = 0;

            this._scanExistingModules();
            this._setupAliases();
        }

        /**
         * Réinitialise le gestionnaire
         */
        reset() {
            this.modules.clear();
            this.aliases.clear();
            this.isInitialized = false;
            this.stats = {
                totalModules: 0,
                accessCount: 0,
                errors: 0
            };

            if (Log) Log.info('[APIModuleManager] Manager reset');
        }
    }

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const _g$4 =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$4.GeoLeaf = _g$4.GeoLeaf || {};

    /**
     * ========================================
     * DOM HELPERS
     * ========================================
     */

    /**
     * Safely get element by ID
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    function getElementById(id) {
        if (!id || typeof id !== "string") return null;
        return document.getElementById(id);
    }

    /**
     * Safely query selector
     * @param {string} selector - CSS selector
     * @param {HTMLElement} parent - Parent element (default: document)
     * @returns {HTMLElement|null}
     */
    function querySelector(selector, parent = document) {
        if (!selector || typeof selector !== "string") return null;
        try {
            return parent.querySelector(selector);
        } catch (e) {
            return null;
        }
    }

    /**
     * Safely query all selectors
     * @param {string} selector - CSS selector
     * @param {HTMLElement} parent - Parent element (default: document)
     * @returns {Array<HTMLElement>}
     */
    function querySelectorAll(selector, parent = document) {
        if (!selector || typeof selector !== "string") return [];
        try {
            return Array.from(parent.querySelectorAll(selector));
        } catch (e) {
            return [];
        }
    }

    /**
     * Create element with attributes and content
     * @param {string} tag - HTML tag name
     * @param {object} options - Element options
     * @returns {HTMLElement}
     */
    function createElement(tag, options = {}) {
        const element = document.createElement(tag);

        const {
            className,
            id,
            attributes = {},
            dataset = {},
            styles = {},
            textContent,
            innerHTML,
            children = [],
            ...otherProps
        } = options;

        if (className) element.className = className;
        if (id) element.id = id;

        Object.keys(attributes).forEach((key) => {
            element.setAttribute(key, attributes[key]);
        });

        Object.keys(dataset).forEach((key) => {
            element.dataset[key] = dataset[key];
        });

        Object.keys(styles).forEach((key) => {
            element.style[key] = styles[key];
        });

        Object.keys(otherProps).forEach((key) => {
            if (key === "ariaLabel") {
                element.setAttribute("aria-label", otherProps[key]);
            } else if (key in element) {
                element[key] = otherProps[key];
            } else {
                element.setAttribute(key, otherProps[key]);
            }
        });

        if (innerHTML) {
            const DOMSecurity = _g$4.GeoLeaf?.DOMSecurity;
            if (DOMSecurity && typeof DOMSecurity.setSafeHTML === "function") {
                DOMSecurity.setSafeHTML(element, innerHTML);
            } else {
                const Log = _g$4.GeoLeaf?.Log;
                if (Log)
                    Log.warn(
                        "[GeoLeaf.Helpers] createElement with innerHTML - DOMSecurity not available"
                    );
                element.innerHTML = innerHTML;
            }
        } else if (textContent) {
            element.textContent = textContent;
        }

        if (children.length > 0) {
            children.forEach((child) => {
                if (child instanceof HTMLElement) {
                    element.appendChild(child);
                }
            });
        }

        return element;
    }

    /**
     * Add class to element
     */
    function addClass(element, ...classNames) {
        if (!element || !element.classList) return;
        const allClasses = classNames.flatMap((cn) => cn.split(" ")).filter(Boolean);
        element.classList.add(...allClasses);
    }

    /**
     * Remove class from element
     */
    function removeClass(element, ...classNames) {
        if (!element || !element.classList) return;
        const allClasses = classNames.flatMap((cn) => cn.split(" ")).filter(Boolean);
        element.classList.remove(...allClasses);
    }

    /**
     * Toggle class on element
     */
    function toggleClass(element, className, force) {
        if (!element || !element.classList) return;
        return element.classList.toggle(className, force);
    }

    /**
     * Check if element has class
     */
    function hasClass(element, className) {
        if (!element || !element.classList) return false;
        return element.classList.contains(className);
    }

    /**
     * Remove element from DOM
     */
    function removeElement(element) {
        if (element && element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }

    /**
     * ========================================
     * PERFORMANCE HELPERS
     * ========================================
     */

    function requestFrame(callback) {
        return window.requestAnimationFrame(callback);
    }

    function cancelFrame(id) {
        window.cancelAnimationFrame(id);
    }

    /**
     * ========================================
     * ABORT CONTROLLER HELPERS
     * ========================================
     */

    function createAbortController(timeout) {
        const controller = new AbortController();
        if (timeout) {
            setTimeout(() => controller.abort(), timeout);
        }
        return controller;
    }

    /**
     * ========================================
     * LAZY LOADING HELPERS
     * ========================================
     */

    function lazyLoadImage(img, options = { threshold: 0.1 }) {
        if (!("IntersectionObserver" in window)) {
            const src = img.dataset.src || img.getAttribute("data-src");
            if (src) img.src = src;
            return;
        }

        const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    const lazyImg = entry.target;
                    const src = lazyImg.dataset.src || lazyImg.getAttribute("data-src");
                    if (src) lazyImg.src = src;
                    observer.unobserve(lazyImg);
                }
            });
        }, options);

        observer.observe(img);
    }

    function lazyExecute(callback, timeout = 100) {
        if ("requestIdleCallback" in window) {
            requestIdleCallback(callback, { timeout });
        } else {
            setTimeout(callback, timeout);
        }
    }

    /**
     * ========================================
     * MEMORY OPTIMIZATION HELPERS
     * ========================================
     */

    function clearObject(obj) {
        if (!obj || typeof obj !== "object") return;
        Object.keys(obj).forEach((key) => {
            delete obj[key];
        });
    }

    function createFragment(children = []) {
        const fragment = document.createDocumentFragment();
        children.forEach((child) => {
            if (child instanceof HTMLElement) {
                fragment.appendChild(child);
            }
        });
        return fragment;
    }

    /**
     * ========================================
     * EVENT HELPERS
     * ========================================
     */

    function addEventListener(element, event, handler, options) {
        if (!element || !event || !handler) return () => {};
        element.addEventListener(event, handler, options);
        return () => {
            element.removeEventListener(event, handler, options);
        };
    }

    function addEventListeners(element, events, options) {
        if (!element || !events) return () => {};
        const cleanups = [];
        Object.keys(events).forEach((eventName) => {
            cleanups.push(addEventListener(element, eventName, events[eventName], options));
        });
        return () => {
            cleanups.forEach((cleanup) => cleanup());
        };
    }

    function delegateEvent(parent, event, selector, handler) {
        const delegatedHandler = (e) => {
            const target = e.target;
            if (target && target.matches && target.matches(selector)) {
                handler.call(target, e);
            }
        };
        return addEventListener(parent, event, delegatedHandler);
    }

    /**
     * ========================================
     * UTILITY HELPERS
     * ========================================
     */

    function deepClone(obj, seen = new WeakMap()) {
        if (obj === null || typeof obj !== "object") return obj;
        if (seen.has(obj)) return seen.get(obj);
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);
        if (obj instanceof Array) {
            const cloned = [];
            seen.set(obj, cloned);
            obj.forEach((item) => cloned.push(deepClone(item, seen)));
            return cloned;
        }
        const cloned = {};
        seen.set(obj, cloned);
        Object.keys(obj).forEach((key) => {
            cloned[key] = deepClone(obj[key], seen);
        });
        return cloned;
    }

    function isEmpty(value) {
        if (value == null) return true;
        if (typeof value === "string") return value.trim().length === 0;
        if (Array.isArray(value)) return value.length === 0;
        if (typeof value === "object") return Object.keys(value).length === 0;
        return false;
    }

    function wait(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function retryWithBackoff(fn, maxRetries = 3, delay = 1000) {
        let lastError;
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                if (i < maxRetries - 1) {
                    const backoffDelay = delay * Math.pow(2, i);
                    await wait(backoffDelay);
                }
            }
        }
        throw lastError;
    }

    /**
     * ========================================
     * PUBLIC API
     * ========================================
     */

    const Helpers = {
        // DOM Helpers
        getElementById,
        querySelector,
        querySelectorAll,
        createElement,
        addClass,
        removeClass,
        toggleClass,
        hasClass,
        removeElement,

        // Performance Helpers
        requestFrame,
        cancelFrame,

        // AbortController Utilities
        createAbortController,

        // Lazy Loading
        lazyLoadImage,
        lazyExecute,

        // Memory Optimization
        clearObject,
        createFragment,

        // Event Helpers
        addEventListener,
        addEventListeners,
        delegateEvent,

        // Utility Functions
        deepClone,
        isEmpty,
        wait,
        retryWithBackoff,
    };

    /**
     * GeoLeaf Table – Sort Utilities
     * Pure sort helpers extracted from geoleaf.table.js (Phase 8.2.2)
     *
     * @module table/sort
     */

    /**
     * Trie le tableau `cachedData` en place selon `sortState`.
     * Ne fait rien si aucun champ de tri n'est défini.
     *
     * @param {Array}    cachedData      - Données GeoJSON features en cache (mutées en place)
     * @param {{field:string|null, direction:string|null}} sortState - État de tri courant
     * @param {Function} getNestedValue  - Fonction `(obj, path) => value`
     */
    function sortInPlace(cachedData, sortState, getNestedValue) {
        if (!sortState.field || !sortState.direction) return;

        const { field, direction } = sortState;

        cachedData.sort((a, b) => {
            const valA = getNestedValue(a, field);
            const valB = getNestedValue(b, field);

            if (valA == null && valB == null) return 0;
            if (valA == null) return direction === "asc" ? 1 : -1;
            if (valB == null) return direction === "asc" ? -1 : 1;

            let result = 0;
            if (typeof valA === "number" && typeof valB === "number") {
                result = valA - valB;
            } else {
                result = String(valA).localeCompare(String(valB));
            }

            return direction === "asc" ? result : -result;
        });
    }

    /**
     * Calcule le prochain état de tri d'après un clic sur une colonne.
     * Cycle : (aucun) → asc → desc → (aucun).
     *
     * @param {{field:string|null, direction:string|null}} sortState - État courant
     * @param {string} field - Champ cliqué
     * @returns {{field:string|null, direction:string|null}} Nouvel état (immutable)
     */
    function nextSortState(sortState, field) {
        if (sortState.field === field) {
            if (sortState.direction === "asc") return { field, direction: "desc" };
            if (sortState.direction === "desc") return { field: null, direction: null };
            return { field, direction: "asc" };
        }
        return { field, direction: "asc" };
    }

    /**
     * GeoLeaf Table – Export Utilities
     * Pure export helpers extracted from geoleaf.table.js (Phase 8.2.2)
     *
     * @module table/export
     */

    /**
     * Résout l'ID d'une feature GeoJSON de façon cohérente avec le renderer.
     * Miroir exact de la logique utilisée dans table/renderer.js.
     *
     * @param {Object} feature        - Feature GeoJSON
     * @param {number} syntheticIndex - Index de fallback (0-based)
     * @returns {string} ID résolu
     */
    function resolveFeatureId(feature, syntheticIndex) {
        // 1. ID standard GeoJSON
        if (feature.id != null && feature.id !== "") return String(feature.id);

        const p = feature.properties;
        if (!p) return "__gl_row_" + syntheticIndex;

        // 2. Propriétés d'identifiant courantes
        if (p.id      != null && p.id      !== "") return String(p.id);
        if (p.fid     != null && p.fid     !== "") return String(p.fid);
        if (p.osm_id  != null && p.osm_id  !== "") return String(p.osm_id);
        if (p.OBJECTID!= null && p.OBJECTID!== "") return String(p.OBJECTID);
        if (p.SITE_ID != null && p.SITE_ID !== "") return String(p.SITE_ID);
        if (p.code    != null && p.code    !== "") return String(p.code);
        if (p.IN1     != null && p.IN1     !== "") return String(p.IN1);

        // 3. Fallback : ID synthétique
        return "__gl_row_" + syntheticIndex;
    }

    /**
     * Construit une FeatureCollection GeoJSON à partir d'un tableau de features.
     *
     * @param {Array} features - Les features GeoJSON sélectionnées
     * @returns {{type: "FeatureCollection", features: Array}} FeatureCollection
     */
    function buildGeoJSONCollection(features) {
        return {
            type: "FeatureCollection",
            features: features.map(f => ({
                type: "Feature",
                properties: f.properties || {},
                geometry: f.geometry || null
            }))
        };
    }

    /**
     * Déclenche le téléchargement d'un fichier GeoJSON dans le navigateur.
     *
     * @param {Object} geojson   - Objet GeoJSON à sérialiser
     * @param {string} layerId   - ID de la couche (utilisé comme préfixe du nom de fichier)
     */
    function downloadGeoJSON(geojson, layerId) {
        const json = JSON.stringify(geojson, null, 2);
        const blob = new Blob([json], { type: "application/geo+json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = (layerId || "export") + "_selection.geojson";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    /**
     * GeoLeaf Contract — Table (lazy-chunk boundary)
     *
     * Interface ESM pure pour que table/panel.js puisse appeler les méthodes
     * du module Table (geoleaf.table.js) sans couplage runtime.
     *
     * Phase 10-E — Pattern G : contrat de chunk Table.
     *
     * CYCLE ROMPU :
     *   geoleaf.table.js → table/panel.js (static import, inchangé)
     *   table/panel.js   → TableContract  (registration pattern)
     *   geoleaf.table.js appelle TableContract.register(Table) au chargement
     *
     * USAGE dans panel.js :
     *   import { TableContract } from '../../../contracts/table.contract.js';
     *
     *   if (TableContract.isAvailable()) {
     *       TableContract.setLayer(layerId);
     *   }
     *
     * REGISTRATION dans geoleaf.table.js (côté Table) :
     *   import { TableContract } from '../../contracts/table.contract.js';
     *   TableContract.register(TableModule);
     */

    /** @type {Object|null} */
    let _table = null;
    /** @type {Object|null} */
    let _panel = null;

    /**
     * Contrat d'interface pour le module Table.
     * Permet à panel.js d'appeler les méthodes Table sans importer geoleaf.table.js
     * (ce qui créerait un cycle).
     * @namespace TableContract
     */
    const TableContract = {
        /**
         * Enregistre l'instance Table (appelé par geoleaf.table.js au chargement).
         * @param {Object} tableInstance
         * @param {Object} [panelInstance]
         */
        register(tableInstance, panelInstance) {
            _table = tableInstance;
            if (panelInstance) _panel = panelInstance;
        },

        /**
         * Retourne true si Table est disponible.
         * @returns {boolean}
         */
        isAvailable() {
            return !!_table;
        },

        /**
         * @param {string} layerId
         */
        setLayer(layerId) {
            if (_table && typeof _table.setLayer === 'function') {
                _table.setLayer(layerId);
            }
        },

        /**
         * Zoom sur la sélection courante.
         */
        zoomToSelection() {
            if (_table && typeof _table.zoomToSelection === 'function') {
                _table.zoomToSelection();
            }
        },

        /**
         * @param {boolean} active
         */
        highlightSelection(active) {
            if (_table && typeof _table.highlightSelection === 'function') {
                _table.highlightSelection(active);
            }
        },

        /**
         * Export de la sélection.
         */
        exportSelection() {
            if (_table && typeof _table.exportSelection === 'function') {
                _table.exportSelection();
            }
        },

        /**
         * Toggle visibilité du tableau.
         */
        toggle() {
            if (_table && typeof _table.toggle === 'function') {
                _table.toggle();
            }
        },

        /**
         * Affiche le tableau.
         */
        show() {
            if (_table && typeof _table.show === 'function') {
                _table.show();
            }
        },

        // ── Selection API ──

        /**
         * @returns {string[]}
         */
        getSelectedIds() {
            if (_table && typeof _table.getSelectedIds === 'function') {
                return _table.getSelectedIds();
            }
            return [];
        },

        /**
         * @param {string[]} ids
         * @param {boolean} [fireEvent]
         */
        setSelection(ids, fireEvent) {
            if (_table && typeof _table.setSelection === 'function') {
                _table.setSelection(ids, fireEvent);
            }
        },

        /**
         * Clear la sélection.
         */
        clearSelection() {
            if (_table && typeof _table.clearSelection === 'function') {
                _table.clearSelection();
            }
        },

        /**
         * @param {string} field
         */
        sortByField(field) {
            if (_table && typeof _table.sortByField === 'function') {
                _table.sortByField(field);
            }
        },

        /**
         * Met à jour les boutons toolbar du panel.
         * @param {number} selectedCount
         */
        updateToolbarButtons(selectedCount) {
            if (_panel && typeof _panel.updateToolbarButtons === 'function') {
                _panel.updateToolbarButtons(selectedCount);
            }
        },
    };

    /**
     * GeoLeaf Table - Panel Module
     * Construction du bottom-sheet drawer pour le tableau
     */

    const _TablePanel = {};
    _TablePanel._eventCleanups = [];

    /**
     * Crée le conteneur principal du tableau (bottom-sheet)
     * @param {L.Map} map - Instance de la carte Leaflet
     * @param {Object} config - Configuration du tableau
     * @returns {HTMLElement} Conteneur du tableau
     */
    _TablePanel.create = function (map, config) {
        // Vérifier si le conteneur existe déj�?
        let container = document.querySelector(".gl-table-panel");
        if (container) {
            return container;
        }

        // Créer le conteneur principal
        container = document.createElement("div");
        container.className = "gl-table-panel";
        container.style.height = config.defaultHeight || "40%";

        // Ajouter la barre de redimensionnement si resizable
        if (config.resizable) {
            const resizeHandle = createResizeHandle(container, config);
            container.appendChild(resizeHandle);
        }

        // Créer la barre d'outils (header)
        const toolbar = createToolbar(map, config);
        container.appendChild(toolbar);

        // Créer le wrapper du tableau avec scroll
        const tableWrapper = document.createElement("div");
        tableWrapper.className = "gl-table-panel__wrapper";
        container.appendChild(tableWrapper);

        // Créer le tableau vide (sera rempli par le renderer)
        const table = document.createElement("table");
        table.className = "gl-table-panel__table";
        tableWrapper.appendChild(table);

        // Ajouter au body
        document.body.appendChild(container);

        // Créer le bouton flottant pour afficher le tableau (quand masqué)
        createFloatingShowButton();

        Log.info("[TablePanel] Panneau créé avec succès");
        return container;
    };

    /**
     * Crée la barre de redimensionnement
     * @param {HTMLElement} container - Conteneur du tableau
     * @param {Object} config - Configuration
     * @returns {HTMLElement}
     * @private
     */
    function createResizeHandle(container, config) {
        const handle = document.createElement("div");
        handle.className = "gl-table-panel__resize-handle";
        const resizeBar = document.createElement("div");
        resizeBar.className = "gl-table-panel__resize-bar";
        handle.appendChild(resizeBar);

        let isResizing = false;
        let startY = 0;
        let startHeight = 0;

        const events$1 = events;
        const mouseDownHandler = (e) => {
            isResizing = true;
            startY = e.clientY;
            startHeight = container.offsetHeight;
            document.body.style.cursor = "ns-resize";
            document.body.style.userSelect = "none";
            e.preventDefault();
        };

        const mouseMoveHandler = (e) => {
            if (!isResizing) return;
            const delta = startY - e.clientY;
            let newHeight = startHeight + delta;
            const viewportHeight = window.innerHeight;
            const minHeightPx = parseHeight(config.minHeight || "20%", viewportHeight);
            const maxHeightPx = parseHeight(config.maxHeight || "80%", viewportHeight);
            newHeight = Math.max(minHeightPx, Math.min(maxHeightPx, newHeight));
            container.style.height = newHeight + "px";
        };

        const mouseUpHandler = () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = "";
                document.body.style.userSelect = "";
            }
        };

        if (events$1) {
            _TablePanel._eventCleanups.push(
                events$1.on(handle, "mousedown", mouseDownHandler, false, "TablePanel.resizeMouseDown")
            );
            _TablePanel._eventCleanups.push(
                events$1.on(document, "mousemove", mouseMoveHandler, false, "TablePanel.resizeMouseMove")
            );
            _TablePanel._eventCleanups.push(
                events$1.on(document, "mouseup", mouseUpHandler, false, "TablePanel.resizeMouseUp")
            );
        } else {
            handle.addEventListener("mousedown", mouseDownHandler);
            document.addEventListener("mousemove", mouseMoveHandler);
            document.addEventListener("mouseup", mouseUpHandler);
        }

        return handle;
    }

    /**
     * Parse une valeur de hauteur (%, px, vh) en pixels
     * @param {string} value - Valeur �?  parser ("40%", "300px", "50vh")
     * @param {number} referenceHeight - Hauteur de référence pour les %
     * @returns {number} Hauteur en pixels
     * @private
     */
    function parseHeight(value, referenceHeight) {
        if (typeof value === "number") return value;
        if (typeof value !== "string") return 300;

        if (value.endsWith("%")) {
            const percent = parseFloat(value);
            return (referenceHeight * percent) / 100;
        } else if (value.endsWith("px")) {
            return parseFloat(value);
        } else if (value.endsWith("vh")) {
            const vh = parseFloat(value);
            return (window.innerHeight * vh) / 100;
        }
        return 300; // Défaut
    }

    /**
     * Crée la barre d'outils du tableau
     * @param {L.Map} map - Instance de la carte
     * @param {Object} config - Configuration
     * @returns {HTMLElement}
     * @private
     */
    function createToolbar(map, config) {
        const toolbar = document.createElement("div");
        toolbar.className = "gl-table-panel__toolbar";

        // Sélecteur de couche
        const layerSelect = createLayerSelector();
        toolbar.appendChild(layerSelect);

        // Champ de recherche
        const searchInput = createSearchInput();
        toolbar.appendChild(searchInput);

        // Bouton Zoom sur la sélection
        const zoomButton = createButton("Zoom sur sélection", "zoom", () => {
            TableContract.zoomToSelection();
        });
        zoomButton.disabled = true;
        zoomButton.setAttribute("data-table-btn", "zoom");
        toolbar.appendChild(zoomButton);

        // Bouton Surbrillance
        const highlightButton = createButton("Surbrillance", "highlight", () => {
            const isActive = highlightButton.classList.toggle("is-active");
            TableContract.highlightSelection(isActive);
        });
        highlightButton.disabled = true;
        highlightButton.setAttribute("data-table-btn", "highlight");
        toolbar.appendChild(highlightButton);

        // Bouton Export (si activé)
        if (config.enableExportButton) {
            const exportButton = createButton("Exporter", "export", () => {
                TableContract.exportSelection();
            });
            exportButton.disabled = true;
            exportButton.setAttribute("data-table-btn", "export");
            toolbar.appendChild(exportButton);
        }

        // Spacer pour pousser le bouton toggle �?  droite
        const spacer = document.createElement("div");
        spacer.style.flex = "1";
        toolbar.appendChild(spacer);

        // Bouton toggle (masquer/afficher le tableau)
        const toggleBtn = createToggleButton();
        toolbar.appendChild(toggleBtn);

        return toolbar;
    }

    /**
     * Crée le sélecteur de couche
     * @returns {HTMLElement}
     * @private
     */
    function createLayerSelector() {
        const wrapper = document.createElement("div");
        wrapper.className = "gl-table-panel__layer-selector";

        const select = document.createElement("select");
        select.id = "geoleaf-table-layer-selector";
        select.name = "geoleaf-table-layer-selector";
        select.className = "gl-table-panel__select";
        select.setAttribute("data-table-layer-select", "");

        // Option par défaut
        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Sélectionner une couche...";
        select.appendChild(defaultOption);

        // Population différée : les couches GeoJSON ne sont pas encore disponibles à la création du panel.
        // refreshLayerSelector() est appelé via l'événement geoleaf:geojson:layers-loaded une fois
        // le chargement asynchrone terminé.

        // Événement de changement - avec cleanup tracking
        const changeHandler = (e) => {
            const layerId = e.target.value;
            TableContract.setLayer(layerId);
        };

        const events$1 = events;
        if (events$1) {
            _TablePanel._eventCleanups.push(
                events$1.on(select, "change", changeHandler, false, "TablePanel.layerSelect")
            );
        } else {
            select.addEventListener("change", changeHandler);
        }

        wrapper.appendChild(select);
        return wrapper;
    }

    /**
     * Peuple le sélecteur avec les couches disponibles
     * @param {HTMLSelectElement} select - Élément select
     * @private
     */
    function populateLayerSelector(select) {
        const allLayersMap = GeoJSONShared.getLayers();
        if (!allLayersMap || allLayersMap.size === 0) {
            Log.warn("[TablePanel] Module GeoJSON non disponible ou aucune couche");
            return;
        }

        const VisibilityManager$1 = VisibilityManager;

        // Vérifier les options existantes pour éviter les doublons
        const existingValues = new Set();
        for (let i = 1; i < select.options.length; i++) {
            existingValues.add(select.options[i].value);
        }

        let addedCount = 0;
        allLayersMap.forEach((layerData, layerId) => {
            if (
                layerData &&
                layerData.config &&
                layerData.config.table &&
                layerData.config.table.enabled
            ) {
                // Vérifier que la couche est visible sur la carte
                let isVisible = true;
                if (VisibilityManager$1 && typeof VisibilityManager$1.getVisibilityState === "function") {
                    const visState = VisibilityManager$1.getVisibilityState(layerId);
                    isVisible = visState && visState.current === true;
                } else if (layerData._visibility) {
                    isVisible = layerData._visibility.current === true;
                }

                if (!isVisible) {
                    return;
                }

                // N'ajouter que si pas déj�?  présent
                if (!existingValues.has(layerId)) {
                    const option = document.createElement("option");
                    option.value = layerId;
                    option.textContent = layerData.label || layerData.config?.title || layerId;
                    select.appendChild(option);
                    addedCount++;
                }
            }
        });

        if (addedCount > 0) {
            Log.info("[TablePanel] Sélecteur de couche peuplé:", addedCount, "couches ajoutées");
        }
    }

    /**
     * Crée le champ de recherche
     * @returns {HTMLElement}
     * @private
     */
    function createSearchInput() {
        const wrapper = document.createElement("div");
        wrapper.className = "gl-table-panel__search";

        const input = document.createElement("input");
        input.type = "text";
        input.id = "geoleaf-table-search-input";
        input.name = "geoleaf-table-search-input";
        input.placeholder = "Rechercher...";
        input.className = "gl-table-panel__search-input";
        input.setAttribute("data-table-search", "");

        // Debounce la recherche pour éviter les appels trop fréquents
        let timeout;
        input.addEventListener("input", (e) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                const searchText = e.target.value.trim().toLowerCase();
                filterTableRows(searchText);
            }, 300);
        });

        wrapper.appendChild(input);
        return wrapper;
    }

    /**
     * Filtre les lignes du tableau selon le texte de recherche
     * @param {string} searchText - Texte �?  rechercher
     * @private
     */
    function filterTableRows(searchText) {
        const table = document.querySelector(".gl-table-panel__table tbody");
        if (!table) return;

        const rows = table.querySelectorAll("tr");
        rows.forEach((row) => {
            if (!searchText) {
                row.style.display = "";
                return;
            }

            const cells = row.querySelectorAll("td");
            let match = false;

            cells.forEach((cell) => {
                const text = cell.textContent.toLowerCase();
                if (text.includes(searchText)) {
                    match = true;
                }
            });

            row.style.display = match ? "" : "none";
        });
    }

    /**
     * Crée un bouton générique
     * @param {string} label - Libellé du bouton
     * @param {string} icon - Classe d'icône (optionnel)
     * @param {Function} onClick - Callback au clic
     * @returns {HTMLElement}
     * @private
     */
    function createButton(label, icon, onClick) {
        const button = document.createElement("button");
        button.className = "gl-table-panel__btn";
        button.textContent = label;

        if (icon) {
            button.classList.add("gl-table-panel__btn--" + icon);
        }

        if (onClick) {
            if (events) {
                _TablePanel._eventCleanups.push(
                    events.on(button, "click", onClick, false, "TablePanel.button")
                );
            } else {
                button.addEventListener("click", onClick);
            }
        }

        return button;
    }

    /**
     * Cr?e le bouton toggle pour masquer le tableau (int?gr? dans le toolbar)
     * @returns {HTMLElement}
     * @private
     */
    function createToggleButton() {
        const button = document.createElement("button");
        button.className = "gl-table-panel__toggle-btn";
        button.title = "Masquer le tableau";
        button.setAttribute("aria-label", "Masquer tableau");

        // Créer l'icône SVG (flèche vers le bas)
        const icon = document.createElement("span");
        icon.className = "gl-table-panel__toggle-btn__icon";
        // SAFE: SVG statique hardcodé, pas de données utilisateur
        const downSvg = DOMSecurity.createSVGIcon(16, 16, "M6 9l6 6 6-6", {
            stroke: "currentColor",
            strokeWidth: "6",
            fill: "none",
        });
        icon.appendChild(downSvg);
        button.appendChild(icon);

        const clickHandler = () => {
            TableContract.toggle();
        };

        const events$1 = events;
        if (events$1) {
            _TablePanel._eventCleanups.push(
                events$1.on(button, "click", clickHandler, false, "TablePanel.toggleBtn")
            );
        } else {
            button.addEventListener("click", clickHandler);
        }

        return button;
    }

    /**
     * Crée le bouton flottant pour afficher le tableau (visible quand tableau masqué)
     * @private
     */
    function createFloatingShowButton() {
        const button = document.createElement("button");
        button.className = "gl-table-panel__floating-show-btn";
        button.title = "Afficher le tableau";
        button.setAttribute("aria-label", "Afficher tableau");

        // Créer l'icône SVG (flèche vers le haut)
        const icon = document.createElement("span");
        icon.className = "gl-table-panel__toggle-btn__icon";
        // SAFE: SVG statique hardcodé, pas de données utilisateur
        const upSvg = DOMSecurity.createSVGIcon(16, 16, "M18 15l-6-6-6 6", {
            stroke: "currentColor",
            strokeWidth: "6",
            fill: "none",
        });
        icon.appendChild(upSvg);
        button.appendChild(icon);

        const clickHandler = () => {
            TableContract.show();
        };

        const events$1 = events;
        if (events$1) {
            _TablePanel._eventCleanups.push(
                events$1.on(button, "click", clickHandler, false, "TablePanel.floatingShowBtn")
            );
        } else {
            button.addEventListener("click", clickHandler);
        }

        document.body.appendChild(button);
    }

    /**
     * Met �?  jour l'état des boutons de la toolbar selon la sélection
     * @param {number} selectedCount - Nombre d'entités sélectionnées
     */
    _TablePanel.updateToolbarButtons = function (selectedCount) {
        const hasSelection = selectedCount > 0;

        const zoomBtn = document.querySelector("[data-table-btn='zoom']");
        const highlightBtn = document.querySelector("[data-table-btn='highlight']");
        const exportBtn = document.querySelector("[data-table-btn='export']");

        if (zoomBtn) zoomBtn.disabled = !hasSelection;
        if (highlightBtn) {
            highlightBtn.disabled = !hasSelection;
            // Si plus aucune sélection, désactiver la surbrillance
            if (!hasSelection && highlightBtn.classList.contains("is-active")) {
                highlightBtn.classList.remove("is-active");
                TableContract.highlightSelection(false);
            }
        }
        if (exportBtn) exportBtn.disabled = !hasSelection;
    };

    /**
     * Rafraîchit le sélecteur de couche (utile après chargement de nouvelles couches)
     */
    _TablePanel.refreshLayerSelector = function () {
        const select = document.querySelector("[data-table-layer-select]");
        if (!select) return;

        // Sauvegarder la valeur actuelle
        const currentValue = select.value;

        // Vider les options (sauf la première)
        while (select.options.length > 1) {
            select.remove(1);
        }

        // Re-peupler
        populateLayerSelector(select);

        // Vérifier si la valeur actuelle est toujours disponible
        const optionValues = Array.from(select.options).map((o) => o.value);
        if (currentValue && optionValues.includes(currentValue)) {
            select.value = currentValue;
        } else if (currentValue && !optionValues.includes(currentValue)) {
            // La couche active a été retirée (masquée) �?? basculer sur la première disponible
            if (select.options.length > 1) {
                select.value = select.options[1].value;
                TableContract.setLayer(select.options[1].value);
            } else {
                // Aucune couche visible ? vider le tableau
                select.value = "";
                TableContract.setLayer("");
            }
        }

        // Mettre �?  jour le placeholder si aucune couche visible
        const defaultOption = select.options[0];
        if (defaultOption) {
            defaultOption.textContent =
                select.options.length > 1 ? "Sélectionner une couche..." : "Aucune couche visible";
        }

        Log.info(
            "[TablePanel] Sélecteur de couche rafraîchi,",
            select.options.length - 1,
            "couches disponibles"
        );
    };

    /**
     * Cleanup all event listeners
     */
    _TablePanel.destroy = function () {
        if (_TablePanel._eventCleanups && _TablePanel._eventCleanups.length > 0) {
            _TablePanel._eventCleanups.forEach((cleanup) => {
                if (typeof cleanup === "function") cleanup();
            });
            _TablePanel._eventCleanups = [];
            Log.info("[TablePanel] Event listeners cleaned up");
        }
    };

    const TablePanel = _TablePanel;

    /**
     * GeoLeaf Table - Renderer Module
     * Rendu des colonnes, lignes et pagination avec virtual scrolling
     */

    const _TableRenderer = {};
    _TableRenderer._eventCleanups = [];

    /**
     * Flush all tracked event cleanups (called before re-render and on destroy)
     */
    _TableRenderer._flushEventCleanups = function () {
        const cleanups = this._eventCleanups;
        for (let i = 0; i < cleanups.length; i++) {
            if (typeof cleanups[i] === "function") {
                try {
                    cleanups[i]();
                } catch (e) {
                    /* ignore */
                }
            }
        }
        cleanups.length = 0;
    };

    /**
     * Destroy the table renderer and clean up all event listeners
     */
    _TableRenderer.destroy = function () {
        this._flushEventCleanups();
    };

    /**
     * Rend le tableau avec les données fournies
     * @param {HTMLElement} container - Conteneur du tableau
     * @param {Object} options - Options de rendu
     * @param {string} options.layerId - ID de la couche
     * @param {Array} options.features - Features à afficher
     * @param {Set} options.selectedIds - IDs des entités sélectionnées
     * @param {Object} options.sortState - État du tri
     * @param {Object} options.config - Configuration du tableau
     */
    _TableRenderer.render = function (container, options) {
        Log.debug("[TableRenderer] render() - Début, options:", options);

        if (!container) {
            Log.error("[TableRenderer] Conteneur invalide");
            return;
        }

        // Phase 1 fix L4.4: flush previous event cleanups before re-render
        _TableRenderer._flushEventCleanups();

        // Réinitialiser le compteur d'IDs synthétiques à chaque rendu
        _syntheticIdCounter = 0;

        const { layerId, features, selectedIds, sortState } = options;
        Log.debug(
            "[TableRenderer] render() - layerId:",
            layerId,
            "features:",
            features ? features.length : 0
        );

        const table = container.querySelector(".gl-table-panel__table");
        if (!table) {
            Log.error("[TableRenderer] Élément table introuvable");
            return;
        }

        // Si pas de layerId, vider le tableau
        if (!layerId) {
            // SAFE: Chaîne vide pour nettoyer le contenu
            DOMSecurity.clearElementFast(table);
            Log.debug("[TableRenderer] Tableau vidé (aucune couche sélectionnée)");
            return;
        }

        // Récupérer la config du layer
        const layerData = GeoJSONShared.getLayerById(layerId);
        const layerConfig =
            layerData && layerData.config && layerData.config.table ? layerData.config.table : null;

        if (!layerConfig || !layerConfig.columns) {
            Log.warn("[TableRenderer] Aucune configuration de colonne pour", layerId);
            // SAFE: Chaîne vide pour nettoyer le contenu
            DOMSecurity.clearElementFast(table);
            return;
        }

        Log.debug("[TableRenderer] Colonnes:", layerConfig.columns);

        // Vider le tableau
        // SAFE: Chaîne vide pour nettoyer le contenu avant reconstruction
        DOMSecurity.clearElementFast(table);

        // Créer le thead
        const thead = createTableHead(layerConfig.columns, sortState);
        table.appendChild(thead);

        // Créer le tbody
        const tbody = createTableBody(features, layerConfig.columns, selectedIds);
        table.appendChild(tbody);

        // Virtual scrolling supprimé — la pagination dans renderTable() est suffisante.
        // TODO(v5): Réimplémenter si les datasets > 10 000 lignes deviennent courants.

        Log.debug("[TableRenderer] Tableau rendu:", features.length, "lignes");
    };

    /**
     * Crée l'en-tête du tableau (thead)
     * @param {Array} columns - Configuration des colonnes
     * @param {Object} sortState - État du tri actuel
     * @returns {HTMLElement}
     * @private
     */
    function createTableHead(columns, sortState) {
        const thead = createElement$1("thead");
        const tr = createElement$1("tr");

        // Colonne checkbox (sélection)
        const thCheckbox = createElement$1("th", {
            className: "gl-table-panel__th gl-table-panel__th--checkbox",
        });

        const checkboxAll = createElement$1("input", {
            type: "checkbox",
            className: "gl-table-panel__checkbox-all",
            title: "Tout sélectionner / Tout désélectionner",
        });

        const checkboxAllHandler = (e) => {
            toggleAllRows(e.target.checked);
        };

        const events$1 = events;
        if (events$1) {
            _TableRenderer._eventCleanups.push(
                events$1.on(checkboxAll, "change", checkboxAllHandler, false, "TableRenderer.checkboxAll")
            );
        } else {
            checkboxAll.addEventListener("change", checkboxAllHandler);
        }

        thCheckbox.appendChild(checkboxAll);
        tr.appendChild(thCheckbox);

        // Colonnes de données
        columns.forEach((col) => {
            const th = createElement$1("th", { className: "gl-table-panel__th" });
            th.textContent = col.label || col.field;

            if (col.width) {
                th.style.width = col.width;
            }

            // Rendre la colonne triable (par défaut toutes les colonnes sont triables)
            const isSortable = col.sortable !== false;
            if (isSortable) {
                th.classList.add("gl-table-panel__th--sortable");
                th.setAttribute("data-field", col.field);

                // Ajouter les indicateurs de tri
                const sortIcon = createElement$1("span", { className: "gl-table-panel__sort-icon" });

                if (sortState.field === col.field) {
                    if (sortState.direction === "asc") {
                        sortIcon.textContent = " ▲";
                        th.classList.add("is-sorted-asc");
                    } else if (sortState.direction === "desc") {
                        sortIcon.textContent = " ▼";
                        th.classList.add("is-sorted-desc");
                    }
                } else {
                    sortIcon.textContent = " ⇅";
                }

                th.appendChild(sortIcon);

                // Événement de tri - avec cleanup tracking
                const sortHandler = () => {
                    TableContract.sortByField(col.field);
                };

                const events$1 = events;
                if (events$1) {
                    _TableRenderer._eventCleanups.push(
                        events$1.on(th, "click", sortHandler, false, "TableRenderer.sort")
                    );
                } else {
                    th.addEventListener("click", sortHandler);
                }
            }

            tr.appendChild(th);
        });

        thead.appendChild(tr);
        return thead;
    }

    /**
     * Crée le corps du tableau (tbody)
     * @param {Array} features - Features à afficher
     * @param {Array} columns - Configuration des colonnes
     * @param {Set} selectedIds - IDs sélectionnés
     * @returns {HTMLElement}
     * @private
     */
    function createTableBody(features, columns, selectedIds) {
        Log.debug("[TableRenderer] createTableBody() - features:", features.length);

        const tbody = createElement$1("tbody");

        // Sprint 3.2: Use DocumentFragment for batch DOM operations
        const fragment = document.createDocumentFragment();

        features.forEach((feature) => {
            const tr = createTableRow(feature, columns, selectedIds);
            fragment.appendChild(tr);
        });

        tbody.appendChild(fragment);

        Log.debug("[TableRenderer] tbody créé avec", tbody.children.length, "lignes");
        return tbody;
    }

    /**
     * Crée une ligne du tableau
     * @param {Object} feature - Feature GeoJSON
     * @param {Array} columns - Configuration des colonnes
     * @param {Set} selectedIds - IDs sélectionnés
     * @returns {HTMLElement}
     * @private
     */
    function createTableRow(feature, columns, selectedIds) {
        const tr = createElement$1("tr");
        const featureId = getFeatureId(feature);
        tr.setAttribute("data-feature-id", featureId);

        const isSelected = selectedIds.has(String(featureId));
        if (isSelected) {
            tr.classList.add("is-selected");
        }

        // Cellule checkbox
        const tdCheckbox = createElement$1("td", {
            className: "gl-table-panel__td gl-table-panel__td--checkbox",
        });

        const checkbox = createElement$1("input", {
            type: "checkbox",
            className: "gl-table-panel__checkbox",
            checked: isSelected,
        });

        const checkboxHandler = (e) => {
            // Pour les checkboxes, toujours traiter comme multi-sélection
            handleRowSelection(featureId, e.target.checked, false, true, true);
        };

        const events$1 = events;
        if (events$1) {
            _TableRenderer._eventCleanups.push(
                events$1.on(checkbox, "change", checkboxHandler, false, "TableRenderer.checkbox")
            );
        } else {
            checkbox.addEventListener("change", checkboxHandler);
        }

        tdCheckbox.appendChild(checkbox);
        tr.appendChild(tdCheckbox);

        // Cellules de données
        columns.forEach((col) => {
            const td = createElement$1("td", { className: "gl-table-panel__td" });

            const value = getNestedValue$1(feature, col.field);
            const formattedValue = formatValue(value, col.type);

            td.textContent = formattedValue;

            // Aligner les nombres à droite
            if (col.type === "number") {
                td.classList.add("gl-table-panel__td--number");
            }

            tr.appendChild(td);
        });

        // Événement clic sur la ligne (sélection simple) - avec cleanup tracking
        const rowClickHandler = (e) => {
            // Ignorer si c'est le checkbox qui a été cliqué
            if (e.target.type === "checkbox") return;
            const currentState = tr.classList.contains("is-selected");
            handleRowSelection(featureId, !currentState, e.shiftKey, e.ctrlKey || e.metaKey);
        };

        // Reuse EventListenerManager from outer scope
        if (events) {
            _TableRenderer._eventCleanups.push(
                events.on(tr, "click", rowClickHandler, false, "TableRenderer.rowClick")
            );
        } else {
            tr.addEventListener("click", rowClickHandler);
        }

        return tr;
    }

    /**
     * Gère la sélection d'une ligne
     * @param {string} featureId - ID de la feature
     * @param {boolean} selected - Sélectionné ou non
     * @param {boolean} shiftKey - Touche Shift enfoncée
     * @param {boolean} ctrlKey - Touche Ctrl/Cmd enfoncée
     * @param {boolean} isCheckbox - Si l'action vient d'une checkbox
     * @private
     */
    function handleRowSelection(featureId, selected, shiftKey, ctrlKey, isCheckbox = false) {
        Log.debug("[TableRenderer] handleRowSelection - featureId:", featureId, "selected:", selected);

        const currentSelection = TableContract.getSelectedIds();

        if (shiftKey && currentSelection.length > 0) {
            // Sélection par plage (Shift+clic)
            Log.debug("[TableRenderer] Mode SHIFT - Sélection par plage");
            selectRange(featureId);
        } else if (ctrlKey || isCheckbox) {
            // Multi-sélection (Ctrl+clic ou checkbox)
            Log.debug(
                "[TableRenderer] Mode MULTI - Multi-sélection" +
                    (isCheckbox ? " (checkbox)" : " (Ctrl)")
            );
            if (selected) {
                const newSelection = [...currentSelection, featureId];
                TableContract.setSelection(newSelection, false);
            } else {
                const newSelection = currentSelection.filter((id) => id !== featureId);
                TableContract.setSelection(newSelection, false);
            }
        } else {
            // Sélection simple
            Log.debug("[TableRenderer] Mode SIMPLE - Sélection unique");
            if (selected) {
                TableContract.setSelection([featureId], false);
            } else {
                TableContract.clearSelection();
            }
        }

        // Mettre à jour l'état des boutons
        updateToolbarButtonsState();
    }

    /**
     * Sélectionne une plage de lignes (Shift+clic)
     * @param {string} targetId - ID de la feature cible
     * @private
     */
    function selectRange(targetId) {
        const tbody = document.querySelector(".gl-table-panel__table tbody");
        if (!tbody) return;

        const rows = Array.from(tbody.querySelectorAll("tr"));
        const currentSelection = TableContract.getSelectedIds();
        const lastSelected = currentSelection[currentSelection.length - 1];

        const targetIndex = rows.findIndex((r) => r.getAttribute("data-feature-id") === targetId);
        const lastIndex = rows.findIndex((r) => r.getAttribute("data-feature-id") === lastSelected);

        if (targetIndex === -1 || lastIndex === -1) return;

        const start = Math.min(targetIndex, lastIndex);
        const end = Math.max(targetIndex, lastIndex);

        const rangeIds = [];
        for (let i = start; i <= end; i++) {
            const id = rows[i].getAttribute("data-feature-id");
            if (id) rangeIds.push(id);
        }

        TableContract.setSelection(rangeIds, false);
        updateToolbarButtonsState();
    }

    /**
     * Toggle toutes les lignes (checkbox "tout sélectionner")
     * @param {boolean} checked - État du checkbox
     * @private
     */
    function toggleAllRows(checked) {
        const tbody = document.querySelector(".gl-table-panel__table tbody");
        if (!tbody) return;

        const rows = tbody.querySelectorAll("tr");
        const ids = [];

        rows.forEach((row) => {
            const id = row.getAttribute("data-feature-id");
            if (id) {
                ids.push(id);
                row.classList.toggle("is-selected", checked);
                const checkbox = row.querySelector(".gl-table-panel__checkbox");
                if (checkbox) checkbox.checked = checked;
            }
        });

        if (checked) {
            TableContract.setSelection(ids, false);
        } else {
            TableContract.clearSelection();
        }

        updateToolbarButtonsState();
    }

    /**
     * Met à jour la sélection visuelle dans le tableau
     * @param {HTMLElement} container - Conteneur du tableau
     * @param {Set} selectedIds - IDs sélectionnés
     */
    _TableRenderer.updateSelection = function (container, selectedIds) {
        const tbody = container.querySelector(".gl-table-panel__table tbody");
        if (!tbody) return;

        const rows = tbody.querySelectorAll("tr");

        rows.forEach((row) => {
            const id = row.getAttribute("data-feature-id");
            const isSelected = selectedIds.has(String(id));

            row.classList.toggle("is-selected", isSelected);

            const checkbox = row.querySelector(".gl-table-panel__checkbox");
            if (checkbox) {
                checkbox.checked = isSelected;
            }
        });

        // Mettre à jour le checkbox "tout sélectionner"
        const checkboxAll = container.querySelector(".gl-table-panel__checkbox-all");
        if (checkboxAll) {
            const totalRows = rows.length;
            const selectedCount = selectedIds.size;
            checkboxAll.checked = totalRows > 0 && selectedCount === totalRows;
            checkboxAll.indeterminate = selectedCount > 0 && selectedCount < totalRows;
        }

        updateToolbarButtonsState();
    };

    // Virtual scrolling supprimé — la pagination dans renderTable() est suffisante.
    // TODO(v5): Réimplémenter si les datasets > 10 000 lignes deviennent courants.

    /**
     * Met à jour l'état des boutons de la toolbar
     * @private
     */
    function updateToolbarButtonsState() {
        const selectedCount = TableContract.getSelectedIds().length;
        TableContract.updateToolbarButtons(selectedCount);
    }

    /**
     * Compteur interne pour générer des IDs synthétiques
     * @type {number}
     * @private
     */
    let _syntheticIdCounter = 0;

    /**
     * Récupère l'ID d'une feature de manière fiable
     * Parcourt plusieurs propriétés candidates puis génère un ID synthétique si nécessaire
     * @param {Object} feature - Feature GeoJSON
     * @returns {string}
     * @private
     */
    function getFeatureId(feature) {
        // 1. ID standard GeoJSON
        if (feature.id != null && feature.id !== "") return String(feature.id);

        const p = feature.properties;
        if (!p) return "__gl_row_" + _syntheticIdCounter++;

        // 2. Propriétés d'identifiant courantes
        if (p.id != null && p.id !== "") return String(p.id);
        if (p.fid != null && p.fid !== "") return String(p.fid);
        if (p.osm_id != null && p.osm_id !== "") return String(p.osm_id);
        if (p.OBJECTID != null && p.OBJECTID !== "") return String(p.OBJECTID);
        if (p.SITE_ID != null && p.SITE_ID !== "") return String(p.SITE_ID);
        if (p.code != null && p.code !== "") return String(p.code);
        if (p.IN1 != null && p.IN1 !== "") return String(p.IN1);

        // 3. Fallback : ID synthétique basé sur un compteur
        return "__gl_row_" + _syntheticIdCounter++;
    }

    /**
     * Formate une valeur selon son type
     * @param {*} value - Valeur à formater
     * @param {string} type - Type de données (string, number, date)
     * @returns {string}
     * @private
     */
    function formatValue(value, type) {
        if (value == null || value === "") return "–";

        if (type === "number") {
            const num = Number(value);
            if (isNaN(num)) return String(value);
            // Formater avec séparateurs de milliers
            return num.toLocaleString("fr-FR");
        }

        if (type === "date") {
            const date = new Date(value);
            if (isNaN(date.getTime())) return String(value);
            return date.toLocaleDateString("fr-FR");
        }

        return String(value);
    }

    const TableRenderer = _TableRenderer;

    /** GeoLeaf Table API - implementation deplacee depuis geoleaf.table.js */
    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    const _g$3 =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$3.GeoLeaf = _g$3.GeoLeaf || {};

    /**
     * Module GeoLeaf.Table
     * Vue tabulaire complémentaire à la carte
     */
    const TableModule = {
        /**
         * Référence vers la carte Leaflet
         * @type {L.Map|null}
         */
        _map: null,

        /**
         * Configuration du module table depuis geoleaf.config.json
         * @type {Object|null}
         */
        _config: null,

        /**
         * Couche actuellement affichée dans le tableau
         * @type {string|null}
         */
        _currentLayerId: null,

        /**
         * IDs des entités sélectionnées
         * @type {Set<string>}
         */
        _selectedIds: new Set(),

        /**
         * Données en cache (features filtrées)
         * @type {Array}
         */
        _cachedData: [],

        /**
         * Mapping featureId → index dans _cachedData (synchronisé avec le renderer)
         * @type {Map<string, number>}
         */
        _featureIdMap: new Map(),

        /**
         * Couches Leaflet de surbrillance actuellement actives
         * @type {Array<L.Layer>}
         */
        _highlightLayers: [],

        /**
         * Indique si la surbrillance est activée
         * @type {boolean}
         */
        _highlightActive: false,

        /**
         * État actuel du tri
         * @type {Object}
         */
        _sortState: {
            field: null,
            direction: null, // 'asc' | 'desc' | null
        },

        /**
         * Conteneur DOM du tableau
         * @type {HTMLElement|null}
         */
        _container: null,

        /**
         * Indique si le tableau est visible
         * @type {boolean}
         */
        _isVisible: false,

        /**
         * Initialise le module Table
         * @param {Object} options - Options d'initialisation
         * @param {L.Map} options.map - Instance de la carte Leaflet
         * @param {Object} [options.config] - Configuration personnalisée
         */
        init(options) {
            if (!options || !options.map) {
                Log.error("[Table] init() nécessite une instance de carte Leaflet");
                return;
            }

            this._map = options.map;

            // Récupérer la config depuis GeoLeaf.Config
            const globalConfig = _g$3.GeoLeaf.Config ? _g$3.GeoLeaf.Config.get("tableConfig") : null;
            this._config = Object.assign(
                {
                    enabled: true,
                    defaultVisible: false,
                    pageSize: 50,
                    maxRowsPerLayer: 1000,
                    enableExportButton: true,
                    virtualScrolling: true,
                    defaultHeight: "40%",
                    minHeight: "20%",
                    maxHeight: "60%",
                    resizable: false,
                },
                globalConfig,
                options.config
            );

            if (!this._config.enabled) {
                Log.info("[Table] Module désactivé via configuration");
                return;
            }

            Log.info("[Table] Initialisation du module Table", this._config);

            // Créer le panel si besoin
            if (TablePanel && typeof TablePanel.create === "function") {
                this._container = TablePanel.create(this._map, this._config);
            } else {
                Log.error("[Table] Module table/panel.js non chargé");
                return;
            }

            // Définir la visibilité initiale
            if (this._config.defaultVisible) {
                this.show();
            }

            // Écouter les événements carte
            this._attachMapEvents();

            Log.info("[Table] Module Table initialisé avec succès");
        },

        /**
         * Attache les listeners d'événements Leaflet
         * @private
         */
        _attachMapEvents() {
            if (!this._map) return;

            // Timer pour debounce du rafraîchissement du sélecteur
            let refreshSelectorTimer = null;
            const debouncedRefreshSelector = () => {
                if (refreshSelectorTimer) clearTimeout(refreshSelectorTimer);
                refreshSelectorTimer = setTimeout(() => {
                    if (TablePanel && typeof TablePanel.refreshLayerSelector === "function") {
                        TablePanel.refreshLayerSelector();
                    }
                }, 150);
            };

            // Synchroniser avec les changements de filtres
            this._map.on("geoleaf:filters:changed", () => {
                if (this._isVisible && this._currentLayerId) {
                    this.refresh();
                }
            });

            // Rafraîchir le sélecteur quand les couches GeoJSON sont chargées
            this._map.on("geoleaf:geojson:layers-loaded", () => {
                Log.debug("[Table] Événement layers-loaded reçu, rafraîchissement du sélecteur");
                debouncedRefreshSelector();
            });

            // Rafraîchir le sélecteur quand un thème est appliqué
            // (c'est à ce moment que la visibilité est réellement définie)
            document.addEventListener("geoleaf:theme:applied", () => {
                Log.debug("[Table] Événement theme:applied reçu, rafraîchissement du sélecteur");
                debouncedRefreshSelector();
            });

            // Synchroniser avec les changements de visibilité des couches
            this._map.on("geoleaf:geojson:visibility-changed", (e) => {
                // Rafraîchir le sélecteur (debounced pour grouper les changements multiples)
                debouncedRefreshSelector();

                // Si la couche active est celle qui a changé de visibilité
                if (this._currentLayerId === e.layerId) {
                    if (e.visible) {
                        this.refresh();
                    } else {
                        // La couche active a été masquée : basculer sur la première couche visible
                        // Attendre le debounce pour que le sélecteur soit à jour
                        setTimeout(() => {
                            const available = this._getAvailableVisibleLayers();
                            if (available.length > 0) {
                                this.setLayer(available[0].id);
                                const select = document.querySelector("[data-table-layer-select]");
                                if (select) select.value = available[0].id;
                            } else {
                                this.setLayer("");
                            }
                        }, 200);
                    }
                }
            });
        },

        /**
         * Affiche le tableau
         */
        show() {
            if (!this._container) {
                Log.warn("[Table] Conteneur non initialisé");
                return;
            }

            this._container.classList.add("is-visible");
            this._isVisible = true;

            this._fireEvent("table:opened", {});
            Log.debug("[Table] Tableau affiché");
        },

        /**
         * Masque le tableau
         */
        hide() {
            if (!this._container) return;

            // Nettoyer la surbrillance
            this._clearHighlightLayers();
            this._highlightActive = false;

            this._container.classList.remove("is-visible");
            this._isVisible = false;

            this._fireEvent("table:closed", {});
            Log.debug("[Table] Tableau masqué");
        },

        /**
         * Toggle la visibilité du tableau
         */
        toggle() {
            if (this._isVisible) {
                this.hide();
            } else {
                this.show();
            }
        },

        /**
         * Définit la couche à afficher dans le tableau
         * @param {string} layerId - ID de la couche
         */
        setLayer(layerId) {
            Log.debug("[Table] setLayer appelé avec:", layerId);

            // Si layerId est vide, vider le tableau
            if (!layerId) {
                this._currentLayerId = null;
                this._selectedIds.clear();
                this._clearHighlightLayers();
                this._highlightActive = false;
                this._featureIdMap.clear();
                this._sortState = { field: null, direction: null };
                this._cachedData = [];

                // Vider le tableau visuellement
                if (TableRenderer && this._container) {
                    TableRenderer.render(this._container, {
                        layerId: null,
                        features: [],
                        selectedIds: this._selectedIds,
                        sortState: this._sortState,
                        config: this._config,
                    });
                }

                this._fireEvent("table:layerChanged", { layerId: null });
                Log.debug("[Table] Tableau vidé (aucune couche sélectionnée)");
                return;
            }

            const layers = this._getAvailableLayers();
            const layer = layers.find((l) => l.id === layerId);

            if (!layer) {
                Log.warn("[Table] Couche introuvable ou non activée pour le tableau:", layerId);
                return;
            }

            this._currentLayerId = layerId;
            this._selectedIds.clear();
            this._clearHighlightLayers();
            this._highlightActive = false;
            this._sortState = { field: null, direction: null };

            // Définir le tri par défaut depuis la config du layer
            const layerData = _g$3.GeoLeaf.GeoJSON ? _g$3.GeoLeaf.GeoJSON.getLayerData(layerId) : null;
            if (
                layerData &&
                layerData.config &&
                layerData.config.table &&
                layerData.config.table.defaultSort
            ) {
                this._sortState.field = layerData.config.table.defaultSort.field;
                this._sortState.direction =
                    layerData.config.table.defaultSort.direction ||
                    layerData.config.table.defaultSort.order ||
                    "asc";
            }

            this.refresh();

            this._fireEvent("table:layerChanged", { layerId });
            Log.debug("[Table] Couche changée:", layerId);
        },

        /**
         * Rafraîchit les données affichées dans le tableau
         */
        refresh() {
            if (!this._currentLayerId) {
                Log.debug("[Table] Aucune couche sélectionnée, impossible de rafraîchir");
                return;
            }

            // Récupérer les données depuis GeoJSON
            const features = this._getLayerFeatures(this._currentLayerId);
            this._cachedData = features;

            // Construire le mapping ID→index (miroir de la logique du renderer)
            this._featureIdMap.clear();
            let syntheticCounter = 0;
            features.forEach((feature, index) => {
                const id = this._resolveFeatureId(feature, syntheticCounter);
                if (id.startsWith("__gl_row_")) syntheticCounter++;
                this._featureIdMap.set(id, index);
            });

            Log.debug("[Table] Features récupérées:", features.length);

            // Appliquer le tri si défini
            if (this._sortState.field && this._sortState.direction) {
                this._applySorting();
            }

            // Rafraîchir le rendu
            if (TableRenderer && typeof TableRenderer.render === "function") {
                TableRenderer.render(this._container, {
                    layerId: this._currentLayerId,
                    features: this._cachedData,
                    selectedIds: this._selectedIds,
                    sortState: this._sortState,
                    config: this._config,
                });
            } else {
                Log.error("[Table] Renderer non disponible");
            }

            Log.debug("[Table] Données rafraîchies:", features.length, "entités");
        },

        /**
         * Récupère les features d'une couche avec les filtres appliqués
         * @param {string} layerId - ID de la couche
         * @returns {Array} Features
         * @private
         */
        _getLayerFeatures(layerId) {
            if (!_g$3.GeoLeaf.GeoJSON || typeof _g$3.GeoLeaf.GeoJSON.getLayerData !== "function") {
                Log.warn("[Table] Module GeoJSON non disponible");
                return [];
            }

            const layerData = _g$3.GeoLeaf.GeoJSON.getLayerData(layerId);

            if (!layerData || !layerData.features) {
                Log.warn("[Table] Aucune donnée pour la couche:", layerId);
                return [];
            }

            Log.debug("[Table] _getLayerFeatures - Nombre de features:", layerData.features.length);

            // Appliquer la limite de lignes
            const maxRows = this._config.maxRowsPerLayer || 1000;
            if (layerData.features.length > maxRows) {
                Log.warn(
                    "[Table] Données volumineuses (" +
                        layerData.features.length +
                        " entités). Limité à " +
                        maxRows
                );
                return layerData.features.slice(0, maxRows);
            }

            return layerData.features || [];
        },

        /**
         * Récupère les couches disponibles pour le tableau (table.enabled)
         * @returns {Array} Liste des couches avec table.enabled = true
         * @private
         */
        _getAvailableLayers() {
            if (!_g$3.GeoLeaf.GeoJSON || typeof _g$3.GeoLeaf.GeoJSON.getAllLayers !== "function") {
                return [];
            }

            const allLayers = _g$3.GeoLeaf.GeoJSON.getAllLayers();
            const availableLayers = [];

            allLayers.forEach((layer) => {
                const layerData = _g$3.GeoLeaf.GeoJSON.getLayerData(layer.id);
                if (
                    layerData &&
                    layerData.config &&
                    layerData.config.table &&
                    layerData.config.table.enabled
                ) {
                    availableLayers.push({
                        id: layer.id,
                        label: layer.label || layer.id,
                        config: layerData.config.table,
                    });
                }
            });

            return availableLayers;
        },

        /**
         * Récupère les couches disponibles ET visibles pour le tableau
         * @returns {Array} Liste des couches avec table.enabled = true et visibles sur la carte
         * @private
         */
        _getAvailableVisibleLayers() {
            const available = this._getAvailableLayers();
            const VisibilityManager = _g$3.GeoLeaf._LayerVisibilityManager;

            return available.filter((layer) => {
                if (VisibilityManager && typeof VisibilityManager.getVisibilityState === "function") {
                    const visState = VisibilityManager.getVisibilityState(layer.id);
                    return visState && visState.current === true;
                }
                // Fallback : vérifier via layerData
                const layerData = _g$3.GeoLeaf.GeoJSON.getLayerData(layer.id);
                return layerData && layerData._visibility && layerData._visibility.current === true;
            });
        },

        /**
         * Applique le tri sur les données en cache
         * @private
         */
        _applySorting() {
            sortInPlace(this._cachedData, this._sortState, (o, p) => this._getNestedValue(o, p));
            Log.debug("[Table] Tri appliqué:", this._sortState.field, this._sortState.direction);
        },

        /**
         * Change le tri sur une colonne
         * @param {string} field - Chemin du champ
         */
        sortByField(field) {
            this._sortState = nextSortState(this._sortState, field);
            this.refresh();
            this._fireEvent("table:sortChanged", this._sortState);
        },

        /**
         * Sélectionne ou désélectionne des entités
         * @param {Array<string>} ids - IDs à sélectionner
         * @param {boolean} [add=false] - Ajouter à la sélection existante ou remplacer
         */
        setSelection(ids, add = false) {
            if (!add) {
                this._selectedIds.clear();
            }

            ids.forEach((id) => this._selectedIds.add(String(id)));

            this._fireEvent("table:selectionChanged", {
                layerId: this._currentLayerId,
                selectedIds: Array.from(this._selectedIds),
            });

            // Rafraîchir le rendu pour mettre à jour les cases cochées
            if (TableRenderer && typeof TableRenderer.updateSelection === "function") {
                TableRenderer.updateSelection(this._container, this._selectedIds);
            }

            Log.debug("[Table] Sélection mise à jour:", this._selectedIds.size, "entités");
        },

        /**
         * Retourne les IDs des entités sélectionnées
         * @returns {Array<string>}
         */
        getSelectedIds() {
            return Array.from(this._selectedIds);
        },

        /**
         * Efface la sélection
         */
        clearSelection() {
            this._selectedIds.clear();
            this._fireEvent("table:selectionChanged", {
                layerId: this._currentLayerId,
                selectedIds: [],
            });

            if (TableRenderer && typeof TableRenderer.updateSelection === "function") {
                TableRenderer.updateSelection(this._container, this._selectedIds);
            }

            Log.debug("[Table] Sélection effacée");
        },

        /**
         * Zoom sur les entités sélectionnées
         */
        zoomToSelection() {
            if (this._selectedIds.size === 0) {
                Log.warn("[Table] Aucune entité sélectionnée pour le zoom");
                return;
            }

            const selectedFeatures = this._getSelectedFeatures();
            if (selectedFeatures.length === 0) {
                Log.warn("[Table] Aucune feature trouvée pour les IDs sélectionnés");
                return;
            }

            const bounds = L.latLngBounds([]);

            selectedFeatures.forEach((feature) => {
                if (feature.geometry && feature.geometry.coordinates) {
                    this._extendBoundsFromGeometry(bounds, feature.geometry);
                }
            });

            if (bounds.isValid()) {
                this._map.fitBounds(bounds, { padding: [50, 50], maxZoom: 16 });
                this._fireEvent("table:zoomToSelection", {
                    layerId: this._currentLayerId,
                    selectedIds: Array.from(this._selectedIds),
                });
                Log.debug("[Table] Zoom sur la sélection (", selectedFeatures.length, "entités)");
            } else {
                Log.warn("[Table] Bounds invalides pour la sélection");
            }
        },

        /**
         * Active/désactive la surbrillance des entités sélectionnées sur la carte
         * @param {boolean} active - Activer ou non
         */
        highlightSelection(active) {
            // Toujours nettoyer les anciennes surbrillances
            this._clearHighlightLayers();

            this._highlightActive = active;

            if (!active) {
                Log.debug("[Table] Surbrillance désactivée");
                this._fireEvent("table:highlightSelection", {
                    layerId: this._currentLayerId,
                    selectedIds: Array.from(this._selectedIds),
                    active: false,
                });
                return;
            }

            if (this._selectedIds.size === 0) {
                Log.warn("[Table] Aucune entité sélectionnée pour la surbrillance");
                return;
            }

            const selectedFeatures = this._getSelectedFeatures();
            if (selectedFeatures.length === 0) {
                Log.warn("[Table] Aucune feature trouvée pour la surbrillance");
                return;
            }

            // Style de surbrillance (contour jaune épais)
            const highlightStyle = {
                color: "#FFD600",
                weight: 4,
                opacity: 1,
                fillOpacity: 0.15,
                fillColor: "#FFD600",
                dashArray: "",
                interactive: false,
            };

            selectedFeatures.forEach((feature) => {
                try {
                    if (feature.geometry) {
                        const geomType = feature.geometry.type;
                        if (geomType === "Point") {
                            // Pour les points, créer un cercle de surbrillance
                            const coords = feature.geometry.coordinates;
                            const circle = L.circleMarker([coords[1], coords[0]], {
                                radius: 14,
                                color: "#FFD600",
                                weight: 4,
                                opacity: 1,
                                fillOpacity: 0.25,
                                fillColor: "#FFD600",
                                interactive: false,
                            });
                            circle.addTo(this._map);
                            this._highlightLayers.push(circle);
                        } else {
                            // Pour les polygones/polylines, superposer le contour
                            const highlightLayer = L.geoJSON(feature, {
                                style: function () {
                                    return highlightStyle;
                                },
                                interactive: false,
                                pointToLayer: function (f, latlng) {
                                    return L.circleMarker(latlng, highlightStyle);
                                },
                            });
                            highlightLayer.addTo(this._map);
                            this._highlightLayers.push(highlightLayer);
                        }
                    }
                } catch (e) {
                    Log.warn("[Table] Erreur surbrillance feature:", e);
                }
            });

            this._fireEvent("table:highlightSelection", {
                layerId: this._currentLayerId,
                selectedIds: Array.from(this._selectedIds),
                active: true,
            });

            Log.debug("[Table] Surbrillance activée pour", selectedFeatures.length, "entités");
        },

        /**
         * Supprime toutes les couches de surbrillance de la carte
         * @private
         */
        _clearHighlightLayers() {
            this._highlightLayers.forEach((layer) => {
                try {
                    if (this._map && this._map.hasLayer(layer)) {
                        this._map.removeLayer(layer);
                    }
                } catch (e) {
                    // Silencieux
                }
            });
            this._highlightLayers = [];
        },

        /**
         * Exporte les entités sélectionnées au format GeoJSON (téléchargement)
         */
        exportSelection() {
            if (this._selectedIds.size === 0) {
                Log.warn("[Table] Aucune entité sélectionnée pour l'export");
                return;
            }

            const selectedFeatures = this._getSelectedFeatures();

            if (selectedFeatures.length === 0) {
                Log.warn("[Table] Aucune feature trouvée pour l'export");
                return;
            }

            try {
                downloadGeoJSON(buildGeoJSONCollection(selectedFeatures), this._currentLayerId);
                Log.info("[Table] Export GeoJSON:", selectedFeatures.length, "entités exportées");
            } catch (e) {
                Log.error("[Table] Erreur lors de l'export:", e);
            }

            this._fireEvent("table:exportSelection", {
                layerId: this._currentLayerId,
                selectedIds: Array.from(this._selectedIds),
                rows: selectedFeatures,
            });
        },

        /**
         * Récupère les features sélectionnées à partir du cache via le mapping d'IDs
         * @returns {Array} Features GeoJSON correspondant à la sélection
         * @private
         */
        _getSelectedFeatures() {
            const result = [];
            this._selectedIds.forEach((id) => {
                const index = this._featureIdMap.get(id);
                if (index != null && this._cachedData[index]) {
                    result.push(this._cachedData[index]);
                }
            });
            return result;
        },

        /**
         * Résout l'ID d'une feature en miroir de la logique du renderer
         * @param {Object} feature - Feature GeoJSON
         * @param {number} syntheticIndex - Index pour les IDs synthétiques
         * @returns {string}
         * @private
         */
        _resolveFeatureId(feature, syntheticIndex) {
            return resolveFeatureId(feature, syntheticIndex);
        },

        /**
         * Étend les bounds à partir d'une géométrie GeoJSON
         * @param {L.LatLngBounds} bounds - Bounds à étendre
         * @param {Object} geometry - Géométrie GeoJSON
         * @private
         */
        _extendBoundsFromGeometry(bounds, geometry) {
            const coords = geometry.coordinates;
            const type = geometry.type;

            if (type === "Point") {
                bounds.extend([coords[1], coords[0]]);
            } else if (type === "LineString") {
                coords.forEach((c) => bounds.extend([c[1], c[0]]));
            } else if (type === "MultiLineString") {
                coords.forEach((line) => line.forEach((c) => bounds.extend([c[1], c[0]])));
            } else if (type === "Polygon") {
                coords[0].forEach((c) => bounds.extend([c[1], c[0]]));
            } else if (type === "MultiPolygon") {
                coords.forEach((poly) => {
                    poly[0].forEach((c) => bounds.extend([c[1], c[0]]));
                });
            } else if (type === "MultiPoint") {
                coords.forEach((c) => bounds.extend([c[1], c[0]]));
            }
        },

        /**
         * Récupère une valeur imbriquée dans un objet (Phase 4 dedup: delegates to Utils)
         * @private
         */
        _getNestedValue(obj, path) {
            return getNestedValue$1(obj, path);
        },

        /**
         * Émet un événement personnalisé
         * @param {string} eventName - Nom de l'événement
         * @param {Object} detail - Données de l'événement
         * @private
         */
        _fireEvent(eventName, detail) {
            if (this._map && typeof this._map.fire === "function") {
                this._map.fire("geoleaf:" + eventName, detail);
            }

            if (typeof document !== "undefined" && document.dispatchEvent) {
                document.dispatchEvent(new CustomEvent("geoleaf:" + eventName, { detail }));
            }
        },
    };

    const Table = TableModule;

    // Register into the ESM contract so table/panel.js and table/renderer.js can call back without globalThis
    TableContract.register(Table, TablePanel);

    /** GeoLeaf UI API - implementation deplacee depuis geoleaf.ui.js */
    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */

    const _g$2 =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};
    _g$2.GeoLeaf = _g$2.GeoLeaf || {};

    // ========================================
    //   NAMESPACE & DEPENDENCIES
    // ========================================

    _g$2.GeoLeaf.UI = _g$2.GeoLeaf.UI || {};

    // Helper pour createElement unifié
    const $create = (tag, props, ...children) => {
        if (_g$2.GeoLeaf.Utils && _g$2.GeoLeaf.Utils.createElement) {
            return _g$2.GeoLeaf.Utils.createElement(tag, props, ...children);
        }
        // Fallback to native if DomHelpers not loaded yet
        const el = document.createElement(tag);
        if (props) {
            if (props.className) el.className = props.className;
            if (props.textContent) el.textContent = props.textContent;
        }
        return el;
    };

    // ========================================
    //   MODULE AVAILABILITY CHECKS
    // ========================================

    /**
     * Vérifie la disponibilité des modules requis
     * @returns {Object} Status de disponibilité des modules
     */
    function checkModuleAvailability() {
        const modules = {
            theme: !!_g$2.GeoLeaf._UITheme,
            controls: !!_g$2.GeoLeaf._UIControls,
            panelBuilder: !!(_g$2.GeoLeaf._UIPanelBuilder || _g$2.GeoLeaf.UI.PanelBuilder),
            filterPanel: !!_g$2.GeoLeaf._UIFilterPanel,
            notifications: !!_g$2.GeoLeaf._UINotifications,
            eventDelegation: !!_g$2.GeoLeaf._UIEventDelegation,
            filterStateManager: !!_g$2.GeoLeaf._UIFilterStateManager,
        };

        const missing = Object.entries(modules)
            .filter(([_name, available]) => !available)
            .map(([name]) => name);

        if (missing.length > 0 && Log) {
            Log.warn("[UI.Orchestrator] Modules manquants:", missing.join(", "));
        }

        return { modules, missing, allAvailable: missing.length === 0 };
    }

    // ========================================
    //   API DELEGATION - THEME MANAGEMENT
    // ========================================

    if (_g$2.GeoLeaf._UITheme) {
        // Délégation directe des fonctions thème
        _g$2.GeoLeaf.UI.initThemeToggle = _g$2.GeoLeaf._UITheme.initThemeToggle;
        _g$2.GeoLeaf.UI.toggleTheme = _g$2.GeoLeaf._UITheme.toggleTheme;
        _g$2.GeoLeaf.UI.applyTheme = _g$2.GeoLeaf._UITheme.applyTheme;
        _g$2.GeoLeaf.UI.getCurrentTheme = _g$2.GeoLeaf._UITheme.getCurrentTheme;

        // Compatibility aliases
        _g$2.GeoLeaf.UI.setTheme = _g$2.GeoLeaf._UITheme.applyTheme;
    }

    // ========================================
    //   API DELEGATION - CONTROLS
    // ========================================

    if (_g$2.GeoLeaf._UIControls) {
        // Délégation des contrôles Leaflet
        _g$2.GeoLeaf.UI.initFullscreenControl = _g$2.GeoLeaf._UIControls.initFullscreenControl;
        _g$2.GeoLeaf.UI.initGeolocationControl = _g$2.GeoLeaf._UIControls.initGeolocationControl;
        _g$2.GeoLeaf.UI.initPoiAddControl = _g$2.GeoLeaf._UIControls.initPoiAddControl;
        _g$2.GeoLeaf.UI.initScaleControl = _g$2.GeoLeaf._UIControls.initScaleControl;

        // État géolocalisation — proxy live vers GeoLocationState (CDN backward compat)
        Object.defineProperty(_g$2.GeoLeaf.UI, "_geolocationActive", {
            get() {
                return GeoLocationState.active;
            },
            set(v) {
                GeoLocationState.active = v;
            },
            configurable: true,
            enumerable: true,
        });
        Object.defineProperty(_g$2.GeoLeaf.UI, "_geolocationWatchId", {
            get() {
                return GeoLocationState.watchId;
            },
            set(v) {
                GeoLocationState.watchId = v;
            },
            configurable: true,
            enumerable: true,
        });
        Object.defineProperty(_g$2.GeoLeaf.UI, "_userPosition", {
            get() {
                return GeoLocationState.userPosition;
            },
            set(v) {
                GeoLocationState.userPosition = v;
            },
            configurable: true,
            enumerable: true,
        });
        Object.defineProperty(_g$2.GeoLeaf.UI, "_userPositionAccuracy", {
            get() {
                return GeoLocationState.userPositionAccuracy;
            },
            set(v) {
                GeoLocationState.userPositionAccuracy = v;
            },
            configurable: true,
            enumerable: true,
        });
    }

    // ========================================
    //   API DELEGATION - PANEL BUILDER
    // ========================================

    if (_g$2.GeoLeaf._UIPanelBuilder || _g$2.GeoLeaf.UI.PanelBuilder) {
        // Délégation vers panel builder
        _g$2.GeoLeaf.UI.buildSidePanel =
            (_g$2.GeoLeaf._UIPanelBuilder && _g$2.GeoLeaf._UIPanelBuilder.buildSidePanel) ||
            (_g$2.GeoLeaf.UI.PanelBuilder && _g$2.GeoLeaf.UI.PanelBuilder.buildSidePanel);
        _g$2.GeoLeaf.UI.renderPoiSidePanel =
            (_g$2.GeoLeaf._UIPanelBuilder && _g$2.GeoLeaf._UIPanelBuilder.renderPoiSidePanel) ||
            (_g$2.GeoLeaf.UI.PanelBuilder && _g$2.GeoLeaf.UI.PanelBuilder.renderPoiSidePanel);

        // Legacy compatibility pour POI panels
        _g$2.GeoLeaf.UI.renderPoiPanelWithLayout = function (poi, layout, container) {
            if (_g$2.GeoLeaf.UI.renderPoiSidePanel) {
                return _g$2.GeoLeaf.UI.renderPoiSidePanel(poi, layout, container);
            }
            if (Log)
                Log.warn("[UI.Orchestrator] renderPoiPanelWithLayout: PanelBuilder non disponible");
        };

        // Helper functions (deprecated, pour compatibilité)
        _g$2.GeoLeaf.UI._resolveField = function (poi, fieldPath) {
            if (_g$2.GeoLeaf._UIDomUtils && _g$2.GeoLeaf._UIDomUtils.resolveField) {
                return _g$2.GeoLeaf._UIDomUtils.resolveField(poi, fieldPath);
            }
            return null;
        };

        _g$2.GeoLeaf.UI._createPlainSection = function (label, innerContent, extraClass) {
            if (_g$2.GeoLeaf.UI.PanelBuilder && _g$2.GeoLeaf.UI.PanelBuilder.createPlainSection) {
                return _g$2.GeoLeaf.UI.PanelBuilder.createPlainSection(label, innerContent, extraClass);
            }
            return $create("section", { className: "gl-poi-panel__section " + (extraClass || "") });
        };

        _g$2.GeoLeaf.UI._createAccordionSection = function (label, innerContent, options) {
            if (_g$2.GeoLeaf.UI.PanelBuilder && _g$2.GeoLeaf.UI.PanelBuilder.createAccordionSection) {
                return _g$2.GeoLeaf.UI.PanelBuilder.createAccordionSection(label, innerContent, options);
            }
            return $create("section", { className: "gl-poi-panel__section--accordion" });
        };
    }

    // ========================================
    //   API DELEGATION - FILTER PANEL
    // ========================================

    if (_g$2.GeoLeaf._UIFilterPanel) {
        // Délégation des fonctions filtres
        _g$2.GeoLeaf.UI.buildFilterPanelFromActiveProfile =
            _g$2.GeoLeaf._UIFilterPanel.buildFilterPanelFromActiveProfile;
        _g$2.GeoLeaf.UI.refreshFilterTags = _g$2.GeoLeaf._UIFilterPanel.refreshFilterTags;
        _g$2.GeoLeaf.UI.initFilterToggle = _g$2.GeoLeaf._UIFilterPanel.initFilterToggle;
        _g$2.GeoLeaf.UI.initProximityFilter = _g$2.GeoLeaf._UIFilterPanel.initProximityFilter;
        _g$2.GeoLeaf.UI._getBasePois = _g$2.GeoLeaf._UIFilterPanel.getBasePois;
        _g$2.GeoLeaf.UI._getBaseRoutes = _g$2.GeoLeaf._UIFilterPanel.getBaseRoutes;

        // Filter state integration si disponible
        if (_g$2.GeoLeaf._UIFilterStateManager) {
            // Bridge entre filter panel et state manager
            _g$2.GeoLeaf.UI.resetAllFilters = function () {
                _g$2.GeoLeaf._UIFilterStateManager.resetAllFilters();
                if (_g$2.GeoLeaf._UIFilterPanel.refreshFilterTags) {
                    _g$2.GeoLeaf._UIFilterPanel.refreshFilterTags();
                }
            };

            _g$2.GeoLeaf.UI.getActiveFilters = _g$2.GeoLeaf._UIFilterStateManager.getActiveFiltersSummary;
            _g$2.GeoLeaf.UI.hasActiveFilters = _g$2.GeoLeaf._UIFilterStateManager.hasActiveFilters;
        }
    }

    // ========================================
    //   API DELEGATION - NOTIFICATIONS
    // ========================================

    if (_g$2.GeoLeaf._UINotifications) {
        // Créer un namespace dédié pour l'accès complet
        _g$2.GeoLeaf.UI.Notifications = {
            show: _g$2.GeoLeaf._UINotifications.show.bind(_g$2.GeoLeaf._UINotifications),
            success: _g$2.GeoLeaf._UINotifications.success.bind(_g$2.GeoLeaf._UINotifications),
            error: _g$2.GeoLeaf._UINotifications.error.bind(_g$2.GeoLeaf._UINotifications),
            warning: _g$2.GeoLeaf._UINotifications.warning.bind(_g$2.GeoLeaf._UINotifications),
            info: _g$2.GeoLeaf._UINotifications.info.bind(_g$2.GeoLeaf._UINotifications),
            clearAll: _g$2.GeoLeaf._UINotifications.clearAll.bind(_g$2.GeoLeaf._UINotifications),
            enable: _g$2.GeoLeaf._UINotifications.enable.bind(_g$2.GeoLeaf._UINotifications),
            disable: _g$2.GeoLeaf._UINotifications.disable.bind(_g$2.GeoLeaf._UINotifications),
            getStatus: _g$2.GeoLeaf._UINotifications.getStatus.bind(_g$2.GeoLeaf._UINotifications),
        };

        // Raccourcis globaux pour l'API publique (rétrocompatibilité)
        _g$2.GeoLeaf.UI.showNotification = _g$2.GeoLeaf._UINotifications.show.bind(
            _g$2.GeoLeaf._UINotifications
        );
        _g$2.GeoLeaf.UI.showSuccess = _g$2.GeoLeaf._UINotifications.success.bind(
            _g$2.GeoLeaf._UINotifications
        );
        _g$2.GeoLeaf.UI.showError = _g$2.GeoLeaf._UINotifications.error.bind(_g$2.GeoLeaf._UINotifications);
        _g$2.GeoLeaf.UI.showWarning = _g$2.GeoLeaf._UINotifications.warning.bind(
            _g$2.GeoLeaf._UINotifications
        );
        _g$2.GeoLeaf.UI.showInfo = _g$2.GeoLeaf._UINotifications.info.bind(_g$2.GeoLeaf._UINotifications);
        _g$2.GeoLeaf.UI.clearNotifications = _g$2.GeoLeaf._UINotifications.clearAll.bind(
            _g$2.GeoLeaf._UINotifications
        );
    }

    // ========================================
    //   EVENT DELEGATION INTEGRATION
    // ========================================

    let _delegationInitialized = false;

    /**
     * Initialise la délégation d'événements pour l'interface
     * @param {Object} options - Options d'initialisation
     */
    function initializeEventDelegation(options = {}) {
        if (_delegationInitialized || !_g$2.GeoLeaf._UIEventDelegation) return;

        const { filterContainer } = options;

        // Event listeners pour les filtres si disponible
        if (filterContainer && _g$2.GeoLeaf._UIFilterStateManager) {
            _g$2.GeoLeaf._UIEventDelegation.attachFilterInputEvents(filterContainer, () => {
                // Callback de changement de filtre - déléguer vers FilterPanel
                if (_g$2.GeoLeaf._UIFilterPanel && _g$2.GeoLeaf._UIFilterPanel.refreshFilterTags) {
                    _g$2.GeoLeaf._UIFilterPanel.refreshFilterTags();
                }
            });
        }

        // Event listeners pour les accordéons
        document.addEventListener("DOMContentLoaded", () => {
            const accordionContainers = document.querySelectorAll(".gl-poi-panel, .gl-filter-panel");
            accordionContainers.forEach((container) => {
                _g$2.GeoLeaf._UIEventDelegation.attachAccordionEvents(container);
            });
        });

        _delegationInitialized = true;
        if (Log) Log.info("[UI.Orchestrator] Event delegation initialisée");
    }

    // ========================================
    //   MAIN INITIALIZATION
    // ========================================

    /**
     * Point d'entrée principal pour l'initialisation UI
     * @param {Object} options - Options d'initialisation
     * @param {HTMLElement} options.map - Instance carte Leaflet
     * @param {HTMLElement} options.mapContainer - Conteneur DOM de la carte
     * @param {HTMLElement} options.filterContainer - Conteneur des filtres
     * @param {string} options.buttonSelector - Sélecteur du bouton thème
     * @param {boolean} options.autoInitOnDomReady - Auto-init au DOMContentLoaded
     * @param {boolean} options.enableEventDelegation - Active la délégation d'événements (défaut: true)
     */
    _g$2.GeoLeaf.UI.init = function (options = {}) {
        const config = {
            buttonSelector: options.buttonSelector || '[data-gl-role="theme-toggle"]',
            autoInitOnDomReady: !!options.autoInitOnDomReady,
            enableEventDelegation: options.enableEventDelegation !== false,
        };

        // Vérification des modules
        const { missing, allAvailable } = checkModuleAvailability();
        if (!allAvailable && Log) {
            Log.warn("[UI.Orchestrator] Initialisation avec modules manquants:", missing);
        }

        // Initialisation du thème
        if (_g$2.GeoLeaf.UI.initThemeToggle) {
            try {
                _g$2.GeoLeaf.UI.initThemeToggle(config);
            } catch (error) {
                if (Log) Log.error("[UI.Orchestrator] Erreur init thème:", error);
            }
        }

        // Initialisation des contrôles si carte disponible
        if (options.map && options.mapContainer) {
            // Fullscreen control
            if (_g$2.GeoLeaf.UI.initFullscreenControl) {
                try {
                    _g$2.GeoLeaf.UI.initFullscreenControl(options.map, options.mapContainer);
                } catch (error) {
                    if (Log) Log.error("[UI.Orchestrator] Erreur fullscreen control:", error);
                }
            }

            // Geolocation control - forcer l'initialisation
            if (_g$2.GeoLeaf.UI.initGeolocationControl) {
                try {
                    _g$2.GeoLeaf.UI.initGeolocationControl(options.map, options.config);
                } catch (error) {
                    if (Log) Log.error("[UI.Orchestrator] Erreur geolocation control:", error);
                }
            }

            // POI Add control - forcer l'initialisation
            if (_g$2.GeoLeaf.UI.initPoiAddControl) {
                try {
                    _g$2.GeoLeaf.UI.initPoiAddControl(options.map, options.config);
                } catch (error) {
                    if (Log) Log.error("[UI.Orchestrator] Erreur POI add control:", error);
                }
            }

            // Scale control
            if (_g$2.GeoLeaf.UI.initScaleControl) {
                try {
                    _g$2.GeoLeaf.UI.initScaleControl(options.map);
                } catch (error) {
                    if (Log) Log.error("[UI.Orchestrator] Erreur scale control:", error);
                }
            }
        }

        // Initialisation de la délégation d'événements
        if (config.enableEventDelegation) {
            initializeEventDelegation({
                filterContainer: options.filterContainer,
            });
        }

        // Initialisation du filter state manager si profil disponible
        if (_g$2.GeoLeaf._UIFilterStateManager && _g$2.GeoLeaf.Config) {
            const activeProfile = _g$2.GeoLeaf.Config.getActiveProfile?.() || null;
            if (activeProfile && activeProfile.filters) {
                try {
                    _g$2.GeoLeaf._UIFilterStateManager.initializeFromProfile(activeProfile);
                } catch (error) {
                    if (Log) Log.error("[UI.Orchestrator] Erreur init filter state:", error);
                }
            }
        }

        if (Log) {
            Log.info(
                `[UI.Orchestrator] Initialisation terminée (modules: ${Object.keys(checkModuleAvailability().modules).length})`
            );
        }
    };

    // ========================================
    //   UTILITY & DEBUG FUNCTIONS
    // ========================================

    /**
     * Informations de debug sur l'état des modules
     * @returns {Object} Status détaillé des modules
     */
    _g$2.GeoLeaf.UI.getModuleStatus = function () {
        return checkModuleAvailability();
    };

    /**
     * Nettoyage général des resources UI
     */
    _g$2.GeoLeaf.UI.cleanup = function () {
        // Nettoyage des event listeners
        if (_g$2.GeoLeaf._UIEventDelegation && _g$2.GeoLeaf._UIEventDelegation.cleanupAllListeners) {
            const cleaned = _g$2.GeoLeaf._UIEventDelegation.cleanupAllListeners();
            if (Log && cleaned > 0) {
                Log.info(`[UI.Orchestrator] ${cleaned} event listeners nettoyés`);
            }
        }

        // Reset flag délégation
        _delegationInitialized = false;

        if (Log) Log.info("[UI.Orchestrator] Nettoyage terminé");
    };

    // ========================================
    //   LEGACY COMPATIBILITY LAYER
    // ========================================

    // Fonctions legacy maintenues pour compatibilité
    _g$2.GeoLeaf.UI._attachAccordionBehavior = function (container) {
        if (_g$2.GeoLeaf._UIEventDelegation && _g$2.GeoLeaf._UIEventDelegation.attachAccordionEvents) {
            return _g$2.GeoLeaf._UIEventDelegation.attachAccordionEvents(container);
        }
        if (Log)
            Log.warn("[UI.Orchestrator] _attachAccordionBehavior: EventDelegation module manquant");
    };

    _g$2.GeoLeaf.UI._getActiveProfileConfig = function () {
        if (_g$2.GeoLeaf._UIDomUtils && _g$2.GeoLeaf._UIDomUtils.getActiveProfileConfig) {
            return _g$2.GeoLeaf._UIDomUtils.getActiveProfileConfig();
        }
        return _g$2.GeoLeaf.Config?.getActiveProfile?.() || null;
    };

    // Version info
    _g$2.GeoLeaf.UI.VERSION = "4.4.0";
    _g$2.GeoLeaf.UI.BUILD = "Sprint-4.4-Modular";

    if (Log) {
        Log.info(`[UI.Orchestrator] Module initialisé v${GeoLeaf.UI.VERSION}`);
    }

    const UI = _g$2.GeoLeaf.UI;

    /**
     * GeoLeaf — General Validators
     * Validation fonctions génériques (coordonnées, URL, email, etc.)
     *
     * @module validators/general-validators
     */

    /**
     * Validate geographic coordinates
     * Delegates range validation to Security.validateCoordinates (canonical).
     * Returns a {valid, error} report object rather than throwing.
     */
    function validateCoordinates(lat, lng, options = {}) {
        const { throwOnError = false } = options;
        try {
            validateCoordinates$2(lat, lng);
            return { valid: true, error: null };
        } catch (err) {
            const error = new Errors.ValidationError(err.message, { lat, lng });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }
    }

    /**
     * Validate URL
     */
    function validateUrl(url, options = {}) {
        const {
            allowedProtocols = ["http:", "https:", "data:"],
            allowDataImages = true,
            throwOnError = false,
        } = options;

        if (!url || typeof url !== "string") {
            const error = new Errors.ValidationError("URL must be a non-empty string", {
                url,
                type: typeof url,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message, url: null };
        }

        try {
            const parsed = new URL(url, "http://dummy.com");
            const protocol = parsed.protocol;

            if (!allowedProtocols.includes(protocol)) {
                if (protocol === "data:") {
                    if (!allowDataImages) {
                        throw new Errors.SecurityError("Data URLs are not allowed", { url, protocol });
                    }
                    const dataType = url.substring(5, url.indexOf(",") || url.indexOf(";"));
                    if (!dataType.startsWith("image/")) {
                        throw new Errors.SecurityError("Only data:image URLs are allowed", {
                            url,
                            dataType,
                        });
                    }
                } else {
                    throw new Errors.SecurityError(`Protocol "${protocol}" not allowed`, {
                        url,
                        protocol,
                        allowed: allowedProtocols,
                    });
                }
            }

            return { valid: true, error: null, url: parsed.href };
        } catch (err) {
            if (throwOnError) throw err;
            return { valid: false, error: err.message, url: null };
        }
    }

    /**
     * Validate email address
     */
    function validateEmail(email, options = {}) {
        const { throwOnError = false } = options;

        if (!email || typeof email !== "string") {
            const error = new Errors.ValidationError("Email must be a non-empty string", {
                email,
                type: typeof email,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            const error = new Errors.ValidationError("Invalid email format", { email });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        return { valid: true, error: null };
    }

    /**
     * Validate phone number
     */
    function validatePhone(phone, options = {}) {
        const { throwOnError = false } = options;

        if (!phone || typeof phone !== "string") {
            const error = new Errors.ValidationError("Phone must be a non-empty string", {
                phone,
                type: typeof phone,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        const phoneRegex = /^[\d\s+\-()]+$/;
        if (!phoneRegex.test(phone)) {
            const error = new Errors.ValidationError("Invalid phone format", { phone });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        const digits = phone.replace(/\D/g, "");
        if (digits.length < 10) {
            const error = new Errors.ValidationError("Phone number must contain at least 10 digits", {
                phone,
                digitCount: digits.length,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        return { valid: true, error: null };
    }

    /**
     * Validate zoom level
     */
    function validateZoom(zoom, options = {}) {
        const { min = 0, max = 20, throwOnError = false } = options;

        if (typeof zoom !== "number") {
            const error = new Errors.ValidationError("Zoom must be a number", {
                zoom,
                type: typeof zoom,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        if (!Number.isFinite(zoom)) {
            const error = new Errors.ValidationError("Zoom must be a finite number", { zoom });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        if (zoom < min || zoom > max) {
            const error = new Errors.ValidationError(`Zoom must be between ${min} and ${max}`, {
                zoom,
                min,
                max,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        return { valid: true, error: null };
    }

    /**
     * Validate required configuration fields
     */
    function validateRequiredFields(config, requiredFields, options = {}) {
        const { throwOnError = false } = options;

        if (!config || typeof config !== "object") {
            const error = new Errors.ConfigError("Config must be an object", {
                config,
                type: typeof config,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message, missing: requiredFields };
        }

        const missing = requiredFields.filter(
            (field) => !(field in config) || config[field] === null || config[field] === undefined
        );

        if (missing.length > 0) {
            const error = new Errors.ConfigError(`Missing required fields: ${missing.join(", ")}`, {
                config,
                missing,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message, missing };
        }

        return { valid: true, error: null, missing: [] };
    }

    /**
     * Validate GeoJSON object
     */
    function validateGeoJSON(geojson, options = {}) {
        const { throwOnError = false } = options;

        if (!geojson || typeof geojson !== "object") {
            const error = new Errors.ValidationError("GeoJSON must be an object", {
                geojson,
                type: typeof geojson,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        if (!geojson.type) {
            const error = new Errors.ValidationError("GeoJSON must have a type field", { geojson });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        const validTypes = [
            "Point",
            "MultiPoint",
            "LineString",
            "MultiLineString",
            "Polygon",
            "MultiPolygon",
            "GeometryCollection",
            "Feature",
            "FeatureCollection",
        ];

        if (!validTypes.includes(geojson.type)) {
            const error = new Errors.ValidationError("Invalid GeoJSON type", {
                type: geojson.type,
                validTypes,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        if (geojson.type === "Feature" && !geojson.geometry) {
            const error = new Errors.ValidationError("Feature must have a geometry", { geojson });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        if (geojson.type === "FeatureCollection" && !Array.isArray(geojson.features)) {
            const error = new Errors.ValidationError("FeatureCollection must have a features array", {
                geojson,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        return { valid: true, error: null };
    }

    /**
     * Validate color string (hex, rgb, rgba, named)
     */
    function validateColor(color, options = {}) {
        const { throwOnError = false } = options;

        if (!color || typeof color !== "string") {
            const error = new Errors.ValidationError("Color must be a non-empty string", {
                color,
                type: typeof color,
            });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        // eslint-disable-next-line security/detect-unsafe-regex
        const hexRegex = /^#[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$/;
        const rgbRegex = /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/;
        const rgbaRegex = /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[\d.]+\s*\)$/;

        const isValid =
            hexRegex.test(color) ||
            rgbRegex.test(color) ||
            rgbaRegex.test(color) ||
            (typeof CSS !== "undefined" && CSS.supports("color", color));

        if (!isValid) {
            const error = new Errors.ValidationError("Invalid color format", { color });
            if (throwOnError) throw error;
            return { valid: false, error: error.message };
        }

        return { valid: true, error: null };
    }

    /**
     * Batch validate multiple values with their validators
     */
    function validateBatch(validations) {
        const errors = [];

        for (const item of validations) {
            const { value, validator, options = {}, label = "value" } = item;

            if (typeof validator !== "function") {
                errors.push(`Invalid validator for ${label}`);
                continue;
            }

            const result = validator(value, { ...options, throwOnError: false });
            if (!result.valid) {
                errors.push(`${label}: ${result.error}`);
            }
        }

        return { valid: errors.length === 0, errors };
    }

    // Assembled namespace
    const Validators = {
        validateCoordinates,
        validateUrl,
        validateEmail,
        validatePhone,
        validateZoom,
        validateRequiredFields,
        validateGeoJSON,
        validateColor,
        validateBatch,
    };

    /*!
     * GeoLeaf Core – API / Boot Info
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     */

    /**
     * Affiche un toast de démarrage listant la version GeoLeaf
     * et les plugins optionnels chargés.
     *
     * Appelé automatiquement à la fin de GeoLeaf.boot() si non désactivé.
     *
     * @module api/boot-info
     */

    /**
     * Détecte les plugins chargés en interrogeant window.GeoLeaf.
     * @param {object} GeoLeaf - Le namespace global GeoLeaf
     * @returns {string[]} Liste des noms de plugins actifs
     */
    function _detectLoadedPlugins(GeoLeaf) {
        // Source principale : PluginRegistry (fiable, auto-enregistrement par chaque plugin).
        // Si le registry est disponible, on s'y fie intégralement — même liste vide (Core seul).
        // Ne PAS tomber en fallback duck-typing : les facades Core (Storage, Labels, LayerManager)
        // existent même sans plugin premium, ce qui fausse la détection.
        if (GeoLeaf.plugins?.getLoadedPlugins) {
            return GeoLeaf.plugins.getLoadedPlugins().filter((n) => !['core'].includes(n));
        }

        // Fallback duck-typing si registry non disponible (compat ascendante)
        const plugins = [];
        if (GeoLeaf.Storage && typeof GeoLeaf.Storage === "object") {
            const hasDB = GeoLeaf.Storage.DB && typeof GeoLeaf.Storage.DB === "object";
            plugins.push(hasDB ? "storage (offline + IndexedDB)" : "storage (cache)");
        }
        if (GeoLeaf.POI?.AddForm && typeof GeoLeaf.POI.AddForm === "object") {
            plugins.push("addpoi");
        }
        if (GeoLeaf._LayerManagerControl || GeoLeaf._LMRenderer) {
            plugins.push("layer-manager");
        }
        if (GeoLeaf.Route && typeof GeoLeaf.Route.load === "function") {
            plugins.push("route");
        }
        if (GeoLeaf.Labels && typeof GeoLeaf.Labels.init === "function") {
            plugins.push("labels");
        }
        return plugins;
    }

    /**
     * Construit le message du toast de démarrage.
     * @param {object} GeoLeaf
     * @returns {{ title: string, message: string }}
     */
    function _buildBootMessage(GeoLeaf) {
        const version = GeoLeaf._version || "4.0.0";
        const plugins = _detectLoadedPlugins(GeoLeaf);

        // Distinguer modules premium des modules core
        const premiumKeys = ["storage", "addpoi"];
        const premiumLoaded = plugins.filter((p) =>
            premiumKeys.some((pk) => p.toLowerCase().startsWith(pk))
        );
        const coreModules = plugins.filter(
            (p) => !premiumKeys.some((pk) => p.toLowerCase().startsWith(pk))
        );

        let message = "";
        if (premiumLoaded.length > 0) {
            message = `Core MIT • Premium: ${premiumLoaded.join(" + ")}`;
            if (coreModules.length > 0) message += ` • ${coreModules.join(" • ")}`;
        } else {
            message =
                plugins.length > 0 ? `Core MIT — ${coreModules.join(" • ")}` : "Core MIT — open source";
        }

        return {
            title: `GeoLeaf JS ${version}`,
            message,
        };
    }

    /**
     * Affiche le toast de démarrage.
     * Respecte la config `debug.showBootInfo` (défaut: true en dev, false en prod).
     *
     * @param {object} GeoLeaf - Le namespace global GeoLeaf
     * @param {object} [options]
     * @param {boolean} [options.force=false] - Forcer l'affichage même si désactivé en config
     * @param {number} [options.duration=4000] - Durée d'affichage en ms
     */
    function showBootInfo(GeoLeaf, options = {}) {
        if (!GeoLeaf) return;

        // Vérification config — désactivable via profil JSON : "debug": { "showBootInfo": false }
        if (!options.force) {
            try {
                const showFlag = GeoLeaf.Config?.get?.("debug.showBootInfo");
                // Si explicitement désactivé, ne pas afficher
                if (showFlag === false) return;
            } catch (_) {
                /* Config non disponible — afficher quand même */
            }
        }

        const { title, message } = _buildBootMessage(GeoLeaf);

        // Log only — toast désactivé (dev info uniquement)
        console.info(`[GeoLeaf] ${title} | ${message}`);
    }

    /**
     * API publique exposée sur GeoLeaf.bootInfo
     */
    const BootInfo = {
        show: showBootInfo,
        detectPlugins: _detectLoadedPlugins,
        buildMessage: _buildBootMessage,
    };

    /*!
     * GeoLeaf Core – API / PluginRegistry
     * © 2026 Mattieu Pottier — MIT License
     */

    /**
     * Registre léger des plugins et modules GeoLeaf chargés.
     * Permet aux intégrateurs d'interroger les capacités disponibles.
     *
     * @module api/plugin-registry
     * @example
     * GeoLeaf.plugins.isLoaded('storage')      // → true/false
     * GeoLeaf.plugins.getLoadedPlugins()        // → ['core', 'storage', 'labels']
     * GeoLeaf.plugins.canActivate('addpoi')     // → true si dépendances OK
     */

    const _registry = new Map(); // name → { name, version, loaded, loadedAt, metadata }

    const _lazyResolvers = new Map(); // name → () => Promise<void>

    const PluginRegistry = {
        /**
         * Enregistre un plugin comme chargé.
         * Appelé automatiquement par globals.js et les fichiers plugins.
         * @param {string} name - Identifiant du plugin (ex: 'storage', 'addpoi', 'labels')
         * @param {object} [metadata] - Métadonnées optionnelles { version, requires, optional }
         */
        register(name, metadata = {}) {
            _registry.set(name, {
                name,
                version: metadata.version || null,
                loaded: true,
                loadedAt: Date.now(),
                requires: metadata.requires || [],
                optional: metadata.optional || [],
                label: metadata.label || name,
                healthCheck: metadata.healthCheck || null,
            });
        },

        /**
         * Enregistre un resolver lazy (appelé par bundle-entry.js).
         * @param {string} name
         * @param {Function} resolver - () => Promise<void>
         */
        registerLazy(name, resolver) {
            _lazyResolvers.set(name, resolver);
        },

        /**
         * Vérifie si un plugin est actuellement chargé.
         * @param {string} name
         * @returns {boolean}
         */
        isLoaded(name) {
            return _registry.has(name) && _registry.get(name).loaded === true;
        },

        /**
         * Vérifie si un plugin peut être activé (ses dépendances `requires` sont chargées).
         * @param {string} name
         * @returns {boolean}
         */
        canActivate(name) {
            const entry = _registry.get(name);
            if (!entry) return _lazyResolvers.has(name);
            return entry.requires.every((dep) => PluginRegistry.isLoaded(dep));
        },

        /**
         * Charge un plugin lazy par son nom.
         * @param {string} name
         * @returns {Promise<void>}
         */
        async load(name) {
            if (PluginRegistry.isLoaded(name)) return;
            const resolver = _lazyResolvers.get(name);
            if (!resolver)
                throw new Error(
                    `[GeoLeaf.plugins] Module inconnu : "${name}". Modules disponibles : ${[..._lazyResolvers.keys()].join(", ")}`
                );
            await resolver();
        },

        /**
         * Retourne la liste des noms de plugins chargés.
         * @returns {string[]}
         */
        getLoadedPlugins() {
            return [..._registry.keys()].filter((k) => _registry.get(k).loaded);
        },

        /**
         * Retourne la liste de tous les modules disponibles (chargés + lazy disponibles).
         * @returns {string[]}
         */
        getAvailableModules() {
            return [...new Set([..._registry.keys(), ..._lazyResolvers.keys()])];
        },

        /**
         * Retourne les métadonnées d'un plugin.
         * @param {string} name
         * @returns {object|null}
         */
        getInfo(name) {
            return _registry.get(name) || null;
        },

        /**
         * Affiche dans la console un rapport des plugins premium chargés.
         * Silencieux si aucun plugin premium n'est chargé (core seul).
         */
        reportPremiumPlugins() {
            const CORE_MODULES = new Set([
                "core",
                "labels",
                "route",
                "table",
                "legend",
                "layerManager",
                "themes",
                "basemapSelector",
                "poiCore",
                "poiRenderers",
                "poiExtras",
                "poi",
                "basemap-selector",
            ]);
            const premium = [..._registry.values()].filter(
                (e) => e.loaded && !CORE_MODULES.has(e.name)
            );
            if (premium.length === 0) {
                console.info("%c[PLUGINS] Core MIT — 0 plugin premium chargé", "color:#6b7280;font-style:italic");
                return;
            }

            console.groupCollapsed(
                // eslint-disable-line no-console
                `%c[PLUGINS] ${premium.length} plugin(s) premium chargé(s)`,
                "color:#7c3aed;font-weight:bold"
            );
            for (const entry of premium) {
                const healthy = typeof entry.healthCheck === "function" ? entry.healthCheck() : true;
                const icon = healthy ? "✅" : "❌";
                const color = healthy ? "color:#16a34a" : "color:#dc2626";
                const label = entry.label || entry.name;
                const version = entry.version ? ` v${entry.version}` : "";
                const status = healthy ? "OK" : "ERREUR — module incomplet";
                console.log(`%c  ${icon} ${label}${version}  [${status}]`, color); // eslint-disable-line no-console
                if (!healthy) {
                    console.warn(
                        // eslint-disable-line no-console
                        `     [PLUGINS] ${entry.name} : healthCheck échoué — vérifiez le chargement du plugin.`
                    );
                }
            }
            console.groupEnd(); // eslint-disable-line no-console
        },

        // Accès interne — ne pas utiliser en dehors de GeoLeaf
        _registry,
        _lazyResolvers,
    };

    /**
     * globals.api.js — Bridge UMD/ESM : B11 — facades geoleaf.*.js + api, PluginRegistry
     *
     * @see globals.js (orchestrateur)
     */

    // geoleaf.api.js is imported last in bundle-entry.js (requires _APIController to be set up first)

    const _g$1 =
        typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : {};

    _g$1.GeoLeaf = _g$1.GeoLeaf || {};

    // ── B11 assignations : facades + api ─────────────────────────────────────────
    if (!_g$1.GeoLeaf.API) _g$1.GeoLeaf.API = {};
    _g$1.GeoLeaf.API.Controller = APIController;
    _g$1.GeoLeaf.API.FactoryManager = APIFactoryManager;
    _g$1.GeoLeaf.API.InitializationManager = APIInitializationManager;
    _g$1.GeoLeaf.API.ModuleManager = APIModuleManager;
    // Aliases expected by api/controller.js._getManagerClass() (Phase 7 key mismatch fix)
    _g$1.GeoLeaf.API.APIModuleManager = APIModuleManager;
    _g$1.GeoLeaf.API.APIInitializationManager = APIInitializationManager;
    _g$1.GeoLeaf.API.APIFactoryManager = APIFactoryManager;
    // Top-level facade modules
    _g$1.GeoLeaf.Baselayers = Baselayers;
    _g$1.GeoLeaf.BaseLayers = Baselayers; // alias stabilisé Phase 7
    _g$1.GeoLeaf.Core = Core;
    _g$1.GeoLeaf.Filters = Filters;
    _g$1.GeoLeaf.Helpers = Helpers;
    _g$1.GeoLeaf.LayerManager = LayerManager;
    _g$1.GeoLeaf.Legend = Legend;
    if (!_g$1.GeoLeaf.POI || !_g$1.GeoLeaf.POI.init)
        _g$1.GeoLeaf.POI = Object.assign(_g$1.GeoLeaf.POI || {}, POI);
    // Renderers must be (re-)set AFTER the Object.assign above because geoleaf.poi.js
    // historically shipped a Renderers:{} key that would overwrite them if set earlier.
    if (!_g$1.GeoLeaf.POI.Renderers) _g$1.GeoLeaf.POI.Renderers = {};
    _g$1.GeoLeaf.POI.Renderers.FieldRenderers = FieldRenderers;
    _g$1.GeoLeaf.POI.Renderers.MediaRenderers = MediaRenderers;
    _g$1.GeoLeaf.Route = Route;
    // Storage: namespace ensured by globals.storage.js; facade methods injected by the premium plugin at runtime
    _g$1.GeoLeaf.Storage = _g$1.GeoLeaf.Storage || {};
    _g$1.GeoLeaf.Table = Table;
    // UI: geoleaf.ui.js built _g.GeoLeaf.UI directly via mutations — re-sync reference
    _g$1.GeoLeaf.UI = UI || _g$1.GeoLeaf.UI;
    // Validators: override B8 SchemaValidators with full public Validators facade
    _g$1.GeoLeaf.Validators = Validators;
    _g$1.GeoLeaf.plugins = PluginRegistry;
    _g$1.GeoLeaf.bootInfo = BootInfo;
    // Enregistrer le core comme chargé
    PluginRegistry.register("core", { version: _g$1.GeoLeaf._version });

    // ── Public API entry points ──────────────────────────────────────────────────
    // Note: api/geoleaf-api.js is excluded by Rollup DCE in the UMD build because
    // Object.assign(existing, {...}) where existing = _g.GeoLeaf||{} is treated as
    // operating on a "local" object (propertyReadSideEffects:false + globalThis).
    // Methods are assigned directly here to guarantee inclusion in the UMD bundle.
    // See ROADMAP_PHASE11_LEGACY_TESTS_2026-02.md for context.

    _g$1.GeoLeaf.init = function (options) {
        try {
            return _g$1.GeoLeaf._APIController.geoleafInit(options);
        } catch (error) {
            if (Log) Log.error("[GeoLeaf.init]", error);
            throw error;
        }
    };
    _g$1.GeoLeaf.setTheme = function (theme) {
        try {
            return _g$1.GeoLeaf._APIController.geoleafSetTheme(theme);
        } catch (error) {
            if (Log) Log.error("[GeoLeaf.setTheme]", error);
            throw error;
        }
    };
    _g$1.GeoLeaf.loadConfig = function (input) {
        if (
            input === null ||
            input === undefined ||
            (typeof input !== "string" && typeof input !== "object")
        ) {
            throw new TypeError(
                `[GeoLeaf.loadConfig] Invalid input: expected string URL or config object, got ${typeof input}`
            );
        }
        try {
            return _g$1.GeoLeaf._APIController.geoleafLoadConfig(input);
        } catch (error) {
            if (Log) Log.error("[GeoLeaf.loadConfig]", error);
            throw error;
        }
    };
    _g$1.GeoLeaf.createMap = function (id, options) {
        const ctrl = _g$1.GeoLeaf._APIController;
        return ctrl && ctrl.geoleafCreateMap ? ctrl.geoleafCreateMap(id, options) : null;
    };
    _g$1.GeoLeaf.getMap = function (id) {
        const ctrl = _g$1.GeoLeaf._APIController;
        return ctrl && ctrl.managers && ctrl.managers.factory
            ? ctrl.managers.factory.getMapInstance(id)
            : null;
    };
    _g$1.GeoLeaf.getAllMaps = function () {
        const ctrl = _g$1.GeoLeaf._APIController;
        return ctrl && ctrl.managers && ctrl.managers.factory
            ? ctrl.managers.factory.getAllMapInstances()
            : [];
    };
    _g$1.GeoLeaf.removeMap = function (id) {
        const ctrl = _g$1.GeoLeaf._APIController;
        if (
            ctrl &&
            ctrl.managers &&
            ctrl.managers.factory &&
            typeof ctrl.managers.factory.removeMapInstance === "function"
        ) {
            return ctrl.managers.factory.removeMapInstance(id);
        }
        return false;
    };
    _g$1.GeoLeaf.getModule = function (name) {
        const ctrl = _g$1.GeoLeaf._APIController;
        return ctrl && ctrl.moduleAccessFn ? ctrl.moduleAccessFn(name) : null;
    };
    _g$1.GeoLeaf.hasModule = function (name) {
        const ctrl = _g$1.GeoLeaf._APIController;
        const mod = ctrl && ctrl.moduleAccessFn ? ctrl.moduleAccessFn(name) : null;
        return !!mod;
    };
    _g$1.GeoLeaf.getNamespace = function (name) {
        // eslint-disable-next-line security/detect-object-injection
        return _g$1.GeoLeaf && name ? _g$1.GeoLeaf[name] || null : null;
    };
    _g$1.GeoLeaf.getHealth = function () {
        const ctrl = _g$1.GeoLeaf._APIController;
        return ctrl && ctrl.getHealthStatus ? ctrl.getHealthStatus() : null;
    };
    _g$1.GeoLeaf.getMetrics = function () {
        return _g$1.GeoLeaf.getHealth();
    };
    // Alias version / CONSTANTS (set also by geoleaf-api.js for ESM — harmless duplicate)
    if (!_g$1.GeoLeaf.version) {
        _g$1.GeoLeaf.version = (_g$1.GeoLeaf.CONSTANTS && _g$1.GeoLeaf.CONSTANTS.VERSION) || "4.0.0";
    }
    // geoleaf.api.js (ESM facade) also sets these; globals.api.js provides the UMD fallback.

    /**
     * globals.js  Orchestrateur du bridge UMD/ESM (Phase 9  refactorisé)
     * Ce fichier délègue aux sous-modules par domaine métier.
     * Chaque sous-module importe ses propres dépendances et appende _g.GeoLeaf.
     *
     * Ordre d'exécution garanti par ESM (depth-first) :
     *   core  config  geojson  ui  storage  poi  api
     *
     *  _namespace.js supprimé en Phase 8  tous les modules utilisent Pattern A pur
     *  globals.js découpé en sous-fichiers par domaine en Phase 9 (P3-DEAD-05)
     *
     * @see ROADMAP_PHASE7_ESM.md
     * @see docs/architecture/BOOT_SEQUENCE.md
     */


    // Re-exporter _g pour les consommateurs qui l'importent directement
    const _g = typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined' ? window : {};

    /*!
     * GeoLeaf Core – App / Helpers
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const GeoLeaf$3 = _g.GeoLeaf;

    /**
     * Namespace interne pour le module Application Bootstrap.
     * Partagé entre app/helpers.js, app/init.js et app/boot.js.
     * @namespace GeoLeaf._app
     * @private
     */
    const _app$2 = GeoLeaf$3._app = GeoLeaf$3._app || {};

    // ============================================================
    // Système de logs production
    // ============================================================
    _app$2.AppLog = {
        log(...args) {
            if (location.search.includes('debug=true')) {
                console.log('[GeoLeaf]', ...args);
            }
        },
        info(...args) {
            console.info('[GeoLeaf]', ...args);
        },
        error(...args) {
            console.error('[GeoLeaf]', ...args);
        },
        warn(...args) {
            console.warn('[GeoLeaf]', ...args);
        }
    };

    // ============================================================
    // Détection automatique du chemin vers profiles/
    // ============================================================
    /**
     * Détecte automatiquement le chemin de base vers le dossier profiles/
     * en fonction de l'URL courante.
     * @returns {string} Chemin relatif vers profiles/
     */
    _app$2.getProfilesBasePath = function () {
        const currentPath = _g.location.pathname;
        if (currentPath.includes('/demo/')) {
            return '../profiles/';
        }
        return './profiles/';
    };

    // ============================================================
    // Vérification des plugins au boot
    // ============================================================
    /**
     * Vérifie que les plugins requis par la configuration sont bien chargés
     * et affiche des avertissements dans la console si ce n'est pas le cas.
     * @param {Object} cfg - Configuration du profil actif
     */
    _app$2.checkPlugins = function (cfg) {
        const AppLog = _app$2.AppLog;

        // Avertissement si config attend AddPOI mais plugin non chargé
        if (cfg && cfg.ui && cfg.ui.showAddPoi === true) {
            if (!GeoLeaf$3.POI || !GeoLeaf$3.POI.AddForm) {
                AppLog.warn(
                    '⚠️ Config has showAddPoi=true but AddPOI plugin is not loaded. ' +
                    'Load geoleaf-addpoi.plugin.js before calling GeoLeaf.boot().'
                );
            }
        }

        // Avertissement si config attend Storage mais plugin non chargé
        if (cfg && cfg.storage) {
            if (!GeoLeaf$3.Storage) {
                AppLog.warn(
                    '⚠️ Config references storage but Storage plugin is not loaded. ' +
                    'Advanced features (IndexedDB, CacheManager, sync) require geoleaf-storage.plugin.js. ' +
                    'Basic offline caching via SW core is always available without the plugin.'
                );
            }

            // SW lite (sw-core.js) is always registered at boot — no check needed.
            // Only warn if user expects PREMIUM SW without the Storage plugin.
            if (cfg.storage.enableServiceWorker && !GeoLeaf$3.Storage) {
                AppLog.warn(
                    '⚠️ Config has enableServiceWorker=true but Storage plugin is not loaded. ' +
                    'Premium SW (IndexedDB tiles, background sync) requires geoleaf-storage.plugin.js. ' +
                    'Core/lite SW remains active for basic offline caching.'
                );
            }
        }

        // Avertissement si SyncHandler est chargé sans Storage
        if (GeoLeaf$3.POI && GeoLeaf$3.POI.SyncHandler && !GeoLeaf$3.Storage) {
            AppLog.warn(
                '⚠️ SyncHandler loaded without Storage plugin — sync operations will be disabled. ' +
                'POI add/edit/delete will work in online-only mode.'
            );
        }
    };

    // ============================================================
    // Helper : afficher une notification
    // ============================================================
    /**
     * Affiche une notification via le système UI de GeoLeaf.
     * Tente d'abord GeoLeaf.UI.Notifications, puis GeoLeaf._UINotifications.
     * @param {string} message - Message à afficher
     * @param {number} [duration=3500] - Durée d'affichage en millisecondes
     * @returns {boolean} true si la notification a été affichée
     */
    _app$2.showNotification = function (message, duration) {
        duration = duration || 3500;
        if (GeoLeaf$3.UI && GeoLeaf$3.UI.Notifications && typeof GeoLeaf$3.UI.Notifications.success === "function") {
            try { GeoLeaf$3.UI.Notifications.success(message, duration); return true; } catch (e) {}
        }
        if (GeoLeaf$3._UINotifications && typeof GeoLeaf$3._UINotifications.success === "function") {
            try { GeoLeaf$3._UINotifications.success(message, duration); return true; } catch (e) {}
        }
        _app$2.AppLog.log(message + " (notifications indisponibles)");
        return false;
    };

    // ============================================================
    // Sprint 6: Lazy module loader helper
    // ============================================================
    /**
     * S'assure qu'un module secondaire est chargé.
     * En mode UMD le module est déjà disponible (inliné) → résolution immédiate.
     * En mode ESM, déclenche le chargement du chunk réseau si nécessaire.
     *
     * @param {string} globalName - Nom sur window.GeoLeaf (ex: 'POI', 'Route')
     * @param {string} chunkName  - Identifiant du chunk (ex: 'poi', 'route')
     * @returns {Promise<void>}
     */
    _app$2._ensureModule = async function(globalName, chunkName) {
        if (GeoLeaf$3[globalName]) return; // déjà chargé (UMD ou déjà importé)
        if (typeof GeoLeaf$3._loadModule === 'function') {
            await GeoLeaf$3._loadModule(chunkName);
        }
    };

    /**
     * GeoLeaf App – Feature Module Initializers
     * Extracted from app/init.js (Phase 8.2.3)
     * Each function initializes one feature domain after secondary modules are loaded.
     *
     * @module app/init-feature-modules
     */

    // Note: L (Leaflet) is a browser global accessed directly.

    /**
     * @typedef {Object} InitDeps
     * @property {Object} GeoLeaf  - The global GeoLeaf object
     * @property {Object} cfg      - The active profile configuration
     * @property {Object} map      - The Leaflet map instance
     * @property {Object} AppLog   - Logger instance
     * @property {Object} [_app]   - The _app namespace (required for initGeoJSON)
     */

    /**
     * Initialize base tile layers from profile cfg.basemaps.
     * @param {InitDeps} deps
     */
    function initBasemaps({ GeoLeaf, cfg, map, AppLog }) {
        const baseLayersModule = GeoLeaf.BaseLayers || GeoLeaf.Baselayers;
        if (!baseLayersModule || typeof baseLayersModule.init !== "function") {
            AppLog.warn("Module BaseLayers introuvable.");
            return;
        }

        let activeKey = "street";
        const basemapsFromConfig = {};
        if (cfg.basemaps && typeof cfg.basemaps === "object") {
            Object.keys(cfg.basemaps).forEach(function (key) {
                const def = cfg.basemaps[key];
                if (def.defaultBasemap === true) activeKey = def.id || key;
                const entry = {
                    id: def.id || key,
                    label: def.label || key,
                    url: def.url || def.fallbackUrl,
                    options: {
                        minZoom: def.minZoom || 0,
                        maxZoom: def.maxZoom || 19,
                        attribution: def.attribution || "",
                    },
                };
                // MapLibre vector basemap support
                if (def.type) entry.type = def.type;
                if (def.style) entry.style = def.style;
                if (def.attribution) entry.attribution = def.attribution;
                // Propagate minZoom/maxZoom at top level for MapLibre path
                if (typeof def.minZoom === "number") entry.minZoom = def.minZoom;
                if (typeof def.maxZoom === "number") entry.maxZoom = def.maxZoom;

                basemapsFromConfig[key] = entry;
            });
        }

        try {
            baseLayersModule.init({
                map: map,
                baselayers: basemapsFromConfig,
                activeKey: activeKey,
                ui: cfg.ui,
                basemaps: cfg.basemaps,
            });
        } catch (e) {
            AppLog.warn("BaseLayers.init a levé une exception :", e);
        }
    }

    /**
     * Initialize POI markers from profile cfg.poi.
     * @param {InitDeps} deps
     */
    function initPOI({ GeoLeaf, cfg, map, AppLog }) {
        const poiApi = GeoLeaf.POI;
        if (!poiApi || typeof poiApi.add !== "function") {
            AppLog.warn("GeoLeaf.POI.add() indisponible, aucun POI ne sera affiché.");
            return;
        }

        try {
            if (typeof poiApi.init === "function") {
                poiApi.init({ map: map, config: cfg.poiConfig || {} });

                // Chargement des légendes POI
                if (
                    GeoLeaf.Legend &&
                    typeof GeoLeaf.Legend.loadLayerLegend === "function" &&
                    cfg.layers &&
                    Array.isArray(cfg.layers)
                ) {
                    cfg.layers.forEach(function (layerRef) {
                        if (layerRef.id && layerRef.id.includes("poi") && layerRef.configFile) {
                            fetch(layerRef.configFile)
                                .then((response) => response.json())
                                .then((layerConfig) => {
                                    let styleId = "default";
                                    if (
                                        layerConfig.styles &&
                                        layerConfig.styles.available &&
                                        layerConfig.styles.available.length > 0
                                    ) {
                                        styleId = layerConfig.styles.available[0].id || "default";
                                    }
                                    GeoLeaf.Legend.loadLayerLegend(layerRef.id, styleId, layerConfig);
                                    if (typeof GeoLeaf.Legend.setLayerVisibility === "function") {
                                        GeoLeaf.Legend.setLayerVisibility(layerRef.id, true);
                                    }
                                })
                                .catch((err) =>
                                    AppLog.warn(`Erreur chargement config couche ${layerRef.id}:`, err)
                                );
                        }
                    });
                }
            }
        } catch (e) {
            AppLog.warn("GeoLeaf.POI.init() a levé une erreur :", e);
        }

        const showFilterPanel = cfg.ui && cfg.ui.showFilterPanel === true;
        if (showFilterPanel) {
            AppLog.info(
                "Panneau de filtres activé : les POI seront chargés via le système de filtres."
            );
            if (GeoLeaf.UI && typeof GeoLeaf.UI.applyFiltersInitial === "function") {
                GeoLeaf.UI.applyFiltersInitial();
            }
            return;
        }

        if (!Array.isArray(cfg.poi) || cfg.poi.length === 0) {
            return;
        }

        const bounds = [];
        cfg.poi.forEach(function (poiItem) {
            let latlng = null;
            if (poiItem.latlng && Array.isArray(poiItem.latlng) && poiItem.latlng.length === 2) {
                latlng = poiItem.latlng;
            } else if (
                poiItem.location &&
                typeof poiItem.location.lat === "number" &&
                typeof poiItem.location.lng === "number"
            ) {
                latlng = [poiItem.location.lat, poiItem.location.lng];
            }
            if (latlng) bounds.push(latlng);
        });

        if (bounds.length > 0) {
            // fitBounds POI uniquement si pas de bounds dans le profil ET pas de couches GeoJSON
            const hasBoundsFromProfile =
                cfg.map && Array.isArray(cfg.map.bounds) && cfg.map.bounds.length === 2;
            const hasGeoJSONLayers = cfg.layers && Array.isArray(cfg.layers) && cfg.layers.length > 0;
            if (!hasBoundsFromProfile && !hasGeoJSONLayers) {
                try {
                    map.fitBounds(L.latLngBounds(bounds), {
                        padding: [80, 80],
                        maxZoom: 12,
                        animate: false,
                    });
                } catch (e) {
                    AppLog.warn("Erreur lors de fitBounds :", e);
                }
            }
            if (GeoLeaf.UI && typeof GeoLeaf.UI.refreshFilterTags === "function") {
                GeoLeaf.UI.refreshFilterTags();
            }
        }
    }

    /**
     * Initialize route display from profile cfg.routes.
     * @param {InitDeps} deps
     */
    function initRoute({ GeoLeaf, cfg, map, AppLog }) {
        const routeApi = GeoLeaf.Route;
        if (
            !routeApi ||
            typeof routeApi.init !== "function" ||
            typeof routeApi.loadFromConfig !== "function"
        ) {
            return;
        }
        try {
            routeApi.init({ map: map, fitBoundsOnLoad: false, maxZoomOnFit: 12 });
        } catch (e) {
            AppLog.warn("GeoLeaf.Route.init() a levé une erreur :", e);
            return;
        }
        if (Array.isArray(cfg.routes) && cfg.routes.length > 0) {
            try {
                routeApi.loadFromConfig(cfg.routes);
                AppLog.log("Itinéraires chargés.");
            } catch (e) {
                AppLog.warn("GeoLeaf.Route.loadFromConfig() a levé une erreur :", e);
            }
        }
    }

    /**
     * Initialize GeoJSON layers and theme selector from profile cfg.layers.
     * @param {InitDeps} deps
     */
    function initGeoJSON({ GeoLeaf, _cfg, map, AppLog, _app }) {
        const geoJsonApi = GeoLeaf.GeoJSON;
        if (!geoJsonApi || typeof geoJsonApi.init !== "function") {
            AppLog.log("GeoLeaf.GeoJSON.init() indisponible — pas de couches GeoJSON.");
            return;
        }

        try {
            geoJsonApi.init({ map: map, fitBoundsOnLoad: false, maxZoomOnFit: 12 });
        } catch (e) {
            AppLog.warn("GeoLeaf.GeoJSON.init() a levé une erreur :", e);
            return;
        }

        if (map && typeof map.on === "function") {
            map.on("geoleaf:geojson:layers-loaded", function (event) {
                if (event && event.detail && typeof event.detail.count === "number") {
                    const count = event.detail.count;
                    const message =
                        count === 1 ? "1 couche GeoJSON chargée" : count + " couches GeoJSON chargées";
                    if (_app && typeof _app.showNotification === "function") {
                        _app.showNotification(message, 3000);
                    }
                }
            });
        }

        // Initialisation du système de thèmes
        // B5 [ESM-02]: IIFE remplacée par fonction nommée — scoping inutile en ESM
        function buildLoadAllConfigsPromise() {
            if (
                GeoLeaf._GeoJSONLoader &&
                typeof GeoLeaf._GeoJSONLoader.loadAllLayersConfigsForLayerManager === "function"
            ) {
                const activeProfile =
                    GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === "function"
                        ? GeoLeaf.Config.getActiveProfile()
                        : null;
                if (activeProfile) {
                    return GeoLeaf._GeoJSONLoader
                        .loadAllLayersConfigsForLayerManager(activeProfile)
                        .catch((err) => {
                            AppLog.warn("Erreur chargement configs couches:", err);
                            return [];
                        });
                }
            }
            return Promise.resolve();
        }
        const loadAllConfigsPromise = buildLoadAllConfigsPromise();

        loadAllConfigsPromise.then(function () {
            if (!GeoLeaf.ThemeSelector || typeof GeoLeaf.ThemeSelector.init !== "function") {
                AppLog.warn("ThemeSelector non disponible");
                return;
            }

            let currentProfileId = null;
            if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfileId === "function") {
                currentProfileId = GeoLeaf.Config.getActiveProfileId();
            }

            const primaryContainer = document.getElementById("gl-theme-primary-container");
            const secondaryContainer = document.getElementById("gl-theme-secondary-container");

            if (!currentProfileId || !primaryContainer || !secondaryContainer) {
                AppLog.warn("ThemeSelector : conteneurs ou profil manquants");
                return;
            }

            GeoLeaf.ThemeSelector.init({
                profileId: currentProfileId,
                primaryContainer: primaryContainer,
                secondaryContainer: secondaryContainer,
            })
                .then(function () {
                    AppLog.log("ThemeSelector initialisé et thème appliqué");

                    if (
                        GeoLeaf._GeoJSONLayerManager &&
                        typeof GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs ===
                            "function"
                    ) {
                        const activeThemeConfig = GeoLeaf.ThemeSelector.getActiveTheme
                            ? GeoLeaf.ThemeSelector.getActiveTheme()
                            : null;
                        GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs(
                            activeThemeConfig
                        );
                    }

                    document.addEventListener("geoleaf:theme:applied", function () {
                        if (
                            GeoLeaf._GeoJSONLayerManager &&
                            typeof GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs ===
                                "function"
                        ) {
                            const activeThemeConfig = GeoLeaf.ThemeSelector.getActiveTheme
                                ? GeoLeaf.ThemeSelector.getActiveTheme()
                                : null;
                            GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs(
                                activeThemeConfig
                            );
                        }
                    });
                })
                .catch(function (e) {
                    AppLog.warn("Erreur initialisation ThemeSelector:", e);
                });
        });
    }

    /*!
     * GeoLeaf Core – App / Init
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const GeoLeaf$2 = _g.GeoLeaf;
    const _app$1 = (GeoLeaf$2._app = GeoLeaf$2._app || {});

    // ============================================================
    // Fonction principale : initialiser l'application
    // ============================================================
    _app$1.initApp = async function (cfg) {
        cfg = cfg || {};
        const AppLog = _app$1.AppLog;
        // perf 5 — benchmark: mesure du démarrage
        if (typeof performance !== "undefined" && performance.mark) {
            performance.mark("geoleaf:initApp:start");
        }
        AppLog.log("Initialisation avec config:", cfg);

        // Vérifier les plugins
        _app$1.checkPlugins(cfg);

        // ========================================================
        // Initialisation de la carte
        // La carte est créée directement sur l'emprise du profil
        // (map.bounds obligatoire dans le profil).
        // ========================================================
        const mapTarget = (cfg.map && (cfg.map.target || cfg.map.id)) || "geoleaf-map";
        const uiTheme = (cfg.ui && cfg.ui.theme) || "light";

        // Bounds obligatoires — pas de fallback carte monde
        if (!cfg.map || !Array.isArray(cfg.map.bounds) || cfg.map.bounds.length !== 2) {
            AppLog.error(
                "[GeoLeaf] Le profil actif ne définit pas de map.bounds valide. " +
                    "L'emprise (map.bounds) est obligatoire dans le fichier profile.json. " +
                    'Exemple : "bounds": [[43.0, 1.0], [44.0, 2.0]]'
            );
            return;
        }

        // Calculer le centre depuis les bounds pour éviter le flash carte monde
        const profileBounds = cfg.map.bounds;
        const profileMaxZoom = cfg.map.initialMaxZoom || cfg.map.maxZoom || 12;
        const profilePadding = cfg.map.padding || [50, 50];
        const mapCenter = [
            (profileBounds[0][0] + profileBounds[1][0]) / 2,
            (profileBounds[0][1] + profileBounds[1][1]) / 2,
        ];

        let map = null;

        // Options Leaflet avancées (maxBounds pour positionFixed, etc.)
        const mapOptions = {};
        if (cfg.map.positionFixed === true) {
            const boundsMargin = typeof cfg.map.boundsMargin === "number" ? cfg.map.boundsMargin : 0.3;
            mapOptions.maxBounds = L.latLngBounds(profileBounds).pad(boundsMargin);
            mapOptions.maxBoundsViscosity = 0.85;
            if (typeof cfg.map.minZoom === "number") {
                mapOptions.minZoom = cfg.map.minZoom;
            } else {
                mapOptions.minZoom = 3;
            }
        }

        try {
            map = GeoLeaf$2.init({
                map: {
                    target: mapTarget,
                    center: mapCenter,
                    zoom: profileMaxZoom,
                    mapOptions: mapOptions,
                },
                ui: {
                    theme: uiTheme,
                },
            });
        } catch (e) {
            AppLog.error("GeoLeaf.init() a levé une erreur :", e);
            return;
        }

        if (!map) {
            AppLog.error("GeoLeaf.init() n'a pas renvoyé de carte valide.");
            return;
        }

        // Précharger les modules secondaires le plus tôt possible pour chevaucher
        // le téléchargement des chunks avec l'initialisation UI/Storage.
        // On garde un await plus bas avant l'usage des modules secondaires afin de
        // préserver le comportement actuel.
        let secondaryModulesPromise = null;
        if (typeof GeoLeaf$2._loadAllSecondaryModules === "function") {
            secondaryModulesPromise = GeoLeaf$2._loadAllSecondaryModules();
        }

        // Appliquer positionFixed directement après création (filet de sécurité)
        if (cfg.map.positionFixed === true) {
            try {
                const boundsMargin =
                    typeof cfg.map.boundsMargin === "number" ? cfg.map.boundsMargin : 0.3;
                const fixedBounds = L.latLngBounds(profileBounds).pad(boundsMargin);
                map.setMaxBounds(fixedBounds);
                map.options.maxBoundsViscosity = 0.85;
                if (typeof cfg.map.minZoom === "number") {
                    map.setMinZoom(cfg.map.minZoom);
                } else {
                    map.setMinZoom(3);
                }
                AppLog.log(
                    "[GeoLeaf] positionFixed activé — déplacement restreint à l'emprise du profil (marge: " +
                        boundsMargin * 100 +
                        "%)."
                );
            } catch (e) {
                AppLog.warn("[GeoLeaf] Erreur lors de l'application de positionFixed :", e);
            }
        }

        // Positionnement précis via fitBounds (ajuste le zoom aux dimensions réelles du conteneur)
        try {
            map.fitBounds(profileBounds, {
                maxZoom: profileMaxZoom,
                padding: profilePadding,
                animate: false,
            });
            AppLog.log("Carte positionnée via map.bounds du profil.");
        } catch (e) {
            AppLog.warn("Erreur fitBounds depuis profile.map.bounds :", e);
        }

        // ========================================================
        // Service Worker core/lite — enregistrement INCONDITIONNEL
        // Le SW lite (sw-core.js) fait partie du core gratuit.
        // Il sera remplacé par le SW premium (sw.js) si le plugin
        // Storage est chargé ET enableServiceWorker = true.
        // ========================================================
        if (GeoLeaf$2._SWRegister) {
            GeoLeaf$2._SWRegister
                .register({ scope: "./" })
                .then(() => AppLog.log("Service Worker (core/lite) enregistré."))
                .catch((err) => AppLog.warn("Erreur enregistrement SW core:", err.message));
        }

        // ========================================================
        // Initialiser le Storage avec la config du profil (si plugin chargé)
        // ========================================================
        const storageConfig = cfg.storage || {};

        if (GeoLeaf$2.Storage && typeof GeoLeaf$2.Storage.init === "function") {
            try {
                AppLog.log("Initialisation du Storage avec config:", storageConfig);

                GeoLeaf$2.Storage.init({
                    indexedDB: { name: "geoleaf-db", version: 2 },
                    cache: storageConfig.cache || {
                        enableProfileCache: true,
                        enableTileCache: true,
                    },
                    offline: {},
                    enableOfflineDetector: !!storageConfig.enableOfflineDetector,
                    enableServiceWorker: !!storageConfig.enableServiceWorker,
                })
                    .then(() => {
                        AppLog.log("Storage initialisé avec succès");
                    })
                    .catch((err) => {
                        AppLog.warn("Erreur initialisation Storage:", err);
                    });
            } catch (e) {
                AppLog.warn("Erreur lors de l'initialisation du Storage:", e);
            }
        } else {
            AppLog.log("Plugin Storage non chargé — fonctionnement en mode cache navigateur standard.");

            // Initialize the Offline Detector for connectivity badge (core mode)
            if (storageConfig.enableOfflineDetector && GeoLeaf$2._OfflineDetector) {
                GeoLeaf$2._OfflineDetector.init({
                    showBadge: true,
                    badgePosition: "topleft",
                    checkInterval: 30000,
                });
                AppLog.log("Offline Detector initialisé (mode core).");
            }
        }

        // ========================================================
        // Initialiser le système de notifications UI
        // ========================================================
        if (GeoLeaf$2._UINotifications && typeof GeoLeaf$2._UINotifications.init === "function") {
            try {
                let notificationContainer = document.getElementById("gl-notifications");
                if (!notificationContainer) {
                    notificationContainer = document.createElement("div");
                    notificationContainer.id = "gl-notifications";
                    notificationContainer.className =
                        "gl-notifications gl-notifications--bottom-center";
                    document.body.appendChild(notificationContainer);
                }

                GeoLeaf$2._UINotifications.init({
                    container: "#gl-notifications",
                    position: "bottom-center",
                    maxVisible: 3,
                    animations: true,
                });

                AppLog.log("Système de notifications initialisé");
            } catch (e) {
                AppLog.warn("Erreur lors de l'initialisation des notifications:", e);
            }
        }

        // ========================================================
        // Toast de chargement persistant pendant le chargement des couches
        // Affiché dès que le ThemeApplier commence à charger un thème,
        // fermé quand geoleaf:theme:applied est émis.
        // ========================================================
        let _loadingToast = null;

        document.addEventListener("geoleaf:theme:applying", function () {
            // Afficher un toast persistant si le système de notifications est prêt
            if (GeoLeaf$2._UINotifications && GeoLeaf$2._UINotifications.container) {
                _loadingToast = GeoLeaf$2._UINotifications.info(
                    "Chargement des données en cours, patientez…",
                    { persistent: true, dismissible: false }
                );
            }
        });

        // ========================================================
        // Écouteurs d'événements (notifications profile & theme)
        // ========================================================
        let pendingProfileToastDetail = null;

        function notificationsReady() {
            try {
                if (
                    GeoLeaf$2.UI &&
                    GeoLeaf$2.UI.Notifications &&
                    typeof GeoLeaf$2.UI.Notifications.getStatus === "function"
                ) {
                    return !!GeoLeaf$2.UI.Notifications.getStatus().initialized;
                }
                if (GeoLeaf$2._UINotifications && GeoLeaf$2._UINotifications.container) {
                    return true;
                }
            } catch (e) {
            }
            return false;
        }

        function tryShowProfileToast(detail) {
            if (!detail || !detail.data) return false;
            const profile = detail.data.profile || {};
            const profileName =
                profile.label || profile.name || profile.title || detail.profileId || "Profil";
            const message = profileName + " chargé";
            if (!notificationsReady()) {
                pendingProfileToastDetail = detail;
                return false;
            }
            const shown = _app$1.showNotification(message);
            if (shown) pendingProfileToastDetail = null;
            else pendingProfileToastDetail = detail;
            return shown;
        }

        document.addEventListener("geoleaf:profile:loaded", function (event) {
            if (event && event.detail) {
                pendingProfileToastDetail = event.detail;
                tryShowProfileToast(event.detail);
            }
        });

        document.addEventListener("geoleaf:theme:applied", function (event) {
            // Fermer le toast de chargement persistant
            if (
                _loadingToast &&
                GeoLeaf$2._UINotifications &&
                typeof GeoLeaf$2._UINotifications.dismiss === "function"
            ) {
                GeoLeaf$2._UINotifications.dismiss(_loadingToast);
                _loadingToast = null;
            }
            if (event && event.detail) {
                const detail = event.detail;
                _app$1.showNotification(
                    `Thème "${detail.themeName}" chargé (${detail.layerCount} couches visibles)`,
                    3500
                );
            }
        });

        // Écouter la fin de chargement pour les notifications en attente
        document.addEventListener("geoleaf:map:ready", function () {
            if (pendingProfileToastDetail) {
                tryShowProfileToast(pendingProfileToastDetail);
            }
        });

        // ========================================================
        // Thème UI via GeoLeaf.setTheme() + initialisation UI
        // ========================================================
        try {
            if (typeof GeoLeaf$2.setTheme === "function") {
                GeoLeaf$2.setTheme(uiTheme);
            }
        } catch (e) {
            AppLog.warn("Erreur lors de l'appel à GeoLeaf.setTheme :", e);
        }

        if (GeoLeaf$2.UI && typeof GeoLeaf$2.UI.init === "function") {
            try {
                const mapContainer =
                    document.querySelector(".gl-main") || document.getElementById(mapTarget);
                GeoLeaf$2.UI.init({
                    buttonSelector: '[data-gl-role="theme-toggle"]',
                    map: map,
                    mapContainer: mapContainer,
                    config: cfg,
                });
            } catch (e) {
                AppLog.warn("GeoLeaf.UI.init() a levé une erreur :", e);
            }
        }

        // Construction du panneau de filtres
        // ui.showFilterPanel === false → masquer le bouton toggle + le panel et ne pas construire
        if (cfg.ui && cfg.ui.showFilterPanel === false) {
            const _toggleBtn = document.getElementById("gl-filter-toggle");
            if (_toggleBtn) _toggleBtn.style.display = "none";
            const _filterPanel = document.getElementById("gl-filter-panel");
            if (_filterPanel) _filterPanel.style.display = "none";
        } else if (GeoLeaf$2.UI && typeof GeoLeaf$2.UI.buildFilterPanelFromActiveProfile === "function") {
            try {
                let filterContainer = document.getElementById("gl-filter-panel");
                if (!filterContainer) {
                    filterContainer = document.createElement("div");
                    filterContainer.id = "gl-filter-panel";
                    filterContainer.setAttribute("data-gl-role", "filter-panel");
                    const glMain = document.querySelector(".gl-main");
                    if (glMain) glMain.appendChild(filterContainer);
                    else document.body.appendChild(filterContainer);
                }

                GeoLeaf$2.UI.buildFilterPanelFromActiveProfile({ container: filterContainer });

                if (typeof GeoLeaf$2.UI.initFilterToggle === "function") {
                    GeoLeaf$2.UI.initFilterToggle();
                }
                if (typeof GeoLeaf$2.UI.initProximityFilter === "function") {
                    GeoLeaf$2.UI.initProximityFilter(map);
                }
            } catch (e) {
                AppLog.warn("Erreur lors de la construction du panneau de filtres :", e);
            }
        }

        // ========================================================
        // Sprint 6: Chargement des modules secondaires (code splitting)
        // En mode ESM → charge les chunks réseau en parallèle.
        // En mode UMD → déjà inliné, résolution immédiate.
        // ========================================================
        if (secondaryModulesPromise) {
            try {
                await secondaryModulesPromise;
                AppLog.log(
                    "Modules secondaires chargés (POI, Route, Legend, LayerManager, Labels, Themes, Table)."
                );
            } catch (e) {
                AppLog.warn("Erreur chargement modules secondaires:", e);
            }
        }

        // Initialisation du module Table
        // ui.showTable !== false → même pattern que showLegend / showLayerManager
        if (
            cfg.ui &&
            cfg.ui.showTable !== false &&
            GeoLeaf$2.Table &&
            typeof GeoLeaf$2.Table.init === "function" &&
            cfg.tableConfig &&
            cfg.tableConfig.enabled !== false
        ) {
            try {
                GeoLeaf$2.Table.init({ map: map, config: cfg.tableConfig });
                AppLog.log("Module Table initialisé.");
            } catch (e) {
                AppLog.warn("Erreur lors de l'initialisation du module Table :", e);
            }
        }

        // Initialisation du bouton de cache offline (si plugin Storage chargé)
        if (GeoLeaf$2.UI && GeoLeaf$2.UI.CacheButton && typeof GeoLeaf$2.UI.CacheButton.init === "function") {
            try {
                GeoLeaf$2.UI.CacheButton.init(map, cfg);
                AppLog.log("Bouton de cache initialisé.");
            } catch (e) {
                AppLog.warn("Erreur lors de l'initialisation du bouton de cache :", e);
            }
        }

        // ========================================================
        // Basemaps via GeoLeaf.BaseLayers
        // ========================================================
        initBasemaps({ GeoLeaf: GeoLeaf$2, cfg, map, AppLog });

        // ========================================================
        // POI via GeoLeaf.POI
        // ========================================================
        initPOI({ GeoLeaf: GeoLeaf$2, cfg, map, AppLog });

        // ========================================================
        // Itinéraires via GeoLeaf.Route
        // ========================================================
        initRoute({ GeoLeaf: GeoLeaf$2, cfg, map, AppLog });

        // ========================================================
        // Couches GeoJSON via GeoLeaf.GeoJSON
        // ========================================================
        initGeoJSON({ GeoLeaf: GeoLeaf$2, map, AppLog, _app: _app$1 });

        // ========================================================
        // Branding
        // ========================================================
        if (GeoLeaf$2.UI && GeoLeaf$2.UI.Branding && typeof GeoLeaf$2.UI.Branding.init === "function") {
            try {
                GeoLeaf$2.UI.Branding.init(map);
            } catch (e) {
                AppLog.warn("GeoLeaf.UI.Branding.init() a levé une erreur :", e);
            }
        }

        // ========================================================
        // Légende et gestionnaire de couches
        // ========================================================
        if (
            cfg.ui &&
            cfg.ui.showLegend !== false &&
            GeoLeaf$2.Legend &&
            typeof GeoLeaf$2.Legend.init === "function"
        ) {
            try {
                GeoLeaf$2.Legend.init(map, {
                    position: "bottomleft",
                    collapsible: true,
                    collapsed: false,
                    title: "Légende",
                });
            } catch (e) {
                AppLog.warn("Erreur lors de l'initialisation du module Legend:", e);
            }
        }

        if (
            cfg.ui &&
            cfg.ui.showLayerManager !== false &&
            GeoLeaf$2.LayerManager &&
            typeof GeoLeaf$2.LayerManager.init === "function"
        ) {
            try {
                GeoLeaf$2.LayerManager.init({ map: map, position: "bottomright" });
            } catch (e) {
                AppLog.warn("GeoLeaf.LayerManager.init() a levé une erreur :", e);
            }
        }

        // ========================================================
        // Contrôle d'échelle
        // ========================================================
        if (GeoLeaf$2.initScaleControl && typeof GeoLeaf$2.initScaleControl === "function") {
            try {
                GeoLeaf$2.initScaleControl(map);
            } catch (e) {
                AppLog.warn("GeoLeaf.initScaleControl() a levé une erreur :", e);
            }
        }

        // ========================================================
        // Système de labels
        // ========================================================
        if (GeoLeaf$2.Labels && typeof GeoLeaf$2.Labels.init === "function") {
            try {
                GeoLeaf$2.Labels.init({ map: map });
            } catch (e) {
                AppLog.warn("GeoLeaf.Labels.init() a levé une erreur :", e);
            }
        }

        // ========================================================
        // Affichage des coordonnées
        // ========================================================
        if (
            cfg.ui &&
            cfg.ui.showCoordinates !== false &&
            GeoLeaf$2.UI &&
            GeoLeaf$2.UI.CoordinatesDisplay &&
            typeof GeoLeaf$2.UI.CoordinatesDisplay.init === "function"
        ) {
            try {
                GeoLeaf$2.UI.CoordinatesDisplay.init(map, { position: "bottomleft", decimals: 6 });
            } catch (e) {
                AppLog.warn("GeoLeaf.UI.CoordinatesDisplay.init() a levé une erreur :", e);
            }
        }

        // ========================================================
        // Révéler l'application quand les couches sont prêtes
        // Le spinner #gl-loader reste opaque pendant que la carte
        // et les couches GeoJSON se chargent derrière.
        // On attend l'événement geoleaf:theme:applied (= toutes
        // les couches visibles sont chargées) avant de révéler.
        // ========================================================
        let _appRevealed = false;
        function revealApp(reason) {
            if (_appRevealed) return;
            _appRevealed = true;
            const loader = document.getElementById("gl-loader");
            if (loader) {
                loader.classList.add("gl-loader--fade");
                // Supprimer du DOM après la transition CSS (400ms)
                // { once: true } garantit qu'on n'appelle pas hide() plusieurs fois
                loader.addEventListener(
                    "transitionend",
                    function () {
                        loader.style.display = "none";
                    },
                    { once: true }
                );
                // Fallback si transitionend ne se déclenche pas — 800ms > durée transition
                // (valeur > durée transition pour laisser transitionend s'exécuter en premier)
                setTimeout(function () {
                    loader.style.display = "none";
                }, 800);
            }

            // Correctif : le loader (#gl-loader) recouvrait la carte (position: fixed; inset: 0)
            // → Leaflet calculait fitBounds sur un conteneur de dimensions incorrectes.
            // On recalcule après le retrait du loader.
            if (map) {
                map.invalidateSize({ pan: false });
                setTimeout(function () {
                    try {
                        map.fitBounds(profileBounds, {
                            maxZoom: profileMaxZoom,
                            padding: profilePadding,
                            animate: true,
                            duration: 0.6,
                        });
                    } catch (e) {
                        AppLog.warn("[GeoLeaf] Correctif fitBounds au reveal :", e);
                    }
                }, 120);
            }

            document.dispatchEvent(new CustomEvent("geoleaf:map:ready"));
            // Émettre l'événement de fin d'initialisation de l'application
            // (utilisé par boot.js pour afficher le boot toast via GeoLeaf.bootInfo)
            document.dispatchEvent(
                new CustomEvent("geoleaf:app:ready", {
                    detail: {
                        version: GeoLeaf$2._version,
                        timestamp: Date.now(),
                    },
                })
            );
            AppLog.info("Application prête — " + reason);
            // perf 5 — benchmark: mesure du temps total de démarrage
            if (typeof performance !== "undefined" && performance.mark) {
                performance.mark("geoleaf:initApp:ready");
                try {
                    performance.measure(
                        "geoleaf:startup-total",
                        "geoleaf:initApp:start",
                        "geoleaf:initApp:ready"
                    );
                    const entries = performance.getEntriesByName("geoleaf:startup-total", "measure");
                    if (entries.length) {
                        AppLog.info(
                            "[Perf] ⏱ Startup total: " +
                                entries[entries.length - 1].duration.toFixed(1) +
                                "ms"
                        );
                    }
                } catch (error) {
                }
            }
        }

        // Attendre que toutes les couches du thème soient chargées
        document.addEventListener(
            "geoleaf:theme:applied",
            function () {
                revealApp("thème appliqué, couches chargées");
            },
            { once: true }
        );

        // Sécurité : révéler après 5s max (réseau lent, erreur…) — perf 5.10: réduit de 15s à 5s
        setTimeout(function () {
            revealApp("timeout sécurité 5s");
        }, 5000);

        AppLog.info("Application initialisée, chargement des couches en arrière-plan…");
    };

    /*!
     * GeoLeaf Core – App / Boot
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    const GeoLeaf$1 = _g.GeoLeaf;
    const _app = (GeoLeaf$1._app = GeoLeaf$1._app || {});

    // ============================================================
    // Fonction startApp : chargement config + lancement initApp
    // ============================================================
    _app.startApp = async function () {
        const AppLog = _app.AppLog;

        if (!GeoLeaf$1) {
            AppLog.error(
                "GeoLeaf global introuvable. Le bundle core doit être chargé avant GeoLeaf.boot()."
            );
            return;
        }

        if (typeof GeoLeaf$1.loadConfig !== "function") {
            AppLog.error(
                "GeoLeaf.loadConfig() est introuvable. Vérifiez que le bundle core est complet."
            );
            return;
        }

        AppLog.info("Démarrage de l'application...");

        // Écouter l'événement de fin d'initialisation pour afficher le boot toast
        // (après que l'UI soit prête — sinon GeoLeaf.UI.notify n'existe pas encore)
        document.addEventListener(
            "geoleaf:app:ready",
            function _onAppReady() {
                if (GeoLeaf$1.bootInfo?.show) {
                    GeoLeaf$1.bootInfo.show(GeoLeaf$1);
                }
            },
            { once: true }
        );

        let selectedProfile = null;
        try {
            const rawProfile = sessionStorage.getItem("gl-selected-profile");
            // Validate profile ID: alphanumeric, hyphens, underscores, max 50 chars
            if (rawProfile && /^[a-zA-Z0-9_-]{1,50}$/.test(rawProfile)) {
                selectedProfile = rawProfile;
                AppLog.log("Profil sélectionné depuis sessionStorage:", selectedProfile);
            } else if (rawProfile) {
                AppLog.warn(
                    "Profil sessionStorage rejeté (format invalide):",
                    rawProfile.substring(0, 20)
                );
            }
            sessionStorage.removeItem("gl-selected-profile");
        } catch (e) {
            AppLog.warn("Impossible de lire sessionStorage:", e);
        }

        const profilesPath = _app.getProfilesBasePath();

        // perf 5.4 : wrapper loadConfig (callback) en Promise pour pouvoir chaîner
        const configPromise = new Promise((resolve, reject) => {
            GeoLeaf$1.loadConfig({
                url: profilesPath + "geoleaf.config.json",
                profileId: selectedProfile,
                autoEvent: true,
                onLoaded: resolve,
                onError: reject,
            });
        });

        let cfg;
        try {
            cfg = await configPromise;
            AppLog.log("Configuration chargée via GeoLeaf.loadConfig :", cfg || {});
        } catch (err) {
            AppLog.error("Erreur chargement config via GeoLeaf.loadConfig :", err);
            return;
        }

        if (GeoLeaf$1.Config && typeof GeoLeaf$1.Config.getCategories === "function") {
            try {
                GeoLeaf$1.Config.getCategories();
            } catch (e) {
                AppLog.warn("Erreur lors de la lecture du mapping catégories :", e);
            }
        }

        const baseCfg = cfg || {};

        if (GeoLeaf$1.Config && typeof GeoLeaf$1.Config.loadActiveProfileResources === "function") {
            try {
                const profileCfg = await GeoLeaf$1.Config.loadActiveProfileResources();
                AppLog.info("Ressources du profil actif chargées.");
                _app.initApp(profileCfg || baseCfg);
            } catch (err) {
                AppLog.warn("Erreur lors du chargement des ressources de profil :", err);
                _app.initApp(baseCfg);
            }
        } else {
            _app.initApp(baseCfg);
        }
    };

    // ============================================================
    // Exposer GeoLeaf.boot() — API publique
    // ============================================================

    /**
     * Démarre l'application GeoLeaf.
     * Charge la configuration, initialise la carte et tous les modules.
     * Les plugins optionnels (Storage, AddPOI) doivent être chargés avant cet appel.
     *
     * @example
     * <script src="dist/geoleaf.umd.js"></script>
     * <script src="dist/geoleaf-storage.plugin.js"></script>  <!-- optionnel -->
     * <script src="dist/geoleaf-addpoi.plugin.js"></script>   <!-- optionnel -->
     * <script>GeoLeaf.boot();</script>
     */
    GeoLeaf$1.boot = function () {
        // Rapport plugins premium — silencieux si aucun chargé (core seul)
        GeoLeaf$1.plugins?.reportPremiumPlugins?.();

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", _app.startApp);
        } else {
            _app.startApp();
        }
    };

    /*!
     * GeoLeaf Core
     * © 2026 Mattieu Pottier
     * Released under the MIT License
     * https://geoleaf.dev
     */


    // ── Sprint 6 / Phase 7: Module loader pour code splitting ──
    // En mode ESM, ces import() produisent des chunks séparés dans dist/chunks/.
    // En mode UMD, Rollup les inline (bundle unique, compatible backward).
    const _gl = typeof globalThis !== "undefined" ? globalThis : window;
    _gl.GeoLeaf = _gl.GeoLeaf || {};

    /**
     * Table des resolvers lazy — Map extensible des modules GeoLeaf.
     * Remplace le switch-case statique (C8).
     * En mode UMD le code est déjà inliné → résolution immédiate.
     * En mode ESM → chunk réseau séparé.
     */
    const _lazyModuleResolvers = new Map([
        // POI : chargement complet (core → renderers + extras en parallèle)
        [
            "poi",
            async () => {
                await Promise.resolve().then(function () { return poiCore; });
                await Promise.all([Promise.resolve().then(function () { return poiRenderers; }), Promise.resolve().then(function () { return poiExtras; })]);
            },
        ],
        // POI sub-chunks (chargement granulaire)
        ["poiCore", () => Promise.resolve().then(function () { return poiCore; })],
        ["poiRenderers", () => Promise.resolve().then(function () { return poiRenderers; })],
        ["poiExtras", () => Promise.resolve().then(function () { return poiExtras; })],
        ["basemapSelector", () => Promise.resolve().then(function () { return basemapSelector; })],
        ["route", () => Promise.resolve().then(function () { return route; })],
        ["layerManager", () => Promise.resolve().then(function () { return layerManager; })],
        ["legend", () => Promise.resolve().then(function () { return legend; })],
        ["labels", () => Promise.resolve().then(function () { return labels; })],
        ["themes", () => Promise.resolve().then(function () { return themes; })],
        ["table", () => Promise.resolve().then(function () { return table; })],
    ]);

    // Enregistrer les resolvers dans PluginRegistry (après globals.js via ESM hoisting)
    if (_gl.GeoLeaf.plugins?.registerLazy) {
        for (const [name, resolver] of _lazyModuleResolvers) {
            _gl.GeoLeaf.plugins.registerLazy(name, resolver);
        }
    }

    /**
     * Charge un module secondaire à la demande.
     * @param {string} moduleName - Nom du module ('poi','route','table','legend','layerManager','labels','themes')
     * @returns {Promise<void>}
     */
    _gl.GeoLeaf._loadModule = async function (moduleName) {
        const resolver = _lazyModuleResolvers.get(moduleName);
        if (!resolver) {
            console.warn(
                `[GeoLeaf] Module inconnu : "${moduleName}". Disponibles : ${[..._lazyModuleResolvers.keys()].join(", ")}`
            );
            return;
        }
        try {
            await resolver();
            _gl.GeoLeaf.plugins?.register(moduleName, { version: _gl.GeoLeaf._version });
        } catch (err) {
            console.error(`[GeoLeaf] Erreur lors du chargement du module "${moduleName}" :`, err);
            throw err;
        }
    };

    /**
     * Charge tous les modules secondaires en parallèle.
     * Appelé par init.js pour pré-charger avant l'initialisation.
     * @returns {Promise<void>}
     */
    _gl.GeoLeaf._loadAllSecondaryModules = async function () {
        // POI core en premier (poi-renderers/extras/add-form en dépendent)
        await Promise.resolve().then(function () { return poiCore; });
        await Promise.all([
            Promise.resolve().then(function () { return poiRenderers; }),
            Promise.resolve().then(function () { return poiExtras; }),
            Promise.resolve().then(function () { return route; }),
            Promise.resolve().then(function () { return layerManager; }),
            Promise.resolve().then(function () { return legend; }),
            Promise.resolve().then(function () { return labels; }),
            Promise.resolve().then(function () { return themes; }),
            Promise.resolve().then(function () { return table; }),
        ]);
    };

    // Export du namespace global GeoLeaf tel qu'assemblé par globals.js
    // ⚠️ Ce `export default` est le SEUL export — PAS de named exports ici.
    //    Ainsi le bundle UMD assigne window.GeoLeaf = l'objet GeoLeaf existant (pas un wrapper).
    var bundleEntry = typeof window !== "undefined" ? window.GeoLeaf : {};

    /**
     * GeoLeaf Lazy Chunk — POI Core
     * Noyau du module POI : état partagé, normalisation, marqueurs, logique principale.
     * Chargé en premier lors du code splitting POI (les autres chunks en dépendent).
     * @module lazy/poi-core
     */

    var poiCore = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — POI Renderers
     * Système de rendu du contenu POI : champs, médias, liens, lightbox, sections.
     * Dépend de poi-core (doit être chargé après).
     * @module lazy/poi-renderers
     */

    var poiRenderers = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — POI Extras
     * Fonctionnalités POI complémentaires : popups, panneau latéral.
     * Dépend de poi-core (doit être chargé après).
     * Note: image-upload, sync-handler, placement-mode → GeoLeaf-Plugins/plugin-addpoi
     * @module lazy/poi-extras
     */

    var poiExtras = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Basemap Selector
     * Sélecteur de fond de carte, chargé conditionnellement selon la configuration.
     * @module lazy/basemap-selector
     */

    var basemapSelector = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Route
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/route
     */

    var route = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — LayerManager
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/layer-manager
     */

    var layerManager = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Legend
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/legend
     */

    var legend = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Labels
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/labels
     */

    var labels = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Themes (loader + applier + selector)
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/themes
     */

    var themes = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * GeoLeaf Lazy Chunk — Table
     * Chargé à la demande via import() dynamique (Sprint 6 code splitting).
     * @module lazy/table
     */

    var table = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    exports.default = bundleEntry;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=geoleaf.umd.js.map
