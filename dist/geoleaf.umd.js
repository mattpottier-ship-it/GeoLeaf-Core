(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.GeoLeaf = {}));
})(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var geoleaf_log = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_log;

	function requireGeoleaf_log () {
		if (hasRequiredGeoleaf_log) return geoleaf_log;
		hasRequiredGeoleaf_log = 1;
		(function (global) {

		    /**
		     * GeoLeaf.Log ‚Äî gestion centralis√©e des logs
		     *
		     * Objectif :
		     * - remplacer tous les console.log/console.warn/... du projet
		     * - fournir un niveau de verbosit√© configurable via la config JSON
		     * - s‚Äôassurer que chaque message poss√®de un pr√©fixe normalis√© [GeoLeaf.X]
		     */

		    if (!global.GeoLeaf) global.GeoLeaf = {};

		    const LEVELS = {
		        DEBUG: 0,
		        INFO: 1,
		        WARN: 2,
		        ERROR: 3
		    };

		    let currentLevel = LEVELS.INFO; // niveau par d√©faut
		    let quietMode = false; // mode silencieux pour les logs r√©p√©titifs
		    let groupedMessageCounts = new Map(); // pour grouper les messages similaires

		    const formatPrefix = (type) => `[GeoLeaf.${type}]`;

		    // D√©tecte si un message est r√©p√©titif ou informatif non critique
		    const isRepetitiveMessage = (message) => {
		        const patterns = [
		            /Chargement du sprite SVG/,
		            /Sprite SVG d√©tect√©/,
		            /IconsConfig r√©cup√©r√©/,
		            /Module.*charg√©/,
		            /Module.*initialis√©/,
		            /Contr√¥le.*ajout√©/,
		            /Bouton.*ajout√©/,
		            /Panneau.*cr√©√©/,
		            /Section.*remplie/,
		            /Profil.*charg√©/,
		            /Couche.*charg√©e/,
		            /Style.*appliqu√©/,
		            /ThemeApplier/,
		            /LayerManager/,
		            /Storage/,
		            /CacheButton/,
		            /Renderers\./,
		            /FormRenderer/,
		            /ResourceEnumerator/,
		            /LayerSelector/,
		            /CacheControl/,
		            /POI.*DEBUG/,
		            /AddForm/
		        ];
		        return patterns.some(pattern => pattern.test(message));
		    };

		    // Messages critiques qui doivent toujours √™tre affich√©s
		    const isCriticalMessage = (message) => {
		        const criticalPatterns = [
		            /ERROR/,
		            /WARN/,
		            /Failed/,
		            /Error/,
		            /Exception/,
		            /Carte initialis√©e avec succ√®s/,
		            /All.*modules loaded/,
		            /Mode.*activ√©/
		        ];
		        return criticalPatterns.some(pattern => pattern.test(message));
		    };

		    // G√®re les messages group√©s
		    const handleGroupedMessage = (message, args) => {
		        const key = message.replace(/\d+/g, 'X').replace(/[{}:,]/g, ''); // normalise
		        const count = (groupedMessageCounts.get(key) || 0) + 1;
		        groupedMessageCounts.set(key, count);

		        if (count === 1) {
		            return true; // affiche le premier
		        } else if (count === 3 && !isCriticalMessage(message)) {
		            console.info(`${formatPrefix('INFO')} [Group√©] Message r√©p√©t√© - suite masqu√©e: ${message.substring(0, 60)}...`);
		            return false;
		        } else if (count > 3) {
		            return false; // supprime apr√®s 3 occurrences pour les non-critiques
		        }
		        return count <= 2; // affiche max 2 fois les messages non critiques
		    };

		    const Log = {
		        /**
		         * D√©finir le niveau de logs global
		         * @param {string} level  "debug" | "info" | "warn" | "error"
		         */
		        setLevel(level) {
		            const lvl = String(level).toLowerCase();
		            switch (lvl) {
		                case "debug":
		                    currentLevel = LEVELS.DEBUG;
		                    break;
		                case "info":
		                    currentLevel = LEVELS.INFO;
		                    break;
		                case "warn":
		                    currentLevel = LEVELS.WARN;
		                    break;
		                case "error":
		                    currentLevel = LEVELS.ERROR;
		                    break;
		                case "production":
		                    currentLevel = LEVELS.WARN; // En production, seulement WARN et ERROR
		                    quietMode = true;
		                    break;
		                default:
		                    console.warn(`${formatPrefix("WARN")} Niveau de log inconnu :`, level);
		            }
		        },

		        /**
		         * Active/d√©sactive le mode silencieux pour les messages r√©p√©titifs
		         */
		        setQuietMode(enabled) {
		            if (quietMode === enabled) return; // √©viter les r√©p√©titions
		            quietMode = enabled;
		            if (enabled) {
		                console.info(`${formatPrefix("INFO")} Mode silencieux activ√© - logs r√©p√©titifs r√©duits`);
		            }
		        },

		        /**
		         * Affiche un r√©sum√© des messages group√©s
		         */
		        showSummary() {
		            if (groupedMessageCounts.size > 0) {
		                console.group(`${formatPrefix("INFO")} R√©sum√© des logs group√©s:`);
		                for (const [message, count] of groupedMessageCounts) {
		                    if (count > 3) {
		                        console.info(`‚Ä¢ ${count}x: ${message.substring(0, 60)}...`);
		                    }
		                }
		                console.groupEnd();
		            }
		        },

		        debug(...args) {
		            if (currentLevel <= LEVELS.DEBUG) {
		                const message = args.join(' ');
		                if (quietMode && isRepetitiveMessage(message)) {
		                    if (!handleGroupedMessage(message)) return;
		                }
		                console.debug(formatPrefix("DEBUG"), ...args);
		            }
		        },

		        info(...args) {
		            if (currentLevel <= LEVELS.INFO) {
		                const message = args.join(' ');

		                // En mode silencieux, filtrer plus agressivement
		                if (quietMode) {
		                    // Toujours afficher les messages critiques
		                    if (isCriticalMessage(message)) {
		                        console.info(formatPrefix("INFO"), ...args);
		                        return;
		                    }

		                    // Grouper/masquer les messages r√©p√©titifs
		                    if (isRepetitiveMessage(message)) {
		                        if (!handleGroupedMessage(message)) return;
		                    }
		                }

		                console.info(formatPrefix("INFO"), ...args);
		            }
		        },

		        warn(...args) {
		            if (currentLevel <= LEVELS.WARN) {
		                console.warn(formatPrefix("WARN"), ...args);
		            }
		        },

		        error(...args) {
		            if (currentLevel <= LEVELS.ERROR) {
		                console.error(formatPrefix("ERROR"), ...args);
		            }
		        }
		    };

		    global.GeoLeaf.Log = Log;

		})(typeof globalThis !== "undefined" ? globalThis : window);
		return geoleaf_log;
	}

	requireGeoleaf_log();

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	/**
	 * Configuration globale des logs pour GeoLeaf
	 * Applique automatiquement les bonnes configurations de log selon l'environnement
	 */

	(function() {

	    // Attendre que GeoLeaf.Log soit charg√©
	    function configureLogging() {
	        if (!window.GeoLeaf || !window.GeoLeaf.Log) {
	            setTimeout(configureLogging, 50);
	            return;
	        }

	        const Log = window.GeoLeaf.Log;

	        // D√©tecter l'environnement
	        const isProduction = location.hostname !== 'localhost' && !location.hostname.includes('127.0.0.1') && !location.search.includes('debug=true');
	        const isDebug = location.search.includes('debug=true') || location.search.includes('verbose=true');

	        if (isProduction) {
	            // Production: seulement warnings et erreurs + mode silencieux
	            Log.setLevel('production');
	            if (window.GeoLeaf && GeoLeaf.Log && GeoLeaf.Log.info) { GeoLeaf.Log.info("üîß [GeoLeaf] Mode production activ√© - logs r√©duits"); }
	        } else if (isDebug) {
	            // Debug explicite: tous les logs
	            Log.setLevel('debug');
	            Log.setQuietMode(false);
	            if (window.GeoLeaf && GeoLeaf.Log && GeoLeaf.Log.info) { GeoLeaf.Log.info("üîß [GeoLeaf] Mode debug activ√© - tous les logs visibles"); }
	        } else {
	            // D√©veloppement: logs informatifs avec mode silencieux pour r√©duire les r√©p√©titions
	            Log.setLevel('info');
	            Log.setQuietMode(true);
	            if (window.GeoLeaf && GeoLeaf.Log && GeoLeaf.Log.info) { GeoLeaf.Log.info("üîß [GeoLeaf] Mode d√©veloppement - logs optimis√©s"); }
	        }

	        // Afficher un r√©sum√© apr√®s chargement complet
	        setTimeout(() => {
	            if (Log.showSummary) {
	                Log.showSummary();
	            }

	            // Afficher un r√©sum√© de d√©marrage concis
	            const endTime = performance.now();
	            if (window.GeoLeaf && GeoLeaf.Log && GeoLeaf.Log.info) {
	                GeoLeaf.Log.info("üéØ [GeoLeaf] D√©marrage termin√©:", {
	                    "‚è±Ô∏è Temps total": Math.round(endTime) + "ms",
	                    "üì¶ Modules": "122 charg√©s",
	                    "üîá Logs": isProduction ? "mode production" : (isDebug ? "mode debug" : "mode optimis√©"),
	                    "üí° Conseil": isDebug ? "" : "Ajoutez ?debug=true pour les logs d√©taill√©s"
	                });
	            }
	        }, 3000);
	    }

	    // D√©marrer la configuration d√®s que possible
	    if (document.readyState === 'loading') {
	        document.addEventListener('DOMContentLoaded', configureLogging);
	    } else {
	        configureLogging();
	    }
	})();

	var geoleaf_security = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_security;

	function requireGeoleaf_security () {
		if (hasRequiredGeoleaf_security) return geoleaf_security;
		hasRequiredGeoleaf_security = 1;
		/**
		 * @fileoverview Module de s√©curit√© GeoLeaf
		 * G√®re l'√©chappement HTML, validation URLs, sanitization
		 *
		 * @module GeoLeaf.Security
		 * @version 2.0.0
		 * @author GeoLeaf Project
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // Logger (d√©fini par geoleaf.logger-shim.js charg√© en premier)
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Security - Fonctions de s√©curit√© centralis√©es
		     * @namespace
		     */
		    const Security = {
		        /**
		         * √âchappe les caract√®res HTML dangereux pour pr√©venir XSS
		         * @param {string} str - Cha√Æne √† √©chapper
		         * @returns {string} Cha√Æne √©chapp√©e
		         * @example
		         * Security.escapeHtml('<script>alert(1)</script>')
		         * // Returns: '&lt;script&gt;alert(1)&lt;/script&gt;'
		         */
		        escapeHtml(str) {
		            if (str === null || str === undefined) {
		                return "";
		            }

		            if (typeof str !== "string") {
		                str = String(str);
		            }

		            const div = document.createElement("div");
		            div.textContent = str;
		            // SAFE: innerHTML here gets the escaped version of textContent
		            return div.innerHTML;
		        },

		        /**
		         * √âchappe les attributs HTML pour utilisation dans des attributs
		         * @param {string} str - Cha√Æne √† √©chapper
		         * @returns {string} Cha√Æne √©chapp√©e
		         * @example
		         * Security.escapeAttribute('value"onclick="alert(1)')
		         * // Returns: 'value&quot;onclick=&quot;alert(1)'
		         */
		        escapeAttribute(str) {
		            if (str === null || str === undefined) {
		                return "";
		            }

		            if (typeof str !== "string") {
		                str = String(str);
		            }

		            return str
		                .replace(/&/g, "&amp;")
		                .replace(/'/g, "&#39;")
		                .replace(/"/g, "&quot;")
		                .replace(/</g, "&lt;")
		                .replace(/>/g, "&gt;");
		        },

		        /**
		         * Valide une URL strictement avec whitelist de protocoles
		         * @param {string} url - URL √† valider
		         * @param {string} [baseUrl] - URL de base pour r√©solution relative
		         * @returns {string} URL valid√©e
		         * @throws {Error} Si URL invalide ou protocole non autoris√©
		         * @example
		         * Security.validateUrl('https://example.com/data.json')
		         * // Returns: 'https://example.com/data.json'
		         *
		         * Security.validateUrl('javascript:alert(1)')
		         * // Throws: Error
		         */
		        validateUrl(url, baseUrl) {
		            if (!url || typeof url !== "string") {
		                throw new TypeError("URL must be a non-empty string");
		            }

		            // Normaliser l'URL
		            url = url.trim();

		            const base = baseUrl || global.location.origin;

		            try {
		                const parsed = new URL(url, base);

		                // Whitelist de protocoles autoris√©s
		                const ALLOWED_PROTOCOLS = ["http:", "https:", "data:"];

		                if (!ALLOWED_PROTOCOLS.includes(parsed.protocol)) {
		                    throw new Error(
		                        `Protocol "${parsed.protocol}" not allowed. ` +
		                            `Allowed protocols: ${ALLOWED_PROTOCOLS.join(", ")}`
		                    );
		                }

		                // Validation suppl√©mentaire pour data: URLs
		                if (parsed.protocol === "data:") {
		                    // Autoriser uniquement les images
		                    const allowedDataTypes = [
		                        "image/png",
		                        "image/jpeg",
		                        "image/jpg",
		                        "image/gif",
		                        "image/svg+xml",
		                        "image/webp",
		                    ];

		                    const dataPrefix = url.split(",")[0];
		                    const mimeMatch = dataPrefix.match(/data:([^;,]+)/);

		                    if (!mimeMatch) {
		                        throw new Error("Invalid data URL format");
		                    }

		                    const mimeType = mimeMatch[1];

		                    if (!allowedDataTypes.includes(mimeType)) {
		                        throw new Error(
		                            `Data URL type "${mimeType}" not allowed. ` +
		                                `Allowed: ${allowedDataTypes.join(", ")}`
		                        );
		                    }
		                }

		                return parsed.href;
		            } catch (e) {
		                if (e.message.includes("not allowed")) {
		                    throw e;
		                }
		                throw new Error(`Invalid URL "${url}": ${e.message}`);
		            }
		        },

		        /**
		         * Valide des coordonn√©es g√©ographiques
		         * @param {number} lat - Latitude
		         * @param {number} lng - Longitude
		         * @returns {[number, number]} Coordonn√©es valid√©es [lat, lng]
		         * @throws {TypeError} Si les coordonn√©es ne sont pas des nombres
		         * @throws {RangeError} Si les coordonn√©es sont hors limites
		         * @example
		         * Security.validateCoordinates(45.5, -73.6)
		         * // Returns: [45.5, -73.6]
		         *
		         * Security.validateCoordinates(999, 0)
		         * // Throws: RangeError
		         */
		        validateCoordinates(lat, lng) {
		            if (typeof lat !== "number" || typeof lng !== "number") {
		                throw new TypeError(
		                    `Coordinates must be numbers, got lat=${typeof lat}, lng=${typeof lng}`
		                );
		            }

		            if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
		                throw new RangeError("Coordinates must be finite numbers (not NaN or Infinity)");
		            }

		            if (lat < -90 || lat > 90) {
		                throw new RangeError(`Latitude must be between -90 and 90, got ${lat}`);
		            }

		            if (lng < -180 || lng > 180) {
		                throw new RangeError(`Longitude must be between -180 and 180, got ${lng}`);
		            }

		            return [lat, lng];
		        },

		        /**
		         * Sanitize un objet de propri√©t√©s POI
		         * √âchappe les champs texte et valide les URLs
		         * @param {Object} props - Propri√©t√©s √† sanitizer
		         * @returns {Object} Propri√©t√©s sanitiz√©es
		         * @example
		         * Security.sanitizePoiProperties({
		         *   label: '<script>alert(1)</script>',
		         *   url: 'https://example.com'
		         * })
		         * // Returns: { label: '&lt;script&gt;...', url: 'https://example.com' }
		         */
		        sanitizePoiProperties(props) {
		            if (!props || typeof props !== "object") {
		                return {};
		            }

		            const sanitized = {};

		            // Champs texte √† √©chapper
		            const textFields = [
		                "label",
		                "name",
		                "title",
		                "description",
		                "desc",
		                "address",
		                "phone",
		                "email",
		                "category",
		                "type",
		            ];

		            // Champs URL √† valider
		            const urlFields = ["url", "website", "image", "photo", "icon"];

		            for (const [key, value] of Object.entries(props)) {
		                // Ignorer les fonctions et symboles
		                if (typeof value === "function" || typeof value === "symbol") {
		                    continue;
		                }

		                // Null/undefined = cha√Æne vide
		                if (value === null || value === undefined) {
		                    sanitized[key] = "";
		                    continue;
		                }

		                // √âchapper les champs texte
		                if (textFields.includes(key) && typeof value === "string") {
		                    sanitized[key] = this.escapeHtml(value);
		                }
		                // Valider les URLs
		                else if (urlFields.includes(key) && typeof value === "string") {
		                    try {
		                        sanitized[key] = this.validateUrl(value);
		                    } catch (e) {
		                        Log.warn(`[Security] Invalid URL for ${key}: ${e.message}`);
		                        sanitized[key] = "";
		                    }
		                }
		                // Tableaux : sanitizer r√©cursivement
		                else if (Array.isArray(value)) {
		                    sanitized[key] = value.map((item) => {
		                        if (typeof item === "object" && item !== null) {
		                            return this.sanitizePoiProperties(item);
		                        }
		                        if (typeof item === "string") {
		                            return this.escapeHtml(item);
		                        }
		                        return item;
		                    });
		                }
		                // Objets : sanitizer r√©cursivement
		                else if (typeof value === "object" && value !== null) {
		                    sanitized[key] = this.sanitizePoiProperties(value);
		                }
		                // Autres types : conserver tel quel
		                else {
		                    sanitized[key] = value;
		                }
		            }

		            return sanitized;
		        },

		        /**
		         * V√©rifie si une cha√Æne contient du HTML potentiellement dangereux
		         * @param {string} str - Cha√Æne √† v√©rifier
		         * @returns {boolean} True si contient du HTML dangereux
		         * @example
		         * Security.containsDangerousHtml('<script>alert(1)</script>')
		         * // Returns: true
		         */
		        containsDangerousHtml(str) {
		            if (typeof str !== "string") {
		                return false;
		            }

		            const dangerousPatterns = [
		                /<script/i,
		                /javascript:/i,
		                /on\w+\s*=/i, // onclick=, onerror=, etc.
		                /<iframe/i,
		                /<object/i,
		                /<embed/i,
		                /<applet/i,
		                /<meta/i,
		                /<link/i,
		                /vbscript:/i,
		                /data:text\/html/i,
		            ];

		            return dangerousPatterns.some((pattern) => pattern.test(str));
		        },

		        /**
		         * Nettoie une cha√Æne de tout HTML (garde uniquement le texte)
		         * @param {string} html - HTML √† nettoyer
		         * @returns {string} Texte uniquement
		         * @example
		         * Security.stripHtml('<p>Hello <b>World</b></p>')
		         * // Returns: 'Hello World'
		         */
		        stripHtml(html) {
		            if (typeof html !== "string") {
		                return "";
		            }

		            // SAFE: Utilisation de DOMParser au lieu de innerHTML pour √©viter l'ex√©cution de scripts
		            const parser = new DOMParser();
		            const doc = parser.parseFromString(html, 'text/html');
		            return doc.body.textContent || doc.body.innerText || "";
		        },

		        /**
		         * Cr√©e un √©l√©ment DOM de mani√®re s√©curis√©e en √©chappant automatiquement le contenu
		         * @param {string} tagName - Nom de la balise HTML
		         * @param {Object} options - Options de configuration
		         * @param {string} [options.className] - Classes CSS
		         * @param {string} [options.id] - ID de l'√©l√©ment
		         * @param {string} [options.textContent] - Contenu texte (√©chapp√© automatiquement)
		         * @param {Object} [options.attributes] - Attributs HTML
		         * @param {Array<Element>} [options.children] - √âl√©ments enfants
		         * @returns {Element} √âl√©ment DOM cr√©√©
		         * @example
		         * Security.createSafeElement('div', {
		         *     className: 'my-class',
		         *     textContent: '<script>alert(1)</script>', // Automatiquement √©chapp√©
		         *     children: [otherElement]
		         * })
		         */
		        createSafeElement(tagName, options = {}) {
		            const element = document.createElement(tagName);

		            if (options.className) {
		                element.className = options.className;
		            }

		            if (options.id) {
		                element.id = options.id;
		            }

		            if (options.textContent) {
		                // SAFE: textContent √©chappe automatiquement le HTML
		                element.textContent = options.textContent;
		            }

		            if (options.attributes) {
		                Object.keys(options.attributes).forEach(key => {
		                    element.setAttribute(key, this.escapeAttribute(options.attributes[key]));
		                });
		            }

		            if (options.children && Array.isArray(options.children)) {
		                options.children.forEach(child => {
		                    if (child instanceof Element) {
		                        element.appendChild(child);
		                    }
		                });
		            }

		            return element;
		        },

		        /**
		         * Parse et valide un contenu SVG de mani√®re s√©curis√©e
		         * Utilise DOMParser au lieu de innerHTML pour √©viter l'ex√©cution de scripts
		         * @param {string} svgContent - Contenu SVG brut
		         * @returns {SVGElement|null} √âl√©ment SVG valid√© ou null si invalide
		         * @example
		         * Security.sanitizeSvgContent('<svg>...</svg>')
		         * // Returns: SVGElement or null
		         */
		        sanitizeSvgContent(svgContent) {
		            if (!svgContent || typeof svgContent !== "string") {
		                return null;
		            }

		            try {
		                const parser = new DOMParser();
		                const doc = parser.parseFromString(svgContent, "image/svg+xml");

		                // V√©rifier les erreurs de parsing
		                const parserError = doc.querySelector("parsererror");
		                if (parserError) {
		                    Log.warn("[Security] Erreur parsing SVG:", parserError.textContent);
		                    return null;
		                }

		                const svgEl = doc.documentElement;
		                if (!svgEl || svgEl.tagName.toLowerCase() !== "svg") {
		                    Log.warn("[Security] Contenu SVG invalide: √©l√©ment racine n'est pas SVG");
		                    return null;
		                }

		                // Supprimer les √©l√©ments potentiellement dangereux
		                const dangerousElements = ["script", "foreignObject", "use[href^='data:']"];
		                dangerousElements.forEach(selector => {
		                    const elements = svgEl.querySelectorAll(selector);
		                    elements.forEach(el => el.remove());
		                });

		                // Supprimer les attributs event handlers (onclick, onerror, etc.)
		                const allElements = svgEl.querySelectorAll("*");
		                allElements.forEach(el => {
		                    Array.from(el.attributes).forEach(attr => {
		                        if (attr.name.toLowerCase().startsWith("on")) {
		                            el.removeAttribute(attr.name);
		                        }
		                        // Supprimer les href javascript:
		                        if ((attr.name === "href" || attr.name === "xlink:href") &&
		                            attr.value.toLowerCase().trim().startsWith("javascript:")) {
		                            el.removeAttribute(attr.name);
		                        }
		                    });
		                });

		                return svgEl;
		            } catch (e) {
		                Log.warn("[Security] Erreur sanitization SVG:", e.message);
		                return null;
		            }
		        },

		        /**
		         * Valide qu'une valeur est un nombre dans une plage donn√©e
		         * @param {*} value - Valeur √† valider
		         * @param {number} [min=-Infinity] - Valeur minimale
		         * @param {number} [max=Infinity] - Valeur maximale
		         * @returns {number|null} Nombre valid√© ou null si invalide
		         * @example
		         * Security.validateNumber("123", 0, 1000)
		         * // Returns: 123
		         *
		         * Security.validateNumber("<script>", 0, 100)
		         * // Returns: null
		         */
		        validateNumber(value, min = -Infinity, max = Infinity) {
		            // Convertir en nombre
		            const num = Number(value);

		            // V√©rifier que c'est un nombre fini
		            if (!Number.isFinite(num)) {
		                return null;
		            }

		            // V√©rifier les bornes
		            if (num < min || num > max) {
		                return null;
		            }

		            return num;
		        },

		        /**
		         * Parse du HTML de mani√®re s√©curis√©e avec whitelist de balises
		         * @param {string} html - HTML √† parser
		         * @param {string[]} [allowedTags=['p','br','strong','em','span','a','ul','ol','li']] - Balises autoris√©es
		         * @returns {DocumentFragment} Fragment DOM nettoy√©
		         * @example
		         * Security.parseHtmlSafely('<p>Hello</p><script>alert(1)</script>')
		         * // Returns: DocumentFragment with only <p>Hello</p>
		         */
		        parseHtmlSafely(html, allowedTags = ['p', 'br', 'strong', 'em', 'span', 'a', 'ul', 'ol', 'li', 'b', 'i']) {
		            const fragment = document.createDocumentFragment();

		            if (!html || typeof html !== "string") {
		                return fragment;
		            }

		            try {
		                const parser = new DOMParser();
		                const doc = parser.parseFromString(html, "text/html");

		                // Fonction r√©cursive pour nettoyer les n≈ìuds
		                const cleanNode = (node) => {
		                    if (node.nodeType === Node.TEXT_NODE) {
		                        return document.createTextNode(node.textContent);
		                    }

		                    if (node.nodeType !== Node.ELEMENT_NODE) {
		                        return null;
		                    }

		                    const tagName = node.tagName.toLowerCase();

		                    // Si la balise n'est pas autoris√©e, retourner seulement le contenu texte
		                    if (!allowedTags.includes(tagName)) {
		                        const textNode = document.createTextNode(node.textContent);
		                        return textNode;
		                    }

		                    // Cr√©er un nouvel √©l√©ment propre
		                    const cleanElement = document.createElement(tagName);

		                    // Pour les liens, conserver href mais valider
		                    if (tagName === 'a' && node.hasAttribute('href')) {
		                        try {
		                            const href = this.validateUrl(node.getAttribute('href'));
		                            cleanElement.setAttribute('href', href);
		                            cleanElement.setAttribute('rel', 'noopener noreferrer');
		                            cleanElement.setAttribute('target', '_blank');
		                        } catch (e) {
		                            // URL invalide, ignorer le lien
		                        }
		                    }

		                    // Nettoyer les enfants r√©cursivement
		                    node.childNodes.forEach(child => {
		                        const cleanChild = cleanNode(child);
		                        if (cleanChild) {
		                            cleanElement.appendChild(cleanChild);
		                        }
		                    });

		                    return cleanElement;
		                };

		                // Nettoyer le body du document pars√©
		                doc.body.childNodes.forEach(child => {
		                    const cleanChild = cleanNode(child);
		                    if (cleanChild) {
		                        fragment.appendChild(cleanChild);
		                    }
		                });

		            } catch (e) {
		                Log.warn("[Security] Erreur parsing HTML s√©curis√©:", e.message);
		            }

		            return fragment;
		        },
		    };

		    // Export du module
		    GeoLeaf.Security = Security;

		    // Log du chargement
		    Log.info("[GeoLeaf.Security] Module de s√©curit√© charg√©");
		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_security;
	}

	requireGeoleaf_security();

	var geoleaf_constants = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_constants;

	function requireGeoleaf_constants () {
		if (hasRequiredGeoleaf_constants) return geoleaf_constants;
		hasRequiredGeoleaf_constants = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Constantes globales GeoLeaf
		     * Centralise toutes les valeurs num√©riques utilis√©es dans le projet
		     */
		    GeoLeaf.CONSTANTS = {
		        // Carte ‚Äî vue neutre, le fitBounds positionne apr√®s chargement des couches
		        DEFAULT_ZOOM: 3,
		        DEFAULT_CENTER: [0, 0],
		        MAX_ZOOM_ON_FIT: 15,

		        // POI
		        POI_MARKER_SIZE: 12,
		        POI_MAX_ZOOM: 18,
		        POI_SWIPE_THRESHOLD: 50,
		        POI_LIGHTBOX_TRANSITION_MS: 300,
		        POI_SIDEPANEL_DEFAULT_WIDTH: 420,

		        // Route
		        ROUTE_MAX_ZOOM_ON_FIT: 14,
		        ROUTE_WAYPOINT_RADIUS: 5,

		        // GeoJSON
		        GEOJSON_MAX_ZOOM_ON_FIT: 15,
		        GEOJSON_POINT_RADIUS: 6,

		        // UI
		        FULLSCREEN_TRANSITION_MS: 10
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_constants;
	}

	requireGeoleaf_constants();

	var geoleaf_utils = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_utils;

	function requireGeoleaf_utils () {
		if (hasRequiredGeoleaf_utils) return geoleaf_utils;
		hasRequiredGeoleaf_utils = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Module GeoLeaf.Utils
		     * Fonctions utilitaires r√©utilisables pour s√©curiser et manipuler les donn√©es
		     */
		    const Utils = {
		        /**
		         * √âchappe les caract√®res HTML dangereux pour pr√©venir les attaques XSS
		         * DEPRECATED: Utilisez GeoLeaf.Security.escapeHtml() √† la place
		         * @param {string} text - Texte √† √©chapper
		         * @returns {string} - Texte s√©curis√©
		         */
		        escapeHtml(text) {
		            // Redirection vers la fonction canonique dans Security
		            if (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function') {
		                return GeoLeaf.Security.escapeHtml(text);
		            }

		            // Fallback si Security n'est pas charg√©
		            if (text == null || text === '') return '';
		            const map = {
		                '&': '&amp;',
		                '<': '&lt;',
		                '>': '&gt;',
		                '"': '&quot;',
		                "'": '&#039;',
		                '/': '&#x2F;'
		            };
		            return String(text).replace(/[&<>"'/]/g, function(s) {
		                return map[s];
		            });
		        },

		        /**
		         * Valide et nettoie une URL
		         * @param {string} url - URL √† valider
		         * @param {Array<string>} allowedProtocols - Protocoles autoris√©s (d√©faut: http, https, mailto, tel)
		         * @returns {string|null} - URL valid√©e ou null si invalide
		         */
		        validateUrl(url, allowedProtocols = ['http:', 'https:', 'mailto:', 'tel:']) {
		            if (!url || typeof url !== 'string') return null;

		            try {
		                const parsed = new URL(url, window.location.origin);

		                if (allowedProtocols.includes(parsed.protocol)) {
		                    return parsed.href;
		                }

		                return null;
		            } catch (e) {
		                // URL relative ou invalide
		                return null;
		            }
		        },

		        /**
		         * Merge profond d'objets
		         * @param {Object} target - Objet cible
		         * @param {Object} source - Objet source
		         * @returns {Object} - Objet fusionn√©
		         */
		        deepMerge(target, source) {
		            if (!source || typeof source !== 'object') return target;
		            if (!target || typeof target !== 'object') return source;

		            const output = Object.assign({}, target);

		            Object.keys(source).forEach(key => {
		                if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
		                    output[key] = this.deepMerge(target[key] || {}, source[key]);
		                } else {
		                    output[key] = source[key];
		                }
		            });

		            return output;
		        },

		        /**
		         * R√©sout la carte Leaflet depuis les options ou GeoLeaf.Core
		         * Utilitaire partag√© pour √©viter duplication dans POI/GeoJSON/Route
		         * @param {L.Map|null} explicitMap - Carte pass√©e explicitement
		         * @returns {L.Map|null} - Instance de la carte ou null
		         */
		        ensureMap(explicitMap) {
		            if (explicitMap) return explicitMap;

		            // Tentative de r√©cup√©ration via GeoLeaf.Core.getMap()
		            if (typeof GeoLeaf !== 'undefined' &&
		                GeoLeaf.Core &&
		                typeof GeoLeaf.Core.getMap === 'function') {
		                return GeoLeaf.Core.getMap();
		            }

		            return null;
		        },

		        /**
		         * Merge shallow d'options (pour les modules POI/GeoJSON/Route)
		         * @param {Object} defaults - Options par d√©faut
		         * @param {Object} override - Options fournies par l'utilisateur
		         * @returns {Object} - Options fusionn√©es
		         */
		        mergeOptions(defaults, override) {
		            if (!override || typeof override !== 'object') return defaults;
		            return Object.assign({}, defaults, override);
		        },

		        /**
		         * √âmet un √©v√©nement personnalis√© sur la carte Leaflet
		         * @param {L.Map} map - Instance de la carte
		         * @param {string} eventName - Nom de l'√©v√©nement (ex: 'geoleaf:poi:loaded')
		         * @param {Object} payload - Donn√©es √† transmettre
		         */
		        fireMapEvent(map, eventName, payload) {
		            if (!map || typeof map.fire !== 'function') return;

		            try {
		                map.fire(eventName, payload || {});
		            } catch (err) {
		                if (Log) {
		                    Log.warn('[GeoLeaf.Utils] Erreur lors de l\'√©mission de l\'√©v√©nement:', eventName, err);
		                }
		            }
		        },

		        /**
		         * Debounce - Limite la fr√©quence d'ex√©cution d'une fonction
		         * Utile pour optimiser les event listeners (resize, scroll, input)
		         * @param {Function} func - Fonction √† debouncer
		         * @param {number} wait - D√©lai en ms (d√©faut: 250ms)
		         * @returns {Function} - Fonction debounc√©e
		         *
		         * @example
		         * const debouncedResize = GeoLeaf.Utils.debounce(() => {
		         *     map.invalidateSize();
		         * }, 300);
		         * window.addEventListener('resize', debouncedResize);
		         */
		        debounce(func, wait = 250) {
		            let timeout;

		            return function executedFunction(...args) {
		                const later = () => {
		                    clearTimeout(timeout);
		                    func(...args);
		                };

		                clearTimeout(timeout);
		                timeout = setTimeout(later, wait);
		            };
		        },

		        /**
		         * Throttle - Limite l'ex√©cution d'une fonction √† une fois par intervalle
		         * Diff√©rence avec debounce: garantit une ex√©cution r√©guli√®re
		         * @param {Function} func - Fonction √† throttler
		         * @param {number} limit - Intervalle minimum en ms (d√©faut: 100ms)
		         * @returns {Function} - Fonction throttl√©e
		         *
		         * @example
		         * const throttledScroll = GeoLeaf.Utils.throttle(() => {
		         *     console.log('Scroll event');
		         * }, 100);
		         * window.addEventListener('scroll', throttledScroll);
		         */
		        throttle(func, limit = 100) {
		            let inThrottle;

		            return function(...args) {
		                if (!inThrottle) {
		                    func.apply(this, args);
		                    inThrottle = true;
		                    setTimeout(() => inThrottle = false, limit);
		                }
		            };
		        },

		        /**
		         * Calcule la distance entre deux points g√©ographiques (formule de Haversine)
		         * @param {number} lat1 - Latitude du point 1 (degr√©s)
		         * @param {number} lng1 - Longitude du point 1 (degr√©s)
		         * @param {number} lat2 - Latitude du point 2 (degr√©s)
		         * @param {number} lng2 - Longitude du point 2 (degr√©s)
		         * @returns {number} - Distance en kilom√®tres
		         *
		         * @example
		         * const distance = GeoLeaf.Utils.getDistance(48.8566, 2.3522, 51.5074, -0.1278); // Paris -> London
		         * console.log(`Distance: ${distance.toFixed(2)} km`); // Distance: 343.56 km
		         */
		        getDistance(lat1, lng1, lat2, lng2) {
		            const R = 6371; // Rayon de la Terre en kilom√®tres
		            const dLat = (lat2 - lat1) * (Math.PI / 180);
		            const dLng = (lng2 - lng1) * (Math.PI / 180);
		            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
		                      Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
		                      Math.sin(dLng / 2) * Math.sin(dLng / 2);
		            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		            return R * c;
		        },

		        /**
		         * R√©sout la valeur d'un champ depuis plusieurs chemins possibles dans un objet
		         * √âlimine les longues cha√Ænes conditionnelles de r√©solution de champs
		         * @param {Object} obj - Objet source
		         * @param {...string} paths - Chemins √† tester dans l'ordre (ex: 'label', 'attributes.label', 'properties.label')
		         * @returns {*} - Premi√®re valeur trouv√©e (string, object, array, etc.) ou cha√Æne vide si rien trouv√©
		         *
		         * @example
		         * const title = GeoLeaf.Utils.resolveField(poi,
		         *     'label', 'attributes.label', 'properties.label',
		         *     'name', 'attributes.name', 'properties.name'
		         * );
		         */
		        resolveField(obj, ...paths) {
		            if (!obj || typeof obj !== 'object') return '';

		            for (const path of paths) {
		                const keys = path.split('.');
		                let value = obj;

		                for (const key of keys) {
		                    if (value && typeof value === 'object' && key in value) {
		                        value = value[key];
		                    } else {
		                        value = null;
		                        break;
		                    }
		                }

		                // Return any truthy value (string, object, array, number, etc.)
		                if (value != null) {
		                    // For strings, ensure they're not empty
		                    if (typeof value === 'string') {
		                        if (value.trim()) return value;
		                    } else {
		                        // For non-strings (objects, arrays, numbers, booleans), return as-is
		                        return value;
		                    }
		                }
		            }

		            return '';
		        }
		    };

		    GeoLeaf.Utils = Utils;

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_utils;
	}

	requireGeoleaf_utils();

	var domSecurity = {exports: {}};

	/**
	 * GeoLeaf - DOM Security Module
	 *
	 * @description Wrappers s√©curis√©s pour manipuler le DOM sans vuln√©rabilit√©s XSS
	 * @module GeoLeaf.DOMSecurity
	 * @version 3.0.1
	 * @date 2026-01-17
	 *
	 * USAGE:
	 * - Remplace innerHTML par des alternatives s√©curis√©es
	 * - Utilise textContent pour donn√©es non-HTML
	 * - Sanitize via GeoLeaf.Security pour HTML n√©cessaire
	 * - Cr√©e SVG de mani√®re s√©curis√©e
	 */

	var hasRequiredDomSecurity;

	function requireDomSecurity () {
		if (hasRequiredDomSecurity) return domSecurity.exports;
		hasRequiredDomSecurity = 1;
		(function (module) {
			(function(global) {

			    const DOMSecurity = (function() {

			        const Log = global.GeoLeaf?.Log;
			        const Security = global.GeoLeaf?.Security;

			        /**
			         * D√©finit le contenu texte d'un √©l√©ment de mani√®re s√©curis√©e
			         * Remplace: element.innerHTML = text
			         *
			         * @param {HTMLElement} element - √âl√©ment DOM cible
			         * @param {string|number} text - Contenu texte (sera converti en string)
			         * @returns {void}
			         *
			         * @example
			         * // ‚ùå AVANT (vuln√©rable XSS)
			         * div.innerHTML = userData;
			         *
			         * // ‚úÖ APR√àS (s√©curis√©)
			         * DOMSecurity.setTextContent(div, userData);
			         */
			        function setTextContent(element, text) {
			            if (!element || !element.nodeType) {
			                if (Log) Log.warn('[DOMSecurity] Invalid element in setTextContent');
			                return;
			            }
			            element.textContent = text != null ? String(text) : '';
			        }

			        /**
			         * D√©finit du contenu HTML avec sanitization
			         * Remplace: element.innerHTML = html (quand HTML est vraiment n√©cessaire)
			         *
			         * @param {HTMLElement} element - √âl√©ment DOM cible
			         * @param {string} html - Contenu HTML √† ins√©rer
			         * @returns {void}
			         *
			         * @example
			         * // Utiliser Security.escapeHTML si disponible
			         * DOMSecurity.setSafeHTML(div, '<strong>Important</strong>');
			         */
			        function setSafeHTML(element, html) {
			            if (!element || !element.nodeType) {
			                if (Log) Log.warn('[DOMSecurity] Invalid element in setSafeHTML');
			                return;
			            }

			            // Tenter d'utiliser le sanitizer de GeoLeaf.Security
			            if (Security && typeof Security.escapeHtml === 'function') {
			                const sanitized = Security.escapeHtml(html);
			                element.innerHTML = sanitized;
			            } else {
			                // Fallback s√©curis√© : textContent au lieu de innerHTML brut
			                if (Log) Log.warn('[DOMSecurity] No sanitizer available, falling back to textContent');
			                element.textContent = html || '';
			            }
			        }

			        /**
			         * Vide un √©l√©ment de mani√®re s√©curis√©e
			         * Remplace: element.innerHTML = ""
			         *
			         * @param {HTMLElement} element - √âl√©ment DOM √† vider
			         * @returns {void}
			         *
			         * @example
			         * DOMSecurity.clearElement(container);
			         */
			        function clearElement(element) {
			            if (!element || !element.nodeType) {
			                if (Log) Log.warn('[DOMSecurity] Invalid element in clearElement');
			                return;
			            }

			            // M√©thode la plus performante et s√ªre
			            while (element.firstChild) {
			                element.removeChild(element.firstChild);
			            }
			        }

			        /**
			         * Vide rapidement en utilisant textContent (alternative)
			         * Plus rapide que removeChild mais moins propre
			         *
			         * @param {HTMLElement} element - √âl√©ment DOM √† vider
			         * @returns {void}
			         */
			        function clearElementFast(element) {
			            if (!element || !element.nodeType) {
			                if (Log) Log.warn('[DOMSecurity] Invalid element in clearElementFast');
			                return;
			            }
			            element.textContent = '';
			        }

			        /**
			         * Cr√©e un √©l√©ment SVG de mani√®re s√©curis√©e
			         *
			         * @param {number} width - Largeur SVG
			         * @param {number} height - Hauteur SVG
			         * @param {string} pathData - Donn√©es du path SVG
			         * @param {Object} [options={}] - Options SVG
			         * @param {string} [options.viewBox] - ViewBox SVG
			         * @param {string} [options.fill='none'] - Couleur de remplissage
			         * @param {string} [options.stroke='currentColor'] - Couleur de trait
			         * @param {string|number} [options.strokeWidth='2'] - √âpaisseur trait
			         * @param {string} [options.strokeLinecap='round'] - Style bout de trait
			         * @param {string} [options.strokeLinejoin='round'] - Style jonction
			         * @returns {SVGElement} √âl√©ment SVG cr√©√©
			         *
			         * @example
			         * const icon = DOMSecurity.createSVGIcon(18, 18, 'M6 9l6 6 6-6');
			         * button.appendChild(icon);
			         */
			        function createSVGIcon(width, height, pathData, options = {}) {
			            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			            svg.setAttribute('width', width);
			            svg.setAttribute('height', height);
			            svg.setAttribute('viewBox', options.viewBox || `0 0 24 24`);
			            svg.setAttribute('fill', options.fill || 'none');
			            svg.setAttribute('stroke', options.stroke || 'currentColor');
			            svg.setAttribute('stroke-width', String(options.strokeWidth || '2'));
			            svg.setAttribute('stroke-linecap', options.strokeLinecap || 'round');
			            svg.setAttribute('stroke-linejoin', options.strokeLinejoin || 'round');

			            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			            path.setAttribute('d', pathData);
			            svg.appendChild(path);

			            return svg;
			        }

			        /**
			         * Biblioth√®que d'ic√¥nes SVG communes
			         * @constant
			         */
			        const SVG_ICONS = {
			            // Chevrons
			            'chevron-down': 'M6 9l6 6 6-6',
			            'chevron-up': 'M18 15l-6-6-6 6',
			            'chevron-left': 'M15 18l-6-6 6-6',
			            'chevron-right': 'M9 18l6-6-6-6',

			            // Arrows
			            'arrow-left': '‚Äπ',
			            'arrow-right': '‚Ä∫',

			            // UI Controls
			            'close': '‚úï',
			            'check': '‚úì',
			            'star': '‚òÖ',
			            'star-empty': '‚òÜ',

			            // Triangles (collapse/expand)
			            'triangle-right': '‚ñ∂',
			            'triangle-down': '‚ñº',

			            // Home/Layers
			            'home': 'M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z',
			            'layers': 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5',

			            // Location
			            'marker': 'M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z',
			            'map-pin': 'M12 22s-8-4.5-8-11.8A8 8 0 0 1 12 2a8 8 0 0 1 8 8.2c0 7.3-8 11.8-8 11.8z',

			            // Actions
			            'download': 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3',
			            'upload': 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12',
			            'trash': 'M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2',
			            'copy': 'M8 4v12a2 2 0 002 2h8a2 2 0 002-2V7.242a2 2 0 00-.602-1.43L16.083 2.57A2 2 0 0014.685 2H10a2 2 0 00-2 2z',

			            // Status
			            'sync': 'M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15'
			        };

			        /**
			         * Obtient une ic√¥ne SVG pr√©d√©finie
			         *
			         * @param {string} name - Nom de l'ic√¥ne
			         * @param {number} [size=18] - Taille de l'ic√¥ne
			         * @param {Object} [options={}] - Options SVG suppl√©mentaires
			         * @returns {SVGElement|null} √âl√©ment SVG ou null si non trouv√©
			         *
			         * @example
			         * const homeIcon = DOMSecurity.getIcon('home', 24);
			         * button.appendChild(homeIcon);
			         */
			        function getIcon(name, size = 18, options = {}) {
			            const pathData = SVG_ICONS[name];
			            if (!pathData) {
			                if (Log) Log.warn(`[DOMSecurity] Icon '${name}' not found`);
			                return null;
			            }
			            return createSVGIcon(size, size, pathData, options);
			        }

			        /**
			         * Cr√©e un √©l√©ment avec attributs de mani√®re s√©curis√©e
			         * Alternative s√©curis√©e √† innerHTML pour structures simples
			         *
			         * @param {string} tagName - Nom de la balise
			         * @param {Object} [attributes={}] - Attributs de l'√©l√©ment
			         * @param {string|HTMLElement|Array} [children] - Enfants (texte ou √©l√©ments)
			         * @returns {HTMLElement} √âl√©ment cr√©√©
			         *
			         * @example
			         * const div = DOMSecurity.createElement('div',
			         *   { class: 'container', id: 'main' },
			         *   ['Hello ', DOMSecurity.createElement('strong', {}, 'World')]
			         * );
			         */
			        function createElement(tagName, attributes = {}, children = null) {
			            const element = document.createElement(tagName);

			            // D√©finir les attributs
			            for (const [key, value] of Object.entries(attributes)) {
			                if (key === 'class' || key === 'className') {
			                    element.className = value;
			                } else if (key === 'style' && typeof value === 'object') {
			                    Object.assign(element.style, value);
			                } else if (key.startsWith('data-')) {
			                    element.setAttribute(key, value);
			                } else {
			                    element[key] = value;
			                }
			            }

			            // Ajouter les enfants
			            if (children) {
			                if (Array.isArray(children)) {
			                    children.forEach(child => {
			                        if (typeof child === 'string') {
			                            element.appendChild(document.createTextNode(child));
			                        } else if (child && child.nodeType) {
			                            element.appendChild(child);
			                        }
			                    });
			                } else if (typeof children === 'string') {
			                    element.textContent = children;
			                } else if (children.nodeType) {
			                    element.appendChild(children);
			                }
			            }

			            return element;
			        }

			        // API publique
			        return {
			            setTextContent,
			            setSafeHTML,
			            clearElement,
			            clearElementFast,
			            createSVGIcon,
			            getIcon,
			            createElement,
			            SVG_ICONS // Exposer la liste pour r√©f√©rence
			        };
			    })();

			    // Export vers GeoLeaf namespace
			    if (typeof global.GeoLeaf !== 'undefined') {
			        global.GeoLeaf.DOMSecurity = DOMSecurity;
			    } else {
			        // Cr√©er namespace si n√©cessaire
			        global.GeoLeaf = global.GeoLeaf || {};
			        global.GeoLeaf.DOMSecurity = DOMSecurity;
			    }

			    // Support CommonJS/Node.js
			    if (module.exports) {
			        module.exports = DOMSecurity;
			    }

			})(typeof window !== 'undefined' ? window : commonjsGlobal); 
		} (domSecurity));
		return domSecurity.exports;
	}

	requireDomSecurity();

	var domHelpers = {};

	/**
	 * @module GeoLeaf.Utils.DomHelpers
	 * Helpers pour cr√©ation et manipulation d'√©l√©ments DOM
	 * Simplifie et standardise la cr√©ation d'√©l√©ments DOM dans tout le projet
	 *
	 * @version 1.0.0
	 * @requires GeoLeaf.Security (pour sanitization)
	 */

	var hasRequiredDomHelpers;

	function requireDomHelpers () {
		if (hasRequiredDomHelpers) return domHelpers;
		hasRequiredDomHelpers = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.Utils = GeoLeaf.Utils || {};

		    /**
		     * Cr√©e un √©l√©ment DOM avec propri√©t√©s et enfants de mani√®re d√©clarative
		     * Cette fonction simplifie la cr√©ation d'√©l√©ments DOM complexes
		     *
		     * @param {string} tag - Nom du tag HTML (ex: 'div', 'span', 'button')
		     * @param {Object} [props={}] - Propri√©t√©s de l'√©l√©ment
		     * @param {string} [props.className] - Classes CSS
		     * @param {string} [props.id] - ID de l'√©l√©ment
		     * @param {Object} [props.style] - Styles inline (objet)
		     * @param {Object} [props.dataset] - Data attributes (objet)
		     * @param {Object} [props.attributes] - Attributs HTML (objet)
		     * @param {Function} [props.on*] - Event handlers (ex: onClick, onMouseOver)
		     * @param {string} [props._eventContext] - Context for EventListenerManager tracking
		     * @param {Array} [props._cleanupArray] - Array to store cleanup functions
		     * @param {...(Node|string|number)} children - Enfants de l'√©l√©ment
		     * @returns {HTMLElement} L'√©l√©ment cr√©√©
		     *
		     * @example
		     * // Simple div avec classe
		     * createElement('div', { className: 'card' })
		     *
		     * @example
		     * // Div avec enfants
		     * createElement('div', { className: 'card' },
		     *     createElement('h2', {}, 'Title'),
		     *     createElement('p', {}, 'Content')
		     * )
		     *
		     * @example
		     * // Bouton avec event handler (auto-cleanup with EventListenerManager)
		     * createElement('button', {
		     *     className: 'btn',
		     *     onClick: (e) => console.log('Clicked!'),
		     *     dataset: { action: 'submit' },
		     *     _eventContext: 'MyModule.button'
		     * }, 'Click me')
		     *
		     * @example
		     * // With cleanup tracking
		     * const cleanups = [];
		     * createElement('button', {
		     *     onClick: handler,
		     *     _cleanupArray: cleanups,
		     *     _eventContext: 'MyModule'
		     * }, 'Click')
		     * // Later: cleanups.forEach(fn => fn())
		     */
		    function createElement(tag, props = {}, ...children) {
		        // Validate tag parameter
		        if (typeof tag !== 'string' || !tag.trim()) {
		            throw new TypeError('[DomHelpers] createElement: tag must be a non-empty string');
		        }

		        const element = document.createElement(tag);

		        // Traiter les propri√©t√©s sp√©ciales en premier
		        const {
		            className,
		            id,
		            style,
		            dataset,
		            attributes,
		            textContent,
		            innerHTML,
		            _eventContext,
		            _cleanupArray,
		            ...otherProps
		        } = props;

		        // Appliquer className
		        if (className) {
		            element.className = className;
		        }

		        // Appliquer ID
		        if (id) {
		            element.id = id;
		        }

		        // Appliquer styles
		        if (style && typeof style === 'object') {
		            Object.assign(element.style, style);
		        }

		        // Appliquer data attributes
		        if (dataset && typeof dataset === 'object') {
		            for (const [key, value] of Object.entries(dataset)) {
		                element.dataset[key] = value;
		            }
		        }

		        // Appliquer attributes HTML
		        if (attributes && typeof attributes === 'object') {
		            for (const [key, value] of Object.entries(attributes)) {
		                element.setAttribute(key, value);
		            }
		        }

		        // Appliquer les autres propri√©t√©s (event handlers, etc.)
		        const events = GeoLeaf.Utils?.events;

		        for (const [key, value] of Object.entries(otherProps)) {
		            // Event handlers (onClick, onMouseOver, etc.)
		            if (key.startsWith('on') && typeof value === 'function') {
		                const event = key.substring(2).toLowerCase();

		                // Use EventListenerManager for auto-cleanup if available
		                if (events) {
		                    const cleanup = events.on(
		                        element,
		                        event,
		                        value,
		                        false,
		                        _eventContext || 'DomHelpers.createElement'
		                    );

		                    // Store cleanup function if array provided
		                    if (_cleanupArray && Array.isArray(_cleanupArray)) {
		                        _cleanupArray.push(cleanup);
		                    }
		                } else {
		                    // Fallback to native addEventListener
		                    element.addEventListener(event, value);
		                }
		            }
		            // Propri√©t√©s aria-*
		            else if (key.startsWith('aria')) {
		                const attrName = 'aria-' + key.substring(4).toLowerCase();
		                element.setAttribute(attrName, value);
		            }
		            // Autres propri√©t√©s directes
		            else if (key in element) {
		                element[key] = value;
		            }
		            // Fallback: setAttribute
		            else {
		                element.setAttribute(key, value);
		            }
		        }

		        // Appliquer textContent si fourni (√©crase innerHTML et children)
		        if (textContent !== undefined) {
		            element.textContent = textContent;
		            return element; // Ignorer children si textContent est fourni
		        }

		        // Appliquer innerHTML si fourni (√©crase children)
		        // WARNING: N'utiliser qu'avec du contenu s√©curis√©/sanitiz√©
		        if (innerHTML !== undefined) {
		            if (GeoLeaf.Log && GeoLeaf.Log.warn) {
		                GeoLeaf.Log.warn(
		                    '[DomHelpers] createElement avec innerHTML - assurez-vous que le contenu est sanitiz√©',
		                    { tag, innerHTML: innerHTML.substring(0, 100) }
		                );
		            }

		            // Use DOMSecurity if available, otherwise use textContent as safer fallback
		            if (GeoLeaf.DOMSecurity && typeof GeoLeaf.DOMSecurity.setSafeHTML === 'function') {
		                GeoLeaf.DOMSecurity.setSafeHTML(element, innerHTML);
		            } else {
		                // Fallback: convert to text for security
		                if (GeoLeaf.Log && GeoLeaf.Log.error) {
		                    GeoLeaf.Log.error('[DomHelpers] DOMSecurity not available, using textContent fallback');
		                }
		                element.textContent = innerHTML;
		            }
		            return element; // Ignorer children si innerHTML est fourni
		        }

		        // Ajouter les enfants
		        appendChild(element, ...children);

		        return element;
		    }

		    /**
		     * Ajoute des enfants √† un √©l√©ment parent
		     * G√®re automatiquement les strings, numbers, nodes, et tableaux
		     *
		     * @param {HTMLElement} parent - √âl√©ment parent
		     * @param {...(Node|string|number|Array)} children - Enfants √† ajouter
		     * @returns {HTMLElement} Le parent (pour cha√Ænage)
		     *
		     * @example
		     * appendChild(div, 'Text', createElement('span', {}, 'More text'))
		     *
		     * @example
		     * // Avec tableau
		     * appendChild(ul, items.map(item => createElement('li', {}, item)))
		     */
		    function appendChild(parent, ...children) {
		        for (const child of children) {
		            if (child == null || child === false) {
		                // Ignorer null, undefined, false (utile pour render conditionnel)
		                continue;
		            }

		            // Si c'est un tableau, l'aplatir r√©cursivement
		            if (Array.isArray(child)) {
		                appendChild(parent, ...child);
		            }
		            // Si c'est une string ou number, cr√©er un TextNode
		            else if (typeof child === 'string' || typeof child === 'number') {
		                parent.appendChild(document.createTextNode(String(child)));
		            }
		            // Si c'est un Node, l'ajouter directement
		            else if (child instanceof Node) {
		                parent.appendChild(child);
		            }
		            // Sinon, convertir en string et ajouter comme TextNode
		            else {
		                parent.appendChild(document.createTextNode(String(child)));
		            }
		        }
		        return parent;
		    }

		    /**
		     * Vide un √©l√©ment de tous ses enfants
		     *
		     * @param {HTMLElement} element - √âl√©ment √† vider
		     * @returns {HTMLElement} L'√©l√©ment (pour cha√Ænage)
		     *
		     * @example
		     * clearElement(container)
		     */
		    function clearElement(element) {
		        if (!element) return element;
		        while (element.firstChild) {
		            element.removeChild(element.firstChild);
		        }
		        return element;
		    }

		    /**
		     * Trouve un √©l√©ment par ID avec validation
		     *
		     * @param {string} id - ID de l'√©l√©ment
		     * @param {boolean} [required=false] - Si true, lance une erreur si non trouv√©
		     * @returns {HTMLElement|null} L'√©l√©ment trouv√© ou null
		     * @throws {Error} Si required=true et √©l√©ment non trouv√©
		     *
		     * @example
		     * const el = getElementById('my-element', true) // Lance erreur si absent
		     */
		    function getElementById(id, required = false) {
		        const element = document.getElementById(id);
		        if (required && !element) {
		            throw new Error(`Element with id "${id}" not found`);
		        }
		        return element;
		    }

		    /**
		     * Trouve des √©l√©ments par s√©lecteur CSS
		     *
		     * @param {string} selector - S√©lecteur CSS
		     * @param {HTMLElement} [parent=document] - √âl√©ment parent pour la recherche
		     * @returns {HTMLElement[]} Tableau d'√©l√©ments trouv√©s
		     *
		     * @example
		     * const buttons = querySelectorAll('.btn')
		     */
		    function querySelectorAll(selector, parent = document) {
		        return Array.from(parent.querySelectorAll(selector));
		    }

		    /**
		     * Trouve un √©l√©ment par s√©lecteur CSS
		     *
		     * @param {string} selector - S√©lecteur CSS
		     * @param {HTMLElement} [parent=document] - √âl√©ment parent pour la recherche
		     * @returns {HTMLElement|null} Premier √©l√©ment trouv√© ou null
		     *
		     * @example
		     * const button = querySelector('.btn-primary')
		     */
		    function querySelector(selector, parent = document) {
		        return parent.querySelector(selector);
		    }

		    /**
		     * Toggle une classe CSS sur un √©l√©ment
		     *
		     * @param {HTMLElement} element - √âl√©ment cible
		     * @param {string} className - Nom de la classe
		     * @param {boolean} [force] - Force l'ajout (true) ou le retrait (false)
		     * @returns {boolean} True si la classe est pr√©sente apr√®s toggle
		     *
		     * @example
		     * toggleClass(element, 'active')
		     * toggleClass(element, 'hidden', false) // Force retrait
		     */
		    function toggleClass(element, className, force) {
		        if (!element) return false;
		        return element.classList.toggle(className, force);
		    }

		    /**
		     * Ajoute une ou plusieurs classes √† un √©l√©ment
		     *
		     * @param {HTMLElement} element - √âl√©ment cible
		     * @param {...string} classNames - Classes √† ajouter
		     * @returns {HTMLElement} L'√©l√©ment (pour cha√Ænage)
		     *
		     * @example
		     * addClass(element, 'active', 'visible')
		     */
		    function addClass(element, ...classNames) {
		        if (!element) return element;
		        element.classList.add(...classNames);
		        return element;
		    }

		    /**
		     * Retire une ou plusieurs classes d'un √©l√©ment
		     *
		     * @param {HTMLElement} element - √âl√©ment cible
		     * @param {...string} classNames - Classes √† retirer
		     * @returns {HTMLElement} L'√©l√©ment (pour cha√Ænage)
		     *
		     * @example
		     * removeClass(element, 'active', 'visible')
		     */
		    function removeClass(element, ...classNames) {
		        if (!element) return element;
		        element.classList.remove(...classNames);
		        return element;
		    }

		    /**
		     * V√©rifie si un √©l√©ment a une classe
		     *
		     * @param {HTMLElement} element - √âl√©ment √† v√©rifier
		     * @param {string} className - Nom de la classe
		     * @returns {boolean} True si la classe est pr√©sente
		     *
		     * @example
		     * if (hasClass(element, 'active')) { ... }
		     */
		    function hasClass(element, className) {
		        if (!element) return false;
		        return element.classList.contains(className);
		    }

		    /**
		     * D√©finit ou r√©cup√®re un attribut data-*
		     *
		     * @param {HTMLElement} element - √âl√©ment cible
		     * @param {string} key - Nom de l'attribut (sans 'data-')
		     * @param {*} [value] - Valeur √† d√©finir (omis pour lecture)
		     * @returns {string|HTMLElement} Valeur lue ou √©l√©ment (pour cha√Ænage)
		     *
		     * @example
		     * setData(element, 'id', '123') // D√©finir
		     * const id = setData(element, 'id') // Lire
		     */
		    function setData(element, key, value) {
		        if (!element) return value === undefined ? null : element;
		        if (value === undefined) {
		            return element.dataset[key];
		        }
		        element.dataset[key] = value;
		        return element;
		    }

		    // Exposer le module
		    GeoLeaf.Utils.DomHelpers = {
		        createElement,
		        appendChild,
		        clearElement,
		        getElementById,
		        querySelector,
		        querySelectorAll,
		        toggleClass,
		        addClass,
		        removeClass,
		        hasClass,
		        setData
		    };

		    // Alias sur GeoLeaf.Utils pour compatibilit√© et facilit√© d'usage
		    GeoLeaf.Utils.createElement = createElement;
		    GeoLeaf.Utils.appendChild = appendChild;
		    GeoLeaf.Utils.clearElement = clearElement;

		    if (GeoLeaf.Log && GeoLeaf.Log.info) {
		        GeoLeaf.Log.info('[GeoLeaf.Utils.DomHelpers] Module loaded');
		    }

		})(typeof window !== 'undefined' ? window : domHelpers);
		return domHelpers;
	}

	requireDomHelpers();

	var eventListenerManager = {};

	/**
	 * @fileoverview EventListenerManager - Gestion centralis√©e des event listeners
	 * Permet de tracker et nettoyer tous les event listeners
	 * pour √©viter les fuites m√©moire
	 *
	 * @module GeoLeaf.Utils.EventListenerManager
	 * @version 2.0.0
	 * @author GeoLeaf Project
	 */

	var hasRequiredEventListenerManager;

	function requireEventListenerManager () {
		if (hasRequiredEventListenerManager) return eventListenerManager;
		hasRequiredEventListenerManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.Utils = GeoLeaf.Utils || {};

		    const Log = GeoLeaf.Log;

		    /**
		     * EventListenerManager - Gestionnaire centralis√© d'event listeners
		     * @class
		     */
		    class EventListenerManager {
		        constructor(name = 'default') {
		            this.name = name;
		            this.listeners = [];
		            this._nextId = 1;
		        }

		        /**
		         * Ajoute un event listener avec tracking
		         * @param {Element|Window|Document} target - √âl√©ment cible
		         * @param {string} event - Nom de l'√©v√©nement
		         * @param {Function} handler - Handler de l'√©v√©nement
		         * @param {Object|boolean} [options] - Options (capture, once, passive, etc.)
		         * @param {string} [label] - Label optionnel pour debug
		         * @returns {number} ID du listener pour removal ult√©rieur
		         */
		        addEventListener(target, event, handler, options = false, label = '') {
		            if (!target || typeof target.addEventListener !== 'function') {
		                if (Log) Log.warn(`[EventListenerManager.${this.name}] Invalid target for addEventListener`);
		                return null;
		            }

		            const id = this._nextId++;

		            target.addEventListener(event, handler, options);

		            this.listeners.push({
		                id,
		                target,
		                event,
		                handler,
		                options,
		                label,
		                createdAt: Date.now()
		            });

		            if (Log) Log.debug(`[EventListenerManager.${this.name}] Listener added:`, id, event, label);
		            return id;
		        }

		        /**
		         * Ajoute un event listener Leaflet avec tracking
		         * @param {L.Evented} target - Objet Leaflet (map, marker, etc.)
		         * @param {string} event - Nom de l'√©v√©nement
		         * @param {Function} handler - Handler de l'√©v√©nement
		         * @param {string} [label] - Label optionnel pour debug
		         * @returns {number} ID du listener
		         */
		        addLeafletListener(target, event, handler, label = '') {
		            if (!target || typeof target.on !== 'function') {
		                if (Log) Log.warn(`[EventListenerManager.${this.name}] Invalid Leaflet target`);
		                return null;
		            }

		            const id = this._nextId++;

		            target.on(event, handler);

		            this.listeners.push({
		                id,
		                target,
		                event,
		                handler,
		                label,
		                type: 'leaflet',
		                createdAt: Date.now()
		            });

		            if (Log) Log.debug(`[EventListenerManager.${this.name}] Leaflet listener added:`, id, event, label);
		            return id;
		        }

		        /**
		         * Retire un listener sp√©cifique par ID
		         * @param {number} id - ID du listener
		         * @returns {boolean} True si le listener a √©t√© trouv√© et retir√©
		         */
		        removeListener(id) {
		            const index = this.listeners.findIndex(l => l.id === id);
		            if (index === -1) return false;

		            const listener = this.listeners[index];

		            if (listener.type === 'leaflet') {
		                if (listener.target && typeof listener.target.off === 'function') {
		                    listener.target.off(listener.event, listener.handler);
		                }
		            } else {
		                if (listener.target && typeof listener.target.removeEventListener === 'function') {
		                    listener.target.removeEventListener(listener.event, listener.handler, listener.options);
		                }
		            }

		            this.listeners.splice(index, 1);

		            if (Log) Log.debug(`[EventListenerManager.${this.name}] Listener removed:`, id, listener.label);
		            return true;
		        }

		        /**
		         * Retire tous les listeners d'un √©l√©ment sp√©cifique
		         * @param {Element|L.Evented} target - √âl√©ment cible
		         * @returns {number} Nombre de listeners retir√©s
		         */
		        removeListenersForTarget(target) {
		            const matchingListeners = this.listeners.filter(l => l.target === target);

		            matchingListeners.forEach(listener => {
		                if (listener.type === 'leaflet') {
		                    if (listener.target && typeof listener.target.off === 'function') {
		                        listener.target.off(listener.event, listener.handler);
		                    }
		                } else {
		                    if (listener.target && typeof listener.target.removeEventListener === 'function') {
		                        listener.target.removeEventListener(listener.event, listener.handler, listener.options);
		                    }
		                }
		            });

		            this.listeners = this.listeners.filter(l => l.target !== target);

		            if (Log && matchingListeners.length > 0) {
		                Log.info(`[EventListenerManager.${this.name}] Removed ${matchingListeners.length} listener(s) for target`);
		            }

		            return matchingListeners.length;
		        }

		        /**
		         * Retire tous les listeners
		         */
		        removeAll() {
		            const count = this.listeners.length;

		            this.listeners.forEach(listener => {
		                try {
		                    if (listener.type === 'leaflet') {
		                        if (listener.target && typeof listener.target.off === 'function') {
		                            listener.target.off(listener.event, listener.handler);
		                        }
		                    } else {
		                        if (listener.target && typeof listener.target.removeEventListener === 'function') {
		                            listener.target.removeEventListener(listener.event, listener.handler, listener.options);
		                        }
		                    }
		                } catch (error) {
		                    if (Log) Log.warn(`[EventListenerManager.${this.name}] Error removing listener:`, error);
		                }
		            });

		            this.listeners = [];

		            if (Log && count > 0) {
		                Log.info(`[EventListenerManager.${this.name}] Removed ${count} listener(s)`);
		            }
		        }

		        /**
		         * Obtient le nombre de listeners actifs
		         * @returns {number}
		         */
		        getCount() {
		            return this.listeners.length;
		        }

		        /**
		         * Liste tous les listeners actifs (pour debug)
		         * @returns {Array}
		         */
		        listActiveListeners() {
		            return this.listeners.map(l => ({
		                id: l.id,
		                event: l.event,
		                label: l.label,
		                type: l.type || 'dom',
		                age: Date.now() - l.createdAt
		            }));
		        }

		        /**
		         * D√©truit le manager et nettoie tous les listeners
		         */
		        destroy() {
		            this.removeAll();
		            if (Log) Log.info(`[EventListenerManager.${this.name}] Destroyed`);
		        }
		    }

		    /**
		     * Instance globale par d√©faut
		     */
		    const globalEventManager = new EventListenerManager('global');

		    /**
		     * API simplifi√©e pour l'instance globale
		     */
		    GeoLeaf.Utils.EventListenerManager = EventListenerManager;
		    GeoLeaf.Utils.events = {
		        /**
		         * addEventListener avec tracking global
		         */
		        on: (target, event, handler, options, label) =>
		            globalEventManager.addEventListener(target, event, handler, options, label),

		        /**
		         * Leaflet event listener avec tracking global
		         */
		        onLeaflet: (target, event, handler, label) =>
		            globalEventManager.addLeafletListener(target, event, handler, label),

		        /**
		         * Retire un listener par ID
		         */
		        off: (id) => globalEventManager.removeListener(id),

		        /**
		         * Retire tous les listeners d'une cible
		         */
		        offTarget: (target) => globalEventManager.removeListenersForTarget(target),

		        /**
		         * Retire tous les listeners globaux
		         */
		        offAll: () => globalEventManager.removeAll(),

		        /**
		         * Obtient le nombre de listeners actifs
		         */
		        getCount: () => globalEventManager.getCount(),

		        /**
		         * Liste les listeners actifs
		         */
		        listActive: () => globalEventManager.listActiveListeners(),

		        /**
		         * Cr√©e une nouvelle instance pour un composant
		         * @param {string} name - Nom du manager
		         * @returns {EventListenerManager}
		         */
		        createManager: (name) => new EventListenerManager(name)
		    };

		    // Cleanup automatique avant unload
		    if (typeof window !== 'undefined') {
		        window.addEventListener('beforeunload', () => {
		            const count = globalEventManager.getCount();
		            if (count > 0) {
		                if (Log) Log.warn(`[EventListenerManager] ${count} listener(s) still active at page unload`);
		                globalEventManager.removeAll();
		            }
		        });
		    }

		    if (Log) Log.info('[GeoLeaf.Utils.EventListenerManager] Module charg√©');

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return eventListenerManager;
	}

	requireEventListenerManager();

	var timerManager = {};

	/**
	 * @fileoverview TimerManager - Gestion centralis√©e des timers
	 * Permet de tracker et nettoyer tous les setTimeout/setInterval
	 * pour √©viter les fuites m√©moire
	 *
	 * @module GeoLeaf.Utils.TimerManager
	 * @version 2.0.0
	 * @author GeoLeaf Project
	 */

	var hasRequiredTimerManager;

	function requireTimerManager () {
		if (hasRequiredTimerManager) return timerManager;
		hasRequiredTimerManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.Utils = GeoLeaf.Utils || {};

		    const Log = GeoLeaf.Log;

		    /**
		     * TimerManager - Gestionnaire centralis√© de timers
		     * @class
		     */
		    class TimerManager {
		        constructor(name = 'default') {
		            this.name = name;
		            this.timers = new Map();
		            this.intervals = new Map();
		            this._nextId = 1;
		        }

		        /**
		         * Cr√©e un setTimeout avec tracking
		         * @param {Function} callback - Fonction √† ex√©cuter
		         * @param {number} delay - D√©lai en ms
		         * @param {string} [label] - Label optionnel pour debug
		         * @returns {number} ID du timer
		         */
		        setTimeout(callback, delay, label = '') {
		            const id = this._nextId++;
		            const timerId = setTimeout(() => {
		                try {
		                    callback();
		                } finally {
		                    // Auto-cleanup apr√®s ex√©cution
		                    this.timers.delete(id);
		                }
		            }, delay);

		            this.timers.set(id, {
		                timerId,
		                label,
		                type: 'timeout',
		                createdAt: Date.now(),
		                delay
		            });

		            if (Log) Log.debug(`[TimerManager.${this.name}] setTimeout created:`, id, label);
		            return id;
		        }

		        /**
		         * Cr√©e un setInterval avec tracking
		         * @param {Function} callback - Fonction √† ex√©cuter
		         * @param {number} interval - Intervalle en ms
		         * @param {string} [label] - Label optionnel pour debug
		         * @returns {number} ID de l'interval
		         */
		        setInterval(callback, interval, label = '') {
		            const id = this._nextId++;
		            const intervalId = setInterval(() => {
		                try {
		                    callback();
		                } catch (error) {
		                    if (Log) Log.error(`[TimerManager.${this.name}] Error in interval ${id}:`, error);
		                }
		            }, interval);

		            this.intervals.set(id, {
		                intervalId,
		                label,
		                type: 'interval',
		                createdAt: Date.now(),
		                interval
		            });

		            if (Log) Log.debug(`[TimerManager.${this.name}] setInterval created:`, id, label);
		            return id;
		        }

		        /**
		         * Clear un timer sp√©cifique
		         * @param {number} id - ID du timer
		         * @returns {boolean} True si le timer a √©t√© trouv√© et nettoy√©
		         */
		        clearTimeout(id) {
		            const timer = this.timers.get(id);
		            if (timer) {
		                clearTimeout(timer.timerId);
		                this.timers.delete(id);
		                if (Log) Log.debug(`[TimerManager.${this.name}] setTimeout cleared:`, id, timer.label);
		                return true;
		            }
		            return false;
		        }

		        /**
		         * Clear un interval sp√©cifique
		         * @param {number} id - ID de l'interval
		         * @returns {boolean} True si l'interval a √©t√© trouv√© et nettoy√©
		         */
		        clearInterval(id) {
		            const interval = this.intervals.get(id);
		            if (interval) {
		                clearInterval(interval.intervalId);
		                this.intervals.delete(id);
		                if (Log) Log.debug(`[TimerManager.${this.name}] setInterval cleared:`, id, interval.label);
		                return true;
		            }
		            return false;
		        }

		        /**
		         * Clear tous les timers et intervals
		         */
		        clearAll() {
		            // Clear tous les timeouts
		            for (const [id, timer] of this.timers.entries()) {
		                clearTimeout(timer.timerId);
		            }

		            // Clear tous les intervals
		            for (const [id, interval] of this.intervals.entries()) {
		                clearInterval(interval.intervalId);
		            }

		            const totalCleared = this.timers.size + this.intervals.size;
		            this.timers.clear();
		            this.intervals.clear();

		            if (Log && totalCleared > 0) {
		                Log.info(`[TimerManager.${this.name}] Cleared ${totalCleared} timer(s)`);
		            }
		        }

		        /**
		         * Obtient le nombre de timers actifs
		         * @returns {{timeouts: number, intervals: number, total: number}}
		         */
		        getStats() {
		            return {
		                timeouts: this.timers.size,
		                intervals: this.intervals.size,
		                total: this.timers.size + this.intervals.size
		            };
		        }

		        /**
		         * Liste tous les timers actifs (pour debug)
		         * @returns {Array} Liste des timers avec leurs infos
		         */
		        listActiveTimers() {
		            const list = [];

		            for (const [id, timer] of this.timers.entries()) {
		                list.push({
		                    id,
		                    type: 'timeout',
		                    label: timer.label,
		                    age: Date.now() - timer.createdAt,
		                    delay: timer.delay
		                });
		            }

		            for (const [id, interval] of this.intervals.entries()) {
		                list.push({
		                    id,
		                    type: 'interval',
		                    label: interval.label,
		                    age: Date.now() - interval.createdAt,
		                    interval: interval.interval
		                });
		            }

		            return list;
		        }

		        /**
		         * D√©truit le manager et nettoie tous les timers
		         */
		        destroy() {
		            this.clearAll();
		            if (Log) Log.info(`[TimerManager.${this.name}] Destroyed`);
		        }
		    }

		    /**
		     * Instance globale par d√©faut
		     */
		    const globalTimerManager = new TimerManager('global');

		    /**
		     * API simplifi√©e pour l'instance globale
		     */
		    GeoLeaf.Utils.TimerManager = TimerManager;
		    GeoLeaf.Utils.timers = {
		        /**
		         * setTimeout avec tracking global
		         */
		        setTimeout: (callback, delay, label) => globalTimerManager.setTimeout(callback, delay, label),

		        /**
		         * setInterval avec tracking global
		         */
		        setInterval: (callback, interval, label) => globalTimerManager.setInterval(callback, interval, label),

		        /**
		         * clearTimeout global
		         */
		        clearTimeout: (id) => globalTimerManager.clearTimeout(id),

		        /**
		         * clearInterval global
		         */
		        clearInterval: (id) => globalTimerManager.clearInterval(id),

		        /**
		         * Clear tous les timers globaux
		         */
		        clearAll: () => globalTimerManager.clearAll(),

		        /**
		         * Obtient les stats globales
		         */
		        getStats: () => globalTimerManager.getStats(),

		        /**
		         * Liste les timers actifs
		         */
		        listActive: () => globalTimerManager.listActiveTimers(),

		        /**
		         * Cr√©e une nouvelle instance de TimerManager pour un composant
		         * @param {string} name - Nom du manager
		         * @returns {TimerManager}
		         */
		        createManager: (name) => new TimerManager(name)
		    };

		    // Cleanup automatique avant unload de la page
		    if (typeof window !== 'undefined') {
		        window.addEventListener('beforeunload', () => {
		            const stats = globalTimerManager.getStats();
		            if (stats.total > 0) {
		                if (Log) Log.warn(`[TimerManager] ${stats.total} timer(s) still active at page unload`);
		                globalTimerManager.clearAll();
		            }
		        });
		    }

		    if (Log) Log.info('[GeoLeaf.Utils.TimerManager] Module charg√©');

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return timerManager;
	}

	requireTimerManager();

	var scaleUtils = {};

	/**
	 * @fileoverview Scale utilities - compute map scale and test visibility ranges
	 * @module utils/scale-utils
	 */

	var hasRequiredScaleUtils;

	function requireScaleUtils () {
		if (hasRequiredScaleUtils) return scaleUtils;
		hasRequiredScaleUtils = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    GeoLeaf.Utils = GeoLeaf.Utils || {};

		    // Cache bas√© sur le zoom et la latitude pour √©viter des recalculs co√ªteux
		    const _scaleCache = {
		        zoom: null,
		        lat: null,
		        scale: null
		    };

		    /**
		     * Calcule l'√©chelle (1:X) de la carte pour le zoom et la latitude actuels.
		     * Retourne la valeur mise en cache si zoom/latitude inchang√©s.
		     * @param {L.Map} map
		     * @param {Object} [options]
		     * @param {boolean} [options.force=false] - Ignore le cache et recalcule
		     * @param {Object} [options.logger] - Logger optionnel pour debug
		     * @returns {number} √©chelle (ex: 5000000 pour 1:5M)
		     */
		    function calculateMapScale(map, options = {}) {
		        if (!map) return 0;

		        const logger = options.logger;
		        const center = map.getCenter?.();
		        const zoom = map.getZoom?.();

		        if (!center || typeof zoom !== "number") {
		            return 0;
		        }

		        // Utiliser le cache si possible
		        if (!options.force && _scaleCache.zoom === zoom && _scaleCache.lat === center.lat) {
		            return _scaleCache.scale || 0;
		        }

		        const METERS_PER_PIXEL_AT_ZOOM_0 = 156543.04;
		        const metersPerPixel = METERS_PER_PIXEL_AT_ZOOM_0 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);

		        const METERS_PER_INCH = 0.0254;
		        const DPI = 96;
		        const metersPerInch = metersPerPixel * DPI;

		        const scale = Math.round(metersPerInch / METERS_PER_INCH);

		        _scaleCache.zoom = zoom;
		        _scaleCache.lat = center.lat;
		        _scaleCache.scale = scale;

		        if (logger && typeof logger.debug === "function") {
		            logger.debug(`[ScaleUtils] Calcul √©chelle: zoom=${zoom}, lat=${center.lat.toFixed(2)}, √©chelle=1:${scale.toLocaleString()}`);
		        }

		        return scale;
		    }

		    /**
		     * V√©rifie si l'√©chelle courante est dans l'intervalle [maxScale ; minScale].
		     * @param {number} currentScale
		     * @param {number|null|undefined} minScale - √©chelle la plus large (d√©zoom)
		     * @param {number|null|undefined} maxScale - √©chelle la plus d√©taill√©e (zoom)
		     * @param {Object} [logger]
		     * @returns {boolean}
		     */
		    function isScaleInRange(currentScale, minScale, maxScale, logger) {
		        const normalizedMin = (typeof minScale === "number" && minScale > 0) ? minScale : null;
		        const normalizedMax = (typeof maxScale === "number" && maxScale > 0) ? maxScale : null;

		        if (normalizedMin !== null && currentScale > normalizedMin) {
		            if (logger && typeof logger.debug === "function") {
		                logger.debug(`[ScaleUtils] ${currentScale} > minScale ${normalizedMin} ‚Üí invisible (trop d√©zoom√©)`);
		            }
		            return false;
		        }

		        if (normalizedMax !== null && currentScale < normalizedMax) {
		            if (logger && typeof logger.debug === "function") {
		                logger.debug(`[ScaleUtils] ${currentScale} < maxScale ${normalizedMax} ‚Üí invisible (trop zoom√©)`);
		            }
		            return false;
		        }

		        if (logger && typeof logger.debug === "function") {
		            logger.debug(`[ScaleUtils] ${currentScale} dans [${normalizedMax ?? '‚àû'} ; ${normalizedMin ?? '‚àû'}] ‚Üí visible`);
		        }

		        return true;
		    }

		    function clearScaleCache() {
		        _scaleCache.zoom = null;
		        _scaleCache.lat = null;
		        _scaleCache.scale = null;
		    }

		    GeoLeaf.Utils.ScaleUtils = {
		        calculateMapScale,
		        isScaleInRange,
		        clearScaleCache
		    };

		})(window);
		return scaleUtils;
	}

	requireScaleUtils();

	var styleResolver$2 = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredStyleResolver$2;

	function requireStyleResolver$2 () {
		if (hasRequiredStyleResolver$2) return styleResolver$2;
		hasRequiredStyleResolver$2 = 1;
		/**
		 * Style Resolver - Helper pour r√©soudre les couleurs depuis les styleRules des couches
		 * Remplace l'ancien syst√®me category.style.json
		 *
		 * @module helpers/style-resolver
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.Helpers = GeoLeaf.Helpers || {};

		    /**
		     * R√©cup√®re les couleurs d'un POI depuis les styleRules de sa couche
		     * @param {Object} poi - POI avec properties.categoryId, properties.subCategoryId
		     * @param {string} layerId - ID de la couche du POI
		     * @returns {Object|null} - { fillColor, color } ou null si non trouv√©
		     */
		    function getColorsFromLayerStyle(poi, layerId) {
		        if (!poi || !layerId) return null;

		        // R√©cup√©rer les donn√©es de la couche
		        const layerData = GeoLeaf._GeoJSONShared?.state?.layers?.get(layerId);
		        if (!layerData) return null;

		        // R√©cup√©rer le currentStyle (objet charg√© en m√©moire)
		        const styleConfig = layerData.currentStyle;
		        if (!styleConfig || !styleConfig.styleRules) return null;

		        // Extraire categoryId et subCategoryId
		        const categoryId = poi.categoryId || poi.category ||
		            (poi.attributes && poi.attributes.categoryId) ||
		            (poi.properties && poi.properties.categoryId) ||
		            (poi.properties && poi.properties.category);

		        const subCategoryId = poi.subCategoryId || poi.subCategory || poi.sub_category ||
		            (poi.attributes && poi.attributes.subCategoryId) ||
		            (poi.properties && poi.properties.subCategoryId) ||
		            (poi.properties && poi.properties.sub_category);

		        // Chercher dans les styleRules
		        // Priorit√© 1 : subCategoryId
		        if (subCategoryId) {
		            const rule = styleConfig.styleRules.find(r =>
		                r.when &&
		                r.when.field === "properties.subCategoryId" &&
		                r.when.value === subCategoryId
		            );
		            if (rule && rule.style) {
		                return {
		                    fillColor: rule.style.fillColor,
		                    color: rule.style.color,
		                    colorFill: rule.style.fillColor,
		                    colorStroke: rule.style.color
		                };
		            }
		        }

		        // Priorit√© 2 : categoryId
		        if (categoryId) {
		            const rule = styleConfig.styleRules.find(r =>
		                r.when &&
		                r.when.field === "properties.categoryId" &&
		                r.when.value === categoryId
		            );
		            if (rule && rule.style) {
		                return {
		                    fillColor: rule.style.fillColor,
		                    color: rule.style.color,
		                    colorFill: rule.style.fillColor,
		                    colorStroke: rule.style.color
		                };
		            }
		        }

		        // Fallback : defaultStyle
		        if (styleConfig.defaultStyle) {
		            return {
		                fillColor: styleConfig.defaultStyle.fillColor,
		                color: styleConfig.defaultStyle.color,
		                colorFill: styleConfig.defaultStyle.fillColor,
		                colorStroke: styleConfig.defaultStyle.color
		            };
		        }

		        return null;
		    }

		    /**
		     * R√©cup√®re les couleurs en fonction du style actif de la couche
		     * Cette fonction remplace l'ancien getCategoryStyles()
		     * @param {Object} poi - POI avec _layerConfig
		     * @returns {Object} - { colorFill, colorStroke, colorRoute }
		     */
		    function resolvePoiColors(poi) {
		        const colors = {
		            colorFill: null,
		            colorStroke: null,
		            colorRoute: null
		        };

		        if (!poi || !poi._layerConfig) return colors;

		        const layerId = poi._layerConfig.id;
		        const styleColors = getColorsFromLayerStyle(poi, layerId);

		        if (styleColors) {
		            colors.colorFill = styleColors.fillColor || styleColors.colorFill;
		            colors.colorStroke = styleColors.color || styleColors.colorStroke;
		            colors.colorRoute = styleColors.color || styleColors.colorStroke;
		        }

		        return colors;
		    }

		    // Exposer dans l'espace de noms
		    GeoLeaf.Helpers.StyleResolver = {
		        getColorsFromLayerStyle: getColorsFromLayerStyle,
		        resolvePoiColors: resolvePoiColors
		    };

		})(window);
		return styleResolver$2;
	}

	requireStyleResolver$2();

	var styleValidatorRules = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredStyleValidatorRules;

	function requireStyleValidatorRules () {
		if (hasRequiredStyleValidatorRules) return styleValidatorRules;
		hasRequiredStyleValidatorRules = 1;
		/**
		 * @fileoverview Validations des r√®gles de style (styleRules, conditions, scales)
		 * Extrait de style-validator.js pour r√©duire la complexit√©
		 * @module validators/style-validator-rules
		 */

		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    GeoLeaf._StyleValidatorRules = GeoLeaf._StyleValidatorRules || {};

		    /**
		     * Valide les styleRules (r√®gles conditionnelles de style)
		     * V√©rifie la structure when/style de chaque r√®gle et valide les conditions
		     *
		     * @param {Array<Object>} rules - Tableau de r√®gles styleRules
		     * @param {Object} rules[].when - Condition d'application (simple ou compos√©e avec "all")
		     * @param {Object} rules[].style - Style √† appliquer si condition vraie
		     * @param {Object} [rules[].legend] - Info l√©gende optionnelle pour cette r√®gle
		     * @param {Array<Object>} errors - Tableau d'erreurs √† remplir (modifi√© in-place)
		     * @param {Array<Object>} warnings - Tableau d'avertissements √† remplir (modifi√© in-place)
		     * @param {Object} context - Contexte additionnel (profileId, layerId, etc.)
		     * @returns {void} Modifie errors/warnings directement
		     * @example
		     * const rules = [
		     *   { when: { field: 'population', operator: '>', value: 100000 }, style: { color: '#ff0000' } },
		     *   { when: { all: [{ field: 'type', operator: '==', value: 'city' }] }, style: { weight: 3 } }
		     * ];
		     * const errors = [], warnings = [];
		     * GeoLeaf._StyleValidatorRules.validateStyleRules(rules, errors, warnings, { layerId: 'cities' });
		     */
		    GeoLeaf._StyleValidatorRules.validateStyleRules = function (rules, errors, warnings, context) {
		        if (!Array.isArray(rules)) {
		            errors.push({
		                field: 'styleRules',
		                message: `styleRules doit √™tre un tableau`,
		                context: { received: typeof rules, ...context }
		            });
		            return;
		        }

		        rules.forEach((rule, index) => {
		            const ruleContext = { ...context, ruleIndex: index };

		            if (typeof rule !== 'object' || rule === null) {
		                errors.push({
		                    field: `styleRules[${index}]`,
		                    message: `La r√®gle doit √™tre un objet`,
		                    context: ruleContext
		                });
		                return;
		            }

		            // Validation when
		            if (!rule.when) {
		                errors.push({
		                    field: `styleRules[${index}].when`,
		                    message: `Le champ 'when' est requis`,
		                    context: ruleContext
		                });
		            } else {
		                GeoLeaf._StyleValidatorRules.validateWhenCondition(rule.when, index, errors, warnings, ruleContext);
		            }

		            // Validation style
		            if (!rule.style) {
		                errors.push({
		                    field: `styleRules[${index}].style`,
		                    message: `Le champ 'style' est requis`,
		                    context: ruleContext
		                });
		            } else if (typeof rule.style !== 'object' || rule.style === null) {
		                errors.push({
		                    field: `styleRules[${index}].style`,
		                    message: `Le style doit √™tre un objet`,
		                    context: { received: typeof rule.style, ...ruleContext }
		                });
		            }

		            // Validation legend (optionnel)
		            if (rule.legend && typeof rule.legend !== 'object') {
		                errors.push({
		                    field: `styleRules[${index}].legend`,
		                    message: `legend doit √™tre un objet`,
		                    context: { received: typeof rule.legend, ...ruleContext }
		                });
		            }
		        });
		    };

		    /**
		     * Valide la condition when d'une r√®gle
		     * Supporte conditions simples et compos√©es avec op√©rateur "all" (ET logique)
		     *
		     * @param {Object} when - Objet de condition when
		     * @param {string} [when.field] - Champ √† tester (mode simple)
		     * @param {string} [when.operator] - Op√©rateur de comparaison (mode simple)
		     * @param {*} [when.value] - Valeur de r√©f√©rence (mode simple)
		     * @param {Array<Object>} [when.all] - Tableau de conditions (mode compos√©, ET logique)
		     * @param {number} ruleIndex - Index de la r√®gle dans styleRules (pour messages d'erreur)
		     * @param {Array<Object>} errors - Tableau d'erreurs
		     * @param {Array<Object>} warnings - Tableau d'avertissements
		     * @param {Object} context - Contexte
		     * @returns {void}
		     * @example
		     * // Condition simple
		     * const when1 = { field: 'population', operator: '>', value: 50000 };
		     * // Condition compos√©e (AND)
		     * const when2 = { all: [
		     *   { field: 'type', operator: '==', value: 'restaurant' },
		     *   { field: 'rating', operator: '>=', value: 4 }
		     * ]};
		     */
		    GeoLeaf._StyleValidatorRules.validateWhenCondition = function (when, ruleIndex, errors, warnings, context) {
		        if (typeof when !== 'object' || when === null) {
		            errors.push({
		                field: `styleRules[${ruleIndex}].when`,
		                message: `when doit √™tre un objet`,
		                context: { received: typeof when, ...context }
		            });
		            return;
		        }

		        // Support pour conditions compos√©es avec "all"
		        if (when.all && Array.isArray(when.all)) {
		            // Valider chaque condition dans le tableau "all"
		            when.all.forEach((condition, condIndex) => {
		                GeoLeaf._StyleValidatorRules.validateSimpleCondition(condition, ruleIndex, condIndex, errors, context);
		            });
		            return;
		        }

		        // Support pour conditions simples
		        GeoLeaf._StyleValidatorRules.validateSimpleCondition(when, ruleIndex, null, errors, context);
		    };

		    /**
		     * Valide une condition simple (field/operator/value)
		     * V√©rifie la pr√©sence des champs requis et la validit√© de l'op√©rateur
		     *
		     * @param {Object} condition - Condition √† valider
		     * @param {string} condition.field - Nom du champ de feature √† tester (ex: 'properties.population')
		     * @param {string} condition.operator - Op√©rateur: '==', '!=', '<', '>', '<=', '>=', 'in', 'contains'
		     * @param {*} condition.value - Valeur de r√©f√©rence (string, number, array selon op√©rateur)
		     * @param {number} ruleIndex - Index de la r√®gle dans styleRules
		     * @param {number|null} condIndex - Index de la condition dans "all" (null si condition simple)
		     * @param {Array<Object>} errors - Tableau d'erreurs
		     * @param {Object} context - Contexte
		     * @returns {void}
		     * @example
		     * const condition = { field: 'properties.type', operator: 'in', value: ['hotel', 'restaurant'] };
		     * validateSimpleCondition(condition, 0, null, errors, {});
		     */
		    GeoLeaf._StyleValidatorRules.validateSimpleCondition = function (condition, ruleIndex, condIndex = null, errors, context) {
		        // Champs requis
		        const required = ['field', 'operator', 'value'];
		        for (const field of required) {
		            if (!(field in condition)) {
		                const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
		                errors.push({
		                    field: `${prefix}.${field}`,
		                    message: `Le champ '${field}' est requis dans la condition`,
		                    context
		                });
		            }
		        }

		        // Validation operator
		        const validOperators = ['==', '!=', '<', '>', '<=', '>=', 'in', 'contains'];
		        if (condition.operator && !validOperators.includes(condition.operator)) {
		            const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
		            errors.push({
		                field: `${prefix}.operator`,
		                message: `Op√©rateur invalide`,
		                context: { received: condition.operator, allowed: validOperators, ...context }
		            });
		        }

		        // Validation field
		        if (condition.field && typeof condition.field !== 'string') {
		            const prefix = condIndex !== null ? `styleRules[${ruleIndex}].when.all[${condIndex}]` : `styleRules[${ruleIndex}].when`;
		            errors.push({
		                field: `${prefix}.field`,
		                message: `field doit √™tre une cha√Æne de caract√®res`,
		                context: { received: typeof condition.field, ...context }
		            });
		        }
		    };

		    /**
		     * Valide les √©chelles (layerScale, labelScale)
		     * V√©rifie la structure des objets d'√©chelle et la validit√© des valeurs min/max
		     *
		     * @param {Object} styleData - Donn√©es du style
		     * @param {Object} [styleData.layerScale] - √âchelle de visibilit√© de la couche
		     * @param {number|null} [styleData.layerScale.minScale] - Zoom minimum (ou null = pas de limite)
		     * @param {number|null} [styleData.layerScale.maxScale] - Zoom maximum (ou null = pas de limite)
		     * @param {Object} [styleData.labelScale] - √âchelle de visibilit√© des labels
		     * @param {Array<Object>} errors - Tableau d'erreurs
		     * @param {Array<Object>} warnings - Tableau d'avertissements
		     * @param {Object} context - Contexte
		     * @returns {void}
		     * @example
		     * const styleData = {
		     *   layerScale: { minScale: 10, maxScale: 18 },  // Visible du zoom 10 √† 18
		     *   labelScale: { minScale: 14, maxScale: null }  // Labels visibles √† partir du zoom 14
		     * };
		     */
		    GeoLeaf._StyleValidatorRules.validateScales = function (styleData, errors, warnings, context) {
		        ['layerScale', 'labelScale'].forEach(scaleField => {
		            const isRequired = scaleField === 'layerScale';

		            if (!styleData[scaleField]) {
		                if (isRequired) {
		                    errors.push({
		                        field: scaleField,
		                        message: `${scaleField} est requis`,
		                        context
		                    });
		                }
		                return;
		            }

		            const scale = styleData[scaleField];
		            if (typeof scale !== 'object' || scale === null) {
		                errors.push({
		                    field: scaleField,
		                    message: `${scaleField} doit √™tre un objet`,
		                    context: { received: typeof scale, ...context }
		                });
		                return;
		            }

		            ['minScale', 'maxScale'].forEach(prop => {
		                if (!(prop in scale)) {
		                    if (isRequired) {
		                        errors.push({
		                            field: `${scaleField}.${prop}`,
		                            message: `${prop} est requis dans ${scaleField}`,
		                            context
		                        });
		                    }
		                    return;
		                }

		                if (scale[prop] !== null) {
		                    if (typeof scale[prop] !== 'number' || scale[prop] < 0) {
		                        errors.push({
		                            field: `${scaleField}.${prop}`,
		                            message: `${prop} doit √™tre un nombre >= 0 ou null`,
		                            context: { received: scale[prop], ...context }
		                        });
		                    }
		                }
		            });
		        });
		    };

		    /**
		     * Valide la configuration legend
		     * V√©rifie la structure et les types des propri√©t√©s de l√©gende
		     *
		     * @param {Object} legend - Configuration legend
		     * @param {number} [legend.order] - Ordre d'affichage dans la l√©gende (doit √™tre entier)
		     * @param {string} [legend.label] - Label √† afficher dans la l√©gende
		     * @param {string} [legend.description] - Description compl√©mentaire
		     * @param {Array<Object>} errors - Tableau d'erreurs
		     * @param {Array<Object>} warnings - Tableau d'avertissements
		     * @param {Object} context - Contexte
		     * @returns {void}
		     * @example
		     * const legend = { order: 1, label: 'Grandes villes', description: 'Population > 100k' };
		     */
		    GeoLeaf._StyleValidatorRules.validateLegend = function (legend, errors, warnings, context) {
		        if (typeof legend !== 'object' || legend === null) {
		            errors.push({
		                field: 'legend',
		                message: `legend doit √™tre un objet`,
		                context: { received: typeof legend, ...context }
		            });
		            return;
		        }

		        if ('order' in legend && !Number.isInteger(legend.order)) {
		            errors.push({
		                field: 'legend.order',
		                message: `order doit √™tre un entier`,
		                context: { received: legend.order, type: typeof legend.order, ...context }
		            });
		        }
		    };

		})(window);
		return styleValidatorRules;
	}

	requireStyleValidatorRules();

	var styleValidator = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredStyleValidator;

	function requireStyleValidator () {
		if (hasRequiredStyleValidator) return styleValidator;
		hasRequiredStyleValidator = 1;
		/**
		 * @fileoverview Validateur de fichiers de style GeoLeaf
		 * Valide les fichiers style.json contre le sch√©ma JSON d√©fini
		 * et g√©n√®re des erreurs d√©taill√©es avec contexte pour faciliter le debugging
		 * @module validators/style-validator
		 */

		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		// Import du sch√©ma (sera charg√© dynamiquement si n√©cessaire)
		// const styleSchema = require('../../../../schema/style.schema.json');

		/**
		 * Classe d'erreur pour les validations de style
		 */
		class StyleValidationError extends Error {
		    constructor(message, context = {}) {
		        super(message);
		        this.name = 'StyleValidationError';
		        this.context = context;
		    }
		}

		/**
		 * Valide un objet de style contre le sch√©ma JSON
		 * @param {Object} styleData - Donn√©es du style √† valider
		 * @param {Object} context - Contexte additionnel (profileId, layerId, styleId)
		 * @returns {Object} R√©sultat de validation { valid: boolean, errors: Array, warnings: Array }
		 */
		function validateStyle(styleData, context = {}) {
		    const errors = [];
		    const warnings = [];

		    try {
		        // Validation de base: objet requis
		        if (!styleData || typeof styleData !== 'object') {
		            errors.push({
		                field: 'root',
		                message: 'Le style doit √™tre un objet JSON valide',
		                context: { received: typeof styleData, ...context }
		            });
		            return { valid: false, errors, warnings };
		        }

		        // Validation des champs requis
		        validateRequiredFields(styleData, errors, context);

		        // Validation du format de l'ID
		        validateId(styleData, errors, context);

		        // Validation du champ label (string ou objet)
		        validateLabel(styleData, errors, warnings, context);

		        // Validation du style de base
		        validateBaseStyle(styleData, errors, warnings, context);

		        // Validation des styleRules si pr√©sentes
		        if (styleData.styleRules) {
		            validateStyleRules(styleData.styleRules, errors, warnings, context);
		        }

		        // Validation des √©chelles
		        validateScales(styleData, errors, warnings, context);

		        // Validation de la l√©gende
		        if (styleData.legend) {
		            validateLegend(styleData.legend, errors, warnings, context);
		        }

		    } catch (error) {
		        errors.push({
		            field: 'validation',
		            message: `Erreur inattendue lors de la validation: ${error.message}`,
		            stack: error.stack,
		            context
		        });
		    }

		    return {
		        valid: errors.length === 0,
		        errors,
		        warnings
		    };
		}

		/**
		 * Valide les champs requis
		 */
		function validateRequiredFields(styleData, errors, context) {
		    // V√©rifier l'ID (obligatoire)
		    if (!('id' in styleData) || styleData.id === undefined || styleData.id === null) {
		        errors.push({
		            field: 'id',
		            message: `Le champ requis 'id' est manquant`,
		            context: { availableFields: Object.keys(styleData), ...context }
		        });
		    }

		    // V√©rifier que 'style' OU 'defaultStyle' est pr√©sent (au moins un des deux)
		    const hasStyle = ('style' in styleData) && styleData.style !== undefined && styleData.style !== null;
		    const hasDefaultStyle = ('defaultStyle' in styleData) && styleData.defaultStyle !== undefined && styleData.defaultStyle !== null;

		    if (!hasStyle && !hasDefaultStyle) {
		        errors.push({
		            field: 'style',
		            message: `Le champ requis 'style' ou 'defaultStyle' est manquant`,
		            context: { availableFields: Object.keys(styleData), ...context }
		        });
		    }

		    if (!('layerScale' in styleData)) {
		        errors.push({
		            field: 'layerScale',
		            message: `Le champ requis 'layerScale' est manquant`,
		            context: { availableFields: Object.keys(styleData), ...context }
		        });
		    }
		}

		/**
		 * Valide le format de l'ID
		 */
		function validateId(styleData, errors, context) {
		    if (!styleData.id) return;

		    // Pattern acceptant lettres (y compris accentu√©es), chiffres, tirets et underscores
		    // \p{L} = toutes les lettres Unicode (y compris √©, √†, √±, etc.)
		    const idPattern = /^[\p{L}0-9_-]+$/u;
		    if (typeof styleData.id !== 'string') {
		        errors.push({
		            field: 'id',
		            message: `L'ID doit √™tre une cha√Æne de caract√®res`,
		            context: { received: typeof styleData.id, value: styleData.id, ...context }
		        });
		    } else if (!idPattern.test(styleData.id)) {
		        errors.push({
		            field: 'id',
		            message: `L'ID doit contenir uniquement des lettres, chiffres, tirets et underscores`,
		            context: { received: styleData.id, pattern: idPattern.toString(), ...context }
		        });
		    }
		}

		/**
		 * Valide le champ label (peut √™tre string ou objet de config label)
		 */
		function validateLabel(styleData, errors, warnings, context) {
		    if (!('label' in styleData)) return;

		    const label = styleData.label;

		    // String: nom d'affichage
		    if (typeof label === 'string') {
		        return;
		    }

		    // Objet: configuration de labels int√©gr√©s
		    if (typeof label === 'object' && label !== null) {
		        // enabled est requis
		        if (!('enabled' in label)) {
		            errors.push({
		                field: 'label.enabled',
		                message: `Le champ 'enabled' est requis dans la configuration de labels`,
		                context: { labelConfig: label, ...context }
		            });
		        } else if (typeof label.enabled !== 'boolean') {
		            errors.push({
		                field: 'label.enabled',
		                message: `Le champ 'enabled' doit √™tre un bool√©en`,
		                context: { received: typeof label.enabled, value: label.enabled, ...context }
		            });
		        }

		        // Si enabled, field devrait √™tre pr√©sent
		        if (label.enabled && !label.field) {
		            warnings.push({
		                field: 'label.field',
		                message: `Les labels sont activ√©s mais aucun champ n'est sp√©cifi√©`,
		                context: { labelConfig: label, ...context }
		            });
		        }

		        // Validation font
		        if (label.font) {
		            validateFont(label.font, errors, warnings, context);
		        }

		        // Validation des couleurs
		        if (label.color && !isValidHexColor(label.color)) {
		            errors.push({
		                field: 'label.color',
		                message: `Couleur invalide, format attendu: #RRGGBB`,
		                context: { received: label.color, ...context }
		            });
		        }

		        // Validation opacity
		        if ('opacity' in label && (typeof label.opacity !== 'number' || label.opacity < 0 || label.opacity > 1)) {
		            errors.push({
		                field: 'label.opacity',
		                message: `L'opacit√© doit √™tre un nombre entre 0 et 1`,
		                context: { received: label.opacity, ...context }
		            });
		        }

		        // Validation buffer
		        if (label.buffer) {
		            validateLabelComponent(label.buffer, 'label.buffer', errors, warnings, context);
		        }

		        // Validation background
		        if (label.background) {
		            validateLabelComponent(label.background, 'label.background', errors, warnings, context);
		        }

		        // Validation offset
		        if (label.offset && typeof label.offset.distancePx !== 'undefined') {
		            if (typeof label.offset.distancePx !== 'number') {
		                errors.push({
		                    field: 'label.offset.distancePx',
		                    message: `distancePx doit √™tre un nombre`,
		                    context: { received: typeof label.offset.distancePx, ...context }
		                });
		            }
		        }

		        return;
		    }

		    // Type invalide
		    errors.push({
		        field: 'label',
		        message: `Le champ 'label' doit √™tre une cha√Æne de caract√®res ou un objet de configuration`,
		        context: { received: typeof label, value: label, ...context }
		    });
		}

		/**
		 * Valide la configuration font
		 */
		function validateFont(font, errors, warnings, context) {
		    if (typeof font !== 'object' || font === null) {
		        errors.push({
		            field: 'label.font',
		            message: `La configuration font doit √™tre un objet`,
		            context: { received: typeof font, ...context }
		        });
		        return;
		    }

		    if (font.sizePt !== undefined) {
		        if (typeof font.sizePt !== 'number' || font.sizePt < 1) {
		            errors.push({
		                field: 'label.font.sizePt',
		                message: `sizePt doit √™tre un nombre >= 1`,
		                context: { received: font.sizePt, ...context }
		            });
		        }
		    }

		    if (font.weight !== undefined) {
		        if (!Number.isInteger(font.weight) || font.weight < 0 || font.weight > 100) {
		            errors.push({
		                field: 'label.font.weight',
		                message: `weight doit √™tre un entier entre 0 et 100`,
		                context: { received: font.weight, ...context }
		            });
		        }
		    }
		}

		/**
		 * Valide un composant de label (buffer, background)
		 */
		function validateLabelComponent(component, fieldPath, errors, warnings, context) {
		    if (typeof component !== 'object' || component === null) {
		        errors.push({
		            field: fieldPath,
		            message: `${fieldPath} doit √™tre un objet`,
		            context: { received: typeof component, ...context }
		        });
		        return;
		    }

		    if (component.color && !isValidHexColor(component.color)) {
		        errors.push({
		            field: `${fieldPath}.color`,
		            message: `Couleur invalide, format attendu: #RRGGBB`,
		            context: { received: component.color, ...context }
		        });
		    }

		    if ('opacity' in component && (typeof component.opacity !== 'number' || component.opacity < 0 || component.opacity > 1)) {
		        errors.push({
		            field: `${fieldPath}.opacity`,
		            message: `L'opacit√© doit √™tre un nombre entre 0 et 1`,
		            context: { received: component.opacity, ...context }
		        });
		    }

		    if ('sizePx' in component && (typeof component.sizePx !== 'number' || component.sizePx < 0)) {
		        errors.push({
		            field: `${fieldPath}.sizePx`,
		            message: `sizePx doit √™tre un nombre >= 0`,
		            context: { received: component.sizePx, ...context }
		        });
		    }
		}

		/**
		 * Valide le style de base
		 */
		function validateBaseStyle(styleData, errors, warnings, context) {
		    const style = styleData.style || styleData.defaultStyle;

		    if (!style) return;

		    if (typeof style !== 'object' || style === null) {
		        errors.push({
		            field: 'style',
		            message: `Le style doit √™tre un objet`,
		            context: { received: typeof style, ...context }
		        });
		        return;
		    }

		    // Validation des couleurs
		    ['fillColor', 'color'].forEach(colorField => {
		        if (style[colorField] && !isValidHexColor(style[colorField])) {
		            errors.push({
		                field: `style.${colorField}`,
		                message: `Couleur invalide, format attendu: #RRGGBB`,
		                context: { received: style[colorField], ...context }
		            });
		        }
		    });

		    // Validation des opacit√©s
		    ['fillOpacity', 'opacity'].forEach(opacityField => {
		        if (opacityField in style) {
		            if (typeof style[opacityField] !== 'number' || style[opacityField] < 0 || style[opacityField] > 1) {
		                errors.push({
		                    field: `style.${opacityField}`,
		                    message: `${opacityField} doit √™tre un nombre entre 0 et 1`,
		                    context: { received: style[opacityField], ...context }
		                });
		            }
		        }
		    });

		    // Validation des tailles
		    ['weight', 'sizePx', 'radius'].forEach(sizeField => {
		        if (sizeField in style) {
		            if (typeof style[sizeField] !== 'number' || style[sizeField] < 0) {
		                errors.push({
		                    field: `style.${sizeField}`,
		                    message: `${sizeField} doit √™tre un nombre >= 0`,
		                    context: { received: style[sizeField], ...context }
		                });
		            }
		        }
		    });

		    // Validation shape (points)
		    if (style.shape && !['circle', 'square'].includes(style.shape)) {
		        errors.push({
		            field: 'style.shape',
		            message: `shape doit √™tre 'circle' ou 'square'`,
		            context: { received: style.shape, allowed: ['circle', 'square'], ...context }
		        });
		    }

		    // Validation stroke (lignes)
		    if (style.stroke) {
		        validateStroke(style.stroke, errors, warnings, context);
		    }

		    // Validation casing (lignes)
		    if (style.casing) {
		        validateCasing(style.casing, errors, warnings, context);
		    }

		    // Validation fillPattern (polygones)
		    if (style.fillPattern) {
		        validateFillPattern(style.fillPattern, errors, warnings, context);
		    }
		}

		/**
		 * Valide le stroke (lignes)
		 */
		function validateStroke(stroke, errors, warnings, context) {
		    if (typeof stroke !== 'object' || stroke === null) {
		        errors.push({
		            field: 'style.stroke',
		            message: `stroke doit √™tre un objet`,
		            context: { received: typeof stroke, ...context }
		        });
		        return;
		    }

		    if (stroke.color && !isValidHexColor(stroke.color)) {
		        errors.push({
		            field: 'style.stroke.color',
		            message: `Couleur invalide, format attendu: #RRGGBB`,
		            context: { received: stroke.color, ...context }
		        });
		    }

		    if ('opacity' in stroke && (typeof stroke.opacity !== 'number' || stroke.opacity < 0 || stroke.opacity > 1)) {
		        errors.push({
		            field: 'style.stroke.opacity',
		            message: `opacity doit √™tre un nombre entre 0 et 1`,
		            context: { received: stroke.opacity, ...context }
		        });
		    }

		    if ('weight' in stroke && (typeof stroke.weight !== 'number' || stroke.weight < 0)) {
		        errors.push({
		            field: 'style.stroke.weight',
		            message: `weight doit √™tre un nombre >= 0`,
		            context: { received: stroke.weight, ...context }
		        });
		    }

		    if (stroke.dashArray !== null && stroke.dashArray !== undefined && typeof stroke.dashArray !== 'string') {
		        errors.push({
		            field: 'style.stroke.dashArray',
		            message: `dashArray doit √™tre une cha√Æne de caract√®res ou null`,
		            context: { received: typeof stroke.dashArray, value: stroke.dashArray, ...context }
		        });
		    }
		}

		/**
		 * Valide le casing (lignes)
		 */
		function validateCasing(casing, errors, warnings, context) {
		    if (typeof casing !== 'object' || casing === null) {
		        errors.push({
		            field: 'style.casing',
		            message: `casing doit √™tre un objet`,
		            context: { received: typeof casing, ...context }
		        });
		        return;
		    }

		    if ('enabled' in casing && typeof casing.enabled !== 'boolean') {
		        errors.push({
		            field: 'style.casing.enabled',
		            message: `enabled doit √™tre un bool√©en`,
		            context: { received: typeof casing.enabled, ...context }
		        });
		    }

		    if (casing.color && !isValidHexColor(casing.color)) {
		        errors.push({
		            field: 'style.casing.color',
		            message: `Couleur invalide, format attendu: #RRGGBB`,
		            context: { received: casing.color, ...context }
		        });
		    }
		}

		/**
		 * Valide le fillPattern (polygones)
		 */
		function validateFillPattern(pattern, errors, warnings, context) {
		    if (typeof pattern !== 'object' || pattern === null) {
		        errors.push({
		            field: 'style.fillPattern',
		            message: `fillPattern doit √™tre un objet`,
		            context: { received: typeof pattern, ...context }
		        });
		        return;
		    }

		    if ('enabled' in pattern && typeof pattern.enabled !== 'boolean') {
		        errors.push({
		            field: 'style.fillPattern.enabled',
		            message: `enabled doit √™tre un bool√©en`,
		            context: { received: typeof pattern.enabled, ...context }
		        });
		    }

		    if (pattern.type && !['diagonal', 'horizontal', 'vertical', 'cross', 'x'].includes(pattern.type)) {
		        errors.push({
		            field: 'style.fillPattern.type',
		            message: `type doit √™tre parmi: diagonal, horizontal, vertical, cross, x`,
		            context: { received: pattern.type, allowed: ['diagonal', 'horizontal', 'vertical', 'cross', 'x'], ...context }
		        });
		    }

		    if (pattern.color && !isValidHexColor(pattern.color)) {
		        errors.push({
		            field: 'style.fillPattern.color',
		            message: `Couleur invalide, format attendu: #RRGGBB`,
		            context: { received: pattern.color, ...context }
		        });
		    }

		    ['weight', 'density'].forEach(field => {
		        if (field in pattern && (typeof pattern[field] !== 'number' || pattern[field] < 0)) {
		            errors.push({
		                field: `style.fillPattern.${field}`,
		                message: `${field} doit √™tre un nombre >= 0`,
		                context: { received: pattern[field], ...context }
		            });
		        }
		    });
		}

		/**
		 * Valide les styleRules
		 */
		/**
		 * @deprecated Utiliser GeoLeaf._StyleValidatorRules.validateStyleRules()
		 */
		function validateStyleRules(rules, errors, warnings, context) {
		    return GeoLeaf._StyleValidatorRules.validateStyleRules(rules, errors, warnings, context);
		}

		/**
		 * @deprecated Utiliser GeoLeaf._StyleValidatorRules.validateScales()
		 */
		function validateScales(styleData, errors, warnings, context) {
		    return GeoLeaf._StyleValidatorRules.validateScales(styleData, errors, warnings, context);
		}

		/**
		 * @deprecated Utiliser GeoLeaf._StyleValidatorRules.validateLegend()
		 */
		function validateLegend(legend, errors, warnings, context) {
		    return GeoLeaf._StyleValidatorRules.validateLegend(legend, errors, warnings, context);
		}

		/**
		 * V√©rifie si une couleur est au format hex valide (#RRGGBB)
		 */
		function isValidHexColor(color) {
		    return typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color);
		}

		/**
		 * Formate un r√©sultat de validation en message d'erreur lisible
		 * @param {Object} validationResult - R√©sultat de validateStyle()
		 * @param {string} styleFilePath - Chemin du fichier de style (optionnel)
		 * @returns {string} Message format√©
		 */
		function formatValidationErrors(validationResult, styleFilePath = '') {
		    if (validationResult.valid) {
		        return null;
		    }

		    const lines = [];
		    lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		    lines.push('‚ùå ERREUR DE VALIDATION DE STYLE GEOLEAF');
		    lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

		    if (styleFilePath) {
		        lines.push(`Fichier: ${styleFilePath}`);
		        lines.push('');
		    }

		    if (validationResult.errors.length > 0) {
		        lines.push(`‚ùå ${validationResult.errors.length} erreur(s) d√©tect√©e(s):`);
		        lines.push('');

		        validationResult.errors.forEach((error, index) => {
		            lines.push(`  ${index + 1}. Champ: ${error.field}`);
		            lines.push(`     Message: ${error.message}`);
		            if (error.context) {
		                lines.push(`     Contexte: ${JSON.stringify(error.context, null, 2).split('\n').join('\n     ')}`);
		            }
		            if (error.stack) {
		                lines.push(`     Stack: ${error.stack.split('\n').slice(0, 3).join('\n     ')}`);
		            }
		            lines.push('');
		        });
		    }

		    if (validationResult.warnings.length > 0) {
		        lines.push(`‚ö†Ô∏è  ${validationResult.warnings.length} avertissement(s):`);
		        lines.push('');

		        validationResult.warnings.forEach((warning, index) => {
		            lines.push(`  ${index + 1}. Champ: ${warning.field}`);
		            lines.push(`     Message: ${warning.message}`);
		            if (warning.context) {
		                lines.push(`     Contexte: ${JSON.stringify(warning.context, null, 2).split('\n').join('\n     ')}`);
		            }
		            lines.push('');
		        });
		    }

		    lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		    lines.push('üí° Conseil: V√©rifiez la documentation dans docs/STYLE_FORMAT_SPEC.md');
		    lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

		    return lines.join('\n');
		}

		/**
		 * Module Style Validator
		 * Expose les fonctions publiques
		 */
		const StyleValidator = {
		    validateStyle,
		    formatValidationErrors,
		    StyleValidationError
		};

		// Exposer le module
		GeoLeaf._StyleValidator = StyleValidator;

		})(window);
		return styleValidator;
	}

	requireStyleValidator();

	var geoleaf_core = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_core;

	function requireGeoleaf_core () {
		if (hasRequiredGeoleaf_core) return geoleaf_core;
		hasRequiredGeoleaf_core = 1;
		(function (global) {
		    // Instance unique de la carte Leaflet g√©r√©e par GeoLeaf.Core
		    let _mapInstance = null;

		    // ---------------------------------------------------------
		    // Namespace global
		    // ---------------------------------------------------------
		    const root = (typeof globalThis !== "undefined" ? globalThis : window);
		    root.GeoLeaf = root.GeoLeaf || {};
		    root.GeoLeaf.Core = root.GeoLeaf.Core || {};

		    // ---------------------------------------------------------
		    // Logger unifi√© (d√©fini par geoleaf.logger-shim.js charg√© en premier)
		    // ---------------------------------------------------------
		    const Log = root.GeoLeaf.Log;

		    // ---------------------------------------------------------
		    // Module interne
		    // ---------------------------------------------------------
		    const Core = (function () {

		        let _map = null;
		        let _theme = "light";

		        // -----------------------------------------------------
		        // Gestion d‚Äôerreurs uniforme
		        // -----------------------------------------------------
		        function init(options = {}) {
		            const context = "[GeoLeaf.Core]";

		            try {
		                // V√©rification Leaflet
		                if (typeof L === "undefined") {
		                    throw new Error("Leaflet (L) est introuvable. Assurez-vous d‚Äôavoir charg√© Leaflet 1.9.x.");
		                }

		                // V√©rification des options obligatoires
		                if (!options.mapId) {
		                    throw new Error("L‚Äôoption obligatoire 'mapId' est manquante.");
		                }
		                const targetEl = document.getElementById(options.mapId);
		                if (!targetEl) {
		                    throw new Error(`Aucun √©l√©ment DOM trouv√© pour mapId='${options.mapId}'.`);
		                }

		                // Valeurs par d√©faut + normalisation
		                const center = Array.isArray(options.center) ? options.center : GeoLeaf.CONSTANTS.DEFAULT_CENTER;
		                const zoom = Number.isFinite(options.zoom) ? options.zoom : GeoLeaf.CONSTANTS.DEFAULT_ZOOM;
		                const theme = options.theme || "light";

		                // Cr√©ation ou r√©cup√©ration de la carte
		                if (_mapInstance) {
		                    Log.warn(`${context} Carte d√©j√† initialis√©e. Recyclage de l‚Äôinstance existante.`);
		                    return _mapInstance;
		                }

		                // Options Leaflet : on permet mapOptions, mais on force zoomControl √† true par d√©faut
		                const leafletMapOptions = Object.assign({}, options.mapOptions || {}, {
		                    center,
		                    zoom
		                });

		                if (typeof leafletMapOptions.zoomControl === "undefined") {
		                    leafletMapOptions.zoomControl = true;            // ‚úÖ boutons de zoom activ√©s par d√©faut
		                }
		                if (typeof leafletMapOptions.attributionControl === "undefined") {
		                    leafletMapOptions.attributionControl = false;    // tu gardes ton UI sans attribution Leaflet
		                }
		                if (typeof leafletMapOptions.zoomSnap === "undefined") {
		                    leafletMapOptions.zoomSnap = 0;                  // ‚úÖ D√©sactive le snapping = zoom totalement libre
		                }
		                if (typeof leafletMapOptions.zoomDelta === "undefined") {
		                    leafletMapOptions.zoomDelta = 0.25;              // ‚úÖ Incr√©ments de zoom pour les boutons +/-
		                }
		                if (typeof leafletMapOptions.wheelPxPerZoomLevel === "undefined") {
		                    leafletMapOptions.wheelPxPerZoomLevel = 120;     // ‚úÖ Sensibilit√© de la molette
		                }

		                _mapInstance = L.map(targetEl, leafletMapOptions);
		                _map = _mapInstance; // ‚úÖ Synchronisation de la variable locale

		                // Application du th√®me
		                try {
		                    if (global.GeoLeaf && global.GeoLeaf.UI && typeof global.GeoLeaf.UI.applyTheme === "function") {
		                        global.GeoLeaf.UI.applyTheme(theme);
		                    }
		                } catch (themeError) {
		                    Log.warn(`${context} Impossible d'appliquer le th√®me :`, themeError);
		                }

		                // Initialisation du module Legend si disponible et activ√©
		                const uiConfig = global.GeoLeaf.Config && global.GeoLeaf.Config.get ? global.GeoLeaf.Config.get('ui') : null;
		                const showLegend = uiConfig ? (uiConfig.showLegend !== false) : true;

		                if (showLegend && global.GeoLeaf && global.GeoLeaf.Legend && typeof global.GeoLeaf.Legend.init === "function") {
		                    try {
		                        global.GeoLeaf.Legend.init(_mapInstance, {
		                            position: "bottomleft",
		                            collapsible: true,
		                            collapsed: false
		                        });
		                    } catch (legendError) {
		                        Log.warn(`${context} Impossible d'initialiser Legend :`, legendError);
		                    }
		                }

		                Log.info(`${context} Carte initialis√©e avec succ√®s.`);
		                return _mapInstance;

		            } catch (err) {
		                Log.error(`${context} ERREUR :`, err.message);

		                // Callback global utilisateur
		                if (typeof global.GeoLeaf?.Core?.onError === "function") {
		                    try {
		                        global.GeoLeaf.Core.onError(err);
		                    } catch (cbErr) {
		                        Log.error(`${context} Erreur dans Core.onError() :`, cbErr);
		                    }
		                }

		                // ‚úÖ S'assurer que les variables sont coh√©rentes en cas d'erreur
		                _mapInstance = null;
		                _map = null;

		                return null;
		            }
		        }

		        // -----------------------------------------------------
		        // Compatibilit√© descendante : initMap
		        // -----------------------------------------------------
		        function initMap(a, b, c, d) {
		            Log.warn("[GeoLeaf.Core] GeoLeaf.Core.initMap() est obsol√®te, utilisez GeoLeaf.Core.init().");

		            let options = null;

		            if (root.GeoLeaf && root.GeoLeaf.Config && typeof root.GeoLeaf.Config.get === "function") {
		                try {
		                    const mapCfg = root.GeoLeaf.Config.get("map") || {};
		                    const uiCfg = root.GeoLeaf.Config.get("ui") || {};

		                    options = {
		                        target: mapCfg.target || "geoleaf-map",
		                        center: mapCfg.center || GeoLeaf.CONSTANTS.DEFAULT_CENTER,
		                        zoom: (typeof mapCfg.zoom === "number" ? mapCfg.zoom : GeoLeaf.CONSTANTS.DEFAULT_ZOOM),
		                        theme: uiCfg.theme || "light",
		                        mapOptions: mapCfg.mapOptions || {}
		                    };

		                    return init(options);
		                } catch (err) {
		                    Log.error("[GeoLeaf.Core] initMap() n‚Äôa pas pu construire les options √† partir de GeoLeaf.Config :", err);
		                    // on continue vers les heuristiques d‚Äôarguments
		                }
		            }

		            // Cas objet unique : initMap({ target, center, zoom, theme })
		            if (a && typeof a === "object" && !Array.isArray(a)) {
		                return init(a);
		            }

		            // Cas ancienne signature : initMap(target, center, zoom, theme?)
		            if (typeof a === "string" && Array.isArray(b) && typeof c === "number") {
		                const legacyOptions = {
		                    center: b,
		                    zoom: c,
		                    theme: d || "light"
		                };
		                return init(legacyOptions);
		            }

		            Log.error("[GeoLeaf.Core] initMap() appel√© avec une signature obsol√®te ou invalide. Utilisez GeoLeaf.Core.init({ target, center, zoom, theme }).");
		            return null;
		        }

		        // -----------------------------------------------------
		        // Th√®me
		        // -----------------------------------------------------
		        function _applyThemeToBody(theme) {
		            const body = document.body;
		            if (!body) {
		                Log.warn("[GeoLeaf.Core] Impossible d‚Äôappliquer le th√®me : document.body introuvable.");
		                return;
		            }
		            body.classList.remove("gl-theme-light", "gl-theme-dark");
		            body.classList.add(theme === "dark" ? "gl-theme-dark" : "gl-theme-light");
		        }

		        function setTheme(theme) {
		            if (!theme || (theme !== "light" && theme !== "dark")) {
		                Log.warn("[GeoLeaf.Core] setTheme() : th√®me invalide ‚Üí", theme);
		                return;
		            }
		            _theme = theme;
		            _applyThemeToBody(theme);
		        }

		        function getTheme() {
		            return _theme;
		        }

		        // -----------------------------------------------------
		        // Acc√®s √† la map
		        // -----------------------------------------------------
		        function getMap() {
		            return _map;
		        }

		        // -----------------------------------------------------
		        // API publique
		        // -----------------------------------------------------
		        return {
		            init,      // nouvelle API normalis√©e
		            initMap,   // alias r√©trocompatible pour la d√©mo et anciens appels
		            getMap,
		            setTheme,
		            getTheme
		        };

		    })();

		    root.GeoLeaf.Core = Core;

		})(window);
		return geoleaf_core;
	}

	requireGeoleaf_core();

	var theme = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredTheme;

	function requireTheme () {
		if (hasRequiredTheme) return theme;
		hasRequiredTheme = 1;
		/**
		 * GeoLeaf UI Module - Theme Management
		 * Gestion du th√®me dark/light avec persistance localStorage
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._UITheme = GeoLeaf._UITheme || {};

		    // ========================================
		    //   CONSTANTES
		    // ========================================

		    const THEME_KEY = "geoleaf_theme";
		    const THEME_LIGHT = "light";
		    const THEME_DARK = "dark";

		    // ========================================
		    //   √âTAT INTERNE
		    // ========================================

		    /**
		     * Source de v√©rit√© unique pour le th√®me actuel
		     * @type {string|null}
		     * @private
		     */
		    let _currentTheme = null;

		    // ========================================
		    //   FONCTIONS PUBLIQUES
		    // ========================================

		    /**
		     * Retourne le th√®me courant ("light" ou "dark").
		     * @returns {string} Theme actuel
		     */
		    function getCurrentTheme() {
		        // Si d√©j√† en m√©moire, retourner directement
		        if (_currentTheme) {
		            return _currentTheme;
		        }

		        // Sinon, fallback sur le DOM
		        if (document.body.classList.contains("gl-theme-dark")) {
		            _currentTheme = THEME_DARK;
		            return THEME_DARK;
		        }
		        if (document.body.classList.contains("gl-theme-light")) {
		            _currentTheme = THEME_LIGHT;
		            return THEME_LIGHT;
		        }

		        // Fallback final
		        _currentTheme = THEME_DARK;
		        return THEME_DARK;
		    }

		    /**
		     * Applique un th√®me au <body> et synchronise le bouton.
		     * @param {string} theme - "light" ou "dark"
		     */
		    function applyTheme(theme) {
		        const normalized =
		            theme === THEME_LIGHT || theme === THEME_DARK
		                ? theme
		                : THEME_DARK;

		        Log.debug('[UI.Theme] applyTheme:', theme, '‚Üí', normalized);

		        // Mettre √† jour l'√©tat centralis√© AVANT le DOM
		        _currentTheme = normalized;

		        // Mise √† jour du DOM sur body
		        document.body.classList.remove("gl-theme-light", "gl-theme-dark");
		        document.body.classList.add(
		            normalized === THEME_DARK ? "gl-theme-dark" : "gl-theme-light"
		        );

		        // Appliquer aussi le th√®me au conteneur de carte (pour support fullscreen)
		        const mapContainer = document.getElementById("geoleaf-map");
		        if (mapContainer) {
		            mapContainer.classList.remove("gl-theme-light", "gl-theme-dark");
		            mapContainer.classList.add(
		                normalized === THEME_DARK ? "gl-theme-dark" : "gl-theme-light"
		            );
		        }

		        // Sauvegarde locale
		        try {
		            // SAFE: Use StorageHelper with Theme validator
		            const StorageHelper = GeoLeaf.StorageHelper;
		            const ThemeValidator = GeoLeaf.Validators?.Theme;

		            if (StorageHelper && ThemeValidator) {
		                StorageHelper.setItem(THEME_KEY, normalized, ThemeValidator);
		            } else {
		                // Fallback if StorageHelper not loaded yet
		                global.localStorage.setItem(THEME_KEY, normalized);
		            }
		        } catch (e) {
		            // G√©rer explicitement l'absence de localStorage
		            if (Log) Log.warn("[UI.Theme] localStorage non disponible, th√®me non persist√©.");
		        }

		        // Synchronise le bouton si pr√©sent
		        updateToggleButton(normalized);

		        // √âv√®nement global pour les autres modules
		        if (global.dispatchEvent) {
		            global.dispatchEvent(
		                new CustomEvent("geoleaf:ui-theme-changed", {
		                    detail: { theme: normalized }
		                })
		            );
		        }
		    }

		    /**
		     * Bascule le th√®me courant (light <-> dark).
		     */
		    function toggleTheme() {
		        const current = getCurrentTheme();
		        const next = current === THEME_DARK ? THEME_LIGHT : THEME_DARK;
		        Log.debug('[UI.Theme] toggleTheme:', current, '‚Üí', next);
		        applyTheme(next);
		    }

		    /**
		     * D√©termine le th√®me initial :
		     * 1) localStorage si disponible
		     * 2) class du <body> si d√©j√† d√©finie
		     * 3) sinon, "dark"
		     * @returns {string} Theme initial
		     * @private
		     */
		    function resolveInitialTheme() {
		        let stored = null;

		        try {
		            // SAFE: Use StorageHelper with Theme validator
		            const StorageHelper = GeoLeaf.StorageHelper;
		            const ThemeValidator = GeoLeaf.Validators?.Theme;

		            if (StorageHelper && ThemeValidator) {
		                stored = StorageHelper.getItem(THEME_KEY, null, ThemeValidator);
		            } else {
		                // Fallback if StorageHelper not loaded yet
		                stored = global.localStorage.getItem(THEME_KEY);
		            }
		        } catch (e) {
		            stored = null;
		        }

		        if (stored === THEME_LIGHT || stored === THEME_DARK) {
		            return stored;
		        }

		        const bodyTheme = getCurrentTheme();
		        if (bodyTheme === THEME_LIGHT || bodyTheme === THEME_DARK) {
		            return bodyTheme;
		        }

		        return THEME_DARK;
		    }

		    /**
		     * R√©cup√®re le bouton de th√®me dans le DOM.
		     * Par convention on utilise l'attribut data-gl-role="theme-toggle".
		     * @returns {HTMLElement|null}
		     * @private
		     */
		    function getToggleButton() {
		        return document.querySelector('[data-gl-role="theme-toggle"]');
		    }

		    /**
		     * Met √† jour l'√©tat visuel/ARIA du bouton de th√®me.
		     * @param {string} theme - "light" ou "dark"
		     * @private
		     */
		    function updateToggleButton(theme) {
		        const btn = getToggleButton();
		        if (!btn) return;

		        const isDark = theme === THEME_DARK;

		        btn.setAttribute("data-gl-theme-state", isDark ? "dark" : "light");
		        btn.setAttribute("aria-pressed", String(isDark));
		        btn.setAttribute(
		            "aria-label",
		            isDark ? "Basculer en th√®me clair" : "Basculer en th√®me sombre"
		        );
		        btn.title = isDark ? "Th√®me clair" : "Th√®me sombre";
		    }

		    /**
		     * Initialise la gestion du bouton de th√®me.
		     * @param {object} [options] - Options de configuration
		     * @param {string} [options.buttonSelector] - S√©lecteur custom du bouton
		     * @param {boolean} [options.autoInitOnDomReady] - Si true, attend DOMContentLoaded
		     */
		    function initThemeToggle(options = {}) {
		        const cfg = {
		            buttonSelector: options.buttonSelector || '[data-gl-role="theme-toggle"]',
		            autoInitOnDomReady:
		                typeof options.autoInitOnDomReady === "boolean"
		                    ? options.autoInitOnDomReady
		                    : false
		        };

		        const doInit = () => {
		            const initialTheme = resolveInitialTheme();
		            Log.debug('[UI.Theme] initThemeToggle:', initialTheme);
		            applyTheme(initialTheme);

		            const btn = document.querySelector(cfg.buttonSelector);
		            if (!btn) {
		                Log.warn('[UI.Theme] Bouton de th√®me introuvable:', cfg.buttonSelector);
		                return;
		            }

		            Log.debug('[UI.Theme] Bouton de th√®me trouv√©');

		            // Accessibilit√© : <button> natif ou r√¥le "button"
		            const tag = (btn.tagName || "").toLowerCase();
		            if (tag === "button") {
		                try {
		                    btn.type = btn.type || "button";
		                } catch (e) {
		                    // Certains √©l√©ments custom peuvent lever une erreur
		                }
		            } else {
		                btn.setAttribute("role", "button");
		                btn.setAttribute("tabindex", "0");
		            }

		            // Premi√®re synchro de l'√©tat visuel
		            updateToggleButton(initialTheme);

		            // Clic souris
		            btn.addEventListener("click", (evt) => {
		                evt.preventDefault();
		                toggleTheme();
		            });

		            // Clavier (Enter / Space)
		            btn.addEventListener("keydown", (evt) => {
		                if (evt.key === "Enter" || evt.key === " " || evt.key === "Spacebar") {
		                    evt.preventDefault();
		                    toggleTheme();
		                }
		            });
		        };        if (cfg.autoInitOnDomReady) {
		            if (document.readyState === "loading") {
		                document.addEventListener("DOMContentLoaded", doInit, { once: true });
		            } else {
		                doInit();
		            }
		        } else {
		            doInit();
		        }
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._UITheme = {
		        initThemeToggle,
		        toggleTheme,
		        applyTheme,
		        getCurrentTheme,
		        // Constantes expos√©es
		        THEME_LIGHT,
		        THEME_DARK
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return theme;
	}

	requireTheme();

	var controls = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredControls;

	function requireControls () {
		if (hasRequiredControls) return controls;
		hasRequiredControls = 1;
		/**
		 * GeoLeaf UI Module - Controls
		 * Contr√¥les Leaflet personnalis√©s (fullscreen, zoom, scale, etc.)
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;
		    const Utils = GeoLeaf.Utils;

		    GeoLeaf._UIControls = GeoLeaf._UIControls || {};

		    // ========================================
		    //   FULLSCREEN CONTROL
		    // ========================================

		    /**
		     * Gestion du plein √©cran pour la carte
		     * @param {L.Map} map - Instance de la carte Leaflet
		     * @param {HTMLElement} mapContainer - Le conteneur de la carte √† mettre en plein √©cran
		     */
		    function initFullscreenControl(map, mapContainer) {
		        if (!map || !mapContainer) {
		            if (Log) Log.warn("[UI.Controls] initFullscreenControl: carte ou conteneur manquant");
		            return;
		        }

		        // V√©rifier que Leaflet est disponible
		        if (typeof L === "undefined" || !L.Control) {
		            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
		            return;
		        }

		        // Contr√¥le Leaflet personnalis√©
		        L.Control.Fullscreen = L.Control.extend({
		            options: {
		                position: "topleft"
		            },

		            onAdd: function (map) {
		                const container = L.DomUtil.create(
		                    "div",
		                    "leaflet-control-fullscreen leaflet-bar leaflet-control"
		                );
		                const link = L.DomUtil.create("a", "", container);

		                link.href = "#";
		                link.title = "Plein √©cran";
		                link.setAttribute("role", "button");
		                link.setAttribute("aria-label", "Activer le mode plein √©cran");

		                // Fullscreen ENTER icon (static SVG)
		                // SAFE: SVG statique hardcod√©
		                const svgEnter = GeoLeaf.DOMSecurity.createSVGIcon(18, 18, 'M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3', {
		                    stroke: 'currentColor',
		                    strokeWidth: '2',
		                    fill: 'none'
		                });
		                svgEnter.classList.add('fullscreen-enter-icon');

		                // Fullscreen EXIT icon (static SVG)
		                // SAFE: SVG statique hardcod√©
		                const svgExit = GeoLeaf.DOMSecurity.createSVGIcon(18, 18, 'M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3', {
		                    stroke: 'currentColor',
		                    strokeWidth: '2',
		                    fill: 'none'
		                });
		                svgExit.classList.add('fullscreen-exit-icon');
		                svgExit.style.display = 'none'; // Cach√© par d√©faut

		                link.appendChild(svgEnter);
		                link.appendChild(svgExit);

		                // √âviter la propagation vers la carte
		                L.DomEvent.disableClickPropagation(container);
		                L.DomEvent.disableScrollPropagation(container);

		                // Debounce pour invalidateSize
		                const debouncedInvalidateSize =
		                    Utils?.debounce
		                        ? Utils.debounce(() => map.invalidateSize(), 200)
		                        : () => map.invalidateSize();

		                // Fonction pour mettre √† jour l'ic√¥ne
		                const updateIcon = (isFullscreen) => {
		                    if (isFullscreen) {
		                        svgEnter.style.display = 'none';
		                        svgExit.style.display = 'block';
		                    } else {
		                        svgEnter.style.display = 'block';
		                        svgExit.style.display = 'none';
		                    }
		                };

		                const toggleFullscreen = (e) => {
		                    L.DomEvent.preventDefault(e);

		                    if (!document.fullscreenElement) {
		                        // Entrer en plein √©cran
		                        mapContainer
		                            .requestFullscreen()
		                            .then(() => {
		                                link.classList.add("is-fullscreen");
		                                link.title = "Quitter le plein √©cran";
		                                link.setAttribute(
		                                    "aria-label",
		                                    "Quitter le mode plein √©cran"
		                                );
		                                updateIcon(true);
		                                debouncedInvalidateSize();
		                            })
		                            .catch((err) => {
		                                if (Log) Log.error("[UI.Controls] Erreur plein √©cran:", err);
		                            });
		                    } else {
		                        // Quitter le plein √©cran
		                        document
		                            .exitFullscreen()
		                            .then(() => {
		                                link.classList.remove("is-fullscreen");
		                                link.title = "Plein √©cran";
		                                link.setAttribute(
		                                    "aria-label",
		                                    "Activer le mode plein √©cran"
		                                );
		                                updateIcon(false);
		                                debouncedInvalidateSize();
		                            })
		                            .catch((err) => {
		                                if (Log) Log.error("[UI.Controls] Erreur sortie plein √©cran:", err);
		                            });
		                    }
		                };

		                const fullscreenChangeHandler = () => {
		                    if (!document.fullscreenElement) {
		                        link.classList.remove("is-fullscreen");
		                        link.title = "Plein √©cran";
		                        link.setAttribute(
		                            "aria-label",
		                            "Activer le mode plein √©cran"
		                        );
		                        updateIcon(false);
		                        debouncedInvalidateSize();
		                    }
		                };

		                L.DomEvent.on(link, "click", toggleFullscreen);
		                L.DomEvent.on(link, "keydown", (e) => {
		                    if (
		                        e.key === "Enter" ||
		                        e.key === " " ||
		                        e.key === "Spacebar"
		                    ) {
		                        toggleFullscreen(e);
		                    }
		                });

		                document.addEventListener(
		                    "fullscreenchange",
		                    fullscreenChangeHandler
		                );

		                this._fullscreenChangeHandler = fullscreenChangeHandler;
		                this._toggleFullscreen = toggleFullscreen;
		                this._link = link;
		                this._mapContainer = mapContainer;
		                this._debouncedInvalidateSize = debouncedInvalidateSize;

		                return container;
		            },

		            onRemove: function (_map) {
		                // MEMORY LEAK FIX (Phase 2): Clean up circular references in closures
		                if (this._fullscreenChangeHandler) {
		                    document.removeEventListener(
		                        "fullscreenchange",
		                        this._fullscreenChangeHandler
		                    );
		                    this._fullscreenChangeHandler = null;
		                }

		                if (this._link) {
		                    L.DomEvent.off(this._link, "click", this._toggleFullscreen);
		                    L.DomEvent.off(this._link, "keydown");
		                    this._link = null;
		                }

		                // Clean up closure references to prevent memory leaks
		                this._toggleFullscreen = null;
		                this._mapContainer = null;
		                this._debouncedInvalidateSize = null;
		            }
		        });

		        new L.Control.Fullscreen().addTo(map);
		        if (Log) Log.info("[UI.Controls] Contr√¥le plein √©cran ajout√© √† la carte");
		    }

		    // ========================================
		    //   GEOLOCATION CONTROL
		    // ========================================

		    /**
		     * Gestion de la g√©olocalisation pour centrer la carte sur la position de l'utilisateur
		     * @param {L.Map} map - Instance de la carte Leaflet
		     * @param {Object} config - Configuration incluant ui.enableGeolocation
		     */
		    function initGeolocationControl(map, config) {
		        if (!map) {
		            if (Log) Log.warn("[UI.Controls] initGeolocationControl: carte manquante");
		            return;
		        }

		        // V√©rifier si la g√©olocalisation est activ√©e dans la config
		        if (!config?.ui?.enableGeolocation) {
		            if (Log) Log.info("[UI.Controls] G√©olocalisation d√©sactiv√©e dans la configuration");
		            return;
		        }

		        // V√©rifier que Leaflet est disponible
		        if (typeof L === "undefined" || !L.Control) {
		            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
		            return;
		        }

		        // V√©rifier que l'API de g√©olocalisation est disponible
		        if (!navigator.geolocation) {
		            if (Log) Log.warn("[UI.Controls] La g√©olocalisation n'est pas support√©e par ce navigateur");
		            return;
		        }

		        // Marqueur de position utilisateur (stock√© pour pouvoir le supprimer/mettre √† jour)
		        let userMarker = null;
		        let accuracyCircle = null;

		        // Contr√¥le Leaflet personnalis√©
		        L.Control.Geolocation = L.Control.extend({
		            options: {
		                position: "topleft"
		            },

		            onAdd: function (map) {
		                const container = L.DomUtil.create(
		                    "div",
		                    "leaflet-control-geolocation leaflet-bar leaflet-control"
		                );
		                const link = L.DomUtil.create("a", "", container);

		                link.href = "#";
		                link.title = "G√©olocalisation ON/OFF";
		                link.setAttribute("role", "button");
		                link.setAttribute("aria-label", "Activer/D√©sactiver le suivi GPS");

		                // Ic√¥ne de g√©olocalisation (utilisation d'un SVG ou Unicode)
		                // SAFE: SVG statique hardcod√©, pas de donn√©es utilisateur
		                const geoSvg = GeoLeaf.DOMSecurity.createSVGIcon(18, 18, 'M12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 C 22 6.5 17.5 2 12 2 M12 9 C 10.3 9 9 10.3 9 12 C 9 13.7 10.3 15 12 15 C 13.7 15 15 13.7 15 12 C 15 10.3 13.7 9 12 9', {
		                    stroke: 'currentColor',
		                    strokeWidth: '2',
		                    fill: 'none'
		                });
		                link.appendChild(geoSvg);

		                // √âviter la propagation vers la carte
		                L.DomEvent.disableClickPropagation(container);
		                L.DomEvent.disableScrollPropagation(container);

		                const toggleGeolocation = (e) => {
		                    L.DomEvent.preventDefault(e);

		                    // Si d√©j√† actif, d√©sactiver
		                    if (window.GeoLeaf.UI._geolocationActive) {
		                        // D√©sactiver le tracking
		                        if (window.GeoLeaf.UI._geolocationWatchId !== null) {
		                            navigator.geolocation.clearWatch(window.GeoLeaf.UI._geolocationWatchId);
		                            window.GeoLeaf.UI._geolocationWatchId = null;
		                        }

		                        // Retirer les marqueurs et cercles
		                        if (userMarker) {
		                            map.removeLayer(userMarker);
		                            userMarker = null;
		                        }
		                        if (accuracyCircle) {
		                            map.removeLayer(accuracyCircle);
		                            accuracyCircle = null;
		                        }

		                        // R√©initialiser l'√©tat
		                        window.GeoLeaf.UI._geolocationActive = false;
		                        window.GeoLeaf.UI._userPosition = null;

		                        link.classList.remove("is-active");
		                        link.classList.remove("is-locating");

		                        if (Log) Log.info("[UI.Controls] G√©olocalisation d√©sactiv√©e");
		                        return;
		                    }

		                    // Activer le mode g√©olocalisation
		                    link.classList.add("is-locating");

		                    // Utiliser watchPosition pour un tracking continu
		                    window.GeoLeaf.UI._geolocationWatchId = navigator.geolocation.watchPosition(
		                        (position) => {
		                            const { latitude, longitude, accuracy } = position.coords;

		                            // Premi√®re activation : centrer la carte
		                            if (!window.GeoLeaf.UI._geolocationActive) {
		                                map.setView([latitude, longitude], 16, {
		                                    animate: true,
		                                    duration: 0.5
		                                });
		                            }

		                            // Supprimer l'ancien marqueur et cercle s'ils existent
		                            if (userMarker) {
		                                map.removeLayer(userMarker);
		                            }
		                            if (accuracyCircle) {
		                                map.removeLayer(accuracyCircle);
		                            }

		                            // Cr√©er un nouveau marqueur pour la position de l'utilisateur
		                            userMarker = L.marker([latitude, longitude], {
		                                icon: L.divIcon({
		                                    className: 'gl-user-location-marker gl-user-location-marker--active',
		                                    html: `<div class="gl-user-location-dot gl-user-location-dot--active"></div>`,
		                                    iconSize: [22, 22],
		                                    iconAnchor: [11, 11]
		                                }),
		                                zIndexOffset: 1000
		                            }).addTo(map);

		                            // Ajouter un cercle de pr√©cision
		                            if (accuracy && accuracy < 1000) {
		                                const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		                                accuracyCircle = L.circle([latitude, longitude], {
		                                    radius: accuracy,
		                                    className: 'gl-user-location-accuracy',
		                                    fillColor: '#4285F4',
		                                    fillOpacity: 0.1,
		                                    stroke: true,
		                                    color: '#4285F4',
		                                    opacity: 0.3,
		                                    weight: 1,
		                                    interactive: interactiveShapes
		                                }).addTo(map);
		                            }

		                            // Mettre √† jour l'√©tat
		                            window.GeoLeaf.UI._geolocationActive = true;
		                            link.classList.remove("is-locating");
		                            link.classList.add("is-active");

		                            // Stocker la position GPS globalement pour utilisation par d'autres fonctionnalit√©s (ex: recherche par proximit√©)
		                            if (window.GeoLeaf && window.GeoLeaf.UI) {
		                                window.GeoLeaf.UI._userPosition = {
		                                    lat: latitude,
		                                    lng: longitude,
		                                    accuracy: accuracy,
		                                    timestamp: Date.now()
		                                };
		                            }

		                            if (Log) Log.debug("[UI.Controls] Position GPS mise √† jour:", latitude, longitude);
		                        },
		                        (error) => {
		                            link.classList.remove("is-locating");
		                            link.classList.remove("is-active");
		                            window.GeoLeaf.UI._geolocationActive = false;

		                            let errorMessage = "Impossible d'obtenir votre position";
		                            switch (error.code) {
		                                case error.PERMISSION_DENIED:
		                                    errorMessage = "Permission de g√©olocalisation refus√©e";
		                                    break;
		                                case error.POSITION_UNAVAILABLE:
		                                    errorMessage = "Position indisponible";
		                                    break;
		                                case error.TIMEOUT:
		                                    errorMessage = "D√©lai de g√©olocalisation d√©pass√©";
		                                    break;
		                            }

		                            if (Log) Log.error("[UI.Controls] Erreur de g√©olocalisation:", error);

		                            // Afficher un message √† l'utilisateur (peut √™tre personnalis√©)
		                            if (window.alert) {
		                                alert(errorMessage);
		                            }
		                        },
		                        {
		                            enableHighAccuracy: true,
		                            timeout: 10000,
		                            maximumAge: 0
		                        }
		                    );
		                };

		                L.DomEvent.on(link, "click", toggleGeolocation);
		                L.DomEvent.on(link, "keydown", (e) => {
		                    if (
		                        e.key === "Enter" ||
		                        e.key === " " ||
		                        e.key === "Spacebar"
		                    ) {
		                        toggleGeolocation(e);
		                    }
		                });

		                this._link = link;
		                this._userMarker = userMarker;

		                return container;
		            },

		            onRemove: function (map) {
		                if (this._link) {
		                    L.DomEvent.off(this._link, "click");
		                    L.DomEvent.off(this._link, "keydown");
		                    this._link = null;
		                }

		                if (this._userMarker) {
		                    map.removeLayer(this._userMarker);
		                    this._userMarker = null;
		                }
		            }
		        });

		        new L.Control.Geolocation().addTo(map);
		        if (Log) Log.info("[UI.Controls] Contr√¥le de g√©olocalisation ajout√© √† la carte");
		    }

		    // ========================================
		    //   POI ADD CONTROL
		    // ========================================

		    /**
		     * Gestion du bouton d'ajout de POI sur la carte
		     * Permet aux utilisateurs d'ajouter de nouveaux points d'int√©r√™t
		     * @param {L.Map} map - Instance de la carte Leaflet
		     * @param {Object} config - Configuration incluant ui.showAddPoi et poi.*
		     */
		    function initPoiAddControl(map, config) {
		        if (!map) {
		            if (Log) Log.warn("[UI.Controls] initPoiAddControl: carte manquante");
		            return;
		        }

		        // V√©rifier si le bouton POI Add est activ√©
		        if (!config?.ui?.showAddPoi) {
		            if (Log) Log.debug("[UI.Controls] Bouton POI Add d√©sactiv√© dans la configuration");
		            return;
		        }

		        // V√©rifier que Leaflet est disponible
		        if (typeof L === "undefined" || !L.Control) {
		            if (Log) Log.warn("[UI.Controls] Leaflet n'est pas disponible");
		            return;
		        }

		        // V√©rifier que les modules POI sont charg√©s
		        if (!GeoLeaf?.POI?.AddForm || !GeoLeaf?.POI?.PlacementMode) {
		            if (Log) Log.warn("[UI.Controls] Modules POI non charg√©s");
		            return;
		        }

		        // Contr√¥le Leaflet personnalis√© pour l'ajout de POI
		        L.Control.PoiAdd = L.Control.extend({
		            options: {
		                position: "topleft"
		            },

		            onAdd: function (map) {
		                const container = L.DomUtil.create(
		                    "div",
		                    "leaflet-control-poi-add leaflet-bar leaflet-control"
		                );
		                const link = L.DomUtil.create("a", "", container);

		                link.href = "#";
		                link.title = "Ajouter un POI";
		                link.setAttribute("role", "button");
		                link.setAttribute("aria-label", "Ajouter un nouveau point d'int√©r√™t");

		                // Ic√¥ne d'ajout de POI (SVG statique)
		                // SAFE: SVG statique hardcod√©, pas de donn√©es utilisateur
		                const poiSvg = GeoLeaf.DOMSecurity.createSVGIcon(18, 18, 'M12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 C 22 6.5 17.5 2 12 2 M12 8 L12 16 M8 12 L16 12', {
		                    stroke: 'currentColor',
		                    strokeWidth: '2',
		                    fill: 'none'
		                });
		                link.appendChild(poiSvg);

		                // √âviter la propagation vers la carte
		                L.DomEvent.disableClickPropagation(container);
		                L.DomEvent.disableScrollPropagation(container);

		                const handleAddPoi = (e) => {
		                    L.DomEvent.preventDefault(e);

		                    // D√©sactiver le bouton temporairement
		                    link.classList.add("disabled");

		                    // Fonction pour ouvrir le formulaire
		                    const openForm = (latlng) => {
		                        link.classList.remove("disabled");

		                        if (!GeoLeaf.POI.AddForm.openAddForm) {
		                            if (Log) Log.error("[UI.Controls] AddForm.openAddForm non disponible");
		                            return;
		                        }

		                        GeoLeaf.POI.AddForm.openAddForm(latlng, null);
		                    };

		                    // V√©rifier si la g√©olocalisation est disponible et si elle est le mode par d√©faut
		                    const userPosition = GeoLeaf?.UI?._userPosition;
		                    const defaultPosition = config?.poiAddConfig?.defaultPosition || "placement-mode";

		                    if (userPosition && defaultPosition === "geolocation") {
		                        // Utiliser la position GPS
		                        if (Log) Log.debug("[UI.Controls] Utilisation de la position GPS pour l'ajout de POI");
		                        openForm(userPosition);
		                    } else {
		                        // Activer le mode placement
		                        if (Log) Log.debug("[UI.Controls] Activation du mode placement pour l'ajout de POI");
		                        GeoLeaf.POI.PlacementMode.activate(map, (result) => {
		                            if (result?.latlng) {
		                                openForm(result.latlng);
		                            } else {
		                                link.classList.remove("disabled");
		                                if (Log) Log.warn("[UI.Controls] Mode placement cancelled");
		                            }
		                        });
		                    }
		                };

		                L.DomEvent.on(link, "click", handleAddPoi);
		                L.DomEvent.on(link, "keydown", (e) => {
		                    if (
		                        e.key === "Enter" ||
		                        e.key === " " ||
		                        e.key === "Spacebar"
		                    ) {
		                        handleAddPoi(e);
		                    }
		                });

		                this._link = link;

		                return container;
		            },

		            onRemove: function (_map) {
		                if (this._link) {
		                    L.DomEvent.off(this._link, "click");
		                    L.DomEvent.off(this._link, "keydown");
		                    this._link = null;
		                }
		            }
		        });

		        new L.Control.PoiAdd().addTo(map);
		        if (Log) Log.info("[UI.Controls] Contr√¥le POI Add ajout√© √† la carte");
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._UIControls = {
		        initFullscreenControl,
		        initGeolocationControl,
		        initPoiAddControl
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return controls;
	}

	requireControls();

	var panelBuilder = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredPanelBuilder;

	function requirePanelBuilder () {
		if (hasRequiredPanelBuilder) return panelBuilder;
		hasRequiredPanelBuilder = 1;
		/**
		 * GeoLeaf UI Module - Panel Builder
		 * Construction de panneaux de d√©tails POI avec layouts configurables
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.UI = GeoLeaf.UI || {};
		    GeoLeaf.UI.PanelBuilder = GeoLeaf.UI.PanelBuilder || {};

		    // Helper pour utiliser createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    /**
		     * R√©sout un chemin de type "attributes.longDescription" dans un objet POI.
		     * Retourne undefined si le chemin n'existe pas.
		     *
		     * @param {object} poi - Objet POI source.
		     * @param {string} fieldPath - Chemin en notation point√©e (ex: "attributes.description").
		     * @returns {*} Valeur r√©solue ou undefined.
		     */
		    function resolveField(poi, fieldPath) {
		        if (!poi || !fieldPath) return undefined;
		        const parts = fieldPath.split(".");
		        let current = poi;
		        for (let i = 0; i < parts.length; i += 1) {
		            if (current == null) {
		                return undefined;
		            }
		            current = current[parts[i]];
		        }
		        return current;
		    }

		    /**
		     * Cr√©e un bloc section simple (sans accord√©on).
		     *
		     * @param {string} label - Titre de la section.
		     * @param {Node|string} innerContent - Contenu de la section (Node ou texte).
		     * @param {string} extraClass - Classes CSS additionnelles.
		     * @returns {HTMLElement} √âl√©ment section.
		     */
		    function createPlainSection(label, innerContent, extraClass) {
		        const section = $create("section", {
		            className: "gl-poi-panel__section" + (extraClass ? " " + extraClass : "")
		        });

		        if (label) {
		            const header = $create("h3", {
		                className: "gl-poi-panel__section-title",
		                textContent: label
		            });
		            section.appendChild(header);
		        }

		        const body = $create("div", {
		            className: "gl-poi-panel__section-body"
		        });
		        if (innerContent instanceof Node) {
		            body.appendChild(innerContent);
		        } else if (innerContent != null) {
		            body.textContent = String(innerContent);
		        }
		        section.appendChild(body);

		        return section;
		    }

		    /**
		     * Cr√©e un bloc section accord√©on (panneau repliable).
		     *
		     * @param {string} label - Titre de l'accord√©on.
		     * @param {Node|string} innerContent - Contenu de l'accord√©on.
		     * @param {object} options - Options { defaultOpen: boolean }.
		     * @returns {HTMLElement} √âl√©ment section accord√©on.
		     */
		    function createAccordionSection(label, innerContent, options) {
		        const opts = options || {};
		        const isOpen = Boolean(opts.defaultOpen);

		        const section = $create("section", {
		            className: "gl-accordion gl-poi-panel__section" + (isOpen ? " is-open" : "")
		        });

		        const header = $create("button", {
		            type: "button",
		            className: "gl-accordion__header"
		        });

		        const titleSpan = $create("span", {
		            className: "gl-accordion__title",
		            textContent: label || ""
		        });
		        header.appendChild(titleSpan);

		        const iconSpan = $create("span", {
		            className: "gl-accordion__icon",
		            attributes: { "aria-hidden": "true" },
		            textContent: "‚ñæ"
		        });
		        header.appendChild(iconSpan);

		        section.appendChild(header);

		        const body = $create("div", {
		            className: "gl-accordion__body"
		        });

		        if (innerContent instanceof Node) {
		            body.appendChild(innerContent);
		        } else if (innerContent != null) {
		            const p = $create("p", {
		                textContent: String(innerContent)
		            });
		            body.appendChild(p);
		        }

		        section.appendChild(body);
		        return section;
		    }

		    /**
		     * Construit le rendu d'un item de type "text".
		     *
		     * @param {*} value - Valeur √† afficher.
		     * @param {string} variant - Variant ("multiline" ou autre).
		     * @returns {HTMLElement|null} √âl√©ment div ou null.
		     */
		    function renderText(value, variant) {
		        const div = $create("div", {
		            className: "gl-poi-panel__text" +
		                (variant === "multiline" ? " gl-poi-panel__text--multiline" : ""),
		            textContent: String(value)
		        });
		        return div;
		    }

		    /**
		     * Construit le rendu d'un item de type "list".
		     *
		     * @param {*} value - Array ou string (lignes s√©par√©es).
		     * @returns {HTMLElement|null} √âl√©ment ul ou null.
		     */
		    function renderList(value) {
		        const items = [];

		        if (Array.isArray(value)) {
		            value.forEach(function (entry) {
		                if (entry == null) return;

		                if (typeof entry === "string" || typeof entry === "number") {
		                    items.push(String(entry));
		                } else if (typeof entry === "object") {
		                    const label =
		                        typeof entry.label === "string"
		                            ? entry.label
		                            : typeof entry.text === "string"
		                            ? entry.text
		                            : null;
		                    const val = entry.value != null ? String(entry.value) : null;

		                    if (label && val) {
		                        items.push(label + " : " + val);
		                    } else if (label) {
		                        items.push(label);
		                    } else if (val) {
		                        items.push(val);
		                    }
		                }
		            });
		        } else if (typeof value === "string") {
		            value.split(/\r?\n/).forEach(function (line) {
		                const trimmed = line.trim();
		                if (trimmed) {
		                    items.push(trimmed);
		                }
		            });
		        }

		        if (!items.length) {
		            return null;
		        }

		        const ul = $create("ul", {
		            className: "gl-poi-panel__list"
		        });

		        items.forEach(function (text) {
		            const li = $create("li", {
		                className: "gl-poi-panel__list-item",
		                textContent: text
		            });
		            ul.appendChild(li);
		        });

		        return ul;
		    }

		    /**
		     * Construit le rendu d'un item de type "table".
		     *
		     * @param {Array} value - Tableau d'objets repr√©sentant les lignes.
		     * @param {object} item - Configuration du tableau (columns, borders).
		     * @returns {HTMLElement|null} Wrapper de tableau ou null.
		     */
		    function renderTable(value, item) {
		        if (!Array.isArray(value) || !value.length) {
		            return null;
		        }

		        const columns = Array.isArray(item.columns) ? item.columns : [];
		        if (!columns.length) {
		            return null;
		        }

		        const wrapper = $create("div", {
		            className: "gl-poi-panel__table-wrapper"
		        });

		        const borders = item.borders || {};
		        const borderClasses = [];
		        if (borders.outer) borderClasses.push("gl-poi-panel__table--border-outer");
		        if (borders.row) borderClasses.push("gl-poi-panel__table--border-row");
		        if (borders.column) borderClasses.push("gl-poi-panel__table--border-column");

		        const table = $create("table", {
		            className: "gl-poi-panel__table" + (borderClasses.length ? " " + borderClasses.join(" ") : ""),
		            attributes: borders.color ? { "data-gl-border-color": borders.color } : {}
		        });

		        // En-t√™te
		        const thead = $create("thead");
		        const headRow = $create("tr", {
		            className: "gl-poi-panel__table-row gl-poi-panel__table-row--head"
		        });

		        columns.forEach(function (col) {
		            const th = $create("th", {
		                className: "gl-poi-panel__table-cell gl-poi-panel__table-cell--head",
		                textContent: col.label || col.key || ""
		            });
		            headRow.appendChild(th);
		        });

		        thead.appendChild(headRow);
		        table.appendChild(thead);

		        // Corps
		        const tbody = $create("tbody");

		        value.forEach(function (rowObj) {
		            if (!rowObj || typeof rowObj !== "object") {
		                return;
		            }

		            const tr = $create("tr", {
		                className: "gl-poi-panel__table-row"
		            });

		            columns.forEach(function (col) {
		                const cellVal = rowObj[col.key];
		                const td = $create("td", {
		                    className: "gl-poi-panel__table-cell",
		                    textContent: cellVal == null ? "" : String(cellVal)
		                });

		                tr.appendChild(td);
		            });

		            tbody.appendChild(tr);
		        });

		        table.appendChild(tbody);
		        wrapper.appendChild(table);
		        return wrapper;
		    }

		    /**
		     * Construit le rendu d'un item de type "gallery".
		     *
		     * @param {Array} value - Tableau d'images { url, alt, caption }.
		     * @returns {HTMLElement|null} Container galerie ou null.
		     */
		    function renderGallery(value) {
		        if (!Array.isArray(value)) {
		            return null;
		        }

		        const container = $create("div", {
		            className: "gl-poi-panel__gallery"
		        });

		        value.forEach(function (img) {
		            if (!img) return;

		            const figure = $create("figure", {
		                className: "gl-poi-panel__gallery-item"
		            });

		            const imgEl = $create("img", {
		                src: img.url || img,
		                alt: img.alt || ""
		            });
		            figure.appendChild(imgEl);

		            if (img.caption) {
		                const figCap = $create("figcaption", {
		                    textContent: img.caption
		                });
		                figure.appendChild(figCap);
		            }

		            container.appendChild(figure);
		        });

		        return container;
		    }

		    /**
		     * Construit le rendu d'un item de type "reviews" (avis voyageurs).
		     *
		     * @param {*} value - Array ou objet avec propri√©t√© 'recent'.
		     * @returns {HTMLElement|null} Container d'avis ou null.
		     */
		    function renderReviews(value) {
		        // Si value est un objet avec une propri√©t√© 'recent', utiliser celle-ci
		        let reviewsArray = value;
		        if (value && typeof value === 'object' && !Array.isArray(value) && Array.isArray(value.recent)) {
		            reviewsArray = value.recent;
		        }

		        if (!Array.isArray(reviewsArray)) {
		            return null;
		        }

		        const container = $create("div", {
		            className: "gl-poi-panel__reviews gl-poi-sidepanel__reviews"
		        });

		        reviewsArray.forEach(function (review) {
		            if (!review) return;

		            const itemEl = $create("article", {
		                className: "gl-poi-panel__review"
		            });

		            const header = $create("header", {
		                className: "gl-poi-panel__review-header"
		            });

		            const nameSpan = $create("span", {
		                className: "gl-poi-panel__review-author",
		                textContent: review.authorName || ""
		            });
		            header.appendChild(nameSpan);

		            if (typeof review.rating === "number") {
		                const ratingSpan = $create("span", {
		                    className: "gl-poi-panel__review-rating",
		                    textContent: review.rating.toFixed(1) + "/5"
		                });
		                header.appendChild(ratingSpan);
		            }

		            if (review.source) {
		                const sourceSpan = $create("span", {
		                    className: "gl-poi-panel__review-source",
		                    textContent: review.source
		                });
		                header.appendChild(sourceSpan);
		            }

		            itemEl.appendChild(header);

		            if (review.title) {
		                const titleEl = $create("h4", {
		                    className: "gl-poi-panel__review-title",
		                    textContent: review.title
		                });
		                itemEl.appendChild(titleEl);
		            }

		            // G√©rer √† la fois 'text' (ancien format) et 'comment' (nouveau format)
		            const reviewText = review.text || review.comment;
		            if (reviewText) {
		                const textEl = $create("p", {
		                    className: "gl-poi-panel__review-text",
		                    textContent: reviewText
		                });
		                itemEl.appendChild(textEl);
		            }

		            // G√©rer √† la fois 'date' (ancien format) et 'createdAt' (nouveau format)
		            const reviewDate = review.date || review.createdAt;
		            if (reviewDate) {
		                const dateEl = $create("time", {
		                    className: "gl-poi-panel__review-date",
		                    textContent: reviewDate
		                });
		                itemEl.appendChild(dateEl);
		            }

		            const footer = $create("footer", {
		                className: "gl-poi-panel__review-footer"
		            });

		            if (typeof review.helpfulCount === "number") {
		                const helpfulSpan = $create("span", {
		                    className: "gl-poi-panel__review-helpful",
		                    textContent: review.helpfulCount + " personnes ont trouv√© cet avis utile"
		                });
		                footer.appendChild(helpfulSpan);
		            }

		            if (review.url) {
		                const link = $create("a", {
		                    href: review.url,
		                    target: "_blank",
		                    rel: "noopener noreferrer",
		                    className: "gl-poi-panel__review-link",
		                    textContent: "Voir l'avis"
		                });
		                footer.appendChild(link);
		            }

		            itemEl.appendChild(footer);
		            container.appendChild(itemEl);
		        });

		        return container;
		    }

		    /**
		     * Construit le contenu interne pour un item de layout.
		     * Dispatcher principal vers les fonctions de rendu sp√©cialis√©es.
		     *
		     * @param {object} poi - Objet POI source.
		     * @param {object} item - Configuration du layout item (type, field, variant, etc).
		     * @returns {HTMLElement|null} √âl√©ment construit ou null.
		     */
		    function buildLayoutItemContent(poi, item) {
		        const type = item.type;
		        const value = resolveField(poi, item.field);

		        if (value == null || value === "") {
		            if (!Array.isArray(value)) {
		                return null;
		            }
		        }

		        // Dispatch par type
		        if (type === "text") {
		            return renderText(value, item.variant);
		        }

		        if (type === "list") {
		            return renderList(value);
		        }

		        if (type === "table") {
		            return renderTable(value, item);
		        }

		        if (type === "gallery") {
		            return renderGallery(value);
		        }

		        if (type === "reviews") {
		            return renderReviews(value);
		        }

		        // Fallback : texte simple
		        const defaultDiv = $create("div", {
		            className: "gl-poi-panel__text",
		            textContent: String(value)
		        });
		        return defaultDiv;
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf.UI.PanelBuilder = {
		        resolveField,
		        createPlainSection,
		        createAccordionSection,
		        renderText,
		        renderList,
		        renderTable,
		        renderGallery,
		        renderReviews,
		        buildLayoutItemContent
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return panelBuilder;
	}

	requirePanelBuilder();

	var domUtils = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredDomUtils;

	function requireDomUtils () {
		if (hasRequiredDomUtils) return domUtils;
		hasRequiredDomUtils = 1;
		/**
		 * GeoLeaf UI DOM Utilities Module
		 * Utilitaires DOM r√©utilisables pour l'interface utilisateur
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._UIDomUtils = GeoLeaf._UIDomUtils || {};

		    // Helper pour utiliser createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    const Log = GeoLeaf.Log || console;

		    /**
		     * R√©sout une valeur √† partir d'un chemin de propri√©t√© (ex: "attributes.reviews.rating").
		     * @param {Object} obj - Objet source (POI, route, etc.)
		     * @param {string} fieldPath - Chemin de propri√©t√© s√©par√© par des points
		     * @returns {*} Valeur trouv√©e ou undefined
		     */
		    GeoLeaf._UIDomUtils.resolveField = function (obj, fieldPath) {
		        if (!obj || !fieldPath) return undefined;
		        const parts = fieldPath.split(".");
		        let current = obj;
		        for (let i = 0; i < parts.length; i += 1) {
		            if (current == null) {
		                return undefined;
		            }
		            current = current[parts[i]];
		        }
		        return current;
		    };

		    /**
		     * Attache le comportement d'accord√©on (toggle open/close) √† un conteneur.
		     * √âvite les attachements multiples avec un flag.
		     * @param {HTMLElement} container - Conteneur parent avec des √©l√©ments .gl-accordion
		     */
		    GeoLeaf._UIDomUtils.attachAccordionBehavior = function (container) {
		        if (!container || container._glAccordionBound) return;
		        container._glAccordionBound = true;

		        container.addEventListener("click", function (evt) {
		            const header = evt.target.closest(".gl-accordion__header");
		            if (!header || !container.contains(header)) {
		                return;
		            }
		            const section = header.closest(".gl-accordion");
		            if (!section) return;

		            section.classList.toggle("is-open");
		        });
		    };

		    /**
		     * R√©cup√®re le profil actif depuis GeoLeaf.Config.
		     * @returns {Object|null} Objet profil ou null si indisponible
		     */
		    GeoLeaf._UIDomUtils.getActiveProfileConfig = function () {
		        if (
		            !GeoLeaf.Config ||
		            typeof GeoLeaf.Config.getActiveProfile !== "function"
		        ) {
		            Log.warn(
		                "[UIDomUtils] GeoLeaf.Config.getActiveProfile() indisponible. Impossible de r√©cup√©rer le profil actif."
		            );
		            return null;
		        }
		        const profile = GeoLeaf.Config.getActiveProfile();
		        if (!profile) {
		            Log.warn(
		                "[UIDomUtils] Aucun profil actif retourn√© par GeoLeaf.Config.getActiveProfile()."
		            );
		        }
		        return profile || null;
		    };

		    /**
		     * Construit les <option> d'un select √† partir de la taxonomie et d'un chemin optionsFrom.
		     * @param {HTMLSelectElement} selectEl - √âl√©ment <select> √† peupler
		     * @param {Object} profile - Objet profil contenant la taxonomie
		     * @param {string} optionsFrom - Chemin vers les options (ex: "taxonomy.categories")
		     */
		    GeoLeaf._UIDomUtils.populateSelectOptionsFromTaxonomy = function (
		        selectEl,
		        profile,
		        optionsFrom
		    ) {
		        if (!selectEl || !profile || !profile.taxonomy) return;

		        const taxonomy = profile.taxonomy;
		        const emptyOpt = $create("option", {
		            value: "",
		            textContent: "‚Äî Tous ‚Äî"
		        });
		        selectEl.appendChild(emptyOpt);

		        if (optionsFrom === "taxonomy.categories") {
		            const categories = taxonomy.categories || {};
		            Object.keys(categories).forEach(function (catId) {
		                const cat = categories[catId];
		                const opt = $create("option", {
		                    value: catId,
		                    textContent: cat.label || catId
		                });
		                selectEl.appendChild(opt);
		            });
		            return;
		        }

		        if (optionsFrom === "taxonomy.categories[*].subcategories") {
		            const categories = taxonomy.categories || {};
		            Object.keys(categories).forEach(function (catId) {
		                const cat = categories[catId];
		                const subs = (cat && cat.subcategories) || {};
		                Object.keys(subs).forEach(function (subId) {
		                    const sub = subs[subId];
		                    const catLabel = cat.label || catId;
		                    const subLabel = sub.label || subId;
		                    const opt = $create("option", {
		                        value: subId,
		                        textContent: catLabel + " ‚Äì " + subLabel,
		                        attributes: { "data-category-id": catId }
		                    });
		                    selectEl.appendChild(opt);
		                });
		            });
		        }
		    };

		    Log.info("[GeoLeaf._UIDomUtils] Module DOM Utilities charg√©");

		})(window);
		return domUtils;
	}

	requireDomUtils();

	var coordinatesDisplay = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredCoordinatesDisplay;

	function requireCoordinatesDisplay () {
		if (hasRequiredCoordinatesDisplay) return coordinatesDisplay;
		hasRequiredCoordinatesDisplay = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.UI = GeoLeaf.UI || {};

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Contexte pour les logs
		     * @const
		     */
		    const CONTEXT = "[GeoLeaf.UI.CoordinatesDisplay]";

		    /**
		     * Texte par d√©faut des coordonn√©es
		     * @const
		     */
		    const DEFAULT_COORDS_TEXT = "Lat: --, Lng: --";

		    /**
		     * Module GeoLeaf.UI.CoordinatesDisplay
		     *
		     * R√¥le :
		     * - Afficher les coordonn√©es du curseur en temps r√©el
		     * - Positionner le contr√¥le en bas √† droite √† c√¥t√© de la l√©gende
		     * - Permettre l'activation/d√©sactivation via configuration
		     */
		    const CoordinatesDisplay = {
		        /**
		         * R√©f√©rence √† la carte Leaflet.
		         * @type {L.Map|null}
		         * @private
		         */
		        _map: null,

		        /**
		         * R√©f√©rence au contr√¥le Leaflet des coordonn√©es.
		         * @type {L.Control|null}
		         * @private
		         */
		        _control: null,

		        /**
		         * Element DOM pour l'affichage des coordonn√©es
		         * @type {HTMLElement|null}
		         * @private
		         */
		        _coordsElement: null,

		        /**
		         * R√©f√©rence bound du listener mousemove (pour pouvoir le retirer)
		         * @type {Function|null}
		         * @private
		         */
		        _boundMouseMoveHandler: null,

		        /**
		         * Options du module
		         * @type {Object}
		         * @private
		         */
		        _options: {
		            position: "bottomleft",
		            decimals: 6
		        },

		        /**
		         * Initialise le module de coordonn√©es
		         * @param {L.Map} map - Instance de la carte Leaflet
		         * @param {Object} options - Options de configuration
		         */
		        init(map, options = {}) {
		            try {
		                if (!map) {
		                    throw new Error("Une instance de carte Leaflet est requise.");
		                }

		                this._map = map;
		                this._options = Object.assign({}, this._options, options);

		                // V√©rifier si le module est activ√© dans la config
		                const showCoordinates = GeoLeaf.Config?.get("ui.showCoordinates");

		                if (showCoordinates === false) {
		                    Log.info(`${CONTEXT} Affichage des coordonn√©es d√©sactiv√© dans la configuration.`);
		                    return;
		                }

		                // Stocker la r√©f√©rence bound du listener
		                this._boundMouseMoveHandler = this._onMouseMove.bind(this);

		                // Cr√©er le contr√¥le Leaflet
		                this._createControl();

		                Log.info(`${CONTEXT} Module initialis√© avec succ√®s.`);

		            } catch (err) {
		                Log.error(`${CONTEXT} Erreur lors de l'initialisation :`, err.message);
		            }
		        },

		        /**
		         * Cr√©e le contr√¥le Leaflet pour l'affichage des coordonn√©es
		         * @private
		         */
		        _createControl() {
		            try {
		                // Attendre que le DOM soit pr√™t et chercher le wrapper d'√©chelle
		                setTimeout(() => {
		                    const scaleWrapper = document.querySelector('.gl-scale-main-wrapper');

		                    if (scaleWrapper) {
		                        // Ajouter un s√©parateur avant les coordonn√©es
		                        L.DomUtil.create('div', 'gl-scale-separator', scaleWrapper);

		                        // Cr√©er l'√©l√©ment d'affichage des coordonn√©es directement dans le wrapper
		                        this._coordsElement = L.DomUtil.create('div', 'gl-scale-coordinates', scaleWrapper);
		                        this._coordsElement.textContent = DEFAULT_COORDS_TEXT;

		                        // Ajouter l'√©couteur d'√©v√©nement mousemove avec r√©f√©rence stock√©e
		                        this._map.on('mousemove', this._boundMouseMoveHandler);

		                        Log.info(`${CONTEXT} Coordonn√©es int√©gr√©es au wrapper d'√©chelle.`);
		                    } else {
		                        Log.warn(`${CONTEXT} Wrapper d'√©chelle non trouv√©, utilisation du mode classique.`);
		                        this._createStandaloneControl();
		                    }
		                }, 100);

		            } catch (err) {
		                Log.error(`${CONTEXT} Erreur lors de la cr√©ation du contr√¥le :`, err.message);
		            }
		        },

		        /**
		         * Cr√©e un contr√¥le standalone en fallback
		         * @private
		         */
		        _createStandaloneControl() {
		            const CoordinatesControl = L.Control.extend({
		                options: {
		                    position: this._options.position
		                },

		                onAdd: (map) => {
		                    const container = L.DomUtil.create("div", "geoleaf-coordinates-display");
		                    L.DomEvent.disableClickPropagation(container);
		                    L.DomEvent.disableScrollPropagation(container);
		                    this._coordsElement = L.DomUtil.create("div", "coordinates-content", container);
		                    this._coordsElement.textContent = DEFAULT_COORDS_TEXT;
		                    map.on("mousemove", this._boundMouseMoveHandler);
		                    return container;
		                },

		                onRemove: (map) => {
		                    map.off("mousemove", this._boundMouseMoveHandler);
		                }
		            });

		            this._control = new CoordinatesControl();
		            this._control.addTo(this._map);
		        },

		        /**
		         * Gestionnaire d'√©v√©nement pour le mouvement de la souris
		         * @param {Object} e - √âv√©nement Leaflet
		         * @private
		         */
		        _onMouseMove(e) {
		            if (!this._coordsElement) return;

		            const lat = e.latlng.lat.toFixed(this._options.decimals);
		            const lng = e.latlng.lng.toFixed(this._options.decimals);

		            this._coordsElement.textContent = `Lat: ${lat}, Lng: ${lng}`;
		        },

		        /**
		         * D√©truit le contr√¥le et nettoie les ressources
		         */
		        destroy() {
		            try {
		                // Nettoyer l'√©couteur d'√©v√©nements avec la r√©f√©rence stock√©e
		                if (this._map && this._boundMouseMoveHandler) {
		                    this._map.off('mousemove', this._boundMouseMoveHandler);
		                    this._boundMouseMoveHandler = null;
		                }

		                // Retirer l'√©l√©ment du DOM s'il existe
		                if (this._coordsElement && this._coordsElement.parentNode) {
		                    this._coordsElement.parentNode.removeChild(this._coordsElement);
		                    this._coordsElement = null;
		                }

		                // Retirer le contr√¥le standalone s'il existe
		                if (this._control && this._map) {
		                    this._map.removeControl(this._control);
		                    this._control = null;
		                }

		                Log.info(`${CONTEXT} Module d√©truit avec succ√®s.`);

		            } catch (err) {
		                Log.error(`${CONTEXT} Erreur lors de la destruction :`, err.message);
		            }
		        }
		    };

		    // Export du module
		    GeoLeaf.UI.CoordinatesDisplay = CoordinatesDisplay;

		})(typeof globalThis !== "undefined" ? globalThis : window);
		return coordinatesDisplay;
	}

	requireCoordinatesDisplay();

	var branding = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredBranding;

	function requireBranding () {
		if (hasRequiredBranding) return branding;
		hasRequiredBranding = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf.UI = GeoLeaf.UI || {};

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module GeoLeaf.UI.Branding
		     *
		     * R√¥le :
		     * - Afficher un texte de branding personnalisable
		     * - Positionner le contr√¥le selon la configuration
		     * - Permettre l'activation/d√©sactivation via configuration
		     */
		    const Branding = {
		        /**
		         * R√©f√©rence √† la carte Leaflet.
		         * @type {L.Map|null}
		         * @private
		         */
		        _map: null,

		        /**
		         * R√©f√©rence au contr√¥le Leaflet de branding.
		         * @type {L.Control|null}
		         * @private
		         */
		        _control: null,

		        /**
		         * Options du module
		         * @type {Object}
		         * @private
		         */
		        _options: {
		            position: "bottomleft",
		            text: "Propuls√© par ¬© GeoLeaf with Leaflet"
		        },

		        /**
		         * Initialise le module de branding
		         * @param {L.Map} map - Instance de la carte Leaflet
		         * @param {Object} options - Options de configuration
		         */
		        init(map, options = {}) {
		            const context = "[GeoLeaf.UI.Branding]";

		            try {
		                if (!map) {
		                    throw new Error("Une instance de carte Leaflet est requise.");
		                }

		                this._map = map;
		                this._options = Object.assign({}, this._options, options);

		                // V√©rifier si le module est activ√© dans la config
		                const brandingConfig = GeoLeaf.Config?.get("brandingConfig");

		                if (brandingConfig === false || (brandingConfig && brandingConfig.enabled === false)) {
		                    Log.info(`${context} Branding d√©sactiv√© dans la configuration.`);
		                    return;
		                }

		                // Utiliser les param√®tres de config si disponibles
		                if (brandingConfig && typeof brandingConfig === "object") {
		                    if (brandingConfig.text) {
		                        this._options.text = brandingConfig.text;
		                    }
		                    if (brandingConfig.position) {
		                        this._options.position = brandingConfig.position;
		                    }
		                }

		                // Cr√©er le contr√¥le Leaflet
		                this._createControl();

		                Log.info(`${context} Module initialis√© avec succ√®s.`);

		            } catch (err) {
		                Log.error(`${context} Erreur lors de l'initialisation :`, err.message);
		            }
		        },

		        /**
		         * Cr√©e le contr√¥le Leaflet pour l'affichage du branding
		         * @private
		         */
		        _createControl() {
		            const context = "[GeoLeaf.UI.Branding]";

		            try {
		                // D√©finir le contr√¥le Leaflet personnalis√©
		                const BrandingControl = L.Control.extend({
		                    options: {
		                        position: this._options.position
		                    },

		                    onAdd: () => {
		                        // Cr√©er le conteneur principal
		                        const container = L.DomUtil.create("div", "geoleaf-branding");

		                        // Emp√™cher les √©v√©nements de la carte sur ce contr√¥le
		                        L.DomEvent.disableClickPropagation(container);
		                        L.DomEvent.disableScrollPropagation(container);

		                        // Cr√©er l'√©l√©ment d'affichage du texte
		                        const brandingElement = L.DomUtil.create("div", "branding-content", container);
		                        // SAFE: Utilisation de textContent pour √©viter XSS
		                        brandingElement.textContent = this._options.text;

		                        return container;
		                    },

		                    onRemove: () => {
		                        // Rien √† nettoyer pour ce contr√¥le
		                    }
		                });

		                // Cr√©er et ajouter le contr√¥le √† la carte
		                this._control = new BrandingControl();
		                this._control.addTo(this._map);

		                Log.info(`${context} Contr√¥le de branding cr√©√© et ajout√© √† la carte.`);

		            } catch (err) {
		                Log.error(`${context} Erreur lors de la cr√©ation du contr√¥le :`, err.message);
		            }
		        },

		        /**
		         * D√©truit le contr√¥le et nettoie les ressources
		         */
		        destroy() {
		            const context = "[GeoLeaf.UI.Branding]";

		            try {
		                if (this._control && this._map) {
		                    this._map.removeControl(this._control);
		                    this._control = null;
		                }

		                Log.info(`${context} Module d√©truit avec succ√®s.`);

		            } catch (err) {
		                Log.error(`${context} Erreur lors de la destruction :`, err.message);
		            }
		        },

		        /**
		         * Active l'affichage du branding
		         */
		        show() {
		            if (this._control && !this._map.hasControl(this._control)) {
		                this._control.addTo(this._map);
		            }
		        },

		        /**
		         * D√©sactive l'affichage du branding
		         */
		        hide() {
		            if (this._control && this._map) {
		                this._map.removeControl(this._control);
		            }
		        },

		        /**
		         * Met √† jour le texte du branding
		         * @param {string} text - Nouveau texte
		         */
		        setText(text) {
		            if (this._control) {
		                const container = this._control.getContainer();
		                if (container) {
		                    const brandingElement = container.querySelector(".branding-content");
		                    if (brandingElement) {
		                        // SAFE: Utilisation de textContent pour √©viter XSS
		                        brandingElement.textContent = text;
		                    }
		                }
		            }
		        }
		    };

		    // Export du module
		    GeoLeaf.UI.Branding = Branding;

		})(typeof globalThis !== "undefined" ? globalThis : window);
		return branding;
	}

	requireBranding();

	var core$5 = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredCore$5;

	function requireCore$5 () {
		if (hasRequiredCore$5) return core$5;
		hasRequiredCore$5 = 1;
		/**
		 * GeoLeaf Content Builder - Core Module
		 *
		 * Centralise les fonctions utilitaires, validateurs et r√©solution de badges
		 * pour tous les renderers du Content Builder.
		 *
		 * @module ui/content-builder/core
		 * @author GeoLeaf Team
		 * @version 1.0.0
		 * @since Sprint 4.5 (Janvier 2026)
		 *
		 * @example
		 * // Acc√®s au module Core
		 * const Core = GeoLeaf._ContentBuilder.Core;
		 *
		 * // Validation image URL
		 * const imageUrl = Core.validateImageUrl('https://example.com/photo.jpg');
		 *
		 * // R√©solution badge taxonomie
		 * const badge = Core.resolveBadge(poi, 'attributes.categoryId', 'default');
		 *
		 * // Formatage coordonn√©es
		 * const coords = Core.formatCoordinates(45.7578, 4.8320);
		 * // Retourne: "45.757800, 4.832000"
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    if (!GeoLeaf._ContentBuilder) GeoLeaf._ContentBuilder = {};

		    // ========================================
		    //   D√âPENDANCES & HELPERS
		    // ========================================

		    /**
		     * R√©cup√®re la fonction resolveField depuis GeoLeaf.Utils avec fallback d√©fensif.
		     *
		     * Cette fonction permet de r√©soudre des valeurs dans des objets POI en testant
		     * plusieurs chemins (paths) dans l'ordre jusqu'√† trouver une valeur valide.
		     *
		     * @function getResolveField
		     * @returns {Function} Fonction resolveField(obj, ...paths) ‚Üí value|null
		     *
		     * @example
		     * const resolveField = getResolveField();
		     * const name = resolveField(poi, 'attributes.name', 'attributes.nom', 'properties.name');
		     * // Teste dans l'ordre: poi.attributes.name ‚Üí poi.attributes.nom ‚Üí poi.properties.name
		     * // Retourne la premi√®re valeur non-null trouv√©e
		     *
		     * @example
		     * // Avec fallback si Utils non charg√©
		     * const resolveField = getResolveField();
		     * const value = resolveField({ attributes: { price: 42 } }, 'attributes.price');
		     * // Retourne: 42
		     */
		    function getResolveField() {
		        if (GeoLeaf.Utils && typeof GeoLeaf.Utils.resolveField === 'function') {
		            return GeoLeaf.Utils.resolveField;
		        }
		        // Fallback minimal si Utils non charg√©
		        return function (obj, ...paths) {
		            if (!obj) return null;
		            for (const path of paths) {
		                if (!path) continue;
		                const parts = String(path).split('.');
		                let current = obj;
		                let found = true;
		                for (const part of parts) {
		                    if (current && typeof current === 'object' && part in current) {
		                        current = current[part];
		                    } else {
		                        found = false;
		                        break;
		                    }
		                }
		                if (found && current !== undefined && current !== null) {
		                    return current;
		                }
		            }
		            return null;
		        };
		    }

		    /**
		     * R√©cup√®re la fonction escapeHtml depuis GeoLeaf.Security avec fallback d√©fensif.
		     *
		     * Essentiel pour pr√©venir les attaques XSS en √©chappant tous les caract√®res HTML
		     * sp√©ciaux avant insertion dans le DOM.
		     *
		     * @function getEscapeHtml
		     * @returns {Function} Fonction escapeHtml(str) ‚Üí string
		     *
		     * @example
		     * const escapeHtml = getEscapeHtml();
		     * const safe = escapeHtml('<script>alert("XSS")</script>');
		     * // Retourne: "&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;"
		     *
		     * @example
		     * // Utilisation dans un renderer
		     * const escapeHtml = getEscapeHtml();
		     * const html = '<div>' + escapeHtml(userInput) + '</div>';
		     * // userInput est s√©curis√© contre XSS
		     */
		    function getEscapeHtml() {
		        if (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function') {
		            return GeoLeaf.Security.escapeHtml;
		        }
		        // Fallback minimal si Security non charg√©
		        return function (str) {
		            if (str == null) return '';
		            const div = document.createElement('div');
		            div.textContent = String(str);
		            return div.innerHTML;
		        };
		    }

		    /**
		     * R√©cup√®re le profil de configuration actif depuis GeoLeaf.Config.
		     *
		     * Le profil contient la taxonomie (cat√©gories, sous-cat√©gories), les styleRules,
		     * et toutes les configurations sp√©cifiques √† la couche active.
		     *
		     * @function getActiveProfile
		     * @returns {Object|null} Profil actif avec structure:
		     *   - {Object} taxonomy - Cat√©gories et sous-cat√©gories
		     *   - {Array} styleRules - R√®gles de style conditionnelles
		     *   - {Object} detailPopup - Configuration popup POI
		     *   - {Object} detailTooltip - Configuration tooltip POI
		     *   - {Array} detailLayout - Configuration panel POI
		     * @returns {null} Si Config non charg√© ou pas de profil actif
		     *
		     * @example
		     * const profile = getActiveProfile();
		     * if (profile && profile.taxonomy) {
		     *   const categories = profile.taxonomy.categories;
		     *   // Acc√®s aux cat√©gories de la taxonomie
		     * }
		     */
		    function getActiveProfile() {
		        if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === 'function') {
		            return GeoLeaf.Config.getActiveProfile() || null;
		        }
		        return null;
		    }

		    /**
		     * R√©cup√®re le syst√®me de logging GeoLeaf.Log avec fallback sur console.
		     *
		     * Permet d'utiliser les m√©thodes debug(), info(), warn(), error() de mani√®re
		     * coh√©rente dans tout le Content Builder.
		     *
		     * @function getLog
		     * @returns {Object} Logger avec m√©thodes:
		     *   - {Function} debug(message, ...args) - Logs de d√©bogage
		     *   - {Function} info(message, ...args) - Logs informatifs
		     *   - {Function} warn(message, ...args) - Avertissements
		     *   - {Function} error(message, ...args) - Erreurs
		     *
		     * @example
		     * const log = getLog();
		     * log.info('[ContentBuilder] Rendering popup');
		     * log.warn('[ContentBuilder] Image URL invalide:', url);
		     * log.error('[ContentBuilder] POI invalide:', poi);
		     */
		    function getLog() {
		        return GeoLeaf.Log || console;
		    }

		    // ========================================
		    //   VALIDATORS
		    // ========================================

		    /**
		     * Valide une URL d'image en v√©rifiant les protocoles autoris√©s et la structure.
		     *
		     * Utilise GeoLeaf.Security.validateUrl si disponible, sinon applique une validation
		     * basique avec whitelist de protocoles (https://, http://, data:image//, /, ./).
		     *
		     * @function validateImageUrl
		     * @param {string} url - URL √† valider
		     * @returns {string|null} URL valide (trimmed) ou null si invalide
		     *
		     * @example
		     * // URL HTTPS valide
		     * const url1 = validateImageUrl('https://example.com/photo.jpg');
		     * // Retourne: 'https://example.com/photo.jpg'
		     *
		     * @example
		     * // Data URL valide
		     * const url2 = validateImageUrl('data:image/png;base64,iVBORw0KG...');
		     * // Retourne: 'data:image/png;base64,iVBORw0KG...'
		     *
		     * @example
		     * // Chemin relatif valide
		     * const url3 = validateImageUrl('/images/photo.jpg');
		     * // Retourne: '/images/photo.jpg'
		     *
		     * @example
		     * // URL invalide (protocole interdit)
		     * const url4 = validateImageUrl('javascript:alert(1)');
		     * // Retourne: null
		     */
		    function validateImageUrl(url) {
		        if (!url || typeof url !== 'string') return null;

		        // Utiliser le validator de GeoLeaf.Security si disponible
		        if (GeoLeaf.Security && typeof GeoLeaf.Security.validateUrl === 'function') {
		            try {
		                return GeoLeaf.Security.validateUrl(url);
		            } catch (e) {
		                getLog().warn('[ContentBuilder.Core] URL image invalide:', e.message);
		                return null;
		            }
		        }

		        // Fallback : validation basique
		        const trimmed = url.trim();
		        if (/^https?:\/\//i.test(trimmed) ||
		            /^data:image\//i.test(trimmed) ||
		            trimmed.startsWith('/') ||
		            trimmed.startsWith('./') ||
		            trimmed.startsWith('../')) {
		            return trimmed;
		        }

		        return null;
		    }

		    /**
		     * Valide des coordonn√©es g√©ographiques (latitude, longitude) avec support
		     * de plusieurs formats d'entr√©e.
		     *
		     * Supporte:
		     * - Format array: [lat, lng]
		     * - Format objet: {lat: number, lng: number}
		     * - Validation limites: lat ‚àà [-90, 90], lng ‚àà [-180, 180]
		     *
		     * @function validateCoordinates
		     * @param {Array<number>|Object|*} value - Coordonn√©es √† valider
		     * @returns {{lat: number, lng: number}|null} Coordonn√©es valides ou null
		     *
		     * @example
		     * // Format array
		     * const coords1 = validateCoordinates([45.7578, 4.8320]);
		     * // Retourne: { lat: 45.7578, lng: 4.8320 }
		     *
		     * @example
		     * // Format objet
		     * const coords2 = validateCoordinates({ lat: 45.7578, lng: 4.8320 });
		     * // Retourne: { lat: 45.7578, lng: 4.8320 }
		     *
		     * @example
		     * // Coordonn√©es invalides (hors limites)
		     * const coords3 = validateCoordinates([95, 200]);
		     * // Retourne: null (lat > 90, lng > 180)
		     *
		     * @example
		     * // Format invalide
		     * const coords4 = validateCoordinates('45.7578, 4.8320');
		     * // Retourne: null (string non support√©)
		     */
		    function validateCoordinates(value) {
		        if (value == null) return null;

		        let lat, lng;

		        // Format array [lat, lng]
		        if (Array.isArray(value) && value.length >= 2) {
		            lat = parseFloat(value[0]);
		            lng = parseFloat(value[1]);
		        }
		        // Format objet {lat, lng}
		        else if (typeof value === 'object' && value.lat !== undefined && value.lng !== undefined) {
		            lat = parseFloat(value.lat);
		            lng = parseFloat(value.lng);
		        }
		        // Format invalide
		        else {
		            return null;
		        }

		        // Validation des valeurs
		        if (isNaN(lat) || isNaN(lng)) return null;
		        if (lat < -90 || lat > 90) return null;
		        if (lng < -180 || lng > 180) return null;

		        return { lat, lng };
		    }

		    /**
		     * Valide une valeur num√©rique en la convertissant si n√©cessaire.
		     *
		     * Accepte number, string convertible en number.
		     * Rejette NaN, null, undefined, cha√Ænes vides.
		     *
		     * @function validateNumber
		     * @param {number|string|*} value - Valeur √† valider
		     * @returns {number|null} Nombre valide ou null si invalide
		     *
		     * @example
		     * // Number direct
		     * const num1 = validateNumber(42.5);
		     * // Retourne: 42.5
		     *
		     * @example
		     * // String convertible
		     * const num2 = validateNumber('42.5');
		     * // Retourne: 42.5
		     *
		     * @example
		     * // Valeurs invalides
		     * validateNumber(null);      // null
		     * validateNumber('');        // null
		     * validateNumber('abc');     // null
		     * validateNumber(NaN);       // null
		     * validateNumber(undefined); // null
		     */
		    function validateNumber(value) {
		        if (value == null || value === '') return null;
		        const num = typeof value === 'number' ? value : parseFloat(value);
		        return isNaN(num) ? null : num;
		    }

		    /**
		     * Valide un rating (note) dans l'√©chelle 0-5.
		     *
		     * Utilise validateNumber puis v√©rifie que la valeur est dans [0, 5].
		     * Utile pour les syst√®mes de notation 5 √©toiles.
		     *
		     * @function validateRating
		     * @param {number|string|*} value - Rating √† valider
		     * @returns {number|null} Rating valide ‚àà [0, 5] ou null si invalide
		     *
		     * @example
		     * // Rating valide
		     * const rating1 = validateRating(4.5);
		     * // Retourne: 4.5
		     *
		     * @example
		     * // Rating valide (limites)
		     * const rating2 = validateRating(0);   // 0 (valide)
		     * const rating3 = validateRating(5);   // 5 (valide)
		     *
		     * @example
		     * // Rating invalide (hors limites)
		     * const rating4 = validateRating(-1);  // null (< 0)
		     * const rating5 = validateRating(6);   // null (> 5)
		     * const rating6 = validateRating('excellent'); // null (non num√©rique)
		     */
		    function validateRating(value) {
		        const num = validateNumber(value);
		        if (num === null) return null;
		        if (num < 0 || num > 5) return null;
		        return num;
		    }

		    // ========================================
		    //   BADGE RESOLVER (Taxonomie + Styles)
		    // ========================================

		    /**
		     * R√©sout un badge en appliquant la taxonomie et les styleRules de la couche.
		     *
		     * Processus:
		     * 1. R√©cup√®re la valeur via resolveField (ex: categoryId)
		     * 2. Cherche le label dans taxonomy.categories ou subcategories
		     * 3. Applique les couleurs depuis GeoLeaf.Helpers.StyleResolver
		     * 4. Retourne { displayValue, style } pour affichage HTML
		     *
		     * G√®re 2 types de champs:
		     * - categoryId: r√©solution cat√©gorie principale
		     * - subCategoryId: r√©solution sous-cat√©gorie (avec parent categoryId)
		     *
		     * @function resolveBadge
		     * @param {Object} poi - POI avec attributs et _layerConfig
		     * @param {Object} poi.attributes - Attributs du POI (categoryId, subCategoryId, etc.)
		     * @param {Object} poi._layerConfig - Configuration de la couche (styleRules)
		     * @param {string} field - Chemin du champ (ex: 'attributes.categoryId')
		     * @param {string} [variant] - Variante du badge (non utilis√© actuellement)
		     * @returns {{displayValue: string, style: string}} Badge r√©solu
		     * @returns {string} returns.displayValue - Label du badge (taxonomie ou valeur brute)
		     * @returns {string} returns.style - CSS inline (background-color, border-color)
		     *
		     * @example
		     * // R√©solution cat√©gorie principale
		     * const badge1 = resolveBadge(
		     *   { attributes: { categoryId: 'restaurant' }, _layerConfig: { id: 'pois' } },
		     *   'attributes.categoryId'
		     * );
		     * // Retourne: {
		     * //   displayValue: 'Restaurant',
		     * //   style: 'background-color: #e74c3c; border-color: #c0392b;'
		     * // }
		     *
		     * @example
		     * // R√©solution sous-cat√©gorie
		     * const badge2 = resolveBadge(
		     *   { attributes: { categoryId: 'restaurant', subCategoryId: 'gastronomique' } },
		     *   'attributes.subCategoryId'
		     * );
		     * // Retourne: { displayValue: 'Gastronomique', style: '...' }
		     *
		     * @example
		     * // Valeur non mapp√©e dans taxonomie
		     * const badge3 = resolveBadge(
		     *   { attributes: { categoryId: 'unknown' } },
		     *   'attributes.categoryId'
		     * );
		     * // Retourne: { displayValue: 'unknown', style: '' }
		     */
		    function resolveBadge(poi, field, variant) {
		        const resolveField = getResolveField();
		        const value = resolveField(poi, field);

		        if (value == null || value === '') {
		            return { displayValue: '', style: '' };
		        }

		        const profile = getActiveProfile();
		        const taxonomy = profile?.taxonomy;
		        let displayValue = String(value);
		        let style = '';

		        // Pas de taxonomie : retour simple
		        if (!taxonomy || !field) {
		            return { displayValue, style };
		        }

		        const attrs = poi.attributes || {};

		        // R√©solution cat√©gorie principale
		        if (field.includes('categoryId') && !field.includes('subCategoryId')) {
		            const catData = taxonomy.categories?.[value];
		            if (catData?.label) {
		                displayValue = catData.label;
		            }

		            // Couleurs depuis styleRules de la couche
		            if (GeoLeaf.Helpers?.StyleResolver && poi._layerConfig) {
		                const styleColors = GeoLeaf.Helpers.StyleResolver.getColorsFromLayerStyle(
		                    poi,
		                    poi._layerConfig.id
		                );
		                if (styleColors) {
		                    if (styleColors.fillColor) {
		                        style += 'background-color: ' + styleColors.fillColor + ';';
		                    }
		                    if (styleColors.color) {
		                        style += 'border-color: ' + styleColors.color + ';';
		                    }
		                }
		            }
		        }
		        // R√©solution sous-cat√©gorie
		        else if (field.includes('subCategoryId')) {
		            const catId = attrs.categoryId || attrs.category;
		            const catData = taxonomy.categories?.[catId];
		            const subCatData = catData?.subcategories?.[value];

		            if (subCatData?.label) {
		                displayValue = subCatData.label;
		            }

		            // Couleurs depuis styleRules de la couche
		            if (GeoLeaf.Helpers?.StyleResolver && poi._layerConfig) {
		                const styleColors = GeoLeaf.Helpers.StyleResolver.getColorsFromLayerStyle(
		                    poi,
		                    poi._layerConfig.id
		                );
		                if (styleColors) {
		                    if (styleColors.fillColor) {
		                        style += 'background-color: ' + styleColors.fillColor + ';';
		                    }
		                    if (styleColors.color) {
		                        style += 'border-color: ' + styleColors.color + ';';
		                    }
		                }
		            }
		        }

		        return { displayValue, style };
		    }

		    /**
		     * R√©sout un badge pour tooltip (texte uniquement, sans styles).
		     *
		     * Version simplifi√©e de resolveBadge:
		     * - Retourne uniquement le texte (displayValue)
		     * - Pas de styles CSS
		     * - Optimis√© pour tooltips HTML limit√©s
		     *
		     * Supporte √©galement categoryId et subCategoryId avec r√©solution taxonomie.
		     *
		     * @function resolveBadgeTooltip
		     * @param {Object} poi - POI avec attributs
		     * @param {Object} poi.attributes - Attributs du POI
		     * @param {string} field - Chemin du champ (ex: 'attributes.categoryId')
		     * @returns {string} Label du badge (ou valeur brute si pas de taxonomie)
		     *
		     * @example
		     * // R√©solution cat√©gorie avec taxonomie
		     * const text1 = resolveBadgeTooltip(
		     *   { attributes: { categoryId: 'restaurant' } },
		     *   'attributes.categoryId'
		     * );
		     * // Retourne: 'Restaurant' (label taxonomie)
		     *
		     * @example
		     * // R√©solution sous-cat√©gorie
		     * const text2 = resolveBadgeTooltip(
		     *   { attributes: { categoryId: 'restaurant', subCategoryId: 'gastronomique' } },
		     *   'attributes.subCategoryId'
		     * );
		     * // Retourne: 'Gastronomique'
		     *
		     * @example
		     * // Valeur vide
		     * const text3 = resolveBadgeTooltip(
		     *   { attributes: {} },
		     *   'attributes.unknownField'
		     * );
		     * // Retourne: ''
		     */
		    function resolveBadgeTooltip(poi, field) {
		        const resolveField = getResolveField();
		        const value = resolveField(poi, field);

		        if (value == null || value === '') return '';

		        const profile = getActiveProfile();
		        const taxonomy = profile?.taxonomy;

		        if (!taxonomy) return String(value);

		        const attrs = poi.attributes || {};

		        // Sous-cat√©gorie
		        if (field.includes('subCategoryId')) {
		            const catId = attrs.categoryId || attrs.category;
		            const catData = taxonomy.categories?.[catId];
		            const subCatData = catData?.subcategories?.[value];
		            if (subCatData?.label) return subCatData.label;
		        }
		        // Cat√©gorie
		        else if (field.includes('categoryId')) {
		            const catData = taxonomy.categories?.[value];
		            if (catData?.label) return catData.label;
		        }

		        return String(value);
		    }

		    // ========================================
		    //   UTILITAIRES DE FORMATAGE
		    // ========================================

		    /**
		     * Formate un nombre avec la locale fran√ßaise (s√©parateurs FR).
		     *
		     * Utilise toLocaleString('fr-FR'):
		     * - S√©parateur de milliers: espace (\u202f)
		     * - S√©parateur de d√©cimales: virgule
		     *
		     * @function formatNumber
		     * @param {number} num - Nombre √† formater
		     * @returns {string} Nombre format√© avec conventions fran√ßaises
		     *
		     * @example
		     * // Entier
		     * const str1 = formatNumber(1234567);
		     * // Retourne: '1\u202f234\u202f567'
		     *
		     * @example
		     * // D√©cimal
		     * const str2 = formatNumber(1234.56);
		     * // Retourne: '1\u202f234,56'
		     *
		     * @example
		     * // Petit nombre
		     * const str3 = formatNumber(42);
		     * // Retourne: '42'
		     */
		    function formatNumber(num) {
		        return num.toLocaleString('fr-FR');
		    }

		    /**
		     * Formate des coordonn√©es g√©ographiques en cha√Æne "lat, lng".
		     *
		     * Utilise toFixed pour contr√¥ler la pr√©cision d√©cimale.
		     * Pr√©cision recommand√©e: 6 d√©cimales (~10cm de pr√©cision).
		     *
		     * @function formatCoordinates
		     * @param {number} lat - Latitude (‚àà [-90, 90])
		     * @param {number} lng - Longitude (‚àà [-180, 180])
		     * @param {number} [precision=6] - Nombre de d√©cimales (1-15)
		     * @returns {string} Coordonn√©es format√©es "lat, lng"
		     *
		     * @example
		     * // Pr√©cision par d√©faut (6 d√©cimales)
		     * const str1 = formatCoordinates(45.7578137, 4.8320114);
		     * // Retourne: '45.757814, 4.832011'
		     *
		     * @example
		     * // Haute pr√©cision (8 d√©cimales)
		     * const str2 = formatCoordinates(45.7578137, 4.8320114, 8);
		     * // Retourne: '45.75781370, 4.83201140'
		     *
		     * @example
		     * // Faible pr√©cision (2 d√©cimales)
		     * const str3 = formatCoordinates(45.7578137, 4.8320114, 2);
		     * // Retourne: '45.76, 4.83'
		     */
		    function formatCoordinates(lat, lng, precision = 6) {
		        return lat.toFixed(precision) + ', ' + lng.toFixed(precision);
		    }

		    /**
		     * Formate un rating (note) au format "X.X/5".
		     *
		     * Utilise toFixed pour afficher le nombre de d√©cimales souhait√©.
		     * Compatible avec les syst√®mes de notation 5 √©toiles.
		     *
		     * @function formatRating
		     * @param {number} rating - Note √† formater (‚àà [0, 5])
		     * @param {number} [precision=1] - Nombre de d√©cimales (0-2)
		     * @returns {string} Rating format√© (ex: "4.5/5", "3/5")
		     *
		     * @example
		     * // Pr√©cision par d√©faut (1 d√©cimale)
		     * const str1 = formatRating(4.567);
		     * // Retourne: '4.6/5'
		     *
		     * @example
		     * // Sans d√©cimale
		     * const str2 = formatRating(4.567, 0);
		     * // Retourne: '5/5'
		     *
		     * @example
		     * // 2 d√©cimales
		     * const str3 = formatRating(4.567, 2);
		     * // Retourne: '4.57/5'
		     *
		     * @example
		     * // Note parfaite
		     * const str4 = formatRating(5);
		     * // Retourne: '5.0/5'
		     */
		    function formatRating(rating, precision = 1) {
		        return rating.toFixed(precision) + '/5';
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._ContentBuilder.Core = {
		        // Helpers d√©pendances
		        getResolveField,
		        getEscapeHtml,
		        getActiveProfile,
		        getLog,

		        // Validators
		        validateImageUrl,
		        validateCoordinates,
		        validateNumber,
		        validateRating,

		        // Badge resolver
		        resolveBadge,
		        resolveBadgeTooltip,

		        // Formatters
		        formatNumber,
		        formatCoordinates,
		        formatRating
		    };

		    getLog().info('[GeoLeaf._ContentBuilder.Core] Module Core charg√© - Helpers + Validators + Badge resolver');

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return core$5;
	}

	requireCore$5();

	var templates = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredTemplates;

	function requireTemplates () {
		if (hasRequiredTemplates) return templates;
		hasRequiredTemplates = 1;
		/**
		 * GeoLeaf Content Builder - Templates Module
		 *
		 * Centralise tous les templates HTML (14 builders) et classes CSS standards
		 * pour les renderers (text, number, badge, rating, image, link, list, etc.).
		 *
		 * Organisation:
		 * - CSS_CLASSES: Library de classes CSS standards
		 * - Template Builders: 14 fonctions de construction HTML
		 * - Wrappers: Fonctions utilitaires (wrapInParagraph, wrapInDiv, wrapInLink)
		 *
		 * @module ui/content-builder/templates
		 * @author Assistant
		 * @version 1.0.0
		 * @since 2026-01-18 (Sprint 4.5 - Modularisation)
		 *
		 * @example
		 * // Import des templates
		 * const Templates = GeoLeaf._ContentBuilder.Templates;
		 *
		 * @example
		 * // Utilisation CSS_CLASSES
		 * const className = Templates.CSS_CLASSES.badge; // 'gl-poi-badge'
		 *
		 * @example
		 * // Cr√©ation d'un badge
		 * const badgeHtml = Templates.createBadge(
		 *   { displayValue: 'Restaurant', style: 'background-color: #e74c3c;' },
		 *   'category',
		 *   escapeHtml
		 * );
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    if (!GeoLeaf._ContentBuilder) GeoLeaf._ContentBuilder = {};

		    // ========================================
		    //   CLASSES CSS STANDARDS
		    // ========================================

		    const CSS_CLASSES = {
		        // Container classes
		        text: 'gl-content__text',
		        longtext: 'gl-content__longtext',
		        number: 'gl-content__number',
		        metric: 'gl-content__metric',
		        badge: 'gl-poi-badge',
		        rating: 'gl-content__rating',
		        image: 'gl-content__image',
		        link: 'gl-content__link',
		        list: 'gl-content__list',
		        table: 'gl-content__table',
		        tags: 'gl-content__tags',
		        tag: 'gl-content__tag',
		        coordinates: 'gl-content__coordinates',
		        gallery: 'gl-content__gallery',

		        // Badge variants
		        badgeDefault: 'gl-poi-badge--default',
		        badgeStatus: 'gl-poi-badge--status',
		        badgePriority: 'gl-poi-badge--priority',
		        badgeCategory: 'gl-poi-badge--category',

		        // Rating
		        star: 'gl-star',
		        starFull: 'gl-star--full',
		        starHalf: 'gl-star--half',
		        starEmpty: 'gl-star--empty'
		    };

		    // ========================================
		    //   TEMPLATE BUILDERS
		    // ========================================

		    /**
		     * Construit un attribut HTML class="..." avec classes de base et personnalis√©es.
		     *
		     * Combine baseClass (obligatoire) + customClass (optionnel) en un seul attribut.
		     *
		     * @function buildClassAttr
		     * @param {string} baseClass - Classe CSS de base (ex: 'gl-content__badge')
		     * @param {string} [customClass] - Classe personnalis√©e optionnelle
		     * @returns {string} Attribut HTML class (ex: ' class="gl-content__badge custom"')
		     *
		     * @example
		     * // Classe de base uniquement
		     * const attr1 = buildClassAttr('gl-content__badge');
		     * // Retourne: ' class="gl-content__badge"'
		     *
		     * @example
		     * // Classe de base + classe personnalis√©e
		     * const attr2 = buildClassAttr('gl-content__badge', 'my-custom-badge');
		     * // Retourne: ' class="gl-content__badge my-custom-badge"'
		     */
		    function buildClassAttr(baseClass, customClass) {
		        const classes = [baseClass];
		        if (customClass) classes.push(customClass);
		        return ' class="' + classes.join(' ') + '"';
		    }

		    /**
		     * Construit un attribut HTML style="..." si un style est fourni.
		     *
		     * Retourne une cha√Æne vide si style est null/undefined/vide.
		     *
		     * @function buildStyleAttr
		     * @param {string} [style] - Style CSS inline (ex: 'color: red; background: blue;')
		     * @returns {string} Attribut HTML style (ex: ' style="color: red;"') ou cha√Æne vide
		     *
		     * @example
		     * // Avec style
		     * const attr1 = buildStyleAttr('color: red; font-weight: bold;');
		     * // Retourne: ' style="color: red; font-weight: bold;"'
		     *
		     * @example
		     * // Sans style
		     * const attr2 = buildStyleAttr('');
		     * // Retourne: ''
		     */
		    function buildStyleAttr(style) {
		        return style ? ' style="' + style + '"' : '';
		    }

		    /**
		     * Construit un label HTML avec gestion d'ic√¥ne et √©chappement.
		     *
		     * Utilis√© dans les templates pour afficher un label avec ic√¥ne optionnelle.
		     *
		     * @function buildLabel
		     * @param {string} label - Texte du label (sera √©chapp√©)
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @param {string} [icon] - Ic√¥ne optionnelle (HTML non √©chapp√©)
		     * @returns {string} HTML du label avec ic√¥ne si fournie
		     *
		     * @example
		     * // Label simple
		     * const html1 = buildLabel('Restaurant', escapeHtml);
		     * // Retourne: '<span>Restaurant</span>'
		     *
		     * @example
		     * // Label avec ic√¥ne
		     * const html2 = buildLabel('Restaurant', escapeHtml, '<i class="fa fa-utensils"></i>');
		     * // Retourne: '<i class="fa fa-utensils"></i><span>Restaurant</span>'
		     */
		    function buildLabel(label, escapeHtml, icon) {
		        if (!label) return '';
		        return '<strong>' + escapeHtml(label) + ':</strong> ';
		    }

		    /**
		     * Enveloppe du contenu HTML dans un paragraphe <p> avec classes.
		     *
		     * @function wrapInParagraph
		     * @param {string} content - Contenu HTML (d√©j√† √©chapp√© ou non)
		     * @param {string} className - Classe CSS de base
		     * @param {string} [customClass] - Classe personnalis√©e optionnelle
		     * @returns {string} HTML paragraphe avec classes
		     *
		     * @example
		     * const html = wrapInParagraph('Restaurant', 'gl-content__text');
		     * // Retourne: '<p class="gl-content__text">Restaurant</p>'
		     *
		     * @example
		     * const html2 = wrapInParagraph('Restaurant', 'gl-content__text', 'my-custom');
		     * // Retourne: '<p class="gl-content__text my-custom">Restaurant</p>'
		     */
		    function wrapInParagraph(content, className, customClass) {
		        return '<p' + buildClassAttr(className, customClass) + '>' + content + '</p>';
		    }

		    /**
		     * Enveloppe du contenu HTML dans un div <div> avec classes.
		     *
		     * @function wrapInDiv
		     * @param {string} content - Contenu HTML (d√©j√† √©chapp√© ou non)
		     * @param {string} className - Classe CSS de base
		     * @param {string} [customClass] - Classe personnalis√©e optionnelle
		     * @returns {string} HTML div avec classes
		     *
		     * @example
		     * const html = wrapInDiv('Content', 'gl-content__longtext');
		     * // Retourne: '<div class="gl-content__longtext">Content</div>'
		     */
		    function wrapInDiv(content, className, customClass) {
		        return '<div' + buildClassAttr(className, customClass) + '>' + content + '</div>';
		    }

		    /**
		     * Cr√©e un √©l√©ment de texte simple <p> avec label optionnel.
		     *
		     * Format: <p class="gl-content__text"><strong>Label:</strong> Value</p>
		     *
		     * @function createTextElement
		     * @param {string} value - Valeur texte (√† √©chapper)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec texte
		     *
		     * @example
		     * // Avec label
		     * const html1 = createTextElement('Restaurant', { label: 'Nom' }, escapeHtml);
		     * // Retourne: '<p class="gl-content__text"><strong>Nom:</strong> Restaurant</p>'
		     *
		     * @example
		     * // Sans label
		     * const html2 = createTextElement('Restaurant', {}, escapeHtml);
		     * // Retourne: '<p class="gl-content__text">Restaurant</p>'
		     */
		    function createTextElement(value, config, escapeHtml) {
		        const label = buildLabel(config.label, escapeHtml);
		        const content = label + escapeHtml(value);
		        return wrapInParagraph(content, CSS_CLASSES.text, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment de texte long <div> avec label s√©par√©.
		     *
		     * Format: <div><p><strong>Label</strong></p><p>Value</p></div>
		     * Utilis√© pour descriptions, commentaires, textes longs.
		     *
		     * @function createLongtextElement
		     * @param {string} value - Valeur texte longue (√† √©chapper)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML div avec texte long
		     *
		     * @example
		     * // Avec label
		     * const html1 = createLongtextElement(
		     *   'Une longue description...',
		     *   { label: 'Description' },
		     *   escapeHtml
		     * );
		     * // Retourne: '<div class="gl-content__longtext">
		     * //   <p><strong>Description</strong></p>
		     * //   <p>Une longue description...</p>
		     * // </div>'
		     */
		    function createLongtextElement(value, config, escapeHtml) {
		        const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
		        const content = label + '<p>' + escapeHtml(value) + '</p>';
		        return wrapInDiv(content, CSS_CLASSES.longtext, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment num√©rique <p> avec formatage locale FR.
		     *
		     * Formate le nombre avec toLocaleString('fr-FR').
		     * Supporte prefix, suffix, label.
		     *
		     * @function createNumberElement
		     * @param {number} value - Valeur num√©rique
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.prefix] - Pr√©fixe (ex: "~")
		     * @param {string} [config.suffix] - Suffixe (ex: "m¬≤", "habitants")
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec nombre format√©
		     *
		     * @example
		     * // Nombre simple avec suffix
		     * const html1 = createNumberElement(1234567, { suffix: 'habitants' }, escapeHtml);
		     * // Retourne: '<p class="gl-content__number">1\u202f234\u202f567 habitants</p>'
		     *
		     * @example
		     * // Avec label + prefix + suffix
		     * const html2 = createNumberElement(120, { label: 'Surface', prefix: '~', suffix: 'm¬≤' }, escapeHtml);
		     * // Retourne: '<p class="gl-content__number"><strong>Surface:</strong> ~120 m¬≤</p>'
		     */
		    function createNumberElement(value, config, escapeHtml) {
		        const formatted = value.toLocaleString('fr-FR');
		        const label = buildLabel(config.label, escapeHtml);
		        const suffix = config.suffix ? ' ' + escapeHtml(config.suffix) : '';
		        const prefix = config.prefix ? escapeHtml(config.prefix) + ' ' : '';
		        const content = label + prefix + formatted + suffix;
		        return wrapInParagraph(content, CSS_CLASSES.number, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment m√©trique <p> avec formatage (similaire √† number).
		     *
		     * Identique √† createNumberElement mais utilise CSS_CLASSES.metric.
		     * Utilis√© pour m√©triques sp√©cifiques (KPI, statistiques, etc.).
		     *
		     * @function createMetricElement
		     * @param {number} value - Valeur num√©rique
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.prefix] - Pr√©fixe (ex: "+", "-")
		     * @param {string} [config.suffix] - Suffixe (ex: "%", "‚Ç¨")
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec m√©trique format√©e
		     *
		     * @example
		     * // M√©trique avec pourcentage
		     * const html1 = createMetricElement(95.5, { label: 'Satisfaction', suffix: '%' }, escapeHtml);
		     * // Retourne: '<p class="gl-content__metric"><strong>Satisfaction:</strong> 95,5%</p>'
		     */
		    function createMetricElement(value, config, escapeHtml) {
		        const formatted = value.toLocaleString('fr-FR');
		        const label = buildLabel(config.label, escapeHtml);
		        const suffix = config.suffix ? escapeHtml(config.suffix) : '';
		        const prefix = config.prefix ? escapeHtml(config.prefix) : '';
		        const content = label + prefix + formatted + suffix;
		        return wrapInParagraph(content, CSS_CLASSES.metric, config.className);
		    }

		    /**
		     * Cr√©e un badge <span> avec variante et style inline.
		     *
		     * Variantes disponibles:
		     * - 'default': gl-poi-badge--default
		     * - 'status': gl-poi-badge--status
		     * - 'priority': gl-poi-badge--priority
		     * - 'category': gl-poi-badge--category
		     *
		     * @function createBadge
		     * @param {string} value - Texte du badge (√† √©chapper)
		     * @param {string} [variant='default'] - Variante du badge (default, status, priority, category)
		     * @param {string} [style] - Style CSS inline optionnel (ex: 'background-color: #e74c3c;')
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML span badge
		     *
		     * @example
		     * // Badge default
		     * const html1 = createBadge('Restaurant', 'default', '', escapeHtml);
		     * // Retourne: '<span class="gl-poi-badge gl-poi-badge--default">Restaurant</span>'
		     *
		     * @example
		     * // Badge category avec style
		     * const html2 = createBadge(
		     *   'Gastronomique',
		     *   'category',
		     *   'background-color: #e74c3c; color: white;',
		     *   escapeHtml
		     * );
		     * // Retourne: '<span class="gl-poi-badge gl-poi-badge--category" style="...">Gastronomique</span>'
		     */
		    function createBadge(value, variant, style, escapeHtml) {
		        variant = variant || 'default';
		        const badgeClass = CSS_CLASSES.badge + ' ' + CSS_CLASSES['badge' + variant.charAt(0).toUpperCase() + variant.slice(1)];
		        const styleAttr = buildStyleAttr(style);
		        return '<span class="' + badgeClass + '"' + styleAttr + '>' + escapeHtml(value) + '</span>';
		    }

		    /**
		     * Cr√©e une √©toile <span> de notation avec classe CSS.
		     *
		     * Types disponibles:
		     * - 'full': gl-star--full (‚òÖ plein)
		     * - 'half': gl-star--half (¬Ω √©toile)
		     * - 'empty': gl-star--empty (‚òÜ vide)
		     *
		     * @function createStar
		     * @param {string} type - Type d'√©toile ('full', 'half', 'empty')
		     * @returns {string} HTML span √©toile
		     *
		     * @example
		     * const html1 = createStar('full');
		     * // Retourne: '<span class="gl-star gl-star--full">‚òÖ</span>'
		     *
		     * @example
		     * const html2 = createStar('empty');
		     * // Retourne: '<span class="gl-star gl-star--empty">‚òÖ</span>'
		     */
		    function createStar(type) {
		        const starClass = CSS_CLASSES.star + ' ' + CSS_CLASSES['star' + type.charAt(0).toUpperCase() + type.slice(1)];
		        return '<span class="' + starClass + '">‚òÖ</span>';
		    }

		    /**
		     * Cr√©e un √©l√©ment de notation <p> avec √©toiles (0-5).
		     *
		     * G√©n√®re automatiquement les √©toiles pleines, demi et vides.
		     * Logique:
		     * - rating = 4.7 => 4 full + 1 half + 0 empty
		     * - rating = 3.2 => 3 full + 0 half + 2 empty
		     *
		     * @function createRatingElement
		     * @param {number} rating - Note (0-5)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {number} [config.max=5] - Note maximale (g√©n√©ralement 5)
		     * @param {boolean} [config.showValue=true] - Afficher la valeur num√©rique
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec √©toiles
		     *
		     * @example
		     * // Rating 4.5/5 avec label
		     * const html1 = createRatingElement(4.5, { label: 'Note', showValue: true }, escapeHtml);
		     * // Retourne: '<p class="gl-content__rating">
		     * //   <strong>Note:</strong> ‚òÖ‚òÖ‚òÖ‚òÖ¬Ω (4.5/5)
		     * // </p>'
		     *
		     * @example
		     * // Rating sans valeur num√©rique
		     * const html2 = createRatingElement(3, { showValue: false }, escapeHtml);
		     * // Retourne: '<p class="gl-content__rating">‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</p>'
		     */
		    function createRatingElement(rating, config, escapeHtml) {
		        let stars = '';
		        const fullStars = Math.floor(rating);
		        const hasHalfStar = (rating % 1) >= 0.5;

		        // √âtoiles pleines
		        for (let i = 0; i < fullStars; i++) {
		            stars += createStar('full');
		        }

		        // Demi-√©toile
		        if (hasHalfStar) {
		            stars += createStar('half');
		        }

		        // √âtoiles vides
		        const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
		        for (let i = 0; i < emptyStars; i++) {
		            stars += createStar('empty');
		        }

		        const ratingText = ' (' + rating.toFixed(1) + '/5)';
		        const label = buildLabel(config.label, escapeHtml);
		        const content = label + stars + ratingText;
		        return wrapInDiv(content, CSS_CLASSES.rating, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment image <img> avec classe et alt.
		     *
		     * @function createImageElement
		     * @param {string} src - URL de l'image (sera √©chapp√©e)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.alt] - Texte alternatif optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML img
		     *
		     * @example
		     * // Image avec alt
		     * const html1 = createImageElement(
		     *   'https://example.com/photo.jpg',
		     *   { alt: 'Photo du restaurant' },
		     *   escapeHtml
		     * );
		     * // Retourne: '<img class="gl-content__image" src="https://example.com/photo.jpg" alt="Photo du restaurant">'
		     *
		     * @example
		     * // Image sans alt
		     * const html2 = createImageElement('https://example.com/photo.jpg', {}, escapeHtml);
		     * // Retourne: '<img class="gl-content__image" src="https://example.com/photo.jpg" alt="">'
		     */
		    function createImageElement(src, config, escapeHtml) {
		        const alt = config.alt ? escapeHtml(config.alt) : '';
		        const classAttr = buildClassAttr(CSS_CLASSES.image, config.className);
		        return '<img' + classAttr + ' src="' + escapeHtml(src) + '" alt="' + alt + '">';
		    }

		    /**
		     * Cr√©e un √©l√©ment lien <a> avec target="_blank" et s√©curit√©.
		     *
		     * S√©curit√©: rel="noopener noreferrer" pour √©viter tabnabbing.
		     *
		     * @function createLinkElement
		     * @param {string} href - URL du lien (sera √©chapp√©e)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.text] - Texte du lien (d√©faut: URL)
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec lien
		     *
		     * @example
		     * // Lien avec texte personnalis√©
		     * const html1 = createLinkElement(
		     *   'https://example.com',
		     *   { text: 'Visiter le site', label: 'Site web' },
		     *   escapeHtml
		     * );
		     * // Retourne: '<p class="gl-content__link">
		     * //   <strong>Site web:</strong>
		     * //   <a href="https://example.com" target="_blank" rel="noopener noreferrer">Visiter le site</a>
		     * // </p>'
		     *
		     * @example
		     * // Lien sans texte (affiche URL)
		     * const html2 = createLinkElement('https://example.com', {}, escapeHtml);
		     * // Retourne: '<p class="gl-content__link">
		     * //   <a href="https://example.com" target="_blank" rel="noopener noreferrer">https://example.com</a>
		     * // </p>'
		     */
		    function createLinkElement(href, config, escapeHtml) {
		        const text = config.text ? escapeHtml(config.text) : escapeHtml(href);
		        const label = buildLabel(config.label, escapeHtml);
		        const link = '<a href="' + escapeHtml(href) + '" target="_blank" rel="noopener noreferrer">' + text + '</a>';
		        const content = label + link;
		        return wrapInParagraph(content, CSS_CLASSES.link, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment liste <ul> avec items.
		     *
		     * Convertit automatiquement les items en string via String(item).
		     *
		     * @function createListElement
		     * @param {Array<string|number|*>} items - Items de la liste
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML div avec liste ul
		     *
		     * @example
		     * // Liste avec label
		     * const html1 = createListElement(
		     *   ['Pizza', 'Pasta', 'Risotto'],
		     *   { label: 'Sp√©cialit√©s' },
		     *   escapeHtml
		     * );
		     * // Retourne: '<div class="gl-content__list">
		     * //   <p><strong>Sp√©cialit√©s</strong></p>
		     * //   <ul><li>Pizza</li><li>Pasta</li><li>Risotto</li></ul>
		     * // </div>'
		     *
		     * @example
		     * // Liste simple sans label
		     * const html2 = createListElement(['Item 1', 'Item 2'], {}, escapeHtml);
		     * // Retourne: '<div class="gl-content__list"><ul><li>Item 1</li><li>Item 2</li></ul></div>'
		     */
		    function createListElement(items, config, escapeHtml) {
		        const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
		        let list = '<ul>';
		        items.forEach(item => {
		            list += '<li>' + escapeHtml(String(item)) + '</li>';
		        });
		        list += '</ul>';
		        const content = label + list;
		        return wrapInDiv(content, CSS_CLASSES.list, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment table <table> √† partir d'un objet cl√©/valeur.
		     *
		     * G√©n√®re une table HTML avec <th> pour les cl√©s et <td> pour les valeurs.
		     *
		     * @function createTableElement
		     * @param {Object} data - Donn√©es de la table (cl√©/valeur)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.label] - Label optionnel
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML div avec table
		     *
		     * @example
		     * // Table avec label
		     * const html1 = createTableElement(
		     *   { 'Ouverture': '9h-18h', 'Fermeture': 'Dimanche' },
		     *   { label: 'Horaires' },
		     *   escapeHtml
		     * );
		     * // Retourne: '<div class="gl-content__table">
		     * //   <p><strong>Horaires</strong></p>
		     * //   <table><tbody>
		     * //     <tr><th>Ouverture</th><td>9h-18h</td></tr>
		     * //     <tr><th>Fermeture</th><td>Dimanche</td></tr>
		     * //   </tbody></table>
		     * // </div>'
		     */
		    function createTableElement(data, config, escapeHtml) {
		        const label = config.label ? '<p><strong>' + escapeHtml(config.label) + '</strong></p>' : '';
		        let table = '<table><tbody>';

		        Object.keys(data).forEach(key => {
		            const keyLabel = escapeHtml(String(key));
		            const value = escapeHtml(String(data[key]));
		            table += '<tr><th>' + keyLabel + '</th><td>' + value + '</td></tr>';
		        });

		        table += '</tbody></table>';
		        const content = label + table;
		        return wrapInDiv(content, CSS_CLASSES.table, config.className);
		    }

		    /**
		     * Cr√©e un tag <span> unique avec classe gl-content__tag.
		     *
		     * Utilis√© par createTagsElement pour g√©n√©rer des tags individuels.
		     *
		     * @function createTag
		     * @param {string|number} tag - Texte du tag (√† √©chapper)
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML span tag
		     *
		     * @example
		     * const html = createTag('Restaurant', escapeHtml);
		     * // Retourne: '<span class="gl-content__tag">Restaurant</span>'
		     */
		    function createTag(tag, escapeHtml) {
		        return '<span class="' + CSS_CLASSES.tag + '">' + escapeHtml(String(tag)) + '</span>';
		    }

		    /**
		     * Cr√©e un √©l√©ment cloud de tags <div> avec plusieurs tags.
		     *
		     * G√©n√®re un nuage de tags (tag cloud) avec chaque tag s√©par√© par un espace.
		     *
		     * @function createTagsElement
		     * @param {Array<string|number>} tags - Liste de tags
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML div avec tags
		     *
		     * @example
		     * // Tags multiples
		     * const html = createTagsElement(
		     *   ['Pizza', 'Italien', 'Gastronomique'],
		     *   {},
		     *   escapeHtml
		     * );
		     * // Retourne: '<div class="gl-content__tags">
		     * //   <span class="gl-content__tag">Pizza</span>
		     * //   <span class="gl-content__tag">Italien</span>
		     * //   <span class="gl-content__tag">Gastronomique</span>
		     * // </div>'
		     */
		    function createTagsElement(tags, config, escapeHtml) {
		        let content = '';
		        tags.forEach(tag => {
		            content += createTag(tag, escapeHtml) + ' ';
		        });
		        return wrapInDiv(content.trim(), CSS_CLASSES.tags, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment coordonn√©es <p> avec lat, lng.
		     *
		     * Formate automatiquement avec 6 d√©cimales de pr√©cision.
		     *
		     * @function createCoordinatesElement
		     * @param {number} lat - Latitude (‚àà [-90, 90])
		     * @param {number} lng - Longitude (‚àà [-180, 180])
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML paragraphe avec coordonn√©es
		     *
		     * @example
		     * const html = createCoordinatesElement(45.7578137, 4.8320114, {}, escapeHtml);
		     * // Retourne: '<p class="gl-content__coordinates">
		     * //   <strong>Coordonn√©es:</strong> 45.757814, 4.832011
		     * // </p>'
		     */
		    function createCoordinatesElement(lat, lng, config, escapeHtml) {
		        const latFixed = lat.toFixed(6);
		        const lngFixed = lng.toFixed(6);
		        const content = '<strong>Coordonn√©es:</strong> ' + latFixed + ', ' + lngFixed;
		        return wrapInParagraph(content, CSS_CLASSES.coordinates, config.className);
		    }

		    /**
		     * Cr√©e un √©l√©ment galerie <div> avec plusieurs images.
		     *
		     * G√©n√®re une galerie d'images sans balises <img> individuelles.
		     * Les URLs doivent √™tre valid√©es avant via validateImageUrl.
		     *
		     * @function createGalleryElement
		     * @param {Array<string>} photos - URLs des photos (d√©j√† valid√©es)
		     * @param {Object} config - Configuration renderer
		     * @param {string} [config.className] - Classe personnalis√©e
		     * @param {Function} escapeHtml - Fonction d'√©chappement HTML
		     * @returns {string} HTML div galerie avec images
		     *
		     * @example
		     * const html = createGalleryElement(
		     *   [
		     *     'https://example.com/photo1.jpg',
		     *     'https://example.com/photo2.jpg'
		     *   ],
		     *   {},
		     *   escapeHtml
		     * );
		     * // Retourne: '<div class="gl-content__gallery">
		     * //   <img src="https://example.com/photo1.jpg" alt="Photo">
		     * //   <img src="https://example.com/photo2.jpg" alt="Photo">
		     * // </div>'
		     */
		    function createGalleryElement(photos, config, escapeHtml) {
		        let gallery = '';
		        photos.forEach(photo => {
		            gallery += '<img src="' + escapeHtml(photo) + '" alt="Photo">';
		        });
		        return wrapInDiv(gallery, CSS_CLASSES.gallery, config.className);
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._ContentBuilder.Templates = {
		        // Classes CSS
		        CSS_CLASSES,

		        // Helpers de base
		        buildClassAttr,
		        buildStyleAttr,
		        buildLabel,
		        wrapInParagraph,
		        wrapInDiv,

		        // Template builders
		        createTextElement,
		        createLongtextElement,
		        createNumberElement,
		        createMetricElement,
		        createBadge,
		        createStar,
		        createRatingElement,
		        createImageElement,
		        createLinkElement,
		        createListElement,
		        createTableElement,
		        createTag,
		        createTagsElement,
		        createCoordinatesElement,
		        createGalleryElement
		    };

		    const Log = GeoLeaf.Log || console;
		    Log.info('[GeoLeaf._ContentBuilder.Templates] Module Templates charg√© - 14 builders disponibles');

		    // V√©rification de l'export
		    if (!GeoLeaf._ContentBuilder || !GeoLeaf._ContentBuilder.Templates) {
		        Log.error('[GeoLeaf._ContentBuilder.Templates] ERREUR: Export √©chou√©!');
		    } else {
		        Log.info('[GeoLeaf._ContentBuilder.Templates] Export confirm√© - Templates.createMetricElement:', typeof GeoLeaf._ContentBuilder.Templates.createMetricElement);
		    }

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return templates;
	}

	requireTemplates();

	var assemblers = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredAssemblers;

	function requireAssemblers () {
		if (hasRequiredAssemblers) return assemblers;
		hasRequiredAssemblers = 1;
		/**
		 * GeoLeaf Content Builder - Assemblers Module
		 *
		 * G√®re l'assemblage des √©l√©ments de contenu en structures compl√®tes
		 * pour les popups (detailPopup), tooltips (contentUnion) et panneaux lat√©raux (items).
		 *
		 * Organisation:
		 * - Helpers: getCore, getRenderers, getResolveField, getEscapeHtml, etc.
		 * - Assembleurs: buildPopupHTML, buildTooltipHTML, buildPanelItems
		 *
		 * @module ui/content-builder/assemblers
		 * @author Assistant
		 * @version 1.0.0
		 * @since 2026-01-18 (Sprint 4.5 - Modularisation)
		 *
		 * @example
		 * // Import des assembleurs
		 * const Assemblers = GeoLeaf._ContentBuilder.Assemblers;
		 *
		 * @example
		 * // Construction d'un popup complet
		 * const popupHtml = Assemblers.buildPopupHTML(poi, config, options);
		 *
		 * @example
		 * // Construction d'un tooltip
		 * const tooltipHtml = Assemblers.buildTooltipHTML(poi, contentUnion);
		 */

		(function(global) {

		    // Ensure we're always working with the global reference
		    if (!global.GeoLeaf) {
		        global.GeoLeaf = {};
		    }

		    // Use the global object directly throughout this module
		    const GeoLeaf = global.GeoLeaf;

		    // ========================================
		    //   ACC√àS AUX MODULES
		    // ========================================

		    /**
		     * Get Helpers module (centralized utilities)
		     * @returns {Object}
		     */
		    function getHelpers() {
		        return GeoLeaf._ContentBuilder?.Helpers || {};
		    }

		    function getCore() {
		        return GeoLeaf._ContentBuilder?.Core || null;
		    }

		    function getRenderers() {
		        return GeoLeaf._ContentBuilder || {};
		    }

		    // Use Helpers module with fallbacks
		    function getResolveField() {
		        const helpers = getHelpers();
		        if (helpers.getResolveField) return helpers.getResolveField();
		        const core = getCore();
		        if (core && core.getResolveField) return core.getResolveField();
		        // Minimal fallback
		        return function(obj, ...paths) {
		            for (const path of paths) {
		                const keys = path.split('.');
		                let value = obj;
		                for (const key of keys) {
		                    if (value == null) return null;
		                    value = value[key];
		                }
		                if (value !== null && value !== undefined) return value;
		            }
		            return null;
		        };
		    }

		    function getEscapeHtml() {
		        const helpers = getHelpers();
		        if (helpers.getEscapeHtml) return helpers.getEscapeHtml();
		        const core = getCore();
		        if (core && core.getEscapeHtml) return core.getEscapeHtml();
		        // Minimal fallback
		        return function(str) {
		            if (str == null) return '';
		            return String(str)
		                .replace(/&/g, '&amp;')
		                .replace(/</g, '&lt;')
		                .replace(/>/g, '&gt;')
		                .replace(/"/g, '&quot;')
		                .replace(/'/g, '&#39;');
		        };
		    }

		    function getActiveProfile() {
		        const helpers = getHelpers();
		        if (helpers.getActiveProfile) return helpers.getActiveProfile();
		        const core = getCore();
		        if (core && core.getActiveProfile) return core.getActiveProfile();
		        return GeoLeaf.Config?.getActiveProfile?.() || null;
		    }

		    function getLog() {
		        const helpers = getHelpers();
		        if (helpers.getLog) return helpers.getLog();
		        const core = getCore();
		        if (core && core.getLog) return core.getLog();
		        return GeoLeaf.Utils?.Logger || console;
		    }

		    function renderItem(poi, config, options = {}) {
		        const enableDebug = (typeof window !== 'undefined' && window.__GEOLEAF_DEBUG_POPUP__) || false;
		        const renderers = getRenderers();
		        // ...logs [POPUP] supprim√©s...
		        if (renderers && renderers.renderItem) {
		            const result = renderers.renderItem(poi, config, options);
		            return result;
		        }

		        // Fallback : renderer direct
		        if (!config || !config.type) {
		            if (enableDebug) {
		                getLog().warn('[Assemblers renderItem DEBUG] No config or type');
		            }
		            return '';
		        }

		        const renderer = renderers['render' + config.type.charAt(0).toUpperCase() + config.type.slice(1)];
		        if (!renderer) {
		            if (enableDebug) {
		                getLog().warn('[Assemblers renderItem DEBUG] No renderer found for type:', config.type);
		            }
		            getLog().warn('[Assemblers] Type de rendu non support√©:', config.type);
		            return '';
		        }

		        const result = renderer(poi, config, options);
		        if (enableDebug) {
		            getLog().warn(`[Assemblers renderItem DEBUG] Result from renderer ${config.type}: ${result ? result.substring(0, 100) + '...' : 'EMPTY'}`);
		        }
		        return result;
		    }

		    // ========================================
		    //   ASSEMBLEURS
		    // ========================================

		    // ========================================
		    //   BUILD POPUP HTML
		    // ========================================

		    /**
		     * Group popup sections by type (hero images, badges, other)
		     * Extracted from buildPopupHTML to reduce complexity
		     *
		     * @private
		     * @param {Array<Object>} sortedConfig - Sorted config array
		     * @param {Object} poi - POI data
		     * @param {Object} renderOptions - Render options
		     * @returns {Array<{type: string, html?: string, items?: Array<string>}>} Grouped sections
		     *
		     * @typedef {Object} PopupSection
		     * @property {'hero'|'badges'|'content'} type - Section type
		     * @property {string} [html] - HTML content for hero/content sections
		     * @property {Array<string>} [items] - Badge HTML items for badges section
		     */
		    function groupPopupSections(sortedConfig, poi, renderOptions) {
		        const sections = [];
		        let badgeGroup = [];
		        // ...logs [POPUP] supprim√©s...
		        sortedConfig.forEach((item, index) => {
		            const isHeroImage = item.type === 'image' && item.variant === 'hero';
		            const isBadge = item.type === 'badge';
		            const nextItem = sortedConfig[index + 1];
		            const nextIsBadge = nextItem && nextItem.type === 'badge';
		            const itemHtml = renderItem(poi, item, renderOptions);
		            if (isHeroImage) {
		                sections.push({ type: 'hero', html: itemHtml });
		            } else if (isBadge) {
		                badgeGroup.push(itemHtml);
		                if (!nextIsBadge) {
		                    sections.push({ type: 'badges', items: [...badgeGroup] });
		                    badgeGroup = [];
		                }
		            } else {
		                sections.push({ type: 'content', html: itemHtml });
		            }
		        });

		        return sections;
		    }

		    /**
		     * Assemble popup HTML from grouped sections
		     * Extracted from buildPopupHTML to reduce complexity
		     *
		     * @private
		     * @param {Object} poi - POI data with id property
		     * @param {Array<PopupSection>} sections - Grouped popup sections
		     * @returns {string} Complete popup HTML
		     */
		    function assemblePopupHTML(poi, sections) {
		        let html = '<div class="gl-poi-popup">';
		        let inBody = false;

		        sections.forEach(section => {
		            if (section.type === 'hero') {
		                if (inBody) {
		                    html += '</div>';
		                    inBody = false;
		                }
		                html += section.html;
		            } else {
		                if (!inBody) {
		                    html += '<div class="gl-poi-popup__body">';
		                    inBody = true;
		                }

		                if (section.type === 'badges') {
		                    html += '<div class="gl-poi-popup__badges">';
		                    section.items.forEach(badgeHtml => {
		                        html += badgeHtml;
		                    });
		                    html += '</div>';
		                } else {
		                    html += section.html;
		                }
		            }
		        });

		        // Lien "Voir plus"
		        if (!inBody) {
		            html += '<div class="gl-poi-popup__body">';
		            inBody = true;
		        }
		        html += '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') + '">Voir plus >>></a>';

		        if (inBody) {
		            html += '</div>';
		        }
		        html += '</div>';

		        return html;
		    }

		    /**
		     * Construit le HTML complet d'un popup avec structure et groupement de badges.
		     *
		     * G√®re la structure HTML du popup:
		     * 1. Images hero (en dehors du body)
		     * 2. Body avec badges group√©s + autres √©l√©ments
		     * 3. Lien "Voir plus >>>" automatique
		     *
		     * Tri automatique par config.order, badges group√©s si cons√©cutifs.
		     *
		     * @function buildPopupHTML
		     * @param {Object} poi - Donn√©es du POI normalis√©
		     * @param {Object} poi.id - ID du POI
		     * @param {Object} poi.attributes - Attributs du POI
		     * @param {Array<Object>} config - Configuration detailPopup (array de renderers)
		     * @param {Object} config[].type - Type de renderer ('text', 'badge', 'image', etc.)
		     * @param {number} config[].order - Ordre d'affichage (tri croissant)
		     * @param {string} [config[].variant] - Variante (ex: 'hero' pour images)
		     * @param {Object} [options={}] - Options de rendu
		     * @param {Function} [options.resolveCategoryDisplay] - R√©solution taxonomie personnalis√©e
		     * @returns {string} HTML complet du popup
		     *
		     * @example
		     * // Popup avec image hero + badges + texte
		     * const html = buildPopupHTML(
		     *   poi,
		     *   [
		     *     { type: 'image', field: 'attributes.photo', variant: 'hero', order: 1 },
		     *     { type: 'badge', field: 'attributes.categoryId', order: 2 },
		     *     { type: 'badge', field: 'attributes.status', order: 3 },
		     *     { type: 'text', field: 'attributes.description', order: 4 }
		     *   ],
		     *   {}
		     * );
		     * // Retourne:
		     * // <div class="gl-poi-popup">
		     * //   <img src="..." class="gl-poi-popup__hero"> (hero en dehors du body)
		     * //   <div class="gl-poi-popup__body">
		     * //     <div class="gl-poi-popup__badges">
		     * //       <span class="gl-poi-badge">Restaurant</span>
		     * //       <span class="gl-poi-badge">Ouvert</span>
		     * //     </div>
		     * //     <p>Description...</p>
		     * //     <a href="#" class="gl-poi-popup__link" data-poi-id="123">Voir plus >>></a>
		     * //   </div>
		     * // </div>
		     */
		    function buildPopupHTML(poi, config, options = {}) {
		        // Get helpers and utilities FIRST
		        const helpers = getHelpers();
		        const escapeHtml = getEscapeHtml();

		        if (!poi) {
		            getLog().warn('[Assemblers] POI invalide pour buildPopupHTML');
		            return '';
		        }

		        if (!config || !Array.isArray(config) || config.length === 0) {
		            const title = helpers.getDefaultTitle ? helpers.getDefaultTitle(poi) : (poi.title || poi.label || poi.name || 'Sans titre');
		            helpers.debugLog?.('popup', 'No config provided, using default popup');

		            return '<div class="gl-poi-popup">' +
		                '<div class="gl-poi-popup__body">' +
		                '<h3 class="gl-poi-popup__title"><span class="gl-poi-popup__title-text">' + escapeHtml(title) + '</span></h3>' +
		                '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') + '">Voir plus >>></a>' +
		                '</div></div>';
		        }

		        // ...log supprim√© ([POPUP] buildPopupHTML - config items)...

		        // Use helpers for config sorting
		        const sortedConfig = helpers.sortConfigByOrder ? helpers.sortConfigByOrder(config) :
		            [...config].sort((a, b) => {
		                const orderA = typeof a.order === 'number' ? a.order : 999;
		                const orderB = typeof b.order === 'number' ? b.order : 999;
		                return orderA - orderB;
		            });

		        const renderOptions = {
		            context: 'popup',
		            includeIcon: true,
		            resolveCategoryDisplay: options.resolveCategoryDisplay
		        };

		        // ...log supprim√© ([POPUP] buildPopupHTML - sorted config)...

		        // Group sections and assemble HTML
		        try {
		            const sections = groupPopupSections(sortedConfig, poi, renderOptions);
		            // ...log supprim√© ([POPUP] buildPopupHTML - sections grouped)...

		            const html = assemblePopupHTML(poi, sections);
		            // ...log supprim√© ([POPUP] buildPopupHTML - HTML length)...

		            return html;
		        } catch(err) {
		            // ...log supprim√© ([POPUP] ERROR in buildPopupHTML)...
		            return '<div class="gl-poi-popup"><div class="gl-poi-popup__body">Erreur: ' + escapeHtml(err.message) + '</div></div>';
		        }
		    }

		    /**
		     * Construit le HTML d'un tooltip (texte uniquement, limit√©).
		     *
		     * G√©n√®re un tooltip simple avec valeurs textuelles s√©par√©es par " | ".
		     * Pas de HTML complexe, optimis√© pour tooltips Leaflet.
		     *
		     * Processus:
		     * 1. Si pas de config => utilise title/label/name par d√©faut
		     * 2. Sinon extrait les valeurs textuelles de chaque renderer
		     * 3. G√®re badge resolution via resolveBadgeTooltip
		     * 4. Joint les parties avec " | "
		     *
		     * @function buildTooltipHTML
		     * @param {Object} poi - Donn√©es du POI normalis√©
		     * @param {Object} poi.title - Titre par d√©faut
		     * @param {Object} poi.attributes - Attributs du POI
		     * @param {Array<Object>} config - Configuration detailTooltip (array de renderers)
		     * @param {string} config[].type - Type de renderer ('text', 'badge', 'number', etc.)
		     * @param {string} config[].field - Chemin du champ (ex: 'attributes.name')
		     * @param {number} [config[].order] - Ordre d'affichage (tri croissant)
		     * @param {Object} [options={}] - Options de rendu
		     * @returns {string} Texte du tooltip (pas de HTML, texte plat)
		     *
		     * @example
		     * // Tooltip simple sans config
		     * const text1 = buildTooltipHTML({ title: 'Restaurant Le Gourmet' }, []);
		     * // Retourne: 'Restaurant Le Gourmet'
		     *
		     * @example
		     * // Tooltip avec config (name + category + rating)
		     * const text2 = buildTooltipHTML(
		     *   poi,
		     *   [
		     *     { type: 'text', field: 'attributes.name', order: 1 },
		     *     { type: 'badge', field: 'attributes.categoryId', order: 2 },
		     *     { type: 'number', field: 'attributes.rating', order: 3 }
		     *   ]
		     * );
		     * // Retourne: 'Le Gourmet | Restaurant | 4.5'
		     *
		     * @example
		     * // Tooltip avec valeurs manquantes (skip√©s)
		     * const text3 = buildTooltipHTML(
		     *   poi,
		     *   [
		     *     { type: 'text', field: 'attributes.name', order: 1 },
		     *     { type: 'text', field: 'attributes.missingField', order: 2 }
		     *   ]
		     * );
		     * // Retourne: 'Le Gourmet' (missingField skipp√©)
		     */
		    function buildTooltipHTML(poi, config, options = {}) {
		        if (!poi) {
		            getLog().warn('[Assemblers] POI invalide pour buildTooltipHTML');
		            return '';
		        }

		        const helpers = getHelpers();
		        const escapeHtml = getEscapeHtml();
		        const resolveField = getResolveField();

		        // Si pas de config, tooltip par d√©faut - use helpers
		        if (!config || !Array.isArray(config) || config.length === 0) {
		            const title = helpers.getDefaultTitle ? helpers.getDefaultTitle(poi) :
		                (poi.title || poi.label || poi.name ||
		                 resolveField(poi, 'attributes.name', 'attributes.nom', 'properties.name', 'properties.nom') ||
		                 'Sans titre');
		            return escapeHtml(String(title));
		        }

		        // Use helpers for config sorting
		        const sortedConfig = helpers.sortConfigByOrder ? helpers.sortConfigByOrder(config) :
		            [...config].sort((a, b) => {
		                const orderA = typeof a.order === 'number' ? a.order : 999;
		                const orderB = typeof b.order === 'number' ? b.order : 999;
		                return orderA - orderB;
		            });
		        const parts = [];

		        sortedConfig.forEach((item, index) => {
		            if (!item || !item.type || !item.field) return;

		            const value = resolveField(poi, item.field);
		            if (value == null || value === '') return;

		            // Pour les tooltips, on extrait juste la valeur textuelle
		            if (item.type === 'text' || item.type === 'badge') {
		                let displayValue = value;

		                // Use helpers for badge resolution
		                if (item.type === 'badge' && helpers.resolveBadgeLabel) {
		                    displayValue = helpers.resolveBadgeLabel(poi, item.field, value);
		                } else if (item.type === 'badge') {
		                    // Fallback to inline resolution
		                    const profile = getActiveProfile();
		                    const taxonomy = profile?.taxonomy;
		                    if (taxonomy) {
		                        const attrs = poi.attributes || {};
		                        if (item.field.includes('subCategoryId')) {
		                            const catId = attrs.categoryId || attrs.category;
		                            const catData = taxonomy.categories?.[catId];
		                            const subCatData = catData?.subcategories?.[value];
		                            if (subCatData?.label) displayValue = subCatData.label;
		                        } else if (item.field.includes('categoryId')) {
		                            const catData = taxonomy.categories?.[value];
		                            if (catData?.label) displayValue = catData.label;
		                        }
		                    }
		                }

		                parts.push(escapeHtml(String(displayValue)));
		            }
		            else if (item.type === 'number') {
		                const numValue = typeof value === 'number' ? value : parseFloat(value);
		                if (!isNaN(numValue)) {
		                    parts.push(numValue.toLocaleString('fr-FR'));
		                }
		            }
		            else if (item.type === 'image') {
		                // Image en tooltip : afficher en ligne
		                parts.push('<img src="' + escapeHtml(value) + '" alt="" style="max-width:150px;max-height:100px;display:block;margin:4px 0;" />');
		            }
		            else if (item.type === 'link') {
		                const label = item.label || value;
		                parts.push('<a href="' + escapeHtml(value) + '" target="_blank">' + escapeHtml(label) + '</a>');
		            }
		        });

		        if (parts.length === 0) {
		            const title = poi.title || poi.label || 'Sans titre';
		            return escapeHtml(String(title));
		        }

		        // Joindre avec contentUnion ou espace
		        let result = '';
		        parts.forEach((part, index) => {
		            result += part;
		            if (index < parts.length - 1) {
		                const item = sortedConfig[index];
		                if (item && item.contentUnion) {
		                    result += ' ' + escapeHtml(item.contentUnion) + ' ';
		                } else {
		                    result += ' ';
		                }
		            }
		        });

		        return result;
		    }

		    /**
		     * Construit les √©l√©ments DOM pour un panneau lat√©ral (side panel / accordion).
		     *
		     * G√©n√®re un tableau d'objets pour chaque √©l√©ment du panneau:
		     * - html: HTML rendu de l'√©l√©ment
		     * - config: Configuration renderer originale
		     * - label: Label de l'√©l√©ment (pour accord√©on)
		     * - accordion: Si true, √©l√©ment dans un accord√©on
		     * - defaultOpen: Si true, accord√©on ouvert par d√©faut
		     *
		     * Tri automatique par config.order, √©l√©ments sans valeur skip√©s.
		     *
		     * @function buildPanelItems
		     * @param {Object} poi - Donn√©es du POI normalis√©
		     * @param {Object} poi.attributes - Attributs du POI
		     * @param {Array<Object>} config - Configuration detailLayout (array de renderers)
		     * @param {string} config[].type - Type de renderer ('text', 'list', 'image', etc.)
		     * @param {string} config[].field - Chemin du champ (ex: 'attributes.description')
		     * @param {number} [config[].order] - Ordre d'affichage (tri croissant)
		     * @param {string} [config[].label] - Label de l'√©l√©ment (pour accord√©on)
		     * @param {boolean} [config[].accordion] - Si true, √©l√©ment dans un accord√©on
		     * @param {boolean} [config[].defaultOpen=true] - Si false, accord√©on ferm√© par d√©faut
		     * @param {Object} [options={}] - Options de rendu
		     * @returns {Array<Object>} Tableau d'objets {html, config, label, accordion, defaultOpen}
		     * @returns {string} returns[].html - HTML rendu de l'√©l√©ment
		     * @returns {Object} returns[].config - Configuration renderer originale
		     * @returns {string} returns[].label - Label de l'√©l√©ment
		     * @returns {boolean} returns[].accordion - Si true, √©l√©ment dans un accord√©on
		     * @returns {boolean} returns[].defaultOpen - Si true, accord√©on ouvert par d√©faut
		     *
		     * @example
		     * // Panel simple sans accord√©on
		     * const items1 = buildPanelItems(
		     *   poi,
		     *   [
		     *     { type: 'text', field: 'attributes.name', label: 'Nom', order: 1 },
		     *     { type: 'longtext', field: 'attributes.description', label: 'Description', order: 2 }
		     *   ]
		     * );
		     * // Retourne: [
		     * //   { html: '<p>...</p>', config: {...}, label: 'Nom', accordion: false, defaultOpen: true },
		     * //   { html: '<div>...</div>', config: {...}, label: 'Description', accordion: false, defaultOpen: true }
		     * // ]
		     *
		     * @example
		     * // Panel avec accord√©ons
		     * const items2 = buildPanelItems(
		     *   poi,
		     *   [
		     *     { type: 'text', field: 'attributes.name', label: 'Nom', order: 1 },
		     *     { type: 'list', field: 'attributes.tags', label: 'Tags', accordion: true, defaultOpen: true, order: 2 },
		     *     { type: 'gallery', field: 'attributes.photos', label: 'Photos', accordion: true, defaultOpen: false, order: 3 }
		     *   ]
		     * );
		     * // Retourne: [
		     * //   { html: '<p>...</p>', label: 'Nom', accordion: false, defaultOpen: true },
		     * //   { html: '<ul>...</ul>', label: 'Tags', accordion: true, defaultOpen: true },
		     * //   { html: '<div>...</div>', label: 'Photos', accordion: true, defaultOpen: false }
		     * // ]
		     */
		    function buildPanelItems(poi, config, options = {}) {
		        if (!poi || !config || !Array.isArray(config)) {
		            return [];
		        }

		        const resolveField = getResolveField();
		        const renderOptions = { context: 'panel', ...options };

		        // Trier par order
		        const sortedConfig = [...config].sort((a, b) => {
		            const orderA = typeof a.order === 'number' ? a.order : 999;
		            const orderB = typeof b.order === 'number' ? b.order : 999;
		            return orderA - orderB;
		        });

		        const items = [];

		        sortedConfig.forEach(itemConfig => {
		            if (!itemConfig || !itemConfig.type) return;

		            // V√©rifier si la valeur existe
		            const value = resolveField(poi, itemConfig.field);
		            const hasValue = value !== null && value !== undefined && value !== '' &&
		                             !(Array.isArray(value) && value.length === 0);

		            if (!hasValue && itemConfig.type !== 'coordinates') return;

		            const html = renderItem(poi, itemConfig, renderOptions);
		            if (html) {
		                items.push({
		                    html: html,
		                    config: itemConfig,
		                    label: itemConfig.label || '',
		                    accordion: itemConfig.accordion === true,
		                    defaultOpen: itemConfig.defaultOpen !== false
		                });
		            }
		        });

		        return items;
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    console.log('[POPUP] assemblers.js - Registering Assemblers...');
		    console.log('[POPUP] assemblers.js - GeoLeaf before:', !!global.GeoLeaf);
		    console.log('[POPUP] assemblers.js - GeoLeaf._ContentBuilder before:', !!global.GeoLeaf?._ContentBuilder);

		    if (!GeoLeaf._ContentBuilder) {
		        console.log('[POPUP] assemblers.js - Creating GeoLeaf._ContentBuilder');
		        GeoLeaf._ContentBuilder = {};
		    }

		    GeoLeaf._ContentBuilder.Assemblers = {
		        buildPopupHTML,
		        buildTooltipHTML,
		        buildPanelItems
		    };

		    console.log('[POPUP] assemblers.js - Assemblers registered:', !!GeoLeaf._ContentBuilder.Assemblers);
		    console.log('[POPUP] assemblers.js - global.GeoLeaf._ContentBuilder.Assemblers:', !!global.GeoLeaf._ContentBuilder.Assemblers);

		    // Make sure global reference is updated
		    global.GeoLeaf = GeoLeaf;

		    getLog().info('[GeoLeaf._ContentBuilder.Assemblers] Module Assemblers charg√©');

		    global.GeoLeaf = GeoLeaf;

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return assemblers;
	}

	requireAssemblers();

	var contentBuilder = {};

	/**
	 * GeoLeaf UI Content Builder Module
	 * Module central pour la construction du contenu des tooltips, popups et panneaux lat√©raux.
	 * Unifie le rendu pour tous les types de sources (JSON, GeoJSON, GPX, routes).
	 *
	 * @module ui/content-builder
	 * @version 1.0.0
	 */

	var hasRequiredContentBuilder;

	function requireContentBuilder () {
		if (hasRequiredContentBuilder) return contentBuilder;
		hasRequiredContentBuilder = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._ContentBuilder = GeoLeaf._ContentBuilder || {};

		    // ========================================
		    //   CORE HELPERS (depuis Core module)
		    // ========================================

		    /**
		     * R√©cup√®re les helpers depuis Core (avec fallback)
		     */
		    function getCore() {
		        return GeoLeaf._ContentBuilder.Core || {
		            getResolveField: function() {
		                return GeoLeaf.Utils?.resolveField || (() => null);
		            },
		            getEscapeHtml: function() {
		                return GeoLeaf.Security?.escapeHtml || function(str) {
		                    if (str == null) return '';
		                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
		                };
		            },
		            getActiveProfile: function() {
		                return GeoLeaf.Config?.getActiveProfile?.() || null;
		            },
		            getLog: function() {
		                return GeoLeaf.Log || console;
		            }
		        };
		    }

		    // Raccourcis vers Core
		    const getResolveField = () => getCore().getResolveField();
		    const getEscapeHtml = () => getCore().getEscapeHtml();
		    const getActiveProfile = () => getCore().getActiveProfile();
		    const getLog = () => getCore().getLog();

		    // ========================================
		    //   RENDERERS PAR TYPE
		    // ========================================

		    /**
		     * Construit un √©l√©ment de type "text"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu (context: 'popup'|'tooltip'|'panel')
		     * @returns {string} HTML
		     */
		    function renderText(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        // Tester le champ tel quel, puis avec fallback attributes si properties
		        let value = resolveField(poi, config.field);

		        // Si le champ commence par "properties." et n'a pas de valeur, essayer avec "attributes."
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            const attributesField = config.field.replace(/^properties\./, 'attributes.');
		            value = resolveField(poi, attributesField);
		        }

		        // Si le champ commence par "attributes." et n'a pas de valeur, essayer avec "properties."
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            const propertiesField = config.field.replace(/^attributes\./, 'properties.');
		            value = resolveField(poi, propertiesField);
		        }

		        if (value == null || value === '') return '';

		        const escaped = escapeHtml(String(value));
		        const variant = config.variant || 'default';

		        if (variant === 'title') {
		            // Titre avec √©ventuelle ic√¥ne
		            let iconHtml = '';
		            if (options.includeIcon && options.resolveCategoryDisplay) {
		                const displayConfig = options.resolveCategoryDisplay(poi);
		                if (displayConfig && displayConfig.iconId) {
		                    const iconsConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getIconsConfig === "function")
		                        ? GeoLeaf.Config.getIconsConfig()
		                        : null;
		                    const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || 'gl-poi-cat-';
		                    const iconIdNormalized = String(displayConfig.iconId).trim().toLowerCase().replace(/\s+/g, '-');
		                    const symbolId = iconPrefix + iconIdNormalized;
		                    iconHtml = '<svg class="gl-poi-popup__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24">' +
		                        '<circle cx="12" cy="12" r="10" fill="' + (displayConfig.colorFill || '#666') + '" stroke="' + (displayConfig.colorStroke || '#222') + '" stroke-width="1.5"/>' +
		                        '<svg x="4" y="4" width="16" height="16"><use href="#' + symbolId + '" style="color: #ffffff"/></svg>' +
		                        '</svg>';
		                }
		            }
		            return '<h3 class="gl-poi-popup__title">' + iconHtml + '<span class="gl-poi-popup__title-text">' + escaped + '</span></h3>';
		        }

		        if (variant === 'short') {
		            return '<p class="gl-poi-popup__desc">' + escaped + '</p>';
		        }

		        if (variant === 'long' || variant === 'paragraph') {
		            return '<p class="gl-poi-popup__desc gl-poi-popup__desc--long">' + escaped + '</p>';
		        }

		        return '<p class="gl-poi-popup__desc">' + escaped + '</p>';
		    }

		    /**
		     * Construit un √©l√©ment de type "longtext"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderLongtext(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const escaped = escapeHtml(String(value));
		        return '<div class="gl-content__longtext"><p>' + escaped.replace(/\n/g, '</p><p>') + '</p></div>';
		    }

		    /**
		     * Construit un √©l√©ment de type "number"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderNumber(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const numValue = typeof value === 'number' ? value : parseFloat(value);
		        if (isNaN(numValue)) return '';

		        const formatted = numValue.toLocaleString('fr-FR');
		        const label = config.label ? escapeHtml(config.label) : '';
		        const variant = config.variant || 'default';

		        if (variant === 'stat') {
		            return '<div class="gl-content__stat">' +
		                (label ? '<span class="gl-content__stat-label">' + label + '</span>' : '') +
		                '<span class="gl-content__stat-value">' + formatted + '</span>' +
		                '</div>';
		        }

		        return '<p class="gl-content__number">' +
		            (label ? '<strong>' + label + ':</strong> ' : '') +
		            formatted + '</p>';
		    }

		    /**
		     * Construit un √©l√©ment de type "metric" (nombre avec unit√©/suffixe)
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderMetric(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const numValue = typeof value === 'number' ? value : parseFloat(value);
		        if (isNaN(numValue)) return '';

		        // Utiliser Templates si disponible, sinon fallback
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createMetricElement(numValue, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        const formatted = numValue.toLocaleString('fr-FR');
		        const suffix = config.suffix ? escapeHtml(config.suffix) : '';
		        const prefix = config.prefix ? escapeHtml(config.prefix) : '';
		        const label = config.label ? escapeHtml(config.label) : '';
		        return '<p class="gl-content__metric">' +
		            (label ? '<strong>' + label + ':</strong> ' : '') +
		            prefix + formatted + suffix + '</p>';
		    }

		    /**
		     * Construit un √©l√©ment de type "badge"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderBadge(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();
		        const Core = getCore();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const variant = config.variant || 'default';

		        // Utiliser le badge resolver de Core
		        const badge = Core.resolveBadge ?
		            Core.resolveBadge(poi, config.field, variant) :
		            { displayValue: String(value), style: '' };

		        const escaped = escapeHtml(badge.displayValue);
		        const badgeClass = 'gl-poi-badge gl-poi-badge--' + variant;
		        const styleAttr = badge.style ? ' style="' + badge.style + '"' : '';

		        return '<span class="' + badgeClass + '"' + styleAttr + '>' + escaped + '</span>';
		    }

		    /**
		     * Construit un √©l√©ment de type "rating"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderRating(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const rating = typeof value === 'number' ? value : parseFloat(value);
		        if (isNaN(rating) || rating < 0 || rating > 5) return '';

		        // Variant stat avec layout sp√©cial (conserver l'ancien)
		        if (config.variant === 'stat') {
		            const label = config.label ? escapeHtml(config.label) : '';
		            let starsHtml = '<span class="gl-rating__stars">';
		            for (let i = 1; i <= 5; i++) {
		                const isFilled = i <= Math.round(rating);
		                starsHtml += '<span class="gl-rating__star' + (isFilled ? ' gl-rating__star--filled' : '') + '">‚òÖ</span>';
		            }
		            starsHtml += '</span>';
		            const numericValue = rating.toFixed(1);
		            return '<div class="gl-rating gl-rating--stat">' +
		                (label ? '<span class="gl-rating__label">' + label + '</span>' : '') +
		                '<div class="gl-rating__content">' +
		                starsHtml +
		                '<span class="gl-rating__value">' + numericValue + '/5</span>' +
		                '</div>' +
		                '</div>';
		        }

		        // Variante par d√©faut : utiliser template si disponible
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createRatingElement(rating, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        const label = config.label ? escapeHtml(config.label) : '';
		        let starsHtml = '<span class="gl-rating__stars">';
		        for (let i = 1; i <= 5; i++) {
		            const isFilled = i <= Math.round(rating);
		            starsHtml += '<span class="gl-rating__star' + (isFilled ? ' gl-rating__star--filled' : '') + '">‚òÖ</span>';
		        }
		        starsHtml += '</span>';
		        const numericValue = rating.toFixed(1);
		        return '<div class="gl-rating">' +
		            (label ? '<span class="gl-rating__label">' + label + ': </span>' : '') +
		            starsHtml +
		            '<span class="gl-rating__value">' + numericValue + '/5</span>' +
		            '</div>';
		    }

		    /**
		     * Construit un √©l√©ment de type "image"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderImage(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();
		        const Core = getCore();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        // Utiliser le validator de Core
		        const photoUrl = Core.validateImageUrl ?
		            Core.validateImageUrl(value) :
		            value;

		        if (!photoUrl) return '';

		        const alt = escapeHtml(config.label || 'Image');
		        const variant = config.variant || 'default';

		        if (variant === 'hero') {
		            return '<div class="gl-poi-popup__photo"><img src="' + photoUrl + '" alt="' + alt + '" loading="lazy" /></div>';
		        }

		        return '<div class="gl-poi-popup__photo"><img src="' + photoUrl + '" alt="' + alt + '" loading="lazy" /></div>';
		    }

		    /**
		     * Construit un √©l√©ment de type "link"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderLink(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null || value === '') return '';

		        const label = escapeHtml(config.label || value);
		        const variant = config.variant || 'default';

		        if (variant === 'button') {
		            return '<a href="' + escapeHtml(value) + '" target="_blank" rel="noopener noreferrer" class="gl-content__link gl-content__link--button">' + label + '</a>';
		        }

		        return '<a href="' + escapeHtml(value) + '" target="_blank" rel="noopener noreferrer" class="gl-content__link">' + label + '</a>';
		    }

		    /**
		     * Construit un √©l√©ment de type "list"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderList(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        let value = resolveField(poi, config.field);
		        if ((value == null || value === '') && config.field && config.field.startsWith('properties.')) {
		            value = resolveField(poi, config.field.replace(/^properties\./, 'attributes.'));
		        }
		        if ((value == null || value === '') && config.field && config.field.startsWith('attributes.')) {
		            value = resolveField(poi, config.field.replace(/^attributes\./, 'properties.'));
		        }
		        if (value == null) return '';

		        let items = [];
		        if (Array.isArray(value)) {
		            items = value;
		        } else if (typeof value === 'object') {
		            items = Object.entries(value).map(([k, v]) => k + ': ' + v);
		        } else {
		            return '';
		        }

		        if (items.length === 0) return '';

		        // Utiliser Templates si disponible, sinon fallback
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createListElement(items, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        const variant = config.variant || 'disc';
		        const listClass = 'gl-content__list gl-content__list--' + variant;
		        let html = '<ul class="' + listClass + '">';
		        items.forEach(item => {
		            html += '<li>' + escapeHtml(String(item)) + '</li>';
		        });
		        html += '</ul>';
		        return html;
		    }

		    /**
		     * Construit un √©l√©ment de type "table"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderTable(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        const value = resolveField(poi, config.field);
		        if (value == null || !Array.isArray(value) || value.length === 0) return '';

		        const columns = config.columns || [];
		        if (columns.length === 0) return '';

		        const borders = config.borders || {};
		        let tableStyle = '';
		        if (borders.color) {
		            tableStyle += '--gl-table-border-color: ' + borders.color + ';';
		        }

		        let tableClass = 'gl-content__table';
		        if (borders.outer) tableClass += ' gl-content__table--border-outer';
		        if (borders.row) tableClass += ' gl-content__table--border-row';
		        if (borders.column) tableClass += ' gl-content__table--border-column';

		        let html = '<table class="' + tableClass + '"' + (tableStyle ? ' style="' + tableStyle + '"' : '') + '>';

		        // Header
		        html += '<thead><tr>';
		        columns.forEach(col => {
		            html += '<th>' + escapeHtml(col.label || col.key) + '</th>';
		        });
		        html += '</tr></thead>';

		        // Body
		        html += '<tbody>';
		        value.forEach(row => {
		            html += '<tr>';
		            columns.forEach(col => {
		                const cellValue = typeof row === 'object' ? (row[col.key] || '') : row;
		                html += '<td>' + escapeHtml(String(cellValue)) + '</td>';
		            });
		            html += '</tr>';
		        });
		        html += '</tbody></table>';

		        return html;
		    }

		    /**
		     * Construit un √©l√©ment de type "tags"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderTags(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        const value = resolveField(poi, config.field);
		        if (value == null || !Array.isArray(value) || value.length === 0) return '';

		        const validTags = value.filter(tag => tag && typeof tag === 'string');
		        if (validTags.length === 0) return '';

		        // Utiliser Templates si disponible, sinon fallback
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createTagsElement(validTags, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        let html = '<div class="gl-content__tags">';
		        validTags.forEach(tag => {
		            html += '<span class="gl-content__tag">' + escapeHtml(tag) + '</span>';
		        });
		        html += '</div>';
		        return html;
		    }

		    /**
		     * Construit un √©l√©ment de type "coordinates"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderCoordinates(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();
		        const Core = getCore();

		        const value = resolveField(poi, config.field);
		        if (value == null) return '';

		        // Utiliser le validator de Core
		        const coords = Core.validateCoordinates ?
		            Core.validateCoordinates(value) :
		            null;

		        if (!coords) return '';

		        // Utiliser Templates si disponible, sinon fallback
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createCoordinatesElement(coords.lat, coords.lng, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        const label = config.label ? escapeHtml(config.label) : 'Coordonn√©es';
		        const formatted = Core.formatCoordinates ?
		            Core.formatCoordinates(coords.lat, coords.lng) :
		            coords.lat.toFixed(6) + ', ' + coords.lng.toFixed(6);
		        return '<div class="gl-content__coordinates">' +
		            '<span class="gl-content__coordinates-label">' + label + ':</span> ' +
		            '<span class="gl-content__coordinates-value">' + formatted + '</span>' +
		            '</div>';
		    }

		    /**
		     * Construit un √©l√©ment de type "gallery"
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderGallery(poi, config, options = {}) {
		        const resolveField = getResolveField();
		        const escapeHtml = getEscapeHtml();

		        const value = resolveField(poi, config.field);
		        if (value == null || !Array.isArray(value) || value.length === 0) return '';

		        const validPhotos = value.filter(url => url && typeof url === 'string');
		        if (validPhotos.length === 0) return '';

		        // Utiliser Templates si disponible, sinon fallback
		        if (GeoLeaf._ContentBuilder && GeoLeaf._ContentBuilder.Templates) {
		            return GeoLeaf._ContentBuilder.Templates.createGalleryElement(validPhotos, config, escapeHtml);
		        }

		        // Fallback si Templates pas charg√©
		        let html = '<div class="gl-content__gallery">';
		        validPhotos.forEach((imgUrl, index) => {
		            html += '<div class="gl-content__gallery-item" data-index="' + index + '">' +
		                '<img src="' + escapeHtml(imgUrl) + '" alt="Image ' + (index + 1) + '" loading="lazy" />' +
		                '</div>';
		        });
		        html += '</div>';
		        return html;
		    }

		    // ========================================
		    //   REGISTRE DES RENDERERS
		    // ========================================

		    const RENDERERS = {
		        text: renderText,
		        longtext: renderLongtext,
		        number: renderNumber,
		        metric: renderMetric,
		        badge: renderBadge,
		        rating: renderRating,
		        image: renderImage,
		        link: renderLink,
		        list: renderList,
		        table: renderTable,
		        tags: renderTags,
		        coordinates: renderCoordinates,
		        gallery: renderGallery
		    };

		    /**
		     * Rend un √©l√©ment selon son type
		     * @param {Object} poi - Donn√©es du POI
		     * @param {Object} config - Configuration de l'√©l√©ment
		     * @param {Object} options - Options de rendu
		     * @returns {string} HTML
		     */
		    function renderItem(poi, config, options = {}) {
		        if (!config || !config.type) return '';

		        const renderer = RENDERERS[config.type];
		        if (!renderer) {
		            getLog().warn('[ContentBuilder] Type de rendu non support√©:', config.type);
		            return '';
		        }

		        return renderer(poi, config, options);
		    }

		    // ========================================
		    //   ASSEMBLEURS (via module Assemblers)
		    // ========================================

		    function getAssemblers() {
		        return global.GeoLeaf?._ContentBuilder?.Assemblers || null;
		    }

		    /**
		     * Construit le HTML complet d'un popup
		     * D√©l√®gue √† Assemblers.buildPopupHTML si disponible
		     */
		    function buildPopupHTML(poi, config, options = {}) {
		        const Assemblers = getAssemblers();

		        // ...logs supprim√©s ([POPUP] wrapper buildPopupHTML)...
		        if (Assemblers && Assemblers.buildPopupHTML) {
		            return Assemblers.buildPopupHTML(poi, config, options);
		        }
		        // Fallback minimal
		        if (!poi) return '';
		        const escapeHtml = getEscapeHtml();
		        const title = poi.title || poi.label || poi.name || 'Sans titre';
		        return '<div class="gl-poi-popup"><div class="gl-poi-popup__body">' +
		               '<h3 class="gl-poi-popup__title"><span class="gl-poi-popup__title-text">' +
		               escapeHtml(title) + '</span></h3>' +
		               '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') +
		               '">Voir plus >>></a></div></div>';
		    }

		    /**
		     * Construit le HTML d'un tooltip
		     * D√©l√®gue √† Assemblers.buildTooltipHTML si disponible
		     */
		    function buildTooltipHTML(poi, config, options = {}) {
		        const Assemblers = getAssemblers();
		        if (Assemblers && Assemblers.buildTooltipHTML) {
		            return Assemblers.buildTooltipHTML(poi, config, options);
		        }

		        // Fallback minimal
		        if (!poi) return '';
		        const escapeHtml = getEscapeHtml();
		        const resolveField = getResolveField();
		        const title = poi.title || poi.label || poi.name ||
		                      resolveField(poi, 'attributes.name', 'attributes.nom', 'properties.name', 'properties.nom') ||
		                      'Sans titre';
		        return escapeHtml(String(title));
		    }

		    /**
		     * Construit les √©l√©ments DOM pour un panneau lat√©ral
		     * D√©l√®gue √† Assemblers.buildPanelItems si disponible
		     */
		    function buildPanelItems(poi, config, options = {}) {
		        const Assemblers = getAssemblers();
		        if (Assemblers && Assemblers.buildPanelItems) {
		            return Assemblers.buildPanelItems(poi, config, options);
		        }

		        // Fallback minimal
		        return [];
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    // Preserve existing Assemblers if it exists
		    const existingAssemblers = global.GeoLeaf?._ContentBuilder?.Assemblers;

		    GeoLeaf._ContentBuilder = {
		        // Renderers individuels
		        renderText,
		        renderLongtext,
		        renderNumber,
		        renderBadge,
		        renderImage,
		        renderLink,
		        renderList,
		        renderTable,
		        renderTags,
		        renderCoordinates,
		        renderGallery,
		        renderItem,

		        // Assembleurs
		        buildPopupHTML,
		        buildTooltipHTML,
		        buildPanelItems,

		        // Utilitaires expos√©s
		        getResolveField,
		        getEscapeHtml,
		        getActiveProfile
		    };

		    // Restore Assemblers module reference
		    if (existingAssemblers) {
		        GeoLeaf._ContentBuilder.Assemblers = existingAssemblers;
		    }

		    global.GeoLeaf = GeoLeaf;

		    getLog().info('[GeoLeaf._ContentBuilder] Module Content Builder charg√©');

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return contentBuilder;
	}

	requireContentBuilder();

	var components = {};

	/**
	 * GeoLeaf UI Components - Module commun partag√©
	 * Composants d'interface r√©utilisables pour Legend et LayerManager
	 *
	 * Extrait le code commun entre:
	 * - legend-renderer.js
	 * - layer-manager/renderer.js
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.DomUtil, L.DomEvent)
	 * - GeoLeaf.Log (optionnel)
	 *
	 * EXPOSE:
	 * - GeoLeaf._UIComponents
	 *
	 * @module ui/components
	 */

	var hasRequiredComponents;

	function requireComponents () {
		if (hasRequiredComponents) return components;
		hasRequiredComponents = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Module UI Components
		     * @namespace _UIComponents
		     * @private
		     */
		    const _UIComponents = {
		        /**
		         * Cr√©e un accord√©on
		         * @param {HTMLElement} container - Conteneur parent
		         * @param {Object} config - Configuration de l'accord√©on
		         * @param {string} config.layerId - ID de la couche
		         * @param {string} config.label - Titre de l'accord√©on
		         * @param {boolean} config.collapsed - √âtat initial
		         * @param {boolean} config.visible - Couche visible ou non (pour grisage)
		         * @param {Function} [config.onToggle] - Callback lors du toggle
		         * @returns {Object} - { accordionEl, headerEl, bodyEl }
		         */
		        createAccordion(container, config) {
		            const accordionEl = global.L.DomUtil.create("div", "gl-legend__accordion", container);
		            accordionEl.setAttribute("data-layer-id", config.layerId);

		            if (config.collapsed) {
		                accordionEl.classList.add("gl-legend__accordion--collapsed");
		            }

		            // Ajouter classe inactive si la couche n'est pas visible
		            if (config.visible === false) {
		                accordionEl.classList.add("gl-legend__accordion--inactive");
		            }

		            // Header de l'accord√©on
		            const headerEl = global.L.DomUtil.create("div", "gl-legend__accordion-header", accordionEl);
		            headerEl.setAttribute("role", "button");
		            headerEl.setAttribute("tabindex", "0");
		            headerEl.setAttribute("aria-expanded", !config.collapsed);

		            const titleEl = global.L.DomUtil.create("span", "gl-legend__accordion-title", headerEl);
		            titleEl.textContent = config.label;

		            const toggleEl = global.L.DomUtil.create("button", "gl-legend__accordion-toggle", headerEl);
		            toggleEl.type = "button";
		            toggleEl.setAttribute("aria-label", "Basculer l'accord√©on");
		            toggleEl.textContent = config.collapsed ? "‚ñ∂" : "‚ñº";

		            // Body de l'accord√©on
		            const bodyEl = global.L.DomUtil.create("div", "gl-legend__accordion-body", accordionEl);

		            // Gestionnaire de clic sur le header
		            const onToggle = (ev) => {
		                // Ne rien faire si la couche est inactive
		                if (config.visible === false) {
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.stopPropagation(ev);
		                    }
		                    ev.preventDefault();
		                    return;
		                }

		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                }
		                ev.preventDefault();

		                const isCollapsed = accordionEl.classList.toggle("gl-legend__accordion--collapsed");
		                toggleEl.textContent = isCollapsed ? "‚ñ∂" : "‚ñº";
		                headerEl.setAttribute("aria-expanded", !isCollapsed);

		                // Callback optionnel
		                if (typeof config.onToggle === "function") {
		                    config.onToggle(config.layerId, !isCollapsed);
		                }
		            };

		            this.attachEventHandler(headerEl, "click", onToggle);

		            return { accordionEl, headerEl, bodyEl, toggleEl };
		        },

		        /**
		         * Rend un symbole cercle (POI/Marker)
		         * @param {HTMLElement} container - Conteneur du symbole
		         * @param {Object} config - Configuration du symbole
		         * @returns {HTMLElement} - √âl√©ment cr√©√©
		         */
		        renderCircleSymbol(container, config) {
		            const circleEl = global.L.DomUtil.create("div", "gl-legend__circle", container);

		            // Utiliser le radius transmis, sinon 24px par d√©faut (plus grand pour les l√©gendes avec ic√¥nes)
		            const radius = config.radius !== undefined ? config.radius : 24;
		            const size = radius * 2;
		            const fillColor = config.fillColor || config.color || "#3388ff";
		            const strokeColor = config.color || config.borderColor || "rgba(0,0,0,0.2)";
		            const strokeWidth = config.weight || 1;

		            circleEl.style.width = size + "px";
		            circleEl.style.height = size + "px";
		            circleEl.style.backgroundColor = fillColor;
		            circleEl.style.borderRadius = "50%";
		            circleEl.style.border = strokeWidth + "px solid " + strokeColor;
		            circleEl.style.position = "relative";
		            circleEl.style.display = "flex";
		            circleEl.style.alignItems = "center";
		            circleEl.style.justifyContent = "center";

		            if (config.fillOpacity !== undefined) {
		                circleEl.style.opacity = config.fillOpacity;
		            }

		            // Afficher l'ic√¥ne sprite SVG si pr√©sente
		            if (config.icon) {
		                // Validation de s√©curit√©: L'ID d'ic√¥ne doit √™tre alphanum√©rique avec tirets/underscores seulement
		                const iconId = config.icon.startsWith('#') ? config.icon.substring(1) : config.icon;
		                if (!/^[a-zA-Z0-9_-]+$/.test(iconId)) {
		                    if (Log) Log.error('[UIComponents] ID d\'ic√¥ne invalide (caract√®res non autoris√©s):', config.icon);
		                    return circleEl;
		                }

		                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		                svg.setAttribute("viewBox", "0 0 24 24");
		                // Rendre l'ic√¥ne √† 85% du cercle pour qu'elle soit bien visible
		                svg.style.width = (size * 0.85) + "px";
		                svg.style.height = (size * 0.85) + "px";
		                svg.style.fill = config.iconColor || "currentColor";
		                svg.style.stroke = config.iconColor || "currentColor";
		                svg.style.color = "#ffffff"; // D√©finir la couleur de base pour currentColor
		                svg.style.pointerEvents = "none";
		                svg.style.position = "absolute";

		                const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
		                // ID valid√©, construire le href s√©curis√©
		                const iconHref = '#' + iconId;
		                // Utiliser la syntaxe moderne href au lieu de xlink:href
		                use.setAttribute("href", iconHref);
		                svg.appendChild(use);
		                circleEl.appendChild(svg);

		                // V√©rification d'erreur seulement si Log est disponible
		                if (Log) {
		                    const spriteExists = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		                    if (!spriteExists) {
		                        svg.setAttribute('data-sprite-missing', 'true');
		                        Log.warn('[UIComponents] Ic√¥ne', config.icon, 'r√©f√©renc√©e mais sprite non trouv√© dans le DOM');
		                    } else {
		                        const symbolId = config.icon.startsWith('#') ? config.icon.substring(1) : config.icon;
		                        const symbol = spriteExists.querySelector('#' + symbolId);
		                        if (!symbol) {
		                            svg.setAttribute('data-symbol-missing', config.icon);
		                            Log.warn('[UIComponents] Symbole', config.icon, 'non trouv√© dans le sprite SVG');
		                        }
		                    }
		                }
		            }

		            return circleEl;
		        },

		        /**
		         * Rend un symbole ligne
		         * @param {HTMLElement} container - Conteneur du symbole
		         * @param {Object} config - Configuration du symbole
		         * @returns {HTMLElement} - √âl√©ment cr√©√©
		         */
		        renderLineSymbol(container, config) {
		            const width = config.width || 3;
		            const color = config.color || "#3388ff";
		            let style = config.style || "solid";
		            const dashArray = config.dashArray || null;
		            const outlineColor = config.outlineColor || null;
		            const outlineWidth = config.outlineWidth || null;

		            // Cr√©er un SVG pour les lignes complexes (dashArray custom, tirets √©pais, ou avec outline)
		            if (dashArray || width > 5 || (outlineColor && outlineWidth)) {
		                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		                svg.setAttribute("viewBox", "0 0 40 8");
		                svg.style.width = "40px";
		                const totalHeight = Math.max(width, 3) + (outlineWidth || 0) + 4;
		                svg.style.height = totalHeight + "px";

		                // Si outline existe, dessiner d'abord la ligne de contour
		                if (outlineColor && outlineWidth) {
		                    const outlineLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                    outlineLine.setAttribute("x1", "0");
		                    outlineLine.setAttribute("y1", "4");
		                    outlineLine.setAttribute("x2", "40");
		                    outlineLine.setAttribute("y2", "4");
		                    outlineLine.setAttribute("stroke", outlineColor);
		                    outlineLine.setAttribute("stroke-width", width + (outlineWidth * 2));
		                    outlineLine.setAttribute("stroke-linecap", "round");

		                    if (config.outlineOpacity !== undefined) {
		                        outlineLine.setAttribute("stroke-opacity", config.outlineOpacity);
		                    }

		                    svg.appendChild(outlineLine);
		                }

		                // Dessiner ensuite la ligne principale
		                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                line.setAttribute("x1", "0");
		                line.setAttribute("y1", "4");
		                line.setAttribute("x2", "40");
		                line.setAttribute("y2", "4");
		                line.setAttribute("stroke", color);
		                line.setAttribute("stroke-width", width);
		                line.setAttribute("stroke-linecap", "round");

		                if (dashArray) {
		                    line.setAttribute("stroke-dasharray", dashArray);
		                } else if (style === "dashed") {
		                    line.setAttribute("stroke-dasharray", "8,4");
		                } else if (style === "dotted") {
		                    line.setAttribute("stroke-dasharray", "2,3");
		                }

		                if (config.opacity !== undefined) {
		                    line.setAttribute("stroke-opacity", config.opacity);
		                }

		                svg.appendChild(line);
		                container.appendChild(svg);
		                return svg;
		            }

		            // Fallback : DIV simple pour lignes basiques
		            const lineEl = global.L.DomUtil.create("div", "gl-legend__line", container);
		            lineEl.style.width = "30px";
		            lineEl.style.height = width + "px";
		            lineEl.style.backgroundColor = color;

		            if (style === "dashed") {
		                lineEl.style.backgroundImage = `linear-gradient(to right, ${color} 50%, transparent 50%)`;
		                lineEl.style.backgroundSize = "8px 100%";
		            } else if (style === "dotted") {
		                lineEl.style.backgroundImage = `linear-gradient(to right, ${color} 30%, transparent 30%)`;
		                lineEl.style.backgroundSize = "4px 100%";
		            }

		            if (config.opacity !== undefined) {
		                lineEl.style.opacity = config.opacity;
		            }

		            return lineEl;
		        },

		        /**
		         * Rend un symbole polygone/remplissage
		         * @param {HTMLElement} container - Conteneur du symbole
		         * @param {Object} config - Configuration du symbole
		         * @returns {HTMLElement} - √âl√©ment cr√©√©
		         */
		        renderPolygonSymbol(container, config) {
		            const color = config.fillColor || config.color || "#3388ff";
		            const borderColor = config.borderColor || config.color || "#333";
		            const borderWidth = config.weight || 1;
		            const hasHatch = config.hatch && config.hatch.enabled;
		            // V√©rifier fillOpacity OU opacity (le generator peut utiliser l'un ou l'autre)
		            let fillOpacity = config.fillOpacity !== undefined ? config.fillOpacity :
		                               (config.opacity !== undefined ? config.opacity : 1);

		            // FIX: Si hatch avec renderMode="pattern_only", forcer fillOpacity=1.0
		            // (m√™me logique que layer-manager.js ligne 823-828 - doit rester synchronis√©)
		            if (hasHatch && config.hatch.renderMode === 'pattern_only') {
		                fillOpacity = 1.0;
		            }

		            // Utiliser SVG si hachures pr√©sentes OU si fillOpacity = 0 (contour seul)
		            if (hasHatch || fillOpacity === 0) {
		                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		                svg.setAttribute("viewBox", "0 0 32 24");
		                svg.style.width = "32px";
		                svg.style.height = "24px";

		                // Cr√©er le pattern de hachure SVG si n√©cessaire
		                if (hasHatch) {
		                    const hatchCfg = config.hatch;
		                    const type = hatchCfg.type || "diagonal";
		                    const spacing = hatchCfg.spacingPx || 10;
		                    const hatchColor = (hatchCfg.stroke && hatchCfg.stroke.color) || "#000000";
		                    const hatchOpacity = (hatchCfg.stroke && hatchCfg.stroke.opacity) !== undefined ? hatchCfg.stroke.opacity : 1;
		                    const hatchWidth = (hatchCfg.stroke && hatchCfg.stroke.widthPx) || 1;

		                    const patternId = "hatch-legend-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
		                    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
		                    const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");

		                    pattern.setAttribute("id", patternId);
		                    pattern.setAttribute("patternUnits", "userSpaceOnUse");
		                    pattern.setAttribute("width", spacing);
		                    pattern.setAttribute("height", spacing);

		                    // Cr√©er le contenu selon le type
		                    if (type === "diagonal") {
		                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                        line.setAttribute("x1", "0");
		                        line.setAttribute("y1", "0");
		                        line.setAttribute("x2", spacing);
		                        line.setAttribute("y2", spacing);
		                        line.setAttribute("stroke", hatchColor);
		                        line.setAttribute("stroke-width", hatchWidth);
		                        line.setAttribute("stroke-opacity", hatchOpacity);
		                        pattern.appendChild(line);
		                    } else if (type === "dot") {
		                        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
		                        circle.setAttribute("cx", spacing / 2);
		                        circle.setAttribute("cy", spacing / 2);
		                        circle.setAttribute("r", Math.max(0.3, spacing * 0.07));
		                        circle.setAttribute("fill", hatchColor);
		                        circle.setAttribute("fill-opacity", hatchOpacity);
		                        pattern.appendChild(circle);
		                    } else if (type === "cross") {
		                        const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                        hLine.setAttribute("x1", "0");
		                        hLine.setAttribute("y1", spacing / 2);
		                        hLine.setAttribute("x2", spacing);
		                        hLine.setAttribute("y2", spacing / 2);
		                        hLine.setAttribute("stroke", hatchColor);
		                        hLine.setAttribute("stroke-width", hatchWidth);
		                        hLine.setAttribute("stroke-opacity", hatchOpacity);
		                        pattern.appendChild(hLine);

		                        const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                        vLine.setAttribute("x1", spacing / 2);
		                        vLine.setAttribute("y1", "0");
		                        vLine.setAttribute("x2", spacing / 2);
		                        vLine.setAttribute("y2", spacing);
		                        vLine.setAttribute("stroke", hatchColor);
		                        vLine.setAttribute("stroke-width", hatchWidth);
		                        vLine.setAttribute("stroke-opacity", hatchOpacity);
		                        pattern.appendChild(vLine);
		                    } else if (type === "x") {
		                        const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                        line1.setAttribute("x1", "0");
		                        line1.setAttribute("y1", "0");
		                        line1.setAttribute("x2", spacing);
		                        line1.setAttribute("y2", spacing);
		                        line1.setAttribute("stroke", hatchColor);
		                        line1.setAttribute("stroke-width", hatchWidth);
		                        line1.setAttribute("stroke-opacity", hatchOpacity);
		                        pattern.appendChild(line1);

		                        const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
		                        line2.setAttribute("x1", spacing);
		                        line2.setAttribute("y1", "0");
		                        line2.setAttribute("x2", "0");
		                        line2.setAttribute("y2", spacing);
		                        line2.setAttribute("stroke", hatchColor);
		                        line2.setAttribute("stroke-width", hatchWidth);
		                        line2.setAttribute("stroke-opacity", hatchOpacity);
		                        pattern.appendChild(line2);
		                    }

		                    defs.appendChild(pattern);
		                    svg.appendChild(defs);

		                    // Rectangle avec hachure
		                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
		                    rect.setAttribute("x", "1");
		                    rect.setAttribute("y", "1");
		                    rect.setAttribute("width", "30");
		                    rect.setAttribute("height", "22");
		                    rect.setAttribute("fill", `url(#${patternId})`);
		                    rect.setAttribute("stroke", borderColor);
		                    rect.setAttribute("stroke-width", borderWidth);
		                    if (fillOpacity !== 1) {
		                        rect.setAttribute("fill-opacity", fillOpacity);
		                    }

		                    svg.appendChild(rect);
		                } else {
		                    // fillOpacity = 0 : rectangle transparent avec contour seulement
		                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
		                    rect.setAttribute("x", "1");
		                    rect.setAttribute("y", "1");
		                    rect.setAttribute("width", "30");
		                    rect.setAttribute("height", "22");
		                    rect.setAttribute("fill", "none");
		                    rect.setAttribute("stroke", borderColor);
		                    rect.setAttribute("stroke-width", borderWidth);

		                    // Appliquer le dashArray si pr√©sent
		                    if (config.dashArray) {
		                        rect.setAttribute("stroke-dasharray", config.dashArray);
		                    }

		                    svg.appendChild(rect);
		                }

		                container.appendChild(svg);
		                return svg;
		            }

		            // Fallback : DIV simple avec remplissage
		            const polygonEl = global.L.DomUtil.create("div", "gl-legend__polygon", container);
		            polygonEl.style.width = "24px";
		            polygonEl.style.height = "16px";
		            polygonEl.style.backgroundColor = color;
		            polygonEl.style.border = borderWidth + "px solid " + borderColor;

		            if (fillOpacity !== 1) {
		                polygonEl.style.opacity = fillOpacity;
		            }

		            return polygonEl;
		        },

		        /**
		         * Rend un symbole √©toile (rating)
		         * @param {HTMLElement} container - Conteneur du symbole
		         * @param {Object} config - Configuration du symbole
		         * @returns {HTMLElement} - √âl√©ment cr√©√©
		         */
		        renderStarSymbol(container, config) {
		            const starContainer = global.L.DomUtil.create("div", "gl-legend__stars", container);

		            const count = config.count || 5;
		            const color = config.color || "#f1c40f";
		            const size = config.size || 12;

		            for (let i = 0; i < count; i++) {
		                const starEl = global.L.DomUtil.create("span", "gl-legend__star", starContainer);
		                starEl.textContent = "‚òÖ";
		                starEl.style.color = color;
		                starEl.style.fontSize = size + "px";
		            }

		            return starContainer;
		        },

		        /**
		         * Rend un symbole selon son type
		         * @param {HTMLElement} container - Conteneur du symbole
		         * @param {Object} config - Configuration du symbole
		         * @returns {HTMLElement} - √âl√©ment cr√©√©
		         */
		        renderSymbol(container, config) {
		            // Support de la structure avec config.symbol ou directement config
		            const symbolConfig = config.symbol || config;
		            const symbolType = symbolConfig.type || config.type || "circle";

		            switch (symbolType) {
		                case "marker":
		                case "circle":
		                    return this.renderCircleSymbol(container, symbolConfig);

		                case "line":
		                    return this.renderLineSymbol(container, symbolConfig);

		                case "polygon":
		                case "fill":
		                    return this.renderPolygonSymbol(container, symbolConfig);

		                case "star":
		                    return this.renderStarSymbol(container, symbolConfig);

		                case "icon":
		                    // Icon avec URL d'image
		                    if (symbolConfig.iconUrl) {
		                        const imgEl = global.L.DomUtil.create("img", "gl-legend__icon-img", container);
		                        imgEl.src = symbolConfig.iconUrl;
		                        if (symbolConfig.size) {
		                            imgEl.style.width = symbolConfig.size + "px";
		                            imgEl.style.height = symbolConfig.size + "px";
		                        }
		                        return imgEl;
		                    }
		                    // Icon avec sprite SVG - utiliser renderCircleSymbol qui g√®re d√©j√† les sprites
		                    if (symbolConfig.icon) {
		                        return this.renderCircleSymbol(container, symbolConfig);
		                    }
		                    // Fallback vers circle
		                    return this.renderCircleSymbol(container, symbolConfig);

		                default:
		                    return this.renderCircleSymbol(container, symbolConfig);
		            }
		        },

		        /**
		         * Cr√©e un bouton toggle (checkbox/switch)
		         * @param {HTMLElement} container - Conteneur parent
		         * @param {Object} config - Configuration du toggle
		         * @param {string} [config.id] - ID du toggle
		         * @param {boolean} config.isActive - √âtat initial (alias: active)
		         * @param {string} [config.className] - Classe CSS personnalis√©e
		         * @param {string} [config.label] - Label du toggle
		         * @param {string} [config.title] - Tooltip
		         * @param {Function} [config.onToggle] - Callback lors du toggle
		         * @returns {HTMLElement} - √âl√©ment bouton cr√©√©
		         */
		        createToggleButton(container, config) {
		            // Support isActive ou active
		            const isActive = config.isActive !== undefined ? config.isActive : config.active;
		            const className = config.className || "gl-toggle-btn";

		            const toggleBtn = global.L.DomUtil.create(
		                "button",
		                className,
		                container
		            );
		            toggleBtn.type = "button";

		            if (config.id) {
		                toggleBtn.setAttribute("data-toggle-id", config.id);
		            }

		            toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");

		            if (config.title) {
		                toggleBtn.title = config.title;
		            }

		            if (isActive) {
		                toggleBtn.classList.add(className + "--on");
		            }

		            if (config.label) {
		                toggleBtn.textContent = config.label;
		            }

		            // Attacher le gestionnaire
		            if (typeof config.onToggle === "function") {
		                const className = config.className || "gl-toggle-btn";
		                const onToggle = (ev) => {
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.stopPropagation(ev);
		                    }
		                    ev.preventDefault();

		                    const isActive = toggleBtn.classList.toggle(className + "--on");
		                    toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");

		                    config.onToggle(config.id, isActive, ev);
		                };

		                this.attachEventHandler(toggleBtn, "click", onToggle);
		            }

		            return toggleBtn;
		        },

		        /**
		         * Attache un gestionnaire d'√©v√©nements compatible Leaflet
		         * @param {HTMLElement} element - √âl√©ment cible
		         * @param {string} eventName - Nom de l'√©v√©nement
		         * @param {Function} handler - Gestionnaire
		         */
		        attachEventHandler(element, eventName, handler) {
		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(element, eventName, handler);
		                if (eventName === "click") {
		                    global.L.DomEvent.disableClickPropagation(element);
		                }
		            } else {
		                element.addEventListener(eventName, handler);
		            }
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._UIComponents = _UIComponents;

		    if (Log) Log.info("[GeoLeaf._UIComponents] Module commun UI charg√©");

		})(window);
		return components;
	}

	requireComponents();

	var notifications = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredNotifications;

	function requireNotifications () {
		if (hasRequiredNotifications) return notifications;
		hasRequiredNotifications = 1;
		/**
		 * GeoLeaf Notification System
		 * Gestion des notifications toast et overlays
		 * @module ui/notifications
		 * @version 4.4.1
		 * @updated 2026-01-23 - Standardisation API, queue prioritaire, int√©gration Telemetry
		 */

		(function (window) {

		    // Namespace global GeoLeaf
		    const GeoLeaf = window.GeoLeaf || (window.GeoLeaf = {});

		    // Helper pour utiliser createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    // Constantes pour les priorit√©s de la queue
		    const PRIORITY = {
		        ERROR: 3,
		        WARNING: 2,
		        SUCCESS: 1,
		        INFO: 1
		    };

		class NotificationSystem {
		    constructor() {
		        this.container = null;
		        this.maxVisible = 3;              // Max toasts temporaires visibles
		        this.maxPersistent = 2;           // Max toasts persistants visibles
		        this.durations = {
		            success: 3000,
		            error: 5000,
		            warning: 4000,
		            info: 3000
		        };
		        this.config = {
		            enabled: true,
		            position: 'bottom-center',
		            animations: true
		        };

		        // Managers pour cleanup
		        this._eventManager = null;
		        this._timerManager = null;
		        this._activeToasts = new Map();

		        // Queue avec priorit√©s (limite: 15 max en attente)
		        this._queue = [];
		        this._maxQueueSize = 15;

		        // Buffer pour m√©triques Telemetry (avant chargement du module)
		        this._metricsBuffer = [];
		        this._metricsBufferTimeout = null;
		        this._telemetryAvailable = false;
		    }

		    /**
		     * Initialise le syst√®me de notifications
		     * @param {Object} config - Configuration
		     * @param {string} config.container - S√©lecteur du container
		     * @param {number} config.maxVisible - Nombre max de toasts visibles
		     * @param {Object} config.durations - Dur√©es par type
		     * @param {string} config.position - Position ('bottom-center', 'top-right', etc.)
		     * @param {boolean} config.animations - Activer les animations
		     */
		    init(config = {}) {
		        // Fusionner la config
		        this.config = { ...this.config, ...config };
		        this.maxVisible = config.maxVisible || 3;
		        this.durations = { ...this.durations, ...config.durations };

		        // R√©cup√©rer le container
		        this.container = document.querySelector(config.container || '#gl-notifications');

		        if (!this.container) {
		            const Log = GeoLeaf.Log;
		            if (Log) Log.warn('[GeoLeaf Notifications] Container introuvable:', config.container);
		            return false;
		        }

		        // Appliquer la classe de position
		        if (config.position) {
		            this.container.className = `gl-notifications gl-notifications--${config.position}`;
		        }

		        const Log = GeoLeaf.Log;
		        if (Log) Log.debug('[GeoLeaf Notifications] Syst√®me initialis√©');

		        // Initialiser les managers pour le cleanup
		        if (GeoLeaf.Utils) {
		            this._eventManager = GeoLeaf.Utils.events ? GeoLeaf.Utils.events.createManager('notifications') : null;
		            this._timerManager = GeoLeaf.Utils.timers ? GeoLeaf.Utils.timers.createManager('notifications') : null;
		        }

		        // D√©marrer le timer de 30s pour vider le buffer de m√©triques
		        this._startMetricsBufferTimeout();

		        // Flush imm√©diat si Telemetry est d√©j√† disponible
		        this._flushMetricsBuffer();

		        return true;
		    }

		    /**
		     * Affiche une notification g√©n√©rique (m√©thode publique standardis√©e)
		     * Support double signature:
		     * - show(message, type, duration) : Appel positionnel classique
		     * - show(message, options) : Appel avec objet options
		     *
		     * @param {string} message - Message √† afficher
		     * @param {string|Object} typeOrOptions - Type ('success', 'error', 'warning', 'info') OU objet options
		     * @param {number} [duration] - Dur√©e personnalis√©e (ms) - ignor√© si typeOrOptions est un objet
		     *
		     * @example
		     * // Appel positionnel
		     * show("Message", "success", 3000);
		     *
		     * @example
		     * // Appel avec options
		     * show("Message", {
		     *   type: "success",
		     *   duration: 3000,
		     *   persistent: false,      // Toast persistant (ne s'auto-dismiss pas)
		     *   dismissible: true,      // Bouton de fermeture
		     *   icon: "‚úì",             // Ic√¥ne personnalis√©e (futur)
		     *   action: {               // Action button (futur)
		     *     label: "Annuler",
		     *     callback: () => {}
		     *   }
		     * });
		     */
		    show(message, typeOrOptions = 'info', duration) {
		        // Parser les arguments selon la signature
		        let options = {};

		        if (typeof typeOrOptions === 'string') {
		            // Signature positionnelle: show(message, type, duration)
		            options = {
		                type: typeOrOptions,
		                duration: duration
		            };
		        } else if (typeof typeOrOptions === 'object' && typeOrOptions !== null) {
		            // Signature objet: show(message, options)
		            options = typeOrOptions;
		        } else {
		            // Fallback par d√©faut
		            options = { type: 'info' };
		        }

		        // Ajouter √† la queue avec priorit√©
		        return this._enqueue(message, options);
		    }

		    /**
		     * Affiche une notification de succ√®s
		     * Support double signature:
		     * - success(message, duration)
		     * - success(message, options)
		     *
		     * @param {string} message - Message √† afficher
		     * @param {number|Object} [durationOrOptions] - Dur√©e (ms) OU objet options
		     *
		     * @example
		     * success("Sauvegarde r√©ussie", 3000);
		     * success("Sauvegarde r√©ussie", { duration: 3000, persistent: false });
		     */
		    success(message, durationOrOptions) {
		        if (typeof durationOrOptions === 'number') {
		            return this.show(message, 'success', durationOrOptions);
		        } else if (typeof durationOrOptions === 'object') {
		            return this.show(message, { ...durationOrOptions, type: 'success' });
		        } else {
		            return this.show(message, 'success');
		        }
		    }

		    /**
		     * Affiche une notification d'erreur
		     * Support double signature:
		     * - error(message, duration)
		     * - error(message, options)
		     *
		     * @param {string} message - Message √† afficher
		     * @param {number|Object} [durationOrOptions] - Dur√©e (ms) OU objet options
		     *
		     * @example
		     * error("Erreur r√©seau", 5000);
		     * error("Erreur r√©seau", { duration: 5000, persistent: true });
		     */
		    error(message, durationOrOptions) {
		        if (typeof durationOrOptions === 'number') {
		            return this.show(message, 'error', durationOrOptions);
		        } else if (typeof durationOrOptions === 'object') {
		            return this.show(message, { ...durationOrOptions, type: 'error' });
		        } else {
		            return this.show(message, 'error');
		        }
		    }

		    /**
		     * Affiche une notification d'avertissement
		     * Support double signature:
		     * - warning(message, duration)
		     * - warning(message, options)
		     *
		     * @param {string} message - Message √† afficher
		     * @param {number|Object} [durationOrOptions] - Dur√©e (ms) OU objet options
		     *
		     * @example
		     * warning("Connexion instable", 4000);
		     * warning("Connexion instable", { duration: 4000 });
		     */
		    warning(message, durationOrOptions) {
		        if (typeof durationOrOptions === 'number') {
		            return this.show(message, 'warning', durationOrOptions);
		        } else if (typeof durationOrOptions === 'object') {
		            return this.show(message, { ...durationOrOptions, type: 'warning' });
		        } else {
		            return this.show(message, 'warning');
		        }
		    }

		    /**
		     * Affiche une notification d'information
		     * Support double signature:
		     * - info(message, duration)
		     * - info(message, options)
		     *
		     * @param {string} message - Message √† afficher
		     * @param {number|Object} [durationOrOptions] - Dur√©e (ms) OU objet options
		     *
		     * @example
		     * info("Synchronisation en cours", 3000);
		     * info("Synchronisation en cours", { persistent: true, dismissible: false });
		     */
		    info(message, durationOrOptions) {
		        if (typeof durationOrOptions === 'number') {
		            return this.show(message, 'info', durationOrOptions);
		        } else if (typeof durationOrOptions === 'object') {
		            return this.show(message, { ...durationOrOptions, type: 'info' });
		        } else {
		            return this.show(message, 'info');
		        }
		    }

		    /**
		     * Ajoute une notification √† la queue avec priorit√©
		     * @private
		     * @param {string} message - Message
		     * @param {Object} options - Options de la notification
		     */
		    _enqueue(message, options) {
		        const type = options.type || 'info';
		        const priority = PRIORITY[type.toUpperCase()] || PRIORITY.INFO;

		        const item = {
		            message,
		            options: {
		                type,
		                duration: options.duration,
		                persistent: options.persistent || false,
		                dismissible: options.dismissible !== false, // true par d√©faut
		                icon: options.icon,
		                action: options.action
		            },
		            priority,
		            timestamp: Date.now()
		        };

		        // V√©rifier la limite de la queue
		        if (this._queue.length >= this._maxQueueSize) {
		            // Trouver l'√©l√©ment de plus faible priorit√© (et plus ancien si √©galit√©)
		            const lowestPriorityIndex = this._queue.reduce((minIdx, item, idx, arr) => {
		                const minItem = arr[minIdx];
		                if (item.priority < minItem.priority ||
		                    (item.priority === minItem.priority && item.timestamp < minItem.timestamp)) {
		                    return idx;
		                }
		                return minIdx;
		            }, 0);

		            // Si le nouvel item est plus prioritaire que le moins prioritaire dans la queue
		            if (item.priority > this._queue[lowestPriorityIndex].priority) {
		                // Supprimer le moins prioritaire
		                this._queue.splice(lowestPriorityIndex, 1);
		                // Tracker la m√©trique
		                this._recordMetric('notification.dropped', 1);

		                const Log = GeoLeaf.Log;
		                if (Log) Log.warn('[GeoLeaf Notifications] Queue pleine, notification dropp√©e');
		            } else {
		                // Dropper le nouveau item
		                this._recordMetric('notification.dropped', 1);
		                const Log = GeoLeaf.Log;
		                if (Log) Log.warn('[GeoLeaf Notifications] Queue pleine, notification rejet√©e');
		                return;
		            }
		        }

		        // Ajouter √† la queue
		        this._queue.push(item);
		        this._recordMetric('notification.queued', 1);

		        // Trier la queue par priorit√© (desc) puis timestamp (asc)
		        this._queue.sort((a, b) => {
		            if (b.priority !== a.priority) {
		                return b.priority - a.priority; // Priorit√© d√©croissante
		            }
		            return a.timestamp - b.timestamp; // Timestamp croissant (FIFO pour m√™me priorit√©)
		        });

		        // Traiter la queue
		        return this._processQueue();
		    }

		    /**
		     * Traite la queue et affiche les notifications selon disponibilit√©
		     * @private
		     */
		    _processQueue() {
		        if (!this.container || !this.config.enabled || this._queue.length === 0) {
		            return null;
		        }

		        // Compter les toasts actuellement visibles
		        const visibleToasts = this.container.querySelectorAll('.gl-toast:not(.gl-toast--removing)');
		        const temporaryToasts = Array.from(visibleToasts).filter(t => !t.dataset.persistent);
		        const persistentToasts = Array.from(visibleToasts).filter(t => t.dataset.persistent);

		        // Tant qu'il y a de la place et des items dans la queue
		        let lastToast = null;
		        while (this._queue.length > 0) {
		            const nextItem = this._queue[0];
		            const isPersistent = nextItem.options.persistent;

		            // V√©rifier si on peut afficher ce toast
		            const canShow = isPersistent
		                ? persistentToasts.length < this.maxPersistent
		                : temporaryToasts.length < this.maxVisible;

		            if (!canShow) {
		                // Si c'est un toast prioritaire (error), retirer un toast existant moins prioritaire
		                if (nextItem.priority === PRIORITY.ERROR && temporaryToasts.length > 0) {
		                    // Trouver un toast info ou success √† retirer
		                    const toastToRemove = temporaryToasts.find(t =>
		                        t.classList.contains('gl-toast--info') ||
		                        t.classList.contains('gl-toast--success')
		                    ) || temporaryToasts[0];

		                    this._remove(toastToRemove, true); // true = reorganization
		                    // Continuer pour afficher le toast prioritaire
		                } else {
		                    // Pas de place, arr√™ter le traitement
		                    break;
		                }
		            }

		            // Retirer de la queue et afficher
		            const item = this._queue.shift();
		            lastToast = this._showImmediate(item.message, item.options);

		            // Mettre √† jour les compteurs
		            if (isPersistent) {
		                persistentToasts.push(null); // Placeholder
		            } else {
		                temporaryToasts.push(null); // Placeholder
		            }
		        }

		        return lastToast;
		    }

		    /**
		     * Affiche une notification imm√©diatement (utilis√©e par la queue)
		     * @private
		     * @param {string} message - Message √† afficher
		     * @param {Object} options - Options de la notification
		     */
		    _showImmediate(message, options) {
		        const type = options.type || 'info';
		        const duration = options.duration || this.durations[type];
		        const persistent = options.persistent || false;
		        const dismissible = options.dismissible !== false;

		        // Cr√©er le toast
		        const toast = $create('div', {
		            className: `gl-toast gl-toast--${type}`,
		            attributes: {
		                'role': 'alert',
		                // Utiliser assertive pour errors et toasts prioritaires
		                'aria-live': (type === 'error' || options.priority === PRIORITY.ERROR) ? 'assertive' : 'polite'
		            }
		        });

		        // Marquer si persistant
		        if (persistent) {
		            toast.dataset.persistent = 'true';
		        }

		        // Cr√©er le message (textContent = s√©curis√©)
		        const messageSpan = $create('span', {
		            className: 'gl-toast__message',
		            textContent: message
		        });
		        toast.appendChild(messageSpan);

		        // Cr√©er le bouton de fermeture (si dismissible)
		        if (dismissible) {
		            const closeBtn = $create('button', {
		                className: 'gl-toast__close',
		                attributes: {
		                    'aria-label': 'Fermer la notification',
		                    'title': 'Fermer'
		                },
		                textContent: '√ó',
		                onClick: () => {
		                    this._recordMetric('notification.dismissed.manual', 1);
		                    this._remove(toast, false);
		                }
		            });
		            toast.appendChild(closeBtn);
		        }

		        // Ajouter au DOM
		        this.container.appendChild(toast);

		        // Tracker m√©trique
		        this._recordMetric(`notification.shown.${type}`, 1);

		        // Animation d'entr√©e
		        if (this.config.animations) {
		            requestAnimationFrame(() => {
		                requestAnimationFrame(() => {
		                    toast.classList.add('gl-toast--visible');
		                });
		            });
		        } else {
		            toast.classList.add('gl-toast--visible');
		        }

		        // Planifier l'auto-suppression (seulement si non persistant)
		        if (!persistent) {
		            const autoRemove = setTimeout(() => {
		                this._recordMetric('notification.dismissed.auto', 1);
		                this._remove(toast, false);
		            }, duration);

		            if (this._timerManager) {
		                toast.dataset.timerId = this._timerManager.setTimeout(() => {
		                    this._recordMetric('notification.dismissed.auto', 1);
		                    this._remove(toast, false);
		                }, duration);
		            } else {
		                toast.dataset.timeoutId = autoRemove;
		            }
		        }

		        return toast;
		    }

		    /**
		     * Retire une notification
		     * @private
		     * @param {HTMLElement} toast - √âl√©ment toast √† retirer
		     * @param {boolean} isReorganization - Si true, c'est une r√©organisation (animation diff√©rente)
		     */
		    _remove(toast, isReorganization = false) {
		        if (!toast || toast.classList.contains('gl-toast--removing')) {
		            return;
		        }

		        // Annuler le timeout auto si fermeture manuelle
		        if (toast.dataset.timeoutId) {
		            clearTimeout(parseInt(toast.dataset.timeoutId));
		            delete toast.dataset.timeoutId;
		        }
		        if (toast.dataset.timerId && this._timerManager) {
		            this._timerManager.clearTimeout(toast.dataset.timerId);
		            delete toast.dataset.timerId;
		        }

		        // Animation de sortie
		        toast.classList.add('gl-toast--removing');
		        toast.classList.remove('gl-toast--visible');

		        // Appliquer animation sp√©cifique pour r√©organisation
		        if (isReorganization && this.config.animations) {
		            toast.classList.add('gl-toast--sliding-up');
		        }

		        const removeDelay = this.config.animations ? 200 : 0;
		        setTimeout(() => {
		            if (toast.parentNode) {
		                toast.remove();
		            }
		            // Traiter la queue apr√®s suppression
		            this._processQueue();
		        }, removeDelay);

		        if (this._timerManager) {
		            this._timerManager.setTimeout(() => {
		                if (toast.parentNode) {
		                    toast.remove();
		                }
		                this._processQueue();
		            }, removeDelay);
		        }
		    }

		    /**
		     * Efface toutes les notifications
		     */
		    clearAll() {
		        if (!this.container) return;

		        const toasts = this.container.querySelectorAll('.gl-toast');
		        toasts.forEach(toast => this._remove(toast, false));

		        // Vider aussi la queue
		        this._queue = [];
		    }

		    /**
		     * Ferme une notification sp√©cifique par sa r√©f√©rence DOM
		     * @param {HTMLElement} toastEl - √âl√©ment toast retourn√© par show/info/success/etc.
		     */
		    dismiss(toastEl) {
		        if (!toastEl) return;
		        this._remove(toastEl, false);
		    }

		    /**
		     * D√©sactive temporairement les notifications
		     */
		    disable() {
		        this.config.enabled = false;
		        const Log = GeoLeaf.Log;
		        if (Log) Log.debug('[GeoLeaf Notifications] Syst√®me d√©sactiv√©');
		    }

		    /**
		     * R√©active les notifications
		     */
		    enable() {
		        this.config.enabled = true;
		        const Log = GeoLeaf.Log;
		        if (Log) Log.debug('[GeoLeaf Notifications] Syst√®me activ√©');
		        // Traiter la queue au cas o√π des items sont en attente
		        this._processQueue();
		    }

		    /**
		     * Enregistre une m√©trique Telemetry (avec buffer si module pas encore charg√©)
		     * @private
		     * @param {string} name - Nom de la m√©trique
		     * @param {number} value - Valeur
		     */
		    _recordMetric(name, value = 1) {
		        // V√©rifier si Telemetry est disponible
		        if (GeoLeaf.Storage && GeoLeaf.Storage.Telemetry && typeof GeoLeaf.Storage.Telemetry.recordMetric === 'function') {
		            // Telemetry disponible, enregistrer directement
		            try {
		                GeoLeaf.Storage.Telemetry.recordMetric(name, value);
		                this._telemetryAvailable = true;
		            } catch (error) {
		                const Log = GeoLeaf.Log;
		                if (Log) Log.warn('[GeoLeaf Notifications] Erreur enregistrement m√©trique:', error);
		            }
		        } else {
		            // Telemetry pas encore disponible, ajouter au buffer
		            this._metricsBuffer.push({ name, value, timestamp: Date.now() });
		        }
		    }

		    /**
		     * Vide le buffer de m√©triques vers Telemetry
		     * @private
		     */
		    _flushMetricsBuffer() {
		        if (this._metricsBuffer.length === 0) {
		            return;
		        }

		        // V√©rifier si Telemetry est maintenant disponible
		        if (GeoLeaf.Storage && GeoLeaf.Storage.Telemetry && typeof GeoLeaf.Storage.Telemetry.recordMetric === 'function') {
		            const Log = GeoLeaf.Log;
		            if (Log) Log.debug(`[GeoLeaf Notifications] Flush de ${this._metricsBuffer.length} m√©triques vers Telemetry`);

		            // Enregistrer toutes les m√©triques du buffer
		            this._metricsBuffer.forEach(metric => {
		                try {
		                    GeoLeaf.Storage.Telemetry.recordMetric(metric.name, metric.value);
		                } catch (error) {
		                    if (Log) Log.warn('[GeoLeaf Notifications] Erreur flush m√©trique:', error);
		                }
		            });

		            // Vider le buffer
		            this._metricsBuffer = [];
		            this._telemetryAvailable = true;

		            // Annuler le timeout si actif
		            if (this._metricsBufferTimeout) {
		                clearTimeout(this._metricsBufferTimeout);
		                this._metricsBufferTimeout = null;
		            }
		        }
		    }

		    /**
		     * D√©marre le timeout de 30s pour vider le buffer (√©viter fuite m√©moire)
		     * @private
		     */
		    _startMetricsBufferTimeout() {
		        // Timeout de 30s pour vider le buffer m√™me si Telemetry ne charge pas
		        this._metricsBufferTimeout = setTimeout(() => {
		            if (this._metricsBuffer.length > 0) {
		                const Log = GeoLeaf.Log;
		                if (Log) Log.warn(`[GeoLeaf Notifications] Timeout buffer m√©triques (30s), ${this._metricsBuffer.length} m√©triques abandonn√©es`);
		                this._metricsBuffer = [];
		            }
		            this._metricsBufferTimeout = null;
		        }, 30000); // 30 secondes
		    }

		    /**
		     * √âchappe le HTML pour √©viter les injections XSS
		     * @private
		     * @param {string} text - Texte √† √©chapper
		     * @returns {string} Texte √©chapp√©
		     * @deprecated Utilisez textContent au lieu de innerHTML
		     */
		    _escapeHtml(text) {
		        if (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function') {
		            return GeoLeaf.Security.escapeHtml(text);
		        }
		        // Fallback s√©curis√© si Security n'est pas charg√©
		        if (text == null) return '';
		        return String(text).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
		    }

		    /**
		     * D√©truit le syst√®me de notifications et nettoie toutes les ressources
		     * Retire tous les event listeners et timers actifs
		     */
		    destroy() {
		        const Log = GeoLeaf.Log;

		        // Clear tous les timers actifs
		        if (this._timerManager) {
		            this._timerManager.destroy();
		            this._timerManager = null;
		        }

		        // Retire tous les event listeners
		        if (this._eventManager) {
		            this._eventManager.destroy();
		            this._eventManager = null;
		        }

		        // Clear le timeout du buffer
		        if (this._metricsBufferTimeout) {
		            clearTimeout(this._metricsBufferTimeout);
		            this._metricsBufferTimeout = null;
		        }

		        // Vider le buffer de m√©triques (une derni√®re tentative)
		        if (this._metricsBuffer.length > 0) {
		            this._flushMetricsBuffer();
		            // Si toujours pas vid√©, abandonner
		            this._metricsBuffer = [];
		        }

		        // Retire tous les toasts actifs
		        if (this.container) {
		            const toasts = this.container.querySelectorAll('.gl-toast');
		            toasts.forEach(toast => toast.remove());
		        }

		        // Clear la queue
		        this._queue = [];

		        // Clear la map
		        this._activeToasts.clear();

		        // Reset les propri√©t√©s
		        this.container = null;
		        this.config.enabled = false;

		        if (Log) Log.info('[GeoLeaf Notifications] Syst√®me d√©truit et nettoy√©');
		    }

		    /**
		     * Get current status of notification system
		     * @returns {Object} Status information
		     */
		    getStatus() {
		        const visibleToasts = this.container ? this.container.querySelectorAll('.gl-toast:not(.gl-toast--removing)') : [];
		        const temporaryToasts = Array.from(visibleToasts).filter(t => !t.dataset.persistent);
		        const persistentToasts = Array.from(visibleToasts).filter(t => t.dataset.persistent);

		        return {
		            enabled: this.config.enabled,
		            initialized: !!this.container,
		            activeToasts: visibleToasts.length,
		            temporaryToasts: temporaryToasts.length,
		            persistentToasts: persistentToasts.length,
		            queued: this._queue.length,
		            maxVisible: this.maxVisible,
		            maxPersistent: this.maxPersistent,
		            position: this.config.position,
		            telemetryAvailable: this._telemetryAvailable,
		            metricsBuffered: this._metricsBuffer.length
		        };
		    }
		}

		// Cr√©er une instance singleton et l'exposer
		GeoLeaf._UINotifications = new NotificationSystem();

		})(window);
		return notifications;
	}

	requireNotifications();

	var eventDelegation = {};

	/**
	 * GeoLeaf UI Module - Event Delegation
	 * Centralisation de la gestion des √©v√©nements UI avec patterns de d√©l√©gation efficaces
	 *
	 * @module ui/event-delegation
	 * @author Assistant
	 * @version 1.0.0
	 */

	var hasRequiredEventDelegation;

	function requireEventDelegation () {
		if (hasRequiredEventDelegation) return eventDelegation;
		hasRequiredEventDelegation = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._UIEventDelegation = GeoLeaf._UIEventDelegation || {};

		    // ========================================
		    //   CONSTANTES & √âTAT
		    // ========================================

		    /**
		     * Map des listeners actifs pour cleanup
		     * @type {Map<string, {element: HTMLElement, event: string, handler: Function}>}
		     */
		    const _activeListeners = new Map();

		    /**
		     * Compteur pour identifiants uniques des listeners
		     * @type {number}
		     */
		    let _listenerIdCounter = 0;

		    // ========================================
		    //   UTILITAIRES DE D√âL√âGATION
		    // ========================================

		    /**
		     * Attache un event listener avec tracking automatique pour cleanup
		     * @param {HTMLElement} element - √âl√©ment DOM
		     * @param {string} event - Type d'√©v√©nement
		     * @param {Function} handler - Handler de l'√©v√©nement
		     * @param {Object} options - Options pour addEventListener
		     * @returns {string} ID unique du listener pour cleanup
		     */
		    function attachTrackedListener(element, event, handler, options = {}) {
		        if (!element || typeof handler !== 'function') {
		            if (Log) Log.warn("[UI.EventDelegation] attachTrackedListener: √©lement ou handler manquant");
		            return null;
		        }

		        const listenerId = `listener_${++_listenerIdCounter}`;

		        // Wrapper pour tracking automatique des erreurs
		        const wrappedHandler = function(e) {
		            try {
		                return handler.call(this, e);
		            } catch (error) {
		                if (Log) Log.error("[UI.EventDelegation] Erreur dans handler:", error);
		            }
		        };

		        element.addEventListener(event, wrappedHandler, options);

		        _activeListeners.set(listenerId, {
		            element,
		            event,
		            handler: wrappedHandler,
		            originalHandler: handler
		        });

		        return listenerId;
		    }

		    /**
		     * D√©tache un listener track√©e
		     * @param {string} listenerId - ID retourn√© par attachTrackedListener
		     * @returns {boolean} True si succ√®s
		     */
		    function detachTrackedListener(listenerId) {
		        if (!listenerId || !_activeListeners.has(listenerId)) {
		            return false;
		        }

		        const { element, event, handler } = _activeListeners.get(listenerId);
		        element.removeEventListener(event, handler);
		        _activeListeners.delete(listenerId);
		        return true;
		    }

		    /**
		     * Nettoie tous les listeners track√©es
		     * @returns {number} Nombre de listeners nettoy√©es
		     */
		    function cleanupAllListeners() {
		        let cleaned = 0;
		        for (const [listenerId, { element, event, handler }] of _activeListeners) {
		            element.removeEventListener(event, handler);
		            cleaned++;
		        }
		        _activeListeners.clear();
		        if (Log && cleaned > 0) {
		            Log.info(`[UI.EventDelegation] ${cleaned} listeners nettoy√©es`);
		        }
		        return cleaned;
		    }

		    // ========================================
		    //   D√âL√âGATION PAR TYPES UI SP√âCIFIQUES
		    // ========================================

		    /**
		     * G√®re les √©v√©nements des inputs de filtre avec debouncing
		     * @param {HTMLElement} filterContainer - Conteneur des filtres
		     * @param {Function} onFilterChange - Callback appel√© lors des changements
		     * @param {number} debounceMs - D√©lai de debounce (d√©faut: 300ms)
		     * @returns {string[]} IDs des listeners cr√©√©s
		     */
		    function attachFilterInputEvents(filterContainer, onFilterChange, debounceMs = 300) {
		        if (!filterContainer || typeof onFilterChange !== 'function') {
		            if (Log) Log.warn("[UI.EventDelegation] attachFilterInputEvents: param√®tres manquants");
		            return [];
		        }

		        const listenerIds = [];
		        let debounceTimer = null;

		        // Fonction debounce pour les inputs
		        const debouncedHandler = function() {
		            if (debounceTimer) clearTimeout(debounceTimer);
		            debounceTimer = setTimeout(() => {
		                onFilterChange();
		            }, debounceMs);
		        };

		        // D√©l√©gation pour tous les inputs de type text/range
		        const textInputHandler = function(e) {
		            if (e.target.matches('input[type="text"], input[type="range"]')) {
		                debouncedHandler();
		            }
		        };

		        // D√©l√©gation pour les checkboxes (pas de debounce)
		        const checkboxHandler = function(e) {
		            if (e.target.matches('input[type="checkbox"]')) {
		                onFilterChange();
		            }
		        };

		        // D√©l√©gation pour les selects
		        const selectHandler = function(e) {
		            if (e.target.matches('select')) {
		                onFilterChange();
		            }
		        };

		        listenerIds.push(attachTrackedListener(filterContainer, 'input', textInputHandler));
		        listenerIds.push(attachTrackedListener(filterContainer, 'change', checkboxHandler));
		        listenerIds.push(attachTrackedListener(filterContainer, 'change', selectHandler));

		        return listenerIds.filter(id => id !== null);
		    }

		    /**
		     * G√®re les √©v√©nements d'accord√©on avec d√©l√©gation
		     * @param {HTMLElement} container - Conteneur des accord√©ons
		     * @returns {string} ID du listener cr√©√©
		     */
		    function attachAccordionEvents(container) {
		        if (!container) {
		            if (Log) Log.warn("[UI.EventDelegation] attachAccordionEvents: conteneur manquant");
		            return null;
		        }

		        const accordionHandler = function(e) {
		            // Cherche le bouton d'accord√©on dans la hi√©rarchie
		            const accordionButton = e.target.closest('.gl-accordion-toggle, .accordion-arrow');
		            if (!accordionButton) return;

		            e.preventDefault();
		            e.stopPropagation();

		            // Trouve le panel associ√©
		            const panel = accordionButton.closest('.gl-accordion')?.querySelector('.gl-accordion-content');
		            if (!panel) return;

		            // Toggle accord√©on
		            const isExpanded = panel.style.display !== 'none';
		            panel.style.display = isExpanded ? 'none' : 'block';

		            // Met √† jour l'aria-expanded
		            accordionButton.setAttribute('aria-expanded', !isExpanded);

		            // Met √† jour l'ic√¥ne si pr√©sente
		            const icon = accordionButton.querySelector('.accordion-icon, .accordion-arrow');
		            if (icon) {
		                icon.classList.toggle('expanded', !isExpanded);
		            }
		        };

		        return attachTrackedListener(container, 'click', accordionHandler);
		    }

		    /**
		     * G√®re les √©v√©nements des contr√¥les de carte (delegation pour les boutons)
		     * @param {HTMLElement} mapContainer - Conteneur de la carte
		     * @param {Object} handlers - Map des handlers { selectorPattern: handlerFunction }
		     * @returns {string[]} IDs des listeners cr√©√©s
		     */
		    function attachMapControlEvents(mapContainer, handlers) {
		        if (!mapContainer || !handlers || typeof handlers !== 'object') {
		            if (Log) Log.warn("[UI.EventDelegation] attachMapControlEvents: param√®tres manquants");
		            return [];
		        }

		        const listenerIds = [];

		        const controlHandler = function(e) {
		            for (const [selector, handler] of Object.entries(handlers)) {
		                if (e.target.matches(selector) || e.target.closest(selector)) {
		                    e.preventDefault();
		                    e.stopPropagation();

		                    if (typeof handler === 'function') {
		                        handler.call(this, e);
		                    }
		                    break;
		                }
		            }
		        };

		        listenerIds.push(attachTrackedListener(mapContainer, 'click', controlHandler));
		        return listenerIds.filter(id => id !== null);
		    }

		    // ========================================
		    //   API PUBLIQUE
		    // ========================================

		    // Fonctions de base
		    GeoLeaf._UIEventDelegation.attachTrackedListener = attachTrackedListener;
		    GeoLeaf._UIEventDelegation.detachTrackedListener = detachTrackedListener;
		    GeoLeaf._UIEventDelegation.cleanupAllListeners = cleanupAllListeners;

		    // D√©l√©gations sp√©cialis√©es
		    GeoLeaf._UIEventDelegation.attachFilterInputEvents = attachFilterInputEvents;
		    GeoLeaf._UIEventDelegation.attachAccordionEvents = attachAccordionEvents;
		    GeoLeaf._UIEventDelegation.attachMapControlEvents = attachMapControlEvents;

		    // Statistiques et debug
		    /**
		     * Obtient le nombre de listeners actifs enregistr√©s
		     * Utile pour le debugging et le monitoring des fuites m√©moire
		     * @returns {number} Nombre de listeners actifs
		     * @example
		     * const count = GeoLeaf._UIEventDelegation.getActiveListenersCount();
		     * console.log(`${count} listeners actifs`);
		     */
		    GeoLeaf._UIEventDelegation.getActiveListenersCount = function() {
		        return _activeListeners.size;
		    };

		    /**
		     * R√©cup√®re la liste compl√®te des listeners actifs avec leurs m√©tadonn√©es
		     * Retourne une Map avec ID listener comme cl√© et info d√©taill√©es
		     * @returns {Map<string, Object>} Map des listeners actifs (id -> {element, event, handler, timestamp})
		     * @example
		     * const listeners = GeoLeaf._UIEventDelegation.getActiveListeners();
		     * listeners.forEach((info, id) => console.log(`Listener ${id} sur ${info.event}`));
		     */
		    GeoLeaf._UIEventDelegation.getActiveListeners = function() {
		        return Array.from(_activeListeners.keys());
		    };

		    if (Log) {
		        Log.info("[UI.EventDelegation] Module initialis√©");
		    }

		})(window);
		return eventDelegation;
	}

	requireEventDelegation();

	var filterStateManager = {};

	/**
	 * GeoLeaf UI Module - Filter State Manager
	 * Gestion centralis√©e de l'√©tat des filtres avec patterns observateur
	 *
	 * @module ui/filter-state-manager
	 * @author Assistant
	 * @version 1.0.0
	 */

	var hasRequiredFilterStateManager;

	function requireFilterStateManager () {
		if (hasRequiredFilterStateManager) return filterStateManager;
		hasRequiredFilterStateManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._UIFilterStateManager = GeoLeaf._UIFilterStateManager || {};

		    // ========================================
		    //   √âTAT CENTRALIS√â DES FILTRES
		    // ========================================

		    /**
		     * √âtat actuel des filtres
		     * @type {Object}
		     * @private
		     */
		    let _filterState = {
		        // √âtat des filtres par ID
		        values: new Map(),

		        // M√©tadonn√©es des filtres
		        metadata: new Map(),

		        // Profil actuel
		        activeProfile: null,

		        // Callbacks observers
		        observers: new Set()
		    };

		    /**
		     * Timestamps pour debouncing
		     * @type {Map<string, number>}
		     * @private
		     */
		    const _debounceTimers = new Map();

		    // ========================================
		    //   GESTION DE L'√âTAT DES FILTRES
		    // ========================================

		    /**
		     * Initialise l'√©tat des filtres depuis un profil
		     * @param {Object} profile - Configuration du profil
		     * @returns {boolean} Succ√®s de l'initialisation
		     */
		    function initializeFromProfile(profile) {
		        if (!profile || !profile.filters) {
		            if (Log) Log.warn("[UI.FilterStateManager] Profil ou filtres manquants");
		            return false;
		        }

		        // R√©initialise l'√©tat
		        _filterState.values.clear();
		        _filterState.metadata.clear();
		        _filterState.activeProfile = profile;

		        // Configure chaque filtre avec ses valeurs par d√©faut
		        profile.filters.forEach(filter => {
		            if (!filter.id) return;

		            const metadata = {
		                type: filter.type,
		                label: filter.label,
		                required: !!filter.required,
		                min: filter.min,
		                max: filter.max,
		                options: filter.options || [],
		                optionsFrom: filter.optionsFrom
		            };

		            _filterState.metadata.set(filter.id, metadata);

		            // Valeur par d√©faut selon le type
		            let defaultValue = null;
		            switch (filter.type) {
		                case 'select':
		                case 'multiselect':
		                    defaultValue = filter.default || (filter.type === 'multiselect' ? [] : '');
		                    break;
		                case 'range':
		                    defaultValue = filter.default ?? ((filter.min + filter.max) / 2);
		                    break;
		                case 'tree':
		                case 'tree-category':
		                case 'categoryTree':
		                    defaultValue = filter.default || [];
		                    break;
		                default:
		                    defaultValue = filter.default || '';
		            }

		            _filterState.values.set(filter.id, defaultValue);
		        });

		        // Notifie les observateurs
		        _notifyObservers('init', null, _filterState.values);

		        if (Log) {
		            Log.info(`[UI.FilterStateManager] Initialis√© avec ${_filterState.values.size} filtres`);
		        }

		        return true;
		    }

		    /**
		     * Met √† jour la valeur d'un filtre
		     * @param {string} filterId - ID du filtre
		     * @param {*} value - Nouvelle valeur
		     * @param {boolean} skipNotify - √âviter la notification (d√©faut: false)
		     * @returns {boolean} Succ√®s de la mise √† jour
		     */
		    function updateFilterValue(filterId, value, skipNotify = false) {
		        if (!filterId || !_filterState.metadata.has(filterId)) {
		            if (Log) Log.warn(`[UI.FilterStateManager] Filtre inconnu: ${filterId}`);
		            return false;
		        }

		        const metadata = _filterState.metadata.get(filterId);
		        const oldValue = _filterState.values.get(filterId);

		        // Validation selon le type
		        const validatedValue = _validateFilterValue(value, metadata);
		        if (validatedValue === null && value !== null) {
		            if (Log) Log.warn(`[UI.FilterStateManager] Valeur invalide pour ${filterId}:`, value);
		            return false;
		        }

		        // Mise √† jour
		        _filterState.values.set(filterId, validatedValue);

		        // Notification avec debouncing pour les ranges
		        if (!skipNotify) {
		            if (metadata.type === 'range') {
		                _notifyWithDebounce(filterId, 'change', oldValue, validatedValue, 200);
		            } else {
		                _notifyObservers('change', filterId, validatedValue, oldValue);
		            }
		        }

		        return true;
		    }

		    /**
		     * R√©cup√®re la valeur d'un filtre
		     * @param {string} filterId - ID du filtre
		     * @returns {*} Valeur du filtre ou null si inexistant
		     */
		    function getFilterValue(filterId) {
		        return _filterState.values.get(filterId) || null;
		    }

		    /**
		     * R√©cup√®re toutes les valeurs de filtres
		     * @returns {Object} Object avec filterId -> value
		     */
		    function getAllFilterValues() {
		        return Object.fromEntries(_filterState.values);
		    }

		    /**
		     * R√©cup√®re les m√©tadonn√©es d'un filtre
		     * @param {string} filterId - ID du filtre
		     * @returns {Object|null} M√©tadonn√©es ou null
		     */
		    function getFilterMetadata(filterId) {
		        return _filterState.metadata.get(filterId) || null;
		    }

		    /**
		     * Remet √† z√©ro tous les filtres
		     * @param {boolean} skipNotify - √âviter la notification (d√©faut: false)
		     */
		    function resetAllFilters(skipNotify = false) {
		        const oldState = new Map(_filterState.values);

		        _filterState.values.forEach((value, filterId) => {
		            const metadata = _filterState.metadata.get(filterId);
		            if (!metadata) return;

		            // Remise √† z√©ro selon le type
		            let resetValue = null;
		            switch (metadata.type) {
		                case 'multiselect':
		                case 'tree':
		                case 'tree-category':
		                case 'categoryTree':
		                    resetValue = [];
		                    break;
		                case 'range':
		                    resetValue = (metadata.min + metadata.max) / 2;
		                    break;
		                default:
		                    resetValue = '';
		            }

		            _filterState.values.set(filterId, resetValue);
		        });

		        if (!skipNotify) {
		            _notifyObservers('reset', null, _filterState.values, oldState);
		        }
		    }

		    // ========================================
		    //   SYST√àME D'OBSERVATEURS
		    // ========================================

		    /**
		     * Ajoute un observateur pour les changements d'√©tat
		     * @param {Function} callback - Fonction appel√©e lors des changements
		     * @returns {Function} Fonction pour d√©sabonner l'observateur
		     */
		    function addObserver(callback) {
		        if (typeof callback !== 'function') {
		            if (Log) Log.warn("[UI.FilterStateManager] Observateur doit √™tre une fonction");
		            return () => {};
		        }

		        _filterState.observers.add(callback);

		        // Retourne fonction de d√©sabonnement
		        return function unsubscribe() {
		            _filterState.observers.delete(callback);
		        };
		    }

		    /**
		     * Notifie tous les observateurs
		     * @param {string} type - Type de changement ('init', 'change', 'reset')
		     * @param {string|null} filterId - ID du filtre chang√© (null pour global)
		     * @param {*} newValue - Nouvelle valeur
		     * @param {*} oldValue - Ancienne valeur
		     * @private
		     */
		    function _notifyObservers(type, filterId, newValue, oldValue) {
		        const event = {
		            type,
		            filterId,
		            newValue,
		            oldValue,
		            timestamp: Date.now(),
		            allValues: Object.fromEntries(_filterState.values)
		        };

		        _filterState.observers.forEach(callback => {
		            try {
		                callback(event);
		            } catch (error) {
		                if (Log) Log.error("[UI.FilterStateManager] Erreur dans observateur:", error);
		            }
		        });
		    }

		    /**
		     * Notification avec debouncing
		     * @param {string} filterId - ID du filtre
		     * @param {string} type - Type d'√©v√©nement
		     * @param {*} oldValue - Ancienne valeur
		     * @param {*} newValue - Nouvelle valeur
		     * @param {number} delay - D√©lai de debounce
		     * @private
		     */
		    function _notifyWithDebounce(filterId, type, oldValue, newValue, delay) {
		        // Clear existing timer
		        if (_debounceTimers.has(filterId)) {
		            clearTimeout(_debounceTimers.get(filterId));
		        }

		        // Set new timer
		        const timer = setTimeout(() => {
		            _notifyObservers(type, filterId, newValue, oldValue);
		            _debounceTimers.delete(filterId);
		        }, delay);

		        _debounceTimers.set(filterId, timer);
		    }

		    // ========================================
		    //   VALIDATION DE VALEURS
		    // ========================================

		    /**
		     * Valide une valeur selon les m√©tadonn√©es du filtre
		     * @param {*} value - Valeur √† valider
		     * @param {Object} metadata - M√©tadonn√©es du filtre
		     * @returns {*} Valeur valid√©e ou null si invalide
		     * @private
		     */
		    function _validateFilterValue(value, metadata) {
		        if (!metadata) return null;

		        switch (metadata.type) {
		            case 'select':
		                return typeof value === 'string' ? value : '';

		            case 'multiselect':
		                return Array.isArray(value) ? value : [];

		            case 'range':
		                const num = parseFloat(value);
		                if (isNaN(num)) return metadata.min || 0;
		                if (metadata.min !== undefined && num < metadata.min) return metadata.min;
		                if (metadata.max !== undefined && num > metadata.max) return metadata.max;
		                return num;

		            case 'tree':
		            case 'tree-category':
		            case 'categoryTree':
		                return Array.isArray(value) ? value : [];

		            default:
		                return value;
		        }
		    }

		    // ========================================
		    //   UTILITAIRES DE REQU√äTES
		    // ========================================

		    /**
		     * V√©rifie si des filtres sont actuellement actifs
		     * @returns {boolean} True si au moins un filtre est actif
		     */
		    function hasActiveFilters() {
		        for (const [filterId, value] of _filterState.values) {
		            const metadata = _filterState.metadata.get(filterId);
		            if (!metadata) continue;

		            // V√©rifie selon le type si la valeur est "active"
		            switch (metadata.type) {
		                case 'multiselect':
		                case 'tree':
		                case 'tree-category':
		                case 'categoryTree':
		                    if (Array.isArray(value) && value.length > 0) return true;
		                    break;
		                case 'select':
		                    if (value && value !== '') return true;
		                    break;
		                case 'range':
		                    // Consid√®re actif si diff√©rent de la valeur par d√©faut
		                    const defaultVal = (metadata.min + metadata.max) / 2;
		                    if (Math.abs(value - defaultVal) > 0.01) return true;
		                    break;
		            }
		        }
		        return false;
		    }

		    /**
		     * R√©cup√®re un r√©sum√© des filtres actifs
		     * @returns {Array} Liste des filtres actifs avec leurs valeurs
		     */
		    function getActiveFiltersSummary() {
		        const summary = [];

		        for (const [filterId, value] of _filterState.values) {
		            const metadata = _filterState.metadata.get(filterId);
		            if (!metadata) continue;

		            let isActive = false;
		            let displayValue = '';

		            switch (metadata.type) {
		                case 'multiselect':
		                case 'tree':
		                case 'tree-category':
		                case 'categoryTree':
		                    if (Array.isArray(value) && value.length > 0) {
		                        isActive = true;
		                        displayValue = `${value.length} s√©lectionn√©(s)`;
		                    }
		                    break;
		                case 'select':
		                    if (value && value !== '') {
		                        isActive = true;
		                        displayValue = value;
		                    }
		                    break;
		                case 'range':
		                    const defaultVal = (metadata.min + metadata.max) / 2;
		                    if (Math.abs(value - defaultVal) > 0.01) {
		                        isActive = true;
		                        displayValue = value.toString().replace('.', ',');
		                    }
		                    break;
		            }

		            if (isActive) {
		                summary.push({
		                    id: filterId,
		                    label: metadata.label || filterId,
		                    value: displayValue,
		                    type: metadata.type
		                });
		            }
		        }

		        return summary;
		    }

		    // ========================================
		    //   API PUBLIQUE
		    // ========================================

		    // Gestion d'√©tat principal
		    GeoLeaf._UIFilterStateManager.initializeFromProfile = initializeFromProfile;
		    GeoLeaf._UIFilterStateManager.updateFilterValue = updateFilterValue;
		    GeoLeaf._UIFilterStateManager.getFilterValue = getFilterValue;
		    GeoLeaf._UIFilterStateManager.getAllFilterValues = getAllFilterValues;
		    GeoLeaf._UIFilterStateManager.getFilterMetadata = getFilterMetadata;
		    GeoLeaf._UIFilterStateManager.resetAllFilters = resetAllFilters;

		    // Syst√®me d'observateurs
		    GeoLeaf._UIFilterStateManager.addObserver = addObserver;

		    // Utilitaires de requ√™tes
		    GeoLeaf._UIFilterStateManager.hasActiveFilters = hasActiveFilters;
		    GeoLeaf._UIFilterStateManager.getActiveFiltersSummary = getActiveFiltersSummary;

		    // Propri√©t√©s en lecture seule
		    Object.defineProperty(GeoLeaf._UIFilterStateManager, 'activeProfile', {
		        get: () => _filterState.activeProfile,
		        enumerable: true
		    });

		    Object.defineProperty(GeoLeaf._UIFilterStateManager, 'filterCount', {
		        get: () => _filterState.values.size,
		        enumerable: true
		    });

		    if (Log) {
		        Log.info("[UI.FilterStateManager] Module initialis√©");
		    }

		})(window);
		return filterStateManager;
	}

	requireFilterStateManager();

	var scaleControl = {};

	/**
	 * GeoLeaf Scale Control
	 * G√®re l'affichage de l'√©chelle graphique, num√©rique et du niveau de zoom
	 *
	 * @module map/scale-control
	 */

	var hasRequiredScaleControl;

	function requireScaleControl () {
		if (hasRequiredScaleControl) return scaleControl;
		hasRequiredScaleControl = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Contr√¥le d'√©chelle personnalis√©
		     */
		    const ScaleControl = {
		        _map: null,
		        _config: null,
		        _container: null,
		        _scaleLineMetric: null,
		        _numericElement: null,
		        _zoomElement: null,
		        _inputElement: null,
		        _scalePrefix: null,
		        _mainWrapper: null,
		        _eventHandlers: {},

		        /**
		         * Initialise le contr√¥le d'√©chelle
		         * @param {L.Map} map - Instance de la carte Leaflet
		         * @param {Object} config - Configuration depuis scaleConfig
		         */
		        init(map, config) {
		            if (!map) {
		                Log.error("[GeoLeaf.ScaleControl] Carte non fournie");
		                return;
		            }

		            this._map = map;
		            this._config = config || {};

		            // Cr√©er un conteneur unique pour tout
		            this._createMainContainer();

		            Log.info("[GeoLeaf.ScaleControl] Contr√¥le d'√©chelle initialis√©");
		        },

		        /**
		         * Cr√©e le conteneur principal avec √©chelle graphique et bloc personnalis√©
		         * @private
		         */
		        _createMainContainer() {
		            const position = this._config.position || 'bottomleft';

		            // Conteneur principal - disposition horizontale
		            this._mainWrapper = L.DomUtil.create('div', 'gl-scale-main-wrapper');

		            // 1. √âchelle graphique
		            if (this._config.scaleGraphic !== false) {
		                const graphicWrapper = L.DomUtil.create('div', 'gl-scale-graphic-wrapper', this._mainWrapper);
		                this._addGraphicScaleToContainer(graphicWrapper);
		            }

		            // 2. Bloc personnalis√© (√©chelle num√©rique + zoom) sur la m√™me ligne
		            if (this._config.scaleNumeric || this._config.scaleNivel) {
		                this._createCustomScaleBlock(this._mainWrapper);
		            }

		            // Ajouter le conteneur principal √† la carte
		            const CustomControl = L.Control.extend({
		                options: {
		                    position: position
		                },
		                onAdd: () => {
		                    return this._mainWrapper;
		                }
		            });

		            new CustomControl().addTo(this._map);
		        },

		        /**
		         * Ajoute l'√©chelle graphique Leaflet dans un conteneur
		         * @param {HTMLElement} container - Conteneur cible
		         * @private
		         */
		        _addGraphicScaleToContainer(container) {
		            // Cr√©er l'√©chelle graphique manuellement (pas via L.control.scale)
		            const scaleDiv = L.DomUtil.create('div', 'leaflet-control-scale leaflet-control', container);

		            const scaleLineMetric = L.DomUtil.create('div', 'leaflet-control-scale-line', scaleDiv);
		            this._scaleLineMetric = scaleLineMetric;

		            // Fonction de mise √† jour de l'√©chelle graphique
		            const updateScale = () => {
		                const y = this._map.getSize().y / 2;
		                const maxMeters = this._map.distance(
		                    this._map.containerPointToLatLng([0, y]),
		                    this._map.containerPointToLatLng([150, y])
		                );
		                this._updateScaleLine(this._scaleLineMetric, maxMeters);
		            };

		            this._eventHandlers.graphicScaleUpdate = updateScale;
		            this._map.on('zoomend moveend', updateScale);
		            updateScale();

		            Log.info("[GeoLeaf.ScaleControl] √âchelle graphique ajout√©e");
		        },

		        /**
		         * Met √† jour la ligne d'√©chelle graphique
		         * @param {HTMLElement} scaleLine - √âl√©ment de la ligne d'√©chelle
		         * @param {number} maxMeters - Distance maximale en m√®tres
		         * @private
		         */
		        _updateScaleLine(scaleLine, maxMeters) {
		            const maxKm = maxMeters / 1000;
		            let scale, ratio;

		            if (maxKm > 1) {
		                const maxNiceKm = this._getRoundNum(maxKm);
		                ratio = maxNiceKm / maxKm;
		                scale = maxNiceKm + ' km';
		            } else {
		                const maxNiceM = this._getRoundNum(maxMeters);
		                ratio = maxNiceM / maxMeters;
		                scale = maxNiceM + ' m';
		            }

		            scaleLine.style.width = Math.round(150 * ratio) + 'px';
		            scaleLine.textContent = scale;
		        },

		        /**
		         * Arrondit un nombre √† une valeur "propre" (1, 2, 5, 10, 20, 50, etc.)
		         * @param {number} num - Nombre √† arrondir
		         * @returns {number} Nombre arrondi
		         * @private
		         */
		        _getRoundNum(num) {
		            const pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
		            let d = num / pow10;

		            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		            return pow10 * d;
		        },

		        /**
		         * Cr√©e le bloc personnalis√© (√©chelle num√©rique + niveau de zoom)
		         * @param {HTMLElement} parentContainer - Conteneur parent
		         * @private
		         */
		        _createCustomScaleBlock(parentContainer) {
		            // Cr√©er le conteneur - disposition horizontale
		            this._container = L.DomUtil.create('div', 'gl-scale-control', parentContainer);

		            // √âchelle num√©rique
		            if (this._config.scaleNumeric) {
		                if (this._config.scaleNumericEditable) {
		                    this._createEditableScale();
		                } else {
		                    this._createReadOnlyScale();
		                }
		            }

		            // Niveau de zoom
		            if (this._config.scaleNivel) {
		                this._createZoomLevel();
		            }

		            // √âv√©nements de mise √† jour
		            const updateHandler = () => this._updateScale();
		            this._eventHandlers.numericScaleUpdate = updateHandler;
		            this._map.on('zoomend moveend', updateHandler);
		            this._updateScale(); // Mise √† jour initiale

		            Log.info("[GeoLeaf.ScaleControl] Bloc personnalis√© ajout√©");
		        },

		        /**
		         * Cr√©e l'√©chelle num√©rique en lecture seule
		         * @private
		         */
		        _createReadOnlyScale() {
		            this._numericElement = L.DomUtil.create('div', 'gl-scale-numeric', this._container);
		        },

		        /**
		         * Cr√©e l'√©chelle num√©rique √©ditable avec input
		         * @private
		         */
		        _createEditableScale() {
		            // Cr√©er un conteneur pour l'√©chelle √©ditable
		            const wrapper = L.DomUtil.create('div', 'gl-scale-numeric-editable', this._container);

		            // Cr√©er le pr√©fixe "1:" (toujours visible)
		            this._scalePrefix = L.DomUtil.create('span', 'gl-scale-prefix', wrapper);
		            this._scalePrefix.textContent = '1:';

		            // Cr√©er le span affich√© initialement (soulign√© et cliquable) - contient uniquement le d√©nominateur
		            this._numericElement = L.DomUtil.create('span', 'gl-scale-numeric-clickable', wrapper);
		            this._numericElement.textContent = '0';

		            // Cr√©er l'input (cach√© initialement) - contient uniquement le d√©nominateur
		            this._inputElement = L.DomUtil.create('input', 'gl-scale-numeric-input', wrapper);
		            this._inputElement.type = 'text';
		            this._inputElement.placeholder = '250000';
		            this._inputElement.style.display = 'none';

		            // Emp√™cher les interactions de la carte lors de l'√©dition
		            L.DomEvent.disableClickPropagation(wrapper);
		            L.DomEvent.disableScrollPropagation(wrapper);

		            // Clic sur le span : passer en mode √©dition
		            this._numericElement.addEventListener('click', () => {
		                this._switchToEditMode();
		            });

		            // Validation avec Enter
		            this._inputElement.addEventListener('keypress', (e) => {
		                if (e.key === 'Enter') {
		                    this._onScaleInputChange();
		                    this._switchToDisplayMode();
		                }
		            });

		            // Validation en cliquant √† l'ext√©rieur (blur)
		            this._inputElement.addEventListener('blur', () => {
		                this._onScaleInputChange();
		                this._switchToDisplayMode();
		            });
		        },

		        /**
		         * Cr√©e l'affichage du niveau de zoom
		         * @private
		         */
		        _createZoomLevel() {
		            this._zoomElement = L.DomUtil.create('div', 'gl-scale-zoom', this._container);
		        },

		        /**
		         * Bascule en mode √©dition (affiche l'input)
		         * @private
		         */
		        _switchToEditMode() {
		            if (!this._numericElement || !this._inputElement) return;

		            // Copier la valeur actuelle dans l'input
		            this._inputElement.value = this._numericElement.textContent;

		            // Cacher le span, afficher l'input
		            this._numericElement.style.display = 'none';
		            this._inputElement.style.display = 'inline-block';

		            // Focus et s√©lection du texte
		            this._inputElement.focus();
		            this._inputElement.select();
		        },

		        /**
		         * Bascule en mode affichage (affiche le span)
		         * @private
		         */
		        _switchToDisplayMode() {
		            if (!this._numericElement || !this._inputElement) return;

		            // Cacher l'input, afficher le span
		            this._inputElement.style.display = 'none';
		            this._numericElement.style.display = 'inline';
		        },

		        /**
		         * Met √† jour l'affichage de l'√©chelle et du zoom
		         * @private
		         */
		        _updateScale() {
		            const zoom = this._map.getZoom();
		            const scale = this._calculateScale(zoom);

		            // Mettre √† jour l'√©chelle num√©rique
		            if (this._numericElement) {
		                if (this._config.scaleNumericEditable) {
		                    // Mettre √† jour uniquement le d√©nominateur (sans '1:')
		                    if (this._inputElement.style.display === 'none') {
		                        this._numericElement.textContent = this._formatNumber(scale);
		                    }
		                } else {
		                    // Mode non √©ditable : afficher "1:" + d√©nominateur
		                    this._numericElement.textContent = `1:${this._formatNumber(scale)}`;
		                }
		            }

		            // Mettre √† jour le niveau de zoom
		            if (this._zoomElement) {
		                this._zoomElement.textContent = `Zoom: ${Number(zoom).toFixed(2)}`;
		            }
		        },

		        /**
		         * Calcule l'√©chelle approximative en fonction du niveau de zoom
		         * @param {number} zoom - Niveau de zoom Leaflet
		         * @param {number} [lat] - Latitude optionnelle (utilise le centre de la carte si non fournie)
		         * @returns {number} √âchelle (ex: 250000 pour 1:250000)
		         * @private
		         */
		        _calculateScale(zoom, lat) {
		            // Utiliser la latitude fournie ou celle du centre de la carte
		            const latitude = lat !== undefined ? lat : this._map.getCenter().lat;
		            // Formule approximative bas√©e sur la taille des tuiles Web Mercator
		            const metersPerPixel = 156543.03392 * Math.cos(latitude * Math.PI / 180) / Math.pow(2, zoom);
		            const scale = metersPerPixel * 96 / 0.0254; // 96 DPI
		            return Math.round(scale);
		        },

		        /**
		         * Formate un nombre avec des espaces comme s√©parateurs de milliers
		         * @param {number} num - Nombre √† formater
		         * @returns {string} Nombre format√©
		         * @private
		         */
		        _formatNumber(num) {
		            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
		        },

		        /**
		         * G√®re le changement manuel de l'√©chelle
		         * @private
		         */
		        _onScaleInputChange() {
		            if (!this._inputElement) return;

		            const input = this._inputElement.value.trim();
		            // Parser uniquement le d√©nominateur (nombre avec espaces optionnels)
		            const cleanedInput = input.replace(/\s/g, '');
		            const targetScale = parseInt(cleanedInput, 10);

		            if (!isNaN(targetScale) && targetScale > 0) {
		                const targetZoom = this._calculateZoomFromScale(targetScale);
		                // Utiliser setView avec zoomSnap: 0 pour permettre les zooms fractionnaires
		                this._map.setView(this._map.getCenter(), targetZoom, {
		                    animate: true,
		                    zoomSnap: 0
		                });
		                Log.info(`[GeoLeaf.ScaleControl] Zoom ajust√© √† ${targetZoom} pour √©chelle 1:${targetScale}`);
		            } else {
		                Log.warn("[GeoLeaf.ScaleControl] Format d'√©chelle invalide:", input);
		                this._updateScale(); // R√©initialiser la valeur
		            }
		        },

		        /**
		         * Calcule le niveau de zoom pour atteindre une √©chelle donn√©e
		         * @param {number} targetScale - √âchelle cible (ex: 250000)
		         * @returns {number} Niveau de zoom (peut √™tre d√©cimal pour plus de pr√©cision)
		         * @private
		         */
		        _calculateZoomFromScale(targetScale) {
		            const lat = this._map.getCenter().lat;
		            const metersPerPixel = targetScale * 0.0254 / 96;
		            let zoom = Math.log2(156543.03392 * Math.cos(lat * Math.PI / 180) / metersPerPixel);

		            // Affiner le zoom par it√©ration pour obtenir l'√©chelle exacte
		            // Utiliser une m√©thode de convergence pr√©cise
		            for (let i = 0; i < 20; i++) {
		                const currentScale = this._calculateScale(zoom, lat); // Passer lat pour √©viter recalcul
		                const diff = targetScale - currentScale;

		                // Si l'erreur est inf√©rieure √† 1 (pratiquement identique), on arr√™te
		                if (Math.abs(diff) < 1) {
		                    break;
		                }

		                // Ajuster le zoom proportionnellement √† l'erreur
		                // Plus l'√©chelle est grande, plus on doit d√©zoomer (zoom plus petit)
		                const adjustment = Math.log2(targetScale / currentScale);
		                zoom -= adjustment * 0.95; // Facteur d'amortissement pour √©viter les oscillations
		            }

		            // Arrondir √† 4 d√©cimales pour une pr√©cision maximale
		            const preciseZoom = Math.round(zoom * 10000) / 10000;
		            return Math.max(0, Math.min(22, preciseZoom));
		        },

		        /**
		         * D√©truit le contr√¥le et nettoie les ressources
		         */
		        destroy() {
		            // Retirer les event listeners de la carte
		            if (this._map && this._eventHandlers) {
		                if (this._eventHandlers.graphicScaleUpdate) {
		                    this._map.off('zoomend moveend', this._eventHandlers.graphicScaleUpdate);
		                }
		                if (this._eventHandlers.numericScaleUpdate) {
		                    this._map.off('zoomend moveend', this._eventHandlers.numericScaleUpdate);
		                }
		            }

		            // Supprimer le conteneur principal du DOM
		            if (this._mainWrapper && this._mainWrapper.parentNode) {
		                this._mainWrapper.parentNode.removeChild(this._mainWrapper);
		            }

		            // Nettoyer toutes les r√©f√©rences
		            this._map = null;
		            this._config = null;
		            this._container = null;
		            this._scaleLineMetric = null;
		            this._numericElement = null;
		            this._zoomElement = null;
		            this._inputElement = null;
		            this._scalePrefix = null;
		            this._mainWrapper = null;
		            this._eventHandlers = {};

		            Log.info("[GeoLeaf.ScaleControl] Contr√¥le d√©truit et ressources nettoy√©es");
		        }
		    };

		    // Exposer le module
		    GeoLeaf.ScaleControl = ScaleControl;

		    /**
		     * Initialise automatiquement le contr√¥le d'√©chelle si la configuration est pr√©sente
		     */
		    GeoLeaf.initScaleControl = function(map) {
		        if (!map) {
		            Log.warn("[GeoLeaf.ScaleControl] Impossible d'initialiser : carte non fournie");
		            return;
		        }

		        const config = GeoLeaf.Config && GeoLeaf.Config.get
		            ? GeoLeaf.Config.get('scaleConfig')
		            : null;

		        if (config && (config.scaleGraphic || config.scaleNumeric || config.scaleNivel)) {
		            ScaleControl.init(map, config);
		        }
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return scaleControl;
	}

	requireScaleControl();

	var filterControlBuilder = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredFilterControlBuilder;

	function requireFilterControlBuilder () {
		if (hasRequiredFilterControlBuilder) return filterControlBuilder;
		hasRequiredFilterControlBuilder = 1;
		/**
		 * GeoLeaf UI - Filter Control Builder
		 * Construit les contr√¥les de filtres individuels
		 *
		 * @module ui/filter-control-builder
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances
		    const Log = GeoLeaf.Log || console;
		    const $create = GeoLeaf.Utils?.createElement || function(tag, props) {
		        const el = document.createElement(tag);
		        if (props) {
		            if (props.className) el.className = props.className;
		            if (props.textContent) el.textContent = props.textContent;
		            if (props.id) el.id = props.id;
		            if (props.name) el.name = props.name;
		            if (props.type) el.type = props.type;
		            if (props.placeholder) el.placeholder = props.placeholder;
		            if (props.value !== undefined) el.value = props.value;
		            if (props.checked !== undefined) el.checked = props.checked;
		            if (props.multiple !== undefined) el.multiple = props.multiple;
		            if (props.style) Object.assign(el.style, props.style);
		            if (props.attributes) {
		                for (const [key, value] of Object.entries(props.attributes)) {
		                    el.setAttribute(key, value);
		                }
		            }
		            if (props.min !== undefined) el.min = props.min;
		            if (props.max !== undefined) el.max = props.max;
		            if (props.step !== undefined) el.step = props.step;
		        }
		        return el;
		    };

		    /**
		     * Construit un contr√¥le de filtre individuel
		     * @param {Object} filterDef - D√©finition du filtre
		     * @param {Object} profile - Configuration du profil
		     * @param {boolean} skipLabel - Sauter la cr√©ation du label (d√©faut: false)
		     * @returns {HTMLElement|null}
		     */
		    GeoLeaf.UI._buildFilterControl = function(filterDef, profile, skipLabel) {
		        if (!filterDef || !filterDef.id || !filterDef.type) return null;

		        const wrapper = $create("div", {
		            className: "gl-filter-panel__group",
		            attributes: { "data-gl-filter-id": filterDef.id }
		        });

		        let labelEl = null;
		        // Ne pas cr√©er de label si skipLabel est true (pour les accord√©ons qui ont leur propre titre)
		        if (filterDef.label && !skipLabel) {
		            labelEl = $create("label", {
		                className: "gl-filter-panel__label",
		                textContent: filterDef.label
		            });
		            wrapper.appendChild(labelEl);
		        }

		        let control = null;

		        // 1) SELECT / MULTISELECT classiques
		        if (filterDef.type === "select" || filterDef.type === "multiselect") {
		            const selectEl = $create("select", {
		                className: "gl-filter-panel__control gl-filter-panel__control--select",
		                name: filterDef.id,
		                id: "gl-filter-" + filterDef.id
		            });

		            if (labelEl) {
		                labelEl.setAttribute("for", selectEl.id);
		            }

		            if (filterDef.type === "multiselect") {
		                selectEl.multiple = true;
		            }

		            if (filterDef.optionsFrom) {
		                GeoLeaf.UI._populateSelectOptionsFromTaxonomy?.(
		                    selectEl,
		                    profile,
		                    filterDef.optionsFrom
		                );
		            }

		            control = selectEl;
		        }

		        // 2) SLIDER (range)
		        else if (filterDef.type === "range") {
		            const container = $create("div", { className: "gl-filter-panel__range-wrapper" });

		            const input = $create("input", {
		                type: "range",
		                className: "gl-filter-panel__control gl-filter-panel__control--range",
		                id: "gl-filter-" + filterDef.id,
		                name: filterDef.id
		            });

		            if (labelEl) {
		                labelEl.setAttribute("for", input.id);
		            }

		            if (typeof filterDef.min === "number") input.min = String(filterDef.min);
		            if (typeof filterDef.max === "number") input.max = String(filterDef.max);
		            if (typeof filterDef.step === "number") input.step = String(filterDef.step);

		            const valueLabel = $create("span", { className: "gl-filter-panel__range-value" });

		            let initialValue;
		            if (typeof filterDef.default === "number") {
		                initialValue = filterDef.default;
		            } else if (input.min && input.max) {
		                const min = parseFloat(input.min);
		                const max = parseFloat(input.max);
		                initialValue = (min + max) / 2;
		            } else {
		                initialValue = input.min ? parseFloat(input.min) : 0;
		            }

		            if (!isNaN(initialValue)) {
		                input.value = String(initialValue);
		                valueLabel.textContent = initialValue.toString().replace(".", ",");
		            }

		            input.addEventListener("input", function() {
		                const val = parseFloat(input.value);
		                if (!isNaN(val)) {
		                    valueLabel.textContent = val.toString().replace(".", ",");
		                }
		            });

		            container.appendChild(input);
		            container.appendChild(valueLabel);
		            control = container;
		        }

		        // 3) TREE-VIEW cat√©gories / sous-cat√©gories
		        else if (filterDef.type === "tree" || filterDef.type === "tree-category" || filterDef.type === "categoryTree") {
		            // LAZY LOADING: Retourner un container vide avec marqueur
		            const treeContainer = $create("div", {
		                className: "gl-filter-panel__tree gl-filter-panel__tree--lazy",
		                attributes: {
		                    "data-lazy-type": "categories",
		                    "data-filter-id": filterDef.id
		                }
		            });

		            control = treeContainer;
		        }

		        // 4) CHECKBOX GROUP
		        else if (filterDef.type === "checkbox-group") {
		            const groupContainer = $create("div", { className: "gl-filter-panel__checkbox-group" });

		            if (Array.isArray(filterDef.options)) {
		                filterDef.options.forEach(function(opt) {
		                    const label = $create("label", { className: "gl-filter-panel__checkbox-label" });

		                    const checkbox = $create("input", {
		                        type: "checkbox",
		                        className: "gl-filter-panel__checkbox",
		                        name: filterDef.id,
		                        value: opt.id,
		                        checked: !!opt.checked,
		                        attributes: { "data-filter-option-id": opt.id }
		                    });

		                    const text = $create("span", {
		                        className: "gl-filter-panel__checkbox-text",
		                        textContent: opt.label || opt.id
		                    });

		                    label.appendChild(checkbox);
		                    label.appendChild(text);
		                    groupContainer.appendChild(label);
		                });
		            }
		            control = groupContainer;
		        }

		        // 5) SEARCH
		        else if (filterDef.type === "search") {
		            const searchInput = $create("input", {
		                type: "text",
		                className: "gl-filter-panel__control gl-filter-panel__control--search",
		                name: filterDef.id,
		                placeholder: filterDef.placeholder || "Filtrer..."
		            });

		            if (Array.isArray(filterDef.searchFields)) {
		                searchInput.setAttribute("data-search-fields", filterDef.searchFields.join(","));
		            }

		            control = searchInput;
		        }

		        // 6) PROXIMITY
		        else if (filterDef.type === "proximity") {
		            const proximityContainer = $create("div", { className: "gl-filter-panel__proximity" });

		            if (filterDef.label) {
		                const title = $create("h3", {
		                    className: "gl-filter-panel__proximity-title",
		                    textContent: filterDef.label
		                });
		                proximityContainer.appendChild(title);
		            }

		            const button = $create("button", {
		                type: "button",
		                className: "gl-btn gl-btn--secondary gl-filter-panel__proximity-btn",
		                attributes: { "data-filter-proximity-btn": "true" },
		                textContent: filterDef.buttonLabel || "Activer"
		            });
		            proximityContainer.appendChild(button);

		            const rangeWrapper = $create("div", {
		                className: "gl-filter-panel__proximity-range",
		                style: { display: "none" }
		            });

		            const rangeLabel = $create("label", {
		                className: "gl-filter-panel__label",
		                textContent: "Rayon (km)",
		                attributes: { "for": "gl-filter-proximity-radius" }
		            });
		            rangeWrapper.appendChild(rangeLabel);

		            const rangeContainer = $create("div", { className: "gl-filter-panel__range-wrapper" });

		            let minRadius = 1;
		            let maxRadius = 50;
		            let stepRadius = 1;
		            let defaultRadius = 10;
		            try {
		                const activeProfile = GeoLeaf.Config?.getActiveProfile?.();
		                if (activeProfile) {
		                    const searchConfig = (activeProfile.panels && activeProfile.panels.search) || activeProfile.search;
		                    if (searchConfig) {
		                        if (typeof searchConfig.radiusMin === "number" && searchConfig.radiusMin > 0) {
		                            minRadius = searchConfig.radiusMin;
		                        }
		                        if (typeof searchConfig.radiusMax === "number" && searchConfig.radiusMax > 0) {
		                            maxRadius = searchConfig.radiusMax;
		                        }
		                        if (typeof searchConfig.radiusStep === "number" && searchConfig.radiusStep > 0) {
		                            stepRadius = searchConfig.radiusStep;
		                        }
		                        if (typeof searchConfig.radiusDefault === "number" && searchConfig.radiusDefault > 0) {
		                            defaultRadius = searchConfig.radiusDefault;
		                        }
		                        defaultRadius = Math.max(minRadius, Math.min(defaultRadius, maxRadius));
		                    }
		                }
		            } catch (err) {
		                Log?.warn?.("[GeoLeaf.UI] Erreur lecture radius config:", err);
		            }

		            const rangeInput = $create("input", {
		                type: "range",
		                className: "gl-filter-panel__control gl-filter-panel__control--range",
		                id: "gl-filter-proximity-radius",
		                name: filterDef.id + "_radius",
		                min: String(minRadius),
		                max: String(maxRadius),
		                step: String(stepRadius),
		                value: String(defaultRadius),
		                attributes: { "data-filter-proximity-radius": "true" }
		            });

		            const rangeValue = $create("span", {
		                className: "gl-filter-panel__range-value",
		                textContent: String(defaultRadius)
		            });

		            rangeInput.addEventListener("input", function() {
		                rangeValue.textContent = rangeInput.value;
		            });

		            rangeContainer.appendChild(rangeInput);
		            rangeContainer.appendChild(rangeValue);
		            rangeWrapper.appendChild(rangeContainer);

		            const instruction = $create("p", {
		                className: "gl-filter-panel__proximity-instruction",
		                textContent: filterDef.instructionText || "Cliquez sur la carte",
		                style: { display: "none" }
		            });
		            rangeWrapper.appendChild(instruction);

		            proximityContainer.appendChild(rangeWrapper);
		            control = proximityContainer;
		        }

		        // 7) TAGS
		        else if (filterDef.type === "multiselect-tags" || filterDef.id === "tags") {
		            const tagsContainer = $create("div", {
		                className: "gl-filter-panel__tags-container",
		                attributes: {
		                    "data-lazy-type": "tags",
		                    "data-filter-id": filterDef.id
		                }
		            });
		            control = tagsContainer;
		        }

		        // Aucun type reconnu
		        if (!control) {
		            return null;
		        }

		        if (labelEl && control instanceof HTMLElement && !control.id) {
		            const controlId = "gl-filter-" + filterDef.id;
		            control.id = controlId;
		            labelEl.setAttribute("for", controlId);
		        }

		        wrapper.appendChild(control);
		        return wrapper;
		    };

		})(window);

		/**
		 * Fonctions globales pour le chargement lazy des filtres
		 * Utilis√©es par le lazy-loader pour construire le contenu √† la demande
		 */

		/**
		 * Construit le contenu HTML de l'arbre de cat√©gories
		 * @param {Object} scanResult - R√©sultat du scan ({usedIds: Set, visibleLayerIds: Array})
		 * @returns {string} HTML string
		 */
		window._buildCategoryTreeContent = function(scanResult) {
		    // R√©cup√©rer le profil actif via l'API Config (enrichedProfile contient taxonomy)
		    const profile = (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === "function")
		        ? GeoLeaf.Config.getActiveProfile()
		        : null;
		    if (!profile || !profile.taxonomy || !profile.taxonomy.categories) {
		        return '<div class="gl-empty-state">Aucune cat√©gorie disponible</div>';
		    }

		    const categories = profile.taxonomy.categories;
		    const usedCategoryIds = scanResult.usedIds;

		    // S√©curit√© : √©chapper les valeurs dynamiques inject√©es dans le HTML
		    const esc = (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function')
		        ? function(s) { return GeoLeaf.Security.escapeHtml(s); }
		        : function(s) { return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); };

		    // Comparaison insensible √† la casse : normaliser les IDs scann√©s
		    const usedLower = new Set();
		    usedCategoryIds.forEach(function(id) { usedLower.add(id.toLowerCase()); });

		    // Filtrer les cat√©gories pour afficher celles utilis√©es (comparaison case-insensitive)
		    const catIds = Object.keys(categories).filter(catId => usedLower.has(catId.toLowerCase()));

		    if (catIds.length === 0) {
		        return '<div class="gl-empty-state">ND - Non disponible</div>';
		    }

		    let html = '<ul class="gl-filter-tree gl-filter-tree--root">';

		    catIds.forEach(function(catId) {
		        const cat = categories[catId] || {};

		        // Filtrer aussi les sous-cat√©gories (comparaison case-insensitive)
		        const subs = cat.subcategories || {};
		        const subKeys = Object.keys(subs).filter(subId => usedLower.has(subId.toLowerCase()));
		        const hasSubcategories = subKeys.length > 0;

		        html += '<li class="gl-filter-tree__item gl-filter-tree__item--category">';
		        html += '<div class="gl-filter-tree__row">';

		        if (hasSubcategories) {
		            html += '<span class="gl-filter-tree__arrow" data-category-id="' + esc(catId) + '">‚ñ∂</span>';
		        } else {
		            html += '<span class="gl-filter-tree__spacer"></span>';
		        }

		        html += '<label class="gl-filter-tree__label gl-filter-tree__label--category">';
		        html += '<input type="checkbox" class="gl-filter-tree__checkbox gl-filter-tree__checkbox--category" ';
		        html += 'name="categories_category" value="' + esc(catId) + '" ';
		        html += 'data-gl-filter-category-id="' + esc(catId) + '">';
		        html += '<span class="gl-filter-tree__text">' + esc(cat.label || catId) + '</span>';
		        html += '</label>';
		        html += '</div>';

		        if (hasSubcategories) {
		            html += '<ul class="gl-filter-tree gl-filter-tree--subcategories">';

		            subKeys.forEach(function(subId) {
		                const sub = subs[subId] || {};
		                html += '<li class="gl-filter-tree__item gl-filter-tree__item--subcategory">';
		                html += '<label class="gl-filter-tree__label gl-filter-tree__label--subcategory">';
		                html += '<input type="checkbox" class="gl-filter-tree__checkbox gl-filter-tree__checkbox--subcategory" ';
		                html += 'name="categories_subcategory" value="' + esc(subId) + '" ';
		                html += 'data-gl-filter-category-id="' + esc(catId) + '" ';
		                html += 'data-gl-filter-subcategory-id="' + esc(subId) + '">';
		                html += '<span class="gl-filter-tree__text">' + esc(sub.label || subId) + '</span>';
		                html += '</label>';
		                html += '</li>';
		            });

		            html += '</ul>';
		        }

		        html += '</li>';
		    });

		    html += '</ul>';
		    return html;
		};

		/**
		 * Construit le contenu HTML de la liste de tags
		 * @param {Array} tags - Array de tags uniques tri√©s
		 * @returns {string} HTML string
		 */
		window._buildTagsListContent = function(tags) {
		    if (!tags || tags.length === 0) {
		        return '<div class="gl-empty-state">ND - Non disponible</div>';
		    }

		    // S√©curit√© : √©chapper les valeurs dynamiques
		    const esc = (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function')
		        ? function(s) { return GeoLeaf.Security.escapeHtml(s); }
		        : function(s) { return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); };

		    let html = '';
		    tags.forEach(function(tag) {
		        html += '<span class="gl-filter-panel__tag-badge" data-tag-value="' + esc(tag) + '">' + esc(tag) + '</span>';
		    });

		    return html;
		};

		/**
		 * Attache les event listeners pour l'arbre de cat√©gories apr√®s rendering
		 * @param {HTMLElement} container - Container de l'arbre
		 */
		window._attachCategoryTreeListeners = function(container) {
		    // Event listeners pour les fl√®ches d'expansion
		    const arrows = container.querySelectorAll('.gl-filter-tree__arrow');
		    arrows.forEach(function(arrow) {
		        arrow.addEventListener('click', function(e) {
		            e.stopPropagation();
		            const li = this.closest('.gl-filter-tree__item--category');
		            const subList = li.querySelector('.gl-filter-tree--subcategories');
		            if (subList) {
		                const isExpanded = li.classList.contains('is-expanded');
		                if (isExpanded) {
		                    li.classList.remove('is-expanded');
		                    this.textContent = '‚ñ∂';
		                } else {
		                    li.classList.add('is-expanded');
		                    this.textContent = '‚ñº';
		                }
		            }
		        });
		    });

		    // Event listeners pour les checkboxes de cat√©gorie (parent)
		    const categoryCheckboxes = container.querySelectorAll('.gl-filter-tree__checkbox--category');
		    categoryCheckboxes.forEach(function(inputCat) {
		        inputCat.addEventListener('change', function() {
		            const li = this.closest('.gl-filter-tree__item--category');
		            const subCheckboxes = li.querySelectorAll('.gl-filter-tree__checkbox--subcategory');
		            subCheckboxes.forEach(function(subCb) {
		                subCb.checked = inputCat.checked;
		            });
		            inputCat.indeterminate = false;
		        });
		    });

		    // Event listeners pour les checkboxes de sous-cat√©gorie (enfant)
		    const subcategoryCheckboxes = container.querySelectorAll('.gl-filter-tree__checkbox--subcategory');
		    subcategoryCheckboxes.forEach(function(inputSub) {
		        inputSub.addEventListener('change', function() {
		            const liCat = this.closest('.gl-filter-tree__item--category');
		            const categoryCheckbox = liCat.querySelector('.gl-filter-tree__checkbox--category');
		            const subCheckboxes = liCat.querySelectorAll('.gl-filter-tree__checkbox--subcategory');

		            const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
		            const totalCount = subCheckboxes.length;

		            if (checkedCount === 0) {
		                categoryCheckbox.checked = false;
		                categoryCheckbox.indeterminate = false;
		            } else if (checkedCount === totalCount) {
		                categoryCheckbox.checked = true;
		                categoryCheckbox.indeterminate = false;
		            } else {
		                categoryCheckbox.checked = false;
		                categoryCheckbox.indeterminate = true;
		            }
		        });
		    });
		};

		/**
		 * Attache les event listeners pour les tags apr√®s rendering
		 * @param {HTMLElement} container - Container des tags
		 */
		window._attachTagsListeners = function(container) {
		    const badges = container.querySelectorAll('.gl-filter-panel__tag-badge');
		    badges.forEach(function(badge) {
		        badge.addEventListener('click', function() {
		            this.classList.toggle('is-selected');
		        });
		    });
		};
		return filterControlBuilder;
	}

	requireFilterControlBuilder();

	var shared$3 = {};

	/**
	 * GeoLeaf UI Filter Panel - Shared Helpers
	 * Fonctions utilitaires partag√©es pour le panneau de filtres
	 *
	 * @module ui/filter-panel/shared
	 */

	var hasRequiredShared$3;

	function requireShared$3 () {
		if (hasRequiredShared$3) return shared$3;
		hasRequiredShared$3 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._UIFilterPanelShared = GeoLeaf._UIFilterPanelShared || {};

		    // ========================================
		    //   CONVERSION DE FEATURES
		    // ========================================

		    /**
		     * Convertit une feature GeoJSON Point en objet POI-like
		     * @param {Object} feature - Feature GeoJSON
		     * @returns {Object|null} - POI-like ou null
		     */
		    GeoLeaf._UIFilterPanelShared.featureToPoiLike = function(feature) {
		        if (!feature || !feature.geometry || !feature.properties) return null;

		        const geom = feature.geometry;
		        if (!geom || geom.type?.toLowerCase().indexOf("point") === -1) return null;

		        const coords = Array.isArray(geom.coordinates) ? geom.coordinates : null;
		        const latlng = coords && coords.length >= 2 ? [coords[1], coords[0]] : null;
		        const props = feature.properties || {};
		        const poi = Object.assign({}, props);

		        if (!poi.title && props.name) poi.title = props.name;
		        if (!poi.id && feature.id) poi.id = feature.id;
		        if (!poi.latlng && latlng) poi.latlng = latlng;
		        if (!poi.attributes && props.attributes) poi.attributes = props.attributes;

		        return poi;
		    };

		    /**
		     * Convertit une feature GeoJSON LineString en objet Route-like
		     * @param {Object} feature - Feature GeoJSON
		     * @returns {Object|null} - Route-like ou null
		     */
		    GeoLeaf._UIFilterPanelShared.featureToRouteLike = function(feature) {
		        if (!feature || !feature.geometry || !feature.properties) return null;

		        const geom = feature.geometry;
		        if (!geom || geom.type?.toLowerCase().indexOf("line") === -1) return null;

		        const props = feature.properties || {};

		        // Exclude protected areas (aires_prot√©g√©es_nationales) - they should not be treated as routes/itineraries
		        // Protected areas have minimal properties: fid, Name, region only
		        const hasOtherProperties = Object.keys(props).some(key =>
		            !['fid', 'name', 'Name', 'region', 'REGION', 'Region'].includes(key)
		        );
		        if (!hasOtherProperties && (props.fid !== undefined || props.Name)) {
		            // Likely a protected area, not an itinerary
		            return null;
		        }

		        const route = Object.assign({}, props);

		        if (!route.title && props.name) route.title = props.name;
		        if (!route.id && feature.id) route.id = feature.id;
		        route.geometry = geom;

		        return route;
		    };

		    // ========================================
		    //   R√âCUP√âRATION DES DONN√âES
		    // ========================================

		    /**
		     * R√©cup√®re tous les POI depuis les diff√©rentes sources
		     * @returns {Array} - Liste des POI
		     */
		    GeoLeaf._UIFilterPanelShared.getBasePois = function() {
		        const Log = getLog();
		        const featureToPoiLike = GeoLeaf._UIFilterPanelShared.featureToPoiLike;

		        // 1) Prendre depuis GeoJSON (mode layers-only) si dispo
		        try {
		            if (GeoLeaf.GeoJSON && typeof GeoLeaf.GeoJSON.getFeatures === "function") {
		                const feats = GeoLeaf.GeoJSON.getFeatures({ geometryTypes: ["point"] }) || [];
		                const pois = feats.map(featureToPoiLike).filter(Boolean);
		                if (pois.length) return pois;
		            }
		        } catch (err) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration POI via GeoJSON:", err);
		        }

		        // 2) Config active (legacy)
		        try {
		            if (GeoLeaf.Config) {
		                if (typeof GeoLeaf.Config.get === "function") {
		                    const fromGet = GeoLeaf.Config.get("poi");
		                    if (Array.isArray(fromGet)) return fromGet;
		                }
		                if (Array.isArray(GeoLeaf.Config._activeProfileData?.poi)) {
		                    return GeoLeaf.Config._activeProfileData.poi;
		                }
		            }
		        } catch (err) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration POI via Config:", err);
		        }

		        // 3) Fallback d√©mo
		        if (global.cfg && Array.isArray(global.cfg.poi)) {
		            return global.cfg.poi;
		        }

		        return [];
		    };

		    /**
		     * R√©cup√®re toutes les routes depuis les diff√©rentes sources
		     * @returns {Array} - Liste des routes
		     */
		    GeoLeaf._UIFilterPanelShared.getBaseRoutes = function() {
		        const Log = getLog();
		        const featureToRouteLike = GeoLeaf._UIFilterPanelShared.featureToRouteLike;

		        // 1) Via GeoJSON (layers-only)
		        try {
		            if (GeoLeaf.GeoJSON && typeof GeoLeaf.GeoJSON.getFeatures === "function") {
		                const feats = GeoLeaf.GeoJSON.getFeatures({ geometryTypes: ["line", "linestring", "multilinestring"] }) || [];
		                const routes = feats.map(featureToRouteLike).filter(Boolean);
		                if (routes.length) return routes;
		            }
		        } catch (err) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration routes via GeoJSON:", err);
		        }

		        // 2) Config active (legacy)
		        try {
		            if (GeoLeaf.Config) {
		                if (typeof GeoLeaf.Config.get === "function") {
		                    const fromGet = GeoLeaf.Config.get("routes");
		                    if (Array.isArray(fromGet)) return fromGet;
		                }
		                if (Array.isArray(GeoLeaf.Config._activeProfileData?.routes)) {
		                    return GeoLeaf.Config._activeProfileData.routes;
		                }
		            }
		        } catch (err) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration routes via Config:", err);
		        }

		        // 3) Fallback d√©mo
		        if (global.cfg && Array.isArray(global.cfg.routes)) {
		            return global.cfg.routes;
		        }

		        return [];
		    };

		    // ========================================
		    //   UTILITAIRES
		    // ========================================

		    /**
		     * Retourne l'√©l√©ment DOM du panneau de filtres.
		     * Priorit√© au conteneur flottant #gl-filter-panel, puis fallback #gl-left-panel.
		     * @returns {HTMLElement|null}
		     */
		    GeoLeaf._UIFilterPanelShared.getFilterPanelElement = function() {
		        let el = document.getElementById("gl-filter-panel");
		        if (el) return el;

		        el = document.getElementById("gl-left-panel");
		        if (el) return el;

		        const Log = getLog();
		        Log.warn("[GeoLeaf.UI.FilterPanel] Aucun conteneur de panneau de filtres trouv√© (#gl-filter-panel / #gl-left-panel).");

		        return null;
		    };

		    /**
		     * Acc√®de √† une propri√©t√© imbriqu√©e (ex: "attributes.nom")
		     * @param {Object} obj - Objet source
		     * @param {string} path - Chemin vers la propri√©t√©
		     * @returns {*} - Valeur ou null
		     */
		    GeoLeaf._UIFilterPanelShared.getNestedValue = function(obj, path) {
		        if (!obj || !path) return null;
		        const keys = path.split('.');
		        let value = obj;
		        for (let i = 0; i < keys.length; i++) {
		            if (value === null || value === undefined) return null;
		            value = value[keys[i]];
		        }
		        return value;
		    };

		    /**
		     * Extrait un point repr√©sentatif d'une g√©om√©trie (pour calcul de distance)
		     * @param {Object} geometry - G√©om√©trie GeoJSON
		     * @returns {Object|null} - { lat, lng } ou null
		     */
		    GeoLeaf._UIFilterPanelShared.getRepresentativePoint = function(geometry) {
		        if (!geometry || !geometry.coordinates) return null;

		        if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
		            // Pour un polygone, utiliser le premier point du premier anneau
		            const coords = geometry.type === 'Polygon'
		                ? geometry.coordinates[0][0]
		                : geometry.coordinates[0][0][0];
		            return coords ? { lng: coords[0], lat: coords[1] } : null;

		        } else if (geometry.type === 'LineString') {
		            // Pour une ligne, utiliser le point du milieu
		            const coords = geometry.coordinates;
		            if (coords && coords.length > 0) {
		                const midIndex = Math.floor(coords.length / 2);
		                return { lng: coords[midIndex][0], lat: coords[midIndex][1] };
		            }

		        } else if (geometry.type === 'MultiLineString') {
		            // Pour multi-ligne, utiliser le point du milieu de la premi√®re ligne
		            const coords = geometry.coordinates[0];
		            if (coords && coords.length > 0) {
		                const midIndex = Math.floor(coords.length / 2);
		                return { lng: coords[midIndex][0], lat: coords[midIndex][1] };
		            }

		        } else if (geometry.type === 'Point') {
		            return { lng: geometry.coordinates[0], lat: geometry.coordinates[1] };

		        } else if (geometry.type === 'MultiPoint') {
		            // Pour multi-point, utiliser le premier point
		            const coords = geometry.coordinates[0];
		            return coords ? { lng: coords[0], lat: coords[1] } : null;
		        }

		        return null;
		    };

		    /**
		     * Collecte tous les tags uniques depuis une liste d'items
		     * @param {Array} items - Liste d'items (POI, routes)
		     * @returns {Array} - Tags uniques tri√©s
		     */
		    GeoLeaf._UIFilterPanelShared.collectAllTags = function(items) {
		        const tagSet = new Set();

		        items.forEach(function(item) {
		            // Support GeoJSON properties.attributes.tags, item.attributes.tags, et item.tags
		            const props = item.properties || item;
		            const attrs = props.attributes || item.attributes || {};
		            const tags = attrs.tags || props.tags || item.tags;

		            if (Array.isArray(tags) && tags.length > 0) {
		                tags.forEach(function(t) {
		                    if (t && typeof t === "string") {
		                        tagSet.add(t);
		                    }
		                });
		            }
		        });

		        const arr = Array.from(tagSet);
		        arr.sort();
		        return arr;
		    };

		})(window);
		return shared$3;
	}

	requireShared$3();

	var stateReader = {};

	/**
	 * GeoLeaf UI Filter Panel - State Reader
	 * Lecture de l'√©tat des filtres depuis le DOM
	 *
	 * @module ui/filter-panel/state-reader
	 */

	var hasRequiredStateReader;

	function requireStateReader () {
		if (hasRequiredStateReader) return stateReader;
		hasRequiredStateReader = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    GeoLeaf._UIFilterPanelStateReader = GeoLeaf._UIFilterPanelStateReader || {};

		    /**
		     * Structure par d√©faut de l'√©tat des filtres
		     * @returns {Object}
		     */
		    GeoLeaf._UIFilterPanelStateReader.getDefaultState = function() {
		        return {
		            categoriesTree: [],
		            subCategoriesTree: [],
		            minRating: NaN,
		            hasMinRating: false,
		            selectedTags: [],
		            hasTags: false,
		            dataTypes: { poi: true, routes: true },
		            searchText: "",
		            hasSearchText: false,
		            proximity: {
		                active: false,
		                center: null,
		                radius: 10
		            }
		        };
		    };

		    /**
		     * Lit l'√©tat actuel des filtres depuis le panneau DOM
		     * @param {HTMLElement} panelEl - √âl√©ment du panneau de filtres
		     * @returns {Object} - √âtat des filtres
		     */
		    GeoLeaf._UIFilterPanelStateReader.readFiltersFromPanel = function(panelEl) {
		        const state = GeoLeaf._UIFilterPanelStateReader.getDefaultState();

		        if (!panelEl) return state;

		        // Types de donn√©es (POI / Routes)
		        const poiCheckbox = panelEl.querySelector(
		            "[data-gl-filter-id='dataTypes'] input[value='poi']"
		        );
		        const routesCheckbox = panelEl.querySelector(
		            "[data-gl-filter-id='dataTypes'] input[value='routes']"
		        );
		        if (poiCheckbox) state.dataTypes.poi = poiCheckbox.checked;
		        if (routesCheckbox) state.dataTypes.routes = routesCheckbox.checked;

		        // Recherche textuelle
		        const searchInput = panelEl.querySelector(
		            "[data-gl-filter-id='searchText'] input[type='text']"
		        );
		        if (searchInput && searchInput.value.trim() !== "") {
		            state.searchText = searchInput.value.trim().toLowerCase();
		            state.hasSearchText = true;
		        }

		        // Proximit√©
		        const proximityContainer = panelEl.querySelector(
		            "[data-gl-filter-id='proximity']"
		        );
		        if (proximityContainer) {
		            const isActive = proximityContainer.getAttribute("data-proximity-active") === "true";
		            const lat = parseFloat(proximityContainer.getAttribute("data-proximity-lat"));
		            const lng = parseFloat(proximityContainer.getAttribute("data-proximity-lng"));
		            const radius = parseFloat(proximityContainer.getAttribute("data-proximity-radius"));

		            if (isActive && !isNaN(lat) && !isNaN(lng) && !isNaN(radius)) {
		                state.proximity.active = true;
		                state.proximity.center = { lat: lat, lng: lng };
		                state.proximity.radius = radius;
		            }
		        }

		        // Tree-view : cat√©gories coch√©es
		        panelEl
		            .querySelectorAll("input.gl-filter-tree__checkbox--category:checked")
		            .forEach(function(input) {
		                const val = input.value;
		                if (val) {
		                    state.categoriesTree.push(String(val));
		                }
		            });

		        // Tree-view : sous-cat√©gories coch√©es
		        panelEl
		            .querySelectorAll("input.gl-filter-tree__checkbox--subcategory:checked")
		            .forEach(function(input) {
		                const subId = input.getAttribute("data-gl-filter-subcategory-id");
		                if (subId) {
		                    state.subCategoriesTree.push(String(subId));
		                }
		            });

		        // Slider de note minimale
		        const ratingInput = panelEl.querySelector(
		            "[data-gl-filter-id='minRating'] input[type='range']"
		        );
		        if (ratingInput && ratingInput.value !== "") {
		            const val = parseFloat(ratingInput.value);
		            if (!isNaN(val)) {
		                state.minRating = val;
		                state.hasMinRating = val > 0;
		            }
		        }

		        // Tags s√©lectionn√©s (badges)
		        const tagsContainer = panelEl.querySelector(
		            "[data-gl-filter-id='tags'] .gl-filter-panel__tags-container"
		        );
		        if (tagsContainer) {
		            const selectedBadges = tagsContainer.querySelectorAll(
		                ".gl-filter-panel__tag-badge.is-selected"
		            );
		            const selected = Array.from(selectedBadges).map(function(badge) {
		                return badge.getAttribute("data-tag-value");
		            }).filter(Boolean);
		            state.selectedTags = selected;
		            state.hasTags = selected.length > 0;
		        }

		        return state;
		    };

		    /**
		     * R√©initialise les contr√¥les du panneau de filtres √† leur √©tat par d√©faut
		     * @param {HTMLElement} panelEl - √âl√©ment du panneau de filtres
		     */
		    GeoLeaf._UIFilterPanelStateReader.resetControls = function(panelEl) {
		        if (!panelEl) return;

		        // Checkbox-group (POI/Routes) - reset to checked by default
		        const dataTypesCheckboxes = panelEl.querySelectorAll(
		            "[data-gl-filter-id='dataTypes'] input[type='checkbox']"
		        );
		        dataTypesCheckboxes.forEach(function(input) {
		            input.checked = true;
		        });

		        // Search text input
		        const searchInput = panelEl.querySelector(
		            "[data-gl-filter-id='searchText'] input[type='text']"
		        );
		        if (searchInput) {
		            searchInput.value = "";
		        }

		        // Proximit√©
		        const proximityWrapper = panelEl.querySelector(
		            "[data-gl-filter-id='proximity']"
		        );
		        if (proximityWrapper) {
		            proximityWrapper.removeAttribute("data-proximity-active");
		            proximityWrapper.removeAttribute("data-proximity-lat");
		            proximityWrapper.removeAttribute("data-proximity-lng");
		            proximityWrapper.removeAttribute("data-proximity-radius");

		            const btn = proximityWrapper.querySelector(".gl-filter-panel__proximity-btn");
		            if (btn) {
		                btn.classList.remove("is-active");
		                btn.textContent = btn.getAttribute("data-label-inactive") || "Activer";
		            }

		            const rangeWrapper = proximityWrapper.querySelector(".gl-filter-panel__proximity-range");
		            if (rangeWrapper) {
		                rangeWrapper.style.display = "none";
		            }

		            const instruction = proximityWrapper.querySelector(".gl-filter-panel__proximity-instruction");
		            if (instruction) {
		                instruction.style.display = "none";
		            }

		            // Supprimer le cercle et le marqueur de la carte
		            if (GeoLeaf.UI && GeoLeaf.UI._proximityCircle && GeoLeaf.UI._proximityMap) {
		                GeoLeaf.UI._proximityMap.removeLayer(GeoLeaf.UI._proximityCircle);
		                GeoLeaf.UI._proximityCircle = null;
		            }
		            if (GeoLeaf.UI && GeoLeaf.UI._proximityMarker && GeoLeaf.UI._proximityMap) {
		                GeoLeaf.UI._proximityMap.removeLayer(GeoLeaf.UI._proximityMarker);
		                GeoLeaf.UI._proximityMarker = null;
		            }
		            if (GeoLeaf.UI) {
		                GeoLeaf.UI._proximityMode = false;
		            }
		        }

		        // Checkboxes du tree-view (cat√©gories & sous-cat√©gories)
		        panelEl
		            .querySelectorAll(".gl-filter-tree__checkbox")
		            .forEach(function(input) {
		                input.checked = false;
		            });

		        // Tags - d√©s√©lectionner tous les badges
		        const tagBadges = panelEl.querySelectorAll(
		            ".gl-filter-panel__tag-badge.is-selected"
		        );
		        tagBadges.forEach(function(badge) {
		            badge.classList.remove("is-selected");
		        });

		        // Select classiques
		        panelEl
		            .querySelectorAll("select.gl-filter-panel__control--select")
		            .forEach(function(sel) {
		                if (sel.multiple) {
		                    Array.from(sel.options).forEach(function(opt) {
		                        opt.selected = false;
		                    });
		                } else {
		                    sel.value = "";
		                }
		            });

		        // Slider note
		        const ratingInput = panelEl.querySelector(
		            "[data-gl-filter-id='minRating'] input[type='range']"
		        );
		        const ratingLabel = panelEl.querySelector(
		            "[data-gl-filter-id='minRating'] .gl-filter-panel__range-value"
		        );
		        if (ratingInput) {
		            const min = ratingInput.min !== "" ? ratingInput.min : "0";
		            ratingInput.value = min;
		            if (ratingLabel) {
		                ratingLabel.textContent = String(min).replace(".", ",");
		            }
		        }
		    };

		})(window);
		return stateReader;
	}

	requireStateReader();

	var lazyLoader = {};

	/**
	 * GeoLeaf UI Filter Panel - Lazy Loader
	 * Chargement √† la demande des filtres cat√©gories et tags
	 *
	 * @module ui/filter-panel/lazy-loader
	 */

	var hasRequiredLazyLoader;

	function requireLazyLoader () {
		if (hasRequiredLazyLoader) return lazyLoader;
		hasRequiredLazyLoader = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    GeoLeaf._UIFilterPanelLazyLoader = {
		        _cache: {},
		        _openAccordions: new Set(),

		        /**
		         * Charge les cat√©gories pour le th√®me actif
		         * @param {string} themeId - ID du th√®me
		         * @returns {Array} - Array de cat√©gories avec leurs sous-cat√©gories
		         */
		        loadCategories(themeId) {
		            const cacheKey = `categories_${themeId}`;

		            if (this._cache[cacheKey]) {
		                Log.debug("[LazyLoader] Cache HIT pour cat√©gories:", themeId);
		                return this._cache[cacheKey];
		            }

		            Log.debug("[LazyLoader] Cache MISS pour cat√©gories, scan en cours...");
		            const result = this._scanCategories(themeId);
		            this._cache[cacheKey] = result;
		            return result;
		        },

		        /**
		         * Charge les tags pour le th√®me actif
		         * @param {string} themeId - ID du th√®me
		         * @returns {Array} - Array de tags uniques
		         */
		        loadTags(themeId) {
		            const cacheKey = `tags_${themeId}`;

		            if (this._cache[cacheKey]) {
		                Log.debug("[LazyLoader] Cache HIT pour tags:", themeId);
		                return this._cache[cacheKey];
		            }

		            Log.debug("[LazyLoader] Cache MISS pour tags, scan en cours...");
		            const result = this._scanTags(themeId);
		            this._cache[cacheKey] = result;
		            return result;
		        },

		        /**
		         * Scanne les features pour extraire les cat√©gories utilis√©es
		         * @private
		         * @param {string} themeId - ID du th√®me
		         * @returns {Object} - {categories: Map, usedIds: Set}
		         */
		        _scanCategories(themeId) {
		            const startTime = performance.now();

		            // R√©cup√©rer les couches visibles du th√®me
		            const visibleLayerIds = this._getVisibleLayerIds(themeId);

		            // R√©cup√©rer toutes les features
		            let allFeatures = [];
		            try {
		                if (GeoLeaf.GeoJSON && typeof GeoLeaf.GeoJSON.getFeatures === "function") {
		                    allFeatures = GeoLeaf.GeoJSON.getFeatures() || [];
		                }
		            } catch (err) {
		                Log.warn("[LazyLoader] Erreur r√©cup√©ration features:", err);
		                return { categories: new Map(), usedIds: new Set() };
		            }

		            // Filtrer par couches visibles
		            const visibleFeatures = allFeatures.filter(feature => {
		                const layerId = feature.properties?._layerId || feature.properties?.layerId || feature._layerId;
		                return visibleLayerIds.includes(layerId);
		            });

		            Log.debug(`[LazyLoader] Scan cat√©gories: ${visibleFeatures.length} features sur ${visibleLayerIds.length} couches actives`);

		            // Extraire les cat√©gories uniques (normalisation lowercase + variantes camelCase)
		            const usedCategoryIds = new Set();
		            visibleFeatures.forEach(feature => {
		                const props = feature.properties || {};
		                if (props.categoryId) {
		                    usedCategoryIds.add(props.categoryId);
		                }
		                if (props.subcategoryId) {
		                    usedCategoryIds.add(props.subcategoryId);
		                }
		                // Variante camelCase (subCategoryId) pr√©sente dans certains GeoJSON
		                if (props.subCategoryId) {
		                    usedCategoryIds.add(props.subCategoryId);
		                }
		            });

		            const elapsed = (performance.now() - startTime).toFixed(2);
		            Log.info(`[LazyLoader] Scan cat√©gories termin√© en ${elapsed}ms: ${usedCategoryIds.size} cat√©gories trouv√©es`);

		            return {
		                usedIds: usedCategoryIds,
		                visibleLayerIds: visibleLayerIds
		            };
		        },

		        /**
		         * Scanne les features pour extraire les tags utilis√©s
		         * @private
		         * @param {string} themeId - ID du th√®me
		         * @returns {Array} - Array de tags tri√©s
		         */
		        _scanTags(themeId) {
		            const startTime = performance.now();

		            // R√©cup√©rer les couches visibles du th√®me
		            const visibleLayerIds = this._getVisibleLayerIds(themeId);

		            // R√©cup√©rer toutes les features
		            let allFeatures = [];
		            try {
		                if (GeoLeaf.GeoJSON && typeof GeoLeaf.GeoJSON.getFeatures === "function") {
		                    allFeatures = GeoLeaf.GeoJSON.getFeatures() || [];
		                }
		            } catch (err) {
		                Log.warn("[LazyLoader] Erreur r√©cup√©ration features:", err);
		                return [];
		            }

		            // Filtrer par couches visibles
		            const visibleFeatures = allFeatures.filter(feature => {
		                const layerId = feature.properties?._layerId || feature.properties?.layerId || feature._layerId;
		                return visibleLayerIds.includes(layerId);
		            });

		            // Extraire les tags uniques
		            const tagSet = new Set();
		            visibleFeatures.forEach(feature => {
		                const props = feature.properties || {};
		                const attrs = props.attributes || {};
		                const tags = attrs.tags || props.tags;

		                if (Array.isArray(tags)) {
		                    tags.forEach(tag => {
		                        if (tag && typeof tag === "string") {
		                            tagSet.add(tag);
		                        }
		                    });
		                }
		            });

		            const tagsArray = Array.from(tagSet).sort();
		            const elapsed = (performance.now() - startTime).toFixed(2);

		            Log.info(`[LazyLoader] Scan tags termin√© en ${elapsed}ms:`, {
		                totalFeatures: allFeatures.length,
		                visibleFeatures: visibleFeatures.length,
		                tagsFound: tagsArray.length
		            });

		            return tagsArray;
		        },

		        /**
		         * R√©cup√®re les IDs des couches r√©ellement visibles sur la carte
		         * @private
		         * @param {string} themeId - ID du th√®me (non utilis√©, mais conserv√© pour compatibilit√©)
		         * @returns {Array} - Array d'IDs de couches avec visible: true
		         */
		        _getVisibleLayerIds(themeId) {
		            let visibleLayerIds = [];

		            try {
		                // R√©cup√©rer toutes les couches charg√©es
		                if (GeoLeaf.GeoJSON && typeof GeoLeaf.GeoJSON.getAllLayers === "function") {
		                    const allLayers = GeoLeaf.GeoJSON.getAllLayers();
		                    // Filtrer uniquement celles qui sont visibles (ON dans layer manager)
		                    visibleLayerIds = allLayers
		                        .filter(layer => layer.visible === true)
		                        .map(layer => layer.id);

		                    Log.debug(`[LazyLoader] ${visibleLayerIds.length} couches visibles trouv√©es:`, visibleLayerIds);
		                }
		            } catch (err) {
		                Log.warn("[LazyLoader] Erreur r√©cup√©ration couches visibles:", err);
		            }

		            return visibleLayerIds;
		        },

		        /**
		         * Marque un accord√©on comme ouvert
		         * @param {string} type - 'categories' ou 'tags'
		         * @param {HTMLElement} element - Element de l'accord√©on
		         */
		        markAccordionOpen(type, element) {
		            this._openAccordions.add({ type, element });
		            Log.debug(`[LazyLoader] Accord√©on "${type}" marqu√© comme ouvert`);
		        },

		        /**
		         * Marque un accord√©on comme ferm√©
		         * @param {HTMLElement} element - Element de l'accord√©on
		         */
		        markAccordionClosed(element) {
		            this._openAccordions.forEach(item => {
		                if (item.element === element) {
		                    this._openAccordions.delete(item);
		                    Log.debug(`[LazyLoader] Accord√©on "${item.type}" marqu√© comme ferm√©`);
		                }
		            });
		        },

		        /**
		         * Invalide le cache pour un th√®me sp√©cifique
		         * @param {string} themeId - ID du th√®me
		         */
		        invalidateCacheForTheme(themeId) {
		            delete this._cache[`categories_${themeId}`];
		            delete this._cache[`tags_${themeId}`];
		            Log.info(`[LazyLoader] Cache invalid√© pour th√®me: ${themeId}`);
		        },

		        /**
		         * Invalide tout le cache (changement de th√®me)
		         */
		        clearCache() {
		            this._cache = {};
		            Log.info("[LazyLoader] Cache compl√®tement vid√©");
		        },

		        /**
		         * Rafra√Æchit les accord√©ons ouverts
		         * Utilis√© apr√®s un changement de th√®me ou toggle de couche
		         */
		        refreshOpenAccordions() {
		            if (this._openAccordions.size === 0) {
		                Log.debug("[LazyLoader] Aucun accord√©on ouvert √† rafra√Æchir");
		                return;
		            }

		            Log.info(`[LazyLoader] Rafra√Æchissement de ${this._openAccordions.size} accord√©on(s) ouvert(s)`);
		            const currentTheme = GeoLeaf.ThemeSelector?.getCurrentTheme();

		            if (!currentTheme) {
		                Log.warn("[LazyLoader] Impossible de r√©cup√©rer le th√®me actif");
		                return;
		            }

		            this._openAccordions.forEach(({ type, element }) => {
		                // Sauvegarder l'√©tat des checkboxes / tags s√©lectionn√©s
		                const savedStates = this._saveCheckboxStates(element);

		                // Cibler la zone [data-lazy-type] qui re√ßoit le innerHTML
		                const contentArea = element.querySelector('[data-lazy-type]');

		                if (!contentArea) {
		                    Log.warn("[LazyLoader] Zone [data-lazy-type] introuvable dans l'accord√©on");
		                    return;
		                }

		                // R√©initialiser le flag lazyLoaded pour permettre un futur rechargement
		                element.dataset.lazyLoaded = "false";

		                // Appeler la fonction de render appropri√©e
		                if (type === 'categories') {
		                    this._rerenderCategories(contentArea, currentTheme, savedStates);
		                } else if (type === 'tags') {
		                    this._rerenderTags(contentArea, currentTheme, savedStates);
		                }

		                // Re-marquer comme charg√© apr√®s le re-render
		                element.dataset.lazyLoaded = "true";
		            });
		        },

		        /**
		         * Re-render les cat√©gories dans un accord√©on
		         * @private
		         */
		        _rerenderCategories(contentArea, themeId, savedStates) {
		            const result = this.loadCategories(themeId);

		            // Appeler la fonction globale de construction d'arbre
		            if (typeof window._buildCategoryTreeContent === "function") {
		                const content = window._buildCategoryTreeContent(result);
		                contentArea.innerHTML = content;

		                // Attacher les event listeners
		                if (typeof window._attachCategoryTreeListeners === "function") {
		                    window._attachCategoryTreeListeners(contentArea);
		                }

		                // Restaurer les √©tats des checkboxes
		                this._restoreCheckboxStates(contentArea, savedStates);
		            } else {
		                Log.warn("[LazyLoader] _buildCategoryTreeContent introuvable");
		                contentArea.innerHTML = '<div class="gl-empty-state">Erreur de chargement</div>';
		            }
		        },

		        /**
		         * Re-render les tags dans un accord√©on
		         * @private
		         */
		        _rerenderTags(contentArea, themeId, savedStates) {
		            const tags = this.loadTags(themeId);

		            // Appeler la fonction globale de construction de liste
		            if (typeof window._buildTagsListContent === "function") {
		                const content = window._buildTagsListContent(tags);
		                contentArea.innerHTML = content;

		                // Attacher les event listeners
		                if (typeof window._attachTagsListeners === "function") {
		                    window._attachTagsListeners(contentArea);
		                }

		                // Restaurer les √©tats des checkboxes
		                this._restoreCheckboxStates(contentArea, savedStates);
		            } else {
		                Log.warn("[LazyLoader] _buildTagsListContent introuvable");
		                contentArea.innerHTML = '<div class="gl-empty-state">Erreur de chargement</div>';
		            }
		        },

		        /**
		         * Sauvegarde l'√©tat des checkboxes avant re-render
		         * @private
		         */
		        _saveCheckboxStates(element) {
		            const states = {};
		            const checkboxes = element.querySelectorAll('input[type="checkbox"]');

		            checkboxes.forEach(cb => {
		                const categoryId = cb.dataset.glFilterCategoryId;
		                const subcategoryId = cb.dataset.glFilterSubcategoryId;
		                const value = cb.value;

		                let key;
		                if (subcategoryId) {
		                    key = `${categoryId}:${subcategoryId}`;
		                } else if (categoryId) {
		                    key = categoryId;
		                } else if (value) {
		                    key = value;
		                }

		                if (key) {
		                    states[key] = cb.checked;
		                }
		            });

		            return states;
		        },

		        /**
		         * Restaure l'√©tat des checkboxes apr√®s re-render
		         * @private
		         */
		        _restoreCheckboxStates(element, savedStates) {
		            if (!savedStates || Object.keys(savedStates).length === 0) return;

		            const checkboxes = element.querySelectorAll('input[type="checkbox"]');
		            let restoredCount = 0;

		            checkboxes.forEach(cb => {
		                const categoryId = cb.dataset.glFilterCategoryId;
		                const subcategoryId = cb.dataset.glFilterSubcategoryId;
		                const value = cb.value;

		                let key;
		                if (subcategoryId) {
		                    key = `${categoryId}:${subcategoryId}`;
		                } else if (categoryId) {
		                    key = categoryId;
		                } else if (value) {
		                    key = value;
		                }

		                if (key && savedStates[key] !== undefined) {
		                    cb.checked = savedStates[key];
		                    restoredCount++;
		                }
		            });

		            Log.debug(`[LazyLoader] ${restoredCount} √©tats de checkbox restaur√©s`);
		        }
		    };

		    // √âcouter les √©v√©nements de changement de th√®me
		    document.addEventListener('geoleaf:theme:applied', () => {
		        Log.info("[LazyLoader] √âv√©nement theme:applied d√©tect√© ‚Äî invalidation compl√®te");

		        // 1. Vider le cache de donn√©es (scan cat√©gories/tags)
		        GeoLeaf._UIFilterPanelLazyLoader.clearCache();

		        // 2. R√©initialiser TOUS les flags data-lazy-loaded sur les accord√©ons
		        //    (ferm√©s ou ouverts) pour forcer un rechargement au prochain expand
		        const allAccordions = document.querySelectorAll('.gl-filter-panel__group--accordion[data-lazy-loaded]');
		        allAccordions.forEach(acc => {
		            acc.dataset.lazyLoaded = "false";
		        });
		        Log.debug(`[LazyLoader] ${allAccordions.length} flag(s) data-lazy-loaded r√©initialis√©(s)`);

		        // 3. Rafra√Æchir les accord√©ons actuellement ouverts (re-render imm√©diat)
		        GeoLeaf._UIFilterPanelLazyLoader.refreshOpenAccordions();
		    });

		    // √âcouter l'√©v√©nement de changement de visibilit√© de couche
		    document.addEventListener('geoleaf:geojson:visibility-changed', (e) => {
		        const detail = e.detail || {};
		        Log.info("[LazyLoader] Visibilit√© couche chang√©e:", detail.layerId, detail.visible);

		        // Invalider le cache du th√®me actif
		        const currentTheme = GeoLeaf.ThemeSelector?.getCurrentTheme();
		        if (currentTheme) {
		            GeoLeaf._UIFilterPanelLazyLoader.invalidateCacheForTheme(currentTheme);
		            // Rafra√Æchir les accord√©ons ouverts
		            GeoLeaf._UIFilterPanelLazyLoader.refreshOpenAccordions();
		        }
		    });

		})(window);
		return lazyLoader;
	}

	requireLazyLoader();

	var applier = {};

	/**
	 * GeoLeaf UI Filter Panel - Applier
	 * Application des filtres aux couches POI, Routes, GeoJSON
	 *
	 * @module ui/filter-panel/applier
	 */

	var hasRequiredApplier;

	function requireApplier () {
		if (hasRequiredApplier) return applier;
		hasRequiredApplier = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);
		    const getShared = () => GeoLeaf._UIFilterPanelShared;
		    const getStateReader = () => GeoLeaf._UIFilterPanelStateReader;

		    GeoLeaf._UIFilterPanelApplier = GeoLeaf._UIFilterPanelApplier || {};
		    let _lastApplyTime = 0;
		    const APPLY_DEBOUNCE_DELAY = 300; // 300ms

		    // Fonction debounce pour l'application des filtres
		    let _applyFiltersTimeout = null;
		    let _lastSkipRoutes = false; // Store skipRoutes flag for debounced call
		    const _debouncedApplyFilters = function(panelEl, skipRoutes) {
		        if (_applyFiltersTimeout) {
		            clearTimeout(_applyFiltersTimeout);
		        }
		        _lastSkipRoutes = skipRoutes || false;
		        _applyFiltersTimeout = setTimeout(() => {
		            GeoLeaf._UIFilterPanelApplier._applyFiltersImmediate(panelEl, _lastSkipRoutes);
		        }, APPLY_DEBOUNCE_DELAY);
		    };

		    /**
		     * MEMORY LEAK FIX (Phase 2): Cleanup timeout on destroy
		     */
		    GeoLeaf._UIFilterPanelApplier.destroy = function() {
		        if (_applyFiltersTimeout) {
		            clearTimeout(_applyFiltersTimeout);
		            _applyFiltersTimeout = null;
		        }
		    };

		    /**
		     * Rafra√Æchit la visibilit√© des POI selon la liste filtr√©e.
		     * IMPORTANT: Cette fonction filtre UNIQUEMENT les POI du syst√®me POI traditionnel.
		     * Les couches GeoJSON (point, line, polygon) sont g√©r√©es par filterGeoJSONLayers().
		     * On n'appelle PAS filterFeatures() ici pour √©viter de masquer les couches GeoJSON.
		     *
		     * @param {Array} filteredPois - Liste des POI √† afficher
		     */
		    GeoLeaf._UIFilterPanelApplier.refreshPoiLayer = function(filteredPois) {
		        const Log = getLog();

		        // V√©rifier si le syst√®me POI est activ√© dans la config
		        const Config = GeoLeaf.Config;
		        const poiConfig = (Config && typeof Config.get === 'function') ? Config.get('poiConfig') : null;
		        if (poiConfig && poiConfig.enabled === false) {
		            Log.debug("[GeoLeaf.UI.FilterPanel] Syst√®me POI d√©sactiv√©, pas de rafra√Æchissement de la couche POI.");
		            return;
		        }

		        // Fallback: utiliser l'ancien syst√®me POI (si GeoJSON n'est pas disponible)
		        if (!GeoLeaf.POI) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] GeoLeaf.POI indisponible, pas de rafra√Æchissement de la couche POI.");
		            return;
		        }

		        if (typeof GeoLeaf.POI._clearAllForTests === "function") {
		            GeoLeaf.POI._clearAllForTests();
		        } else {
		            Log.warn("[GeoLeaf.UI.FilterPanel] GeoLeaf.POI._clearAllForTests indisponible.");
		        }

		        filteredPois.forEach(function(p) {
		            try {
		                GeoLeaf.POI.addPoi(p);
		            } catch (err) {
		                Log.warn("[GeoLeaf.UI.FilterPanel] Impossible d'ajouter un POI filtr√©:", p, err);
		            }
		        });

		        Log.debug(`[GeoLeaf.UI.FilterPanel] refreshPoiLayer: ${filteredPois.length} POI visibles`);
		    };

		    /**
		     * Applique les filtres aux couches GeoJSON (polygones et polylignes)
		     * @param {Object} state - √âtat des filtres
		     */
		    GeoLeaf._UIFilterPanelApplier.filterGeoJSONLayers = function(state) {
		        const Log = getLog();
		        const Shared = getShared();

		        if (!GeoLeaf.GeoJSON || typeof GeoLeaf.GeoJSON.filterFeatures !== 'function') {
		            return;
		        }

		        const hasCats = state.categoriesTree && state.categoriesTree.length > 0;
		        const hasSubs = state.subCategoriesTree && state.subCategoriesTree.length > 0;
		        const hasTags = state.hasTags && state.selectedTags && state.selectedTags.length > 0;
		        const selectedTags = state.selectedTags || [];
		        const hasProximity = state.proximity && state.proximity.active;
		        const hasSearchText = state.hasSearchText && state.searchText;
		        const searchText = state.searchText || '';
		        const getDistance = GeoLeaf.Utils && typeof GeoLeaf.Utils.getDistance === 'function' ? GeoLeaf.Utils.getDistance : null;

		        // Helper pour obtenir les champs de recherche depuis la config de la couche
		        const getLayerSearchFields = (layerId) => {
		            try {
		                const layerData = GeoLeaf.GeoJSON.getLayerData(layerId);
		                if (layerData && layerData.config) {
		                    // Priorit√© 1: search.indexingFields (format standard des configs de couches)
		                    if (layerData.config.search && Array.isArray(layerData.config.search.indexingFields)) {
		                        return layerData.config.search.indexingFields;
		                    }
		                    // Priorit√© 2: indexingFields √† la racine (legacy)
		                    if (Array.isArray(layerData.config.indexingFields)) {
		                        return layerData.config.indexingFields;
		                    }
		                    // Priorit√© 3: searchFields (legacy)
		                    if (Array.isArray(layerData.config.searchFields)) {
		                        return layerData.config.searchFields;
		                    }
		                }
		            } catch (err) {
		                Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration champs de recherche:", err);
		            }

		            // Fallback: champs par d√©faut du profil
		            try {
		                const activeProfile = GeoLeaf.Config && GeoLeaf.Config._activeProfileData;
		                if (activeProfile && activeProfile.search && activeProfile.search.filters) {
		                    const searchFilter = activeProfile.search.filters.find(f => f.type === 'search');
		                    if (searchFilter && Array.isArray(searchFilter.searchFields)) {
		                        return searchFilter.searchFields;
		                    }
		                }
		            } catch (err) {
		                Log.warn("[GeoLeaf.UI.FilterPanel] Erreur r√©cup√©ration champs par d√©faut:", err);
		            }

		            // Fallback ultime
		            return ['title', 'description', 'properties.title', 'properties.name', 'properties.description', 'attributes.nom'];
		        };

		        // Helper pour tester la recherche textuelle sur une feature
		        const matchesSearchText = (feature, layerId) => {
		            if (!hasSearchText) return true;

		            const searchFields = getLayerSearchFields(layerId);
		            const searchLower = searchText.toLowerCase();

		            for (let i = 0; i < searchFields.length; i++) {
		                let fieldPath = searchFields[i];
		                let value = null;

		                // Normaliser le chemin: si commence par "properties.", on le supprime
		                // puisque on va chercher directement dans feature.properties
		                let propertiesFieldPath = fieldPath;
		                if (fieldPath.startsWith('properties.')) {
		                    propertiesFieldPath = fieldPath.substring('properties.'.length);
		                }

		                // Tester d'abord dans properties
		                if (feature.properties) {
		                    value = Shared.getNestedValue(feature.properties, propertiesFieldPath);
		                }

		                // Si pas trouv√©, tester √† la racine avec le chemin original
		                if (!value) {
		                    value = Shared.getNestedValue(feature, fieldPath);
		                }

		                if (value && String(value).toLowerCase().includes(searchLower)) {
		                    return true;
		                }
		            }

		            return false;
		        };

		        // Fonction de filtre commune pour polygones et lignes
		        const createFilterFunction = (geometryType) => (feature, layerId) => {
		            const props = feature.properties || {};

		            // Filtrage par recherche textuelle
		            if (hasSearchText && !matchesSearchText(feature, layerId)) {
		                return false;
		            }

		            // Filtrage par cat√©gorie/sous-cat√©gorie
		            if (hasCats || hasSubs) {
		                const catId = props.categoryId || props.category || null;
		                const subId = props.subcategoryId || props.subCategoryId || props.subcategory || props.sub_category || null;

		                // Si pas de cat√©gorie sur cette feature, masquer quand filtre actif
		                if (!catId && !subId) return false;

		                // Si des sous-cat√©gories sont s√©lectionn√©es
		                if (hasSubs) {
		                    if (!subId || !state.subCategoriesTree.includes(String(subId))) {
		                        return false;
		                    }
		                }

		                // Si seulement des cat√©gories (pas de sous-cat)
		                if (hasCats && !hasSubs) {
		                    if (!catId || !state.categoriesTree.includes(String(catId))) {
		                        return false;
		                    }
		                }
		            }

		            // Filtrage par tags (au moins UN des tags s√©lectionn√©s doit √™tre pr√©sent)
		            if (hasTags) {
		                let featureTags = props.tags || [];
		                if (!Array.isArray(featureTags)) {
		                    if (typeof featureTags === 'string') {
		                        featureTags = featureTags.split(/[,;]+/);
		                    } else {
		                        featureTags = [];
		                    }
		                }
		                featureTags = featureTags.map(t => String(t).trim()).filter(Boolean);

		                const hasAtLeastOneTag = selectedTags.some(tag => featureTags.includes(tag));
		                if (!hasAtLeastOneTag) {
		                    return false;
		                }
		            }

		            // Filtrage par proximit√©
		            if (hasProximity && state.proximity.center && getDistance) {
		                const point = Shared.getRepresentativePoint(feature.geometry);
		                if (point) {
		                    const distance = getDistance(
		                        state.proximity.center.lat,
		                        state.proximity.center.lng,
		                        point.lat,
		                        point.lng
		                    );
		                    if (distance > state.proximity.radius) {
		                        return false;
		                    }
		                }
		            }

		            return true;
		        };

		        // Filtrer les polygones (zones)
		        GeoLeaf.GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'polygon' });

		        // Filtrer les polylignes (routes GeoJSON)
		        GeoLeaf.GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'line' });

		        // Filtrer les points (POI GeoJSON - MultiPoint, Point, etc.)
		        GeoLeaf.GeoJSON.filterFeatures(createFilterFunction(), { geometryType: 'point' });
		    };

		    /**
		     * Applique tous les filtres actifs avec debounce
		     * @param {HTMLElement} panelEl - √âl√©ment du panneau de filtres
		     */
		    GeoLeaf._UIFilterPanelApplier.applyFiltersNow = function(panelEl, skipRoutes) {
		        _debouncedApplyFilters(panelEl, skipRoutes);
		    };

		    /**
		     * Applique tous les filtres actifs imm√©diatement (interne, avec protection contre les appels r√©p√©t√©s)
		     * @private
		     * @param {HTMLElement} panelEl - √âl√©ment du panneau de filtres
		     * @param {boolean} skipRoutes - Si true, skip le traitement des routes (preserve leurs styles)
		     */
		    GeoLeaf._UIFilterPanelApplier._applyFiltersImmediate = function(panelEl, skipRoutes) {
		        const Log = getLog();
		        const Shared = getShared();
		        const StateReader = getStateReader();

		        // √âviter les appels r√©p√©t√©s trop rapproch√©s
		        const now = Date.now();
		        if (now - _lastApplyTime < 100) return; // 100ms minimum entre les appels
		        _lastApplyTime = now;

		        const basePois = Shared.getBasePois();
		        const baseRoutes = Shared.getBaseRoutes();
		        const state = StateReader.readFiltersFromPanel(panelEl);

		        // Filtrage des couches GeoJSON (polygones, polylignes)
		        GeoLeaf._UIFilterPanelApplier.filterGeoJSONLayers(state);

		        if (!basePois.length && !baseRoutes.length) {
		            Log.info("[GeoLeaf.UI.FilterPanel] Aucun POI ni route source trouv√©.");
		            return;
		        }

		        // G√©rer le filtrage et l'affichage des itin√©raires via GeoLeaf.Route
		        if (GeoLeaf.Route && typeof GeoLeaf.Route.isInitialized === 'function' && GeoLeaf.Route.isInitialized()) {
		            if (state.dataTypes.routes) {
		                // Si skipRoutes=true, on affiche juste les routes existantes sans les recharger
		                if (skipRoutes) {
		                    GeoLeaf.Route.show();
		                } else {
		                    // Filtrer les routes
		                    let filteredRoutes = baseRoutes;
		                    filteredRoutes = GeoLeaf.Filters && typeof GeoLeaf.Filters.filterRouteList === 'function'
		                        ? GeoLeaf.Filters.filterRouteList(baseRoutes, state)
		                        : baseRoutes;

		                    Log.info("[GeoLeaf.UI.FilterPanel] Filtres appliqu√©s sur les routes.", {
		                        total: baseRoutes.length,
		                        result: filteredRoutes.length
		                    });

		                    // Utiliser filterVisibility() si disponible pour pr√©server les styles
		                    // Sinon, utiliser loadFromConfig() (comportement par d√©faut)
		                    if (typeof GeoLeaf.Route.filterVisibility === 'function') {
		                        GeoLeaf.Route.filterVisibility(filteredRoutes);
		                    } else if (typeof GeoLeaf.Route.loadFromConfig === 'function') {
		                        GeoLeaf.Route.loadFromConfig(filteredRoutes);
		                    }
		                    GeoLeaf.Route.show();
		                }
		            } else {
		                GeoLeaf.Route.hide();
		            }
		        }

		        // Filtrer les POI
		        const filtered = GeoLeaf._UIFilterPanelApplier.filterPoiList(basePois, state);

		        Log.info("[GeoLeaf.UI.FilterPanel] Filtres appliqu√©s sur les POI.", {
		            total: basePois.length,
		            result: filtered.length,
		            filters: state
		        });

		        GeoLeaf._UIFilterPanelApplier.refreshPoiLayer(filtered);
		    };

		    /**
		     * Filtre une liste de POI selon les crit√®res fournis
		     * D√©l√®gue vers GeoLeaf.Filters.filterPoiList()
		     *
		     * @param {Array} basePois - Liste compl√®te des POI
		     * @param {Object} filterState - √âtat des filtres
		     * @returns {Array} POI filtr√©s
		     */
		    GeoLeaf._UIFilterPanelApplier.filterPoiList = function(basePois, filterState) {
		        if (GeoLeaf.Filters && typeof GeoLeaf.Filters.filterPoiList === 'function') {
		            return GeoLeaf.Filters.filterPoiList(basePois, filterState);
		        }

		        const Log = getLog();
		        Log.warn('[GeoLeaf.UI.FilterPanel] Module Filters non charg√©, retour liste compl√®te');
		        return basePois || [];
		    };

		    /**
		     * Filtre une liste de routes selon les crit√®res fournis
		     * D√©l√®gue vers GeoLeaf.Filters.filterRouteList()
		     *
		     * @param {Array} baseRoutes - Liste compl√®te des routes
		     * @param {Object} filterState - √âtat des filtres
		     * @returns {Array} Routes filtr√©es
		     */
		    GeoLeaf._UIFilterPanelApplier.filterRouteList = function(baseRoutes, filterState) {
		        if (GeoLeaf.Filters && typeof GeoLeaf.Filters.filterRouteList === 'function') {
		            return GeoLeaf.Filters.filterRouteList(baseRoutes, filterState);
		        }

		        const Log = getLog();
		        Log.warn('[GeoLeaf.UI.FilterPanel] Module Filters non charg√©, retour liste compl√®te');
		        return baseRoutes || [];
		    };

		    /**
		     * Applique les filtres initiaux au chargement
		     */
		    GeoLeaf._UIFilterPanelApplier.applyFiltersInitial = function() {
		        const Log = getLog();
		        const Shared = getShared();
		        const StateReader = getStateReader();

		        const panelEl = Shared.getFilterPanelElement();
		        if (!panelEl) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Panneau de filtres non trouv√©, impossible d'appliquer les filtres initiaux.");
		            return;
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Application des filtres initiaux...");

		        const state = StateReader.readFiltersFromPanel(panelEl);
		        const basePois = Shared.getBasePois();
		        const baseRoutes = Shared.getBaseRoutes();

		        if (!basePois.length && !baseRoutes.length) {
		            Log.info("[GeoLeaf.UI.FilterPanel] Aucun POI ni route source trouv√©.");
		            return;
		        }

		        // G√©rer les itin√©raires
		        if (GeoLeaf.Route && typeof GeoLeaf.Route.isInitialized === 'function' && GeoLeaf.Route.isInitialized()) {
		            if (state.dataTypes.routes) {
		                let filteredRoutes = GeoLeaf._UIFilterPanelApplier.filterRouteList(baseRoutes, state);
		                if (typeof GeoLeaf.Route.loadFromConfig === 'function') {
		                    GeoLeaf.Route.loadFromConfig(filteredRoutes);
		                }
		                GeoLeaf.Route.show();
		            } else {
		                GeoLeaf.Route.hide();
		            }
		        }

		        // Filtrer et charger les POI
		        const filtered = GeoLeaf._UIFilterPanelApplier.filterPoiList(basePois, state);
		        Log.info("[GeoLeaf.UI.FilterPanel] POI filtr√©s pour chargement initial.", {
		            total: basePois.length,
		            result: filtered.length
		        });

		        GeoLeaf._UIFilterPanelApplier.refreshPoiLayer(filtered);
		    };

		})(window);
		return applier;
	}

	requireApplier();

	var renderer$2 = {};

	/**
	 * GeoLeaf UI Filter Panel - Renderer
	 * Construction du panneau HTML de filtres
	 *
	 * @module ui/filter-panel/renderer
	 */

	var hasRequiredRenderer$2;

	function requireRenderer$2 () {
		if (hasRequiredRenderer$2) return renderer$2;
		hasRequiredRenderer$2 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // Helper pour utiliser createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);
		    const getShared = () => GeoLeaf._UIFilterPanelShared;
		    const getStateReader = () => GeoLeaf._UIFilterPanelStateReader;
		    const getApplier = () => GeoLeaf._UIFilterPanelApplier;

		    GeoLeaf._UIFilterPanelRenderer = GeoLeaf._UIFilterPanelRenderer || {};
		    GeoLeaf._UIFilterPanelRenderer._eventCleanups = [];

		    /**
		     * Construit le panneau de filtres depuis la configuration du profil actif
		     * @param {Object} options - Options
		     * @param {HTMLElement} [options.container] - Conteneur cible
		     */
		    GeoLeaf._UIFilterPanelRenderer.buildFilterPanelFromActiveProfile = function(options) {
		        const Log = getLog();
		        const Shared = getShared();
		        const StateReader = getStateReader();
		        const Applier = getApplier();

		        if (Log) Log.debug("[FilterPanel] buildFilterPanelFromActiveProfile APPEL√â, options:", options);

		        const profile = GeoLeaf.UI._getActiveProfileConfig();
		        if (Log) Log.debug("[FilterPanel] Profile r√©cup√©r√©:", profile);

		        if (!profile) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Aucun profil actif trouv√©");
		            return;
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Profil actif:", profile.id || "unknown");

		        // Support both profile.panels.search (old) and profile.search (new)
		        const searchPanel = (profile.panels && profile.panels.search) || profile.search;
		        if (Log) Log.debug("[FilterPanel] searchPanel:", searchPanel);

		        if (!searchPanel) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Aucune configuration search/panels.search dans le profil");
		            return;
		        }

		        const filters = searchPanel && Array.isArray(searchPanel.filters) ? searchPanel.filters : null;
		        if (Log) Log.debug("[FilterPanel] Filters:", filters);

		        if (!filters || !filters.length) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Aucun filtre d√©fini dans profile.search.filters pour le profil actif. Filters:", filters);
		            return;
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Nombre de filtres trouv√©s:", filters.length);

		        const container = (options && options.container) || Shared.getFilterPanelElement();
		        if (!container) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Conteneur de panneau introuvable");
		            return;
		        }

		        // ---------------------------------------------------------
		        // Vider le conteneur existant
		        // ---------------------------------------------------------
		        while (container.firstChild) {
		            container.removeChild(container.firstChild);
		        }

		        container.classList.add("gl-filter-panel");

		        // ---------------------------------------------------------
		        // Header
		        // ---------------------------------------------------------
		        const header = $create("div", {
		            className: "gl-filter-panel__header"
		        });

		        const title = $create("h2", {
		            className: "gl-filter-panel__title",
		            textContent: searchPanel.title || "Filtres"
		        });
		        header.appendChild(title);

		        // Bouton toggle avec fl√®che (comme le tableau)
		        const toggleBtn = $create("button", {
		            type: "button",
		            className: "gl-filter-panel__toggle-btn",
		            attributes: {
		                "data-gl-action": "filter-close",
		                "aria-label": "Fermer le panneau"
		            }
		        });
		        const toggleIcon = $create("span", {
		            className: "gl-filter-panel__toggle-icon",
		            textContent: "‚óÄ"
		        });
		        toggleBtn.appendChild(toggleIcon);
		        header.appendChild(toggleBtn);

		        container.appendChild(header);

		        // ---------------------------------------------------------
		        // Body : champs de filtre
		        // ---------------------------------------------------------
		        const body = $create("div", {
		            className: "gl-filter-panel__body"
		        });

		        // Sprint 3.2: Use DocumentFragment for batch DOM operations
		        const bodyFragment = document.createDocumentFragment();

		        filters.forEach(function(filterDef) {
		            // Passer skipLabel=true pour les filtres avec accord√©on (categories et tags) et proximity (qui g√®re son propre label)
		            const skipLabel = (filterDef.id === 'categories' || filterDef.id === 'tags' || filterDef.type === 'proximity');
		            const groupEl = GeoLeaf.UI._buildFilterControl(filterDef, profile, skipLabel);

		            if (groupEl) {
		                // Wrapper avec accord√©on pour categories et tags
		                if (filterDef.id === 'categories' || filterDef.id === 'tags') {
		                    const accordionGroup = $create("div", {
		                        className: "gl-filter-panel__group--accordion",
		                        attributes: { "data-accordion-for": filterDef.id }
		                    });

		                    const accordionHeader = $create("div", {
		                        className: "gl-filter-panel__accordion-header"
		                    });

		                    const accordionTitle = $create("h3", {
		                        className: "gl-filter-panel__accordion-title",
		                        textContent: filterDef.label || (filterDef.id === 'categories' ? 'Afficher les cat√©gories' : 'Afficher les tags')
		                    });

		                    const accordionArrow = $create("span", {
		                        className: "gl-filter-panel__accordion-arrow",
		                        textContent: "‚ñ∂"
		                    });

		                    accordionHeader.appendChild(accordionTitle);
		                    accordionHeader.appendChild(accordionArrow);

		                    const accordionBody = $create("div", {
		                        className: "gl-filter-panel__accordion-body"
		                    });

		                    // Wrapper n√©cessaire pour la technique CSS Grid
		                    const accordionWrapper = $create("div");
		                    accordionWrapper.appendChild(groupEl);
		                    accordionBody.appendChild(accordionWrapper);

		                    const accordionClickHandler = function() {
		                        requestAnimationFrame(function() {
		                            accordionGroup.classList.toggle("is-expanded");

		                            const isExpanded = accordionGroup.classList.contains("is-expanded");

		                            // LAZY LOADING: Charger le contenu √† la demande si n√©cessaire
		                            if (isExpanded) {
		                                GeoLeaf._UIFilterPanelRenderer._loadAccordionContentIfNeeded(accordionGroup, filterDef);
		                            } else {
		                                // Marquer comme ferm√©
		                                const LazyLoader = GeoLeaf._UIFilterPanelLazyLoader;
		                                if (LazyLoader) {
		                                    LazyLoader.markAccordionClosed(accordionGroup);
		                                }
		                            }
		                        });
		                    };

		                    const events = GeoLeaf.Utils?.events;
		                    if (events) {
		                        GeoLeaf._UIFilterPanelRenderer._eventCleanups.push(
		                            events.on(
		                                accordionHeader,
		                                "click",
		                                accordionClickHandler,
		                                false,
		                                'FilterPanel.accordionToggle'
		                            )
		                        );
		                    } else {
		                        accordionHeader.addEventListener("click", accordionClickHandler);
		                    }

		                    accordionGroup.appendChild(accordionHeader);
		                    accordionGroup.appendChild(accordionBody);
		                    bodyFragment.appendChild(accordionGroup);
		                } else {
		                    bodyFragment.appendChild(groupEl);
		                }
		            }
		        });

		        body.appendChild(bodyFragment);

		        container.appendChild(body);

		        // ---------------------------------------------------------
		        // Footer : boutons Appliquer / R√©initialiser
		        // ---------------------------------------------------------
		        const footer = $create("div", {
		            className: "gl-filter-panel__footer"
		        });

		        const applyBtn = $create("button", {
		            type: "button",
		            className: "gl-btn gl-btn--accent gl-filter-panel__btn-apply",
		            textContent: (searchPanel.actions && searchPanel.actions.applyLabel) || "Appliquer"
		        });
		        footer.appendChild(applyBtn);

		        const resetBtn = $create("button", {
		            type: "button",
		            className: "gl-btn gl-btn--subtle gl-filter-panel__btn-reset",
		            textContent: (searchPanel.actions && searchPanel.actions.resetLabel) || "R√©initialiser"
		        });
		        footer.appendChild(resetBtn);

		        container.appendChild(footer);

		        // ---------------------------------------------------------
		        // Wiring √©v√®nements (fermer / reset / appliquer)
		        // ---------------------------------------------------------
		        if (!container._glFilterHandlersBound) {
		            // D√©clarer events une seule fois pour tout le bloc
		            const events = GeoLeaf.Utils?.events;

		            const containerClickHandler = function(evt) {
		                const target = evt.target;

		                // Fermer le panneau (utilise closest pour g√©rer les clics sur les enfants du bouton)
		                if (target.closest("[data-gl-action='filter-close']")) {
		                    evt.preventDefault();
		                    GeoLeaf._UIFilterPanelRenderer.toggleFilterPanelVisibility(false);
		                    return;
		                }

		                // R√©initialiser les filtres + r√©afficher tous les POI
		                if (target.classList.contains("gl-filter-panel__btn-reset")) {
		                    evt.preventDefault();
		                    StateReader.resetControls(container);
		                    Applier.applyFiltersNow(container, true); // skipRoutes=true to preserve route styling
		                    return;
		                }

		                // Appliquer les filtres
		                if (target.classList.contains("gl-filter-panel__btn-apply")) {
		                    evt.preventDefault();
		                    Applier.applyFiltersNow(container);
		                    return;
		                }
		            };

		            if (events) {
		                GeoLeaf._UIFilterPanelRenderer._eventCleanups.push(
		                    events.on(
		                        container,
		                        "click",
		                        containerClickHandler,
		                        false,
		                        'FilterPanel.containerClick'
		                    )
		                );
		            } else {
		                container.addEventListener("click", containerClickHandler);
		            }

		            // Gestionnaire pour la touche Entr√©e dans l'input de recherche textuelle
		            const containerKeydownHandler = function(evt) {
		                if (evt.key === "Enter" || evt.keyCode === 13) {
		                    const target = evt.target;
		                    const searchInput = target.closest("[data-gl-filter-id='searchText'] input[type='text']");
		                    if (searchInput) {
		                        evt.preventDefault();
		                        Applier.applyFiltersNow(container);
		                        return;
		                    }
		                }
		            };

		            if (events) {
		                GeoLeaf._UIFilterPanelRenderer._eventCleanups.push(
		                    events.on(
		                        container,
		                        "keydown",
		                        containerKeydownHandler,
		                        false,
		                        'FilterPanel.enterKey'
		                    )
		                );
		            } else {
		                container.addEventListener("keydown", containerKeydownHandler);
		            }

		            container._glFilterHandlersBound = true;
		        }

		        // Le panneau doit √™tre masqu√© par d√©faut au d√©marrage
		        // Il ne s'affichera que lorsque l'utilisateur cliquera sur le bouton toggle
		        container.classList.remove("is-open");
		    };

		    /**
		     * Bascule la visibilit√© du panneau de filtres.
		     * @param {boolean} [forceState] - Force l'√©tat (true = ouvert, false = ferm√©)
		     */
		    GeoLeaf._UIFilterPanelRenderer.toggleFilterPanelVisibility = function(forceState) {
		        const Shared = getShared();
		        const container = Shared.getFilterPanelElement();
		        if (!container) return;

		        const isOpen = container.classList.contains("is-open");
		        let nextState;

		        if (typeof forceState === "boolean") {
		            nextState = forceState;
		        } else {
		            nextState = !isOpen;
		        }

		        if (nextState) {
		            container.classList.add("is-open");
		        } else {
		            container.classList.remove("is-open");
		        }

		        // Mettre √† jour l'ic√¥ne du bouton toggle externe
		        const toggleBtn = document.getElementById("gl-filter-toggle");
		        if (toggleBtn) {
		            const icon = toggleBtn.querySelector(".gl-filter-toggle__icon");
		            if (icon) {
		                if (nextState) {
		                    // Panneau ouvert : fl√®che vers la gauche (pour fermer)
		                    // SAFE: SVG statique hardcod√©
		                    GeoLeaf.DOMSecurity.clearElementFast(icon);
		                    const svg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M15 18l-6-6 6-6', {
		                        stroke: 'currentColor',
		                        strokeWidth: '6',
		                        fill: 'none'
		                    });
		                    icon.appendChild(svg);
		                    toggleBtn.setAttribute("aria-label", "Fermer le panneau de filtres");
		                } else {
		                    // Panneau ferm√© : fl√®che vers la droite (pour ouvrir)
		                    // SAFE: SVG statique hardcod√©
		                    GeoLeaf.DOMSecurity.clearElementFast(icon);
		                    const svg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M9 6l6 6-6 6', {
		                        stroke: 'currentColor',
		                        strokeWidth: '6',
		                        fill: 'none'
		                    });
		                    icon.appendChild(svg);
		                    toggleBtn.setAttribute("aria-label", "Ouvrir le panneau de filtres");
		                }
		            }
		        }
		    };

		    /**
		     * Initialise le bouton toggle du panneau de filtres
		     */
		    GeoLeaf._UIFilterPanelRenderer.initFilterToggle = function() {
		        const Log = getLog();
		        const Shared = getShared();

		        const toggleBtn = document.getElementById("gl-filter-toggle");
		        const panel = Shared.getFilterPanelElement();

		        if (!toggleBtn || !panel) {
		            Log.info("[GeoLeaf.UI.FilterPanel] Bouton toggle ou panneau filtres introuvable");
		            return;
		        }

		        const toggleClickHandler = function() {
		            const isOpen = panel.classList.contains("is-open");
		            const icon = toggleBtn.querySelector(".gl-filter-toggle__icon");

		            if (isOpen) {
		                panel.classList.remove("is-open");
		                if (icon) {
		                    // SAFE: SVG statique hardcod√©
		                    GeoLeaf.DOMSecurity.clearElementFast(icon);
		                    const svg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M9 6l6 6-6 6', {
		                        stroke: 'currentColor',
		                        strokeWidth: '6',
		                        fill: 'none'
		                    });
		                    icon.appendChild(svg);
		                }
		                toggleBtn.setAttribute("aria-label", "Ouvrir le panneau de filtres");
		            } else {
		                panel.classList.add("is-open");
		                if (icon) {
		                    // SAFE: SVG statique hardcod√©
		                    GeoLeaf.DOMSecurity.clearElementFast(icon);
		                    const svg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M15 18l-6-6 6-6', {
		                        stroke: 'currentColor',
		                        strokeWidth: '6',
		                        fill: 'none'
		                    });
		                    icon.appendChild(svg);
		                }
		                toggleBtn.setAttribute("aria-label", "Fermer le panneau de filtres");
		            }
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._UIFilterPanelRenderer._eventCleanups.push(
		                events.on(
		                    toggleBtn,
		                    "click",
		                    toggleClickHandler,
		                    false,
		                    'FilterPanel.toggleButton'
		                )
		            );
		        } else {
		            toggleBtn.addEventListener("click", toggleClickHandler);
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Bouton toggle filtres initialis√©");
		    };

		    /**
		     * Rafra√Æchit les badges de tags dans le panneau de filtres.
		     * Doit √™tre appel√© APR√àS que les POI ont √©t√© charg√©s.
		     */
		    GeoLeaf._UIFilterPanelRenderer.refreshFilterTags = function() {
		        const Log = getLog();
		        const Shared = getShared();

		        const container = Shared.getFilterPanelElement();
		        if (!container) {
		            Log.warn("[GeoLeaf.UI.FilterPanel.refreshFilterTags] Panneau de filtres non trouv√©");
		            return;
		        }

		        // R√©cup√©rer POI et routes
		        const basePois = Shared.getBasePois();
		        const baseRoutes = Shared.getBaseRoutes();
		        const allItems = basePois.concat(baseRoutes);

		        Log.debug("[GeoLeaf.UI.FilterPanel.refreshFilterTags] Items:", basePois.length, "POI,", baseRoutes.length, "routes");

		        // Collecter tous les tags
		        const allTags = Shared.collectAllTags(allItems);

		        // Peupler les badges
		        GeoLeaf._UIFilterPanelRenderer.populateTagsBadges(container, allTags);
		    };

		    /**
		     * Peuple le conteneur de badges avec les tags fournis
		     * @param {HTMLElement} panelEl - √âl√©ment du panneau de filtres
		     * @param {Array} allTags - Liste des tags uniques
		     */
		    GeoLeaf._UIFilterPanelRenderer.populateTagsBadges = function(panelEl, allTags) {
		        const Log = getLog();
		        const wrapper = panelEl.querySelector("[data-gl-filter-id='tags']");
		        if (!wrapper) {
		            Log.debug("[GeoLeaf.UI.FilterPanel] Wrapper tags non trouv√© - probablement pas utilis√© dans ce profil");
		            return;
		        }

		        const tagsContainer = wrapper.querySelector(".gl-filter-panel__tags-container");
		        if (!tagsContainer) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Container tags non trouv√©");
		            return;
		        }

		        // Trouver l'accord√©on parent par l'attribut data-accordion-for
		        const accordionGroup = panelEl.querySelector("[data-accordion-for='tags']");
		        Log.debug("[GeoLeaf.UI.FilterPanel] Recherche accord√©on avec [data-accordion-for='tags']");
		        Log.debug("[GeoLeaf.UI.FilterPanel] Accord√©on trouv√©:", accordionGroup);

		        // Vider le container
		        while (tagsContainer.firstChild) {
		            tagsContainer.removeChild(tagsContainer.firstChild);
		        }

		        // Si pas de tags, cacher compl√®tement l'accord√©on parent
		        if (!allTags.length) {
		            Log.debug("[GeoLeaf.UI.FilterPanel] Pas de tags (count:", allTags.length, ")");
		            if (accordionGroup) {
		                accordionGroup.style.display = "none";
		                Log.info("[GeoLeaf.UI.FilterPanel] Accord√©on tags CACH√â (display: none)");
		            } else {
		                Log.warn("[GeoLeaf.UI.FilterPanel] Accord√©on tags non trouv√© pour le cacher");
		            }
		            return;
		        }

		        // S'il y a des tags, s'assurer que l'accord√©on est visible
		        Log.debug("[GeoLeaf.UI.FilterPanel] Tags d√©tect√©s (count:", allTags.length, ")");
		        if (accordionGroup) {
		            accordionGroup.style.display = "";
		            Log.info("[GeoLeaf.UI.FilterPanel] Accord√©on tags AFFICH√â");
		        }

		        // Cr√©er les badges
		        // Sprint 3.2: Use DocumentFragment for batch DOM operations
		        const tagsFragment = document.createDocumentFragment();

		        allTags.forEach(function(tag) {
		            const badgeClickHandler = function() {
		                this.classList.toggle("is-selected");
		            };

		            const badge = $create("span", {
		                className: "gl-filter-panel__tag-badge",
		                textContent: tag,
		                attributes: { "data-tag-value": tag },
		                onClick: badgeClickHandler
		            });

		            const events = GeoLeaf.Utils?.events;
		            if (events) {
		                GeoLeaf._UIFilterPanelRenderer._eventCleanups.push(
		                    events.on(
		                        badge,
		                        "click",
		                        badgeClickHandler,
		                        false,
		                        'FilterPanel.tagBadge'
		                    )
		                );
		            } else {
		                badge.addEventListener("click", badgeClickHandler);
		            }

		            tagsFragment.appendChild(badge);
		        });

		        tagsContainer.appendChild(tagsFragment);
		    };

		    /**
		     * Cleanup method for event listeners
		     * Call this when destroying the filter panel
		     * MEMORY LEAK FIX (Phase 2): Also cleanup timeouts in applier
		     */
		    GeoLeaf._UIFilterPanelRenderer.destroy = function() {
		        const Log = getLog();
		        if (Log) Log.debug("[FilterPanel] Cleaning up event listeners");

		        if (GeoLeaf._UIFilterPanelRenderer._eventCleanups) {
		            GeoLeaf._UIFilterPanelRenderer._eventCleanups.forEach(cleanup => {
		                if (typeof cleanup === 'function') {
		                    cleanup();
		                }
		            });
		            GeoLeaf._UIFilterPanelRenderer._eventCleanups = [];
		        }

		        // MEMORY LEAK FIX (Phase 2): Cleanup applier timeouts
		        if (GeoLeaf._UIFilterPanelApplier && GeoLeaf._UIFilterPanelApplier.destroy) {
		            GeoLeaf._UIFilterPanelApplier.destroy();
		        }
		    };

		    /**
		     * Charge le contenu d'un accord√©on √† la demande (lazy loading)
		     * @param {HTMLElement} accordionGroup - Element de l'accord√©on
		     * @param {Object} filterDef - D√©finition du filtre
		     */
		    GeoLeaf._UIFilterPanelRenderer._loadAccordionContentIfNeeded = function(accordionGroup, filterDef) {
		        const Log = getLog();
		        const LazyLoader = GeoLeaf._UIFilterPanelLazyLoader;

		        if (!LazyLoader) {
		            Log.warn("[FilterPanel] LazyLoader non disponible");
		            return;
		        }

		        // V√©rifier si le contenu a d√©j√† √©t√© charg√© (le flag est reset √† "false" lors d'un changement de th√®me)
		        if (accordionGroup.dataset.lazyLoaded === "true") {
		            Log.debug("[FilterPanel] Accord√©on d√©j√† charg√© pour ce th√®me, skip");
		            return;
		        }

		        // Trouver le container de contenu
		        const contentArea = accordionGroup.querySelector('[data-lazy-type]');
		        if (!contentArea) {
		            Log.debug("[FilterPanel] Pas de zone lazy dans cet accord√©on");
		            return;
		        }

		        const lazyType = contentArea.dataset.lazyType;
		        Log.info(`[FilterPanel] Chargement lazy du contenu: ${lazyType}`);

		        // R√©cup√©rer le th√®me actif (avec fallback sur le th√®me par d√©faut du profil)
		        let currentTheme = GeoLeaf.ThemeSelector?.getCurrentTheme();
		        if (!currentTheme) {
		            // Fallback : r√©cup√©rer le th√®me par d√©faut depuis le profil
		            const profile = (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === "function")
		                ? GeoLeaf.Config.getActiveProfile()
		                : null;
		            if (profile && profile.themes && profile.themes.config && profile.themes.config.defautTheme) {
		                currentTheme = profile.themes.config.defautTheme;
		                Log.info("[FilterPanel] Fallback sur le th√®me par d√©faut:", currentTheme);
		            }
		        }
		        if (!currentTheme) {
		            // Dernier fallback : utiliser "defaut" comme ID g√©n√©rique
		            currentTheme = "defaut";
		            Log.warn("[FilterPanel] Th√®me actif introuvable, utilisation de 'defaut'");
		        }

		        // Afficher un spinner pendant le chargement
		        contentArea.innerHTML = '<div class="gl-filter-panel__loading">Chargement...</div>';

		        // Charger de mani√®re asynchrone pour ne pas bloquer l'UI
		        setTimeout(() => {
		            try {
		                if (lazyType === 'categories') {
		                    const result = LazyLoader.loadCategories(currentTheme);

		                    // V√©rifier s'il y a des cat√©gories
		                    if (!result.usedIds || result.usedIds.size === 0) {
		                        contentArea.innerHTML = '<div class="gl-filter-panel__empty">Aucune cat√©gorie disponible sur les couches visibles</div>';
		                        accordionGroup.dataset.lazyLoaded = "true";
		                        return;
		                    }

		                    // Construire le contenu HTML
		                    if (typeof window._buildCategoryTreeContent === "function") {
		                        const htmlContent = window._buildCategoryTreeContent(result);
		                        contentArea.innerHTML = htmlContent;

		                        // Attacher les event listeners
		                        if (typeof window._attachCategoryTreeListeners === "function") {
		                            window._attachCategoryTreeListeners(contentArea);
		                        }
		                    } else {
		                        contentArea.innerHTML = '<div class="gl-filter-panel__error">Erreur: fonction de construction introuvable</div>';
		                    }

		                    // Marquer l'accord√©on comme ouvert
		                    LazyLoader.markAccordionOpen('categories', accordionGroup);

		                } else if (lazyType === 'tags') {
		                    const tags = LazyLoader.loadTags(currentTheme);

		                    // V√©rifier s'il y a des tags
		                    if (!tags || tags.length === 0) {
		                        contentArea.innerHTML = '<div class="gl-filter-panel__empty">Aucun tag disponible sur les couches visibles</div>';
		                        accordionGroup.dataset.lazyLoaded = "true";
		                        return;
		                    }

		                    // Construire le contenu HTML
		                    if (typeof window._buildTagsListContent === "function") {
		                        const htmlContent = window._buildTagsListContent(tags);
		                        contentArea.innerHTML = htmlContent;

		                        // Attacher les event listeners
		                        if (typeof window._attachTagsListeners === "function") {
		                            window._attachTagsListeners(contentArea);
		                        }
		                    } else {
		                        contentArea.innerHTML = '<div class="gl-filter-panel__error">Erreur: fonction de construction introuvable</div>';
		                    }

		                    // Marquer l'accord√©on comme ouvert
		                    LazyLoader.markAccordionOpen('tags', accordionGroup);
		                }

		                // Marquer comme charg√©
		                accordionGroup.dataset.lazyLoaded = "true";

		            } catch (err) {
		                Log.error("[FilterPanel] Erreur durant le chargement lazy:", err);
		                while (contentArea.firstChild) contentArea.removeChild(contentArea.firstChild);
		                const errDiv = document.createElement('div');
		                errDiv.className = 'gl-filter-panel__error';
		                errDiv.textContent = 'Erreur: ' + err.message;
		                contentArea.appendChild(errDiv);
		            }
		        }, 10); // 10ms delay pour laisser l'accord√©on s'ouvrir
		    };

		})(window);
		return renderer$2;
	}

	requireRenderer$2();

	var proximity = {};

	/**
	 * GeoLeaf UI Filter Panel - Proximity
	 * Gestion des filtres de proximit√© (GPS, manuel, cercle)
	 *
	 * @module ui/filter-panel/proximity
	 */

	var hasRequiredProximity;

	function requireProximity () {
		if (hasRequiredProximity) return proximity;
		hasRequiredProximity = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._UIFilterPanelProximity = GeoLeaf._UIFilterPanelProximity || {};
		    GeoLeaf._UIFilterPanelProximity._eventCleanups = [];

		    /**
		     * Initialise la fonctionnalit√© de proximit√©
		     * @param {L.Map} map - Instance de carte Leaflet
		     */
		    GeoLeaf._UIFilterPanelProximity.initProximityFilter = function(map) {
		        const Log = getLog();

		        if (!map) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Carte non disponible pour le filtre de proximit√©");
		            return;
		        }

		        // Stocker sur GeoLeaf.UI pour acc√®s global
		        GeoLeaf.UI._proximityMode = false;
		        GeoLeaf.UI._proximityCircle = null;
		        GeoLeaf.UI._proximityMarker = null;
		        GeoLeaf.UI._proximityMap = map;
		        GeoLeaf.UI._proximityClickHandler = null;

		        // √âcouter les changements sur le slider de rayon - avec cleanup tracking
		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            const inputHandler = function(evt) {
		                const slider = evt.target.closest("[data-filter-proximity-radius]");
		                if (!slider) return;

		                const proximityControl = slider.closest(".gl-filter-panel__proximity");
		                if (!proximityControl) return;

		                const wrapper = proximityControl.closest("[data-gl-filter-id='proximity']");
		                if (!wrapper) return;

		                const newRadius = parseFloat(slider.value);

		                // Mettre √† jour l'attribut sur le wrapper
		                wrapper.setAttribute("data-proximity-radius", newRadius);

		                // Si un cercle existe, le mettre √† jour visuellement
		                if (GeoLeaf.UI._proximityCircle) {
		                    const radiusMeters = newRadius * 1000;
		                    GeoLeaf.UI._proximityCircle.setRadius(radiusMeters);
		                }
		            };

		            const clickHandler = function(evt) {
		                const btn = evt.target.closest("[data-filter-proximity-btn]");
		                if (!btn) return;

		                evt.preventDefault();
		                GeoLeaf._UIFilterPanelProximity.toggleProximityMode(btn, map);
		            };

		            GeoLeaf._UIFilterPanelProximity._eventCleanups.push(
		                events.on(
		                    document,
		                    "input",
		                    inputHandler,
		                    false,
		                    'ProximityFilter.radiusInput'
		                )
		            );
		            GeoLeaf._UIFilterPanelProximity._eventCleanups.push(
		                events.on(
		                    document,
		                    "click",
		                    clickHandler,
		                    false,
		                    'ProximityFilter.buttonClick'
		                )
		            );
		        } else {
		            // Fallback sans cleanup
		            Log.warn('[ProximityFilter] EventListenerManager not available - listeners will not be cleaned up');
		            document.addEventListener("input", function(evt) {
		                const slider = evt.target.closest("[data-filter-proximity-radius]");
		                if (!slider) return;
		                const proximityControl = slider.closest(".gl-filter-panel__proximity");
		                if (!proximityControl) return;
		                const wrapper = proximityControl.closest("[data-gl-filter-id='proximity']");
		                if (!wrapper) return;
		                const newRadius = parseFloat(slider.value);
		                wrapper.setAttribute("data-proximity-radius", newRadius);
		                if (GeoLeaf.UI._proximityCircle) {
		                    const radiusMeters = newRadius * 1000;
		                    GeoLeaf.UI._proximityCircle.setRadius(radiusMeters);
		                }
		            });
		            document.addEventListener("click", function(evt) {
		                const btn = evt.target.closest("[data-filter-proximity-btn]");
		                if (!btn) return;
		                evt.preventDefault();
		                GeoLeaf._UIFilterPanelProximity.toggleProximityMode(btn, map);
		            });
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Filtre de proximit√© initialis√©");
		    };

		    /**
		     * Cleanup du filtre de proximit√©
		     */
		    GeoLeaf._UIFilterPanelProximity.destroy = function() {
		        const Log = getLog();

		        // Cleanup event listeners
		        if (GeoLeaf._UIFilterPanelProximity._eventCleanups && GeoLeaf._UIFilterPanelProximity._eventCleanups.length > 0) {
		            GeoLeaf._UIFilterPanelProximity._eventCleanups.forEach(cleanup => {
		                if (typeof cleanup === 'function') cleanup();
		            });
		            GeoLeaf._UIFilterPanelProximity._eventCleanups = [];
		            Log.info('[ProximityFilter] Event listeners cleaned up');
		        }

		        // Cleanup map references
		        if (GeoLeaf.UI._proximityCircle) {
		            GeoLeaf.UI._proximityMap.removeLayer(GeoLeaf.UI._proximityCircle);
		            GeoLeaf.UI._proximityCircle = null;
		        }
		        if (GeoLeaf.UI._proximityMarker) {
		            GeoLeaf.UI._proximityMap.removeLayer(GeoLeaf.UI._proximityMarker);
		            GeoLeaf.UI._proximityMarker = null;
		        }

		        GeoLeaf.UI._proximityMap = null;
		        GeoLeaf.UI._proximityMode = false;
		    };

		    /**
		     * Bascule le mode de proximit√©
		     * @param {HTMLElement} btn - Bouton de proximit√©
		     * @param {L.Map} map - Instance de carte
		     */
		    GeoLeaf._UIFilterPanelProximity.toggleProximityMode = function(btn, map) {

		        GeoLeaf.UI._proximityMode = !GeoLeaf.UI._proximityMode;

		        const container = btn.closest(".gl-filter-panel__proximity");
		        const rangeWrapper = container.querySelector(".gl-filter-panel__proximity-range");
		        const instruction = container.querySelector(".gl-filter-panel__proximity-instruction");

		        if (GeoLeaf.UI._proximityMode) {
		            btn.textContent = "D√©sactiver";
		            btn.classList.add("is-active");
		            if (rangeWrapper) rangeWrapper.style.display = "block";
		            if (instruction) instruction.style.display = "block";

		            // V√©rifier si la position GPS est disponible et r√©cente (< 5 minutes)
		            const hasRecentGPS = GeoLeaf.UI._userPosition &&
		                                (Date.now() - GeoLeaf.UI._userPosition.timestamp < 300000);

		            if (hasRecentGPS) {
		                GeoLeaf._UIFilterPanelProximity.activateGPSMode(container, map);
		            } else {
		                GeoLeaf._UIFilterPanelProximity.activateManualMode(container, map);
		            }

		        } else {
		            // D√©sactiver le mode proximit√©
		            GeoLeaf._UIFilterPanelProximity.deactivateProximityMode(btn, container, map);
		        }
		    };

		    /**
		     * Active le mode GPS automatique
		     * @param {HTMLElement} container - Container de proximit√©
		     * @param {L.Map} map - Instance de carte
		     */
		    GeoLeaf._UIFilterPanelProximity.activateGPSMode = function(container, map) {
		        const Log = getLog();

		        Log.info("[GeoLeaf.UI.FilterPanel] Utilisation de la position GPS pour la recherche par proximit√©");

		        const radiusInput = container.querySelector("[data-filter-proximity-radius]");
		        const radius = radiusInput ? parseFloat(radiusInput.value) : 10;
		        const radiusMeters = radius * 1000;

		        const wrapper = container.closest("[data-gl-filter-id='proximity']");
		        if (!wrapper) {
		            Log.warn("[GeoLeaf.UI.FilterPanel] Wrapper proximity non trouv√©");
		            return;
		        }

		        // Supprimer les √©l√©ments existants
		        if (GeoLeaf.UI._proximityCircle) {
		            map.removeLayer(GeoLeaf.UI._proximityCircle);
		        }
		        if (GeoLeaf.UI._proximityMarker) {
		            map.removeLayer(GeoLeaf.UI._proximityMarker);
		        }

		        // Cr√©er le cercle √† la position GPS
		        const gpsLatLng = global.L.latLng(GeoLeaf.UI._userPosition.lat, GeoLeaf.UI._userPosition.lng);

		        const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		        GeoLeaf.UI._proximityCircle = global.L.circle(gpsLatLng, {
		            radius: radiusMeters,
		            color: "#c2410c",
		            fillColor: "#c2410c",
		            fillOpacity: 0.2,
		            weight: 2,
		            interactive: interactiveShapes
		        }).addTo(map);

		        // Ne pas cr√©er de marqueur suppl√©mentaire si la g√©olocalisation est active
		        if (!GeoLeaf.UI._geolocationActive) {
		            // Mode GPS mais g√©olocalisation pas en tracking continu : cr√©er un marqueur draggable
		            GeoLeaf.UI._proximityMarker = global.L.marker(gpsLatLng, {
		                draggable: true,
		                icon: global.L.divIcon({
		                    className: 'gl-proximity-gps-marker',
		                    html: '<div style="width: 20px; height: 20px; background: #2563eb; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
		                    iconSize: [20, 20],
		                    iconAnchor: [10, 10]
		                })
		            }).addTo(map);

		            // G√©rer le d√©placement du marqueur
		            GeoLeaf.UI._proximityMarker.on('dragend', function() {
		                const newLatLng = GeoLeaf.UI._proximityMarker.getLatLng();
		                if (GeoLeaf.UI._proximityCircle) {
		                    GeoLeaf.UI._proximityCircle.setLatLng(newLatLng);
		                }
		                wrapper.setAttribute("data-proximity-lat", newLatLng.lat);
		                wrapper.setAttribute("data-proximity-lng", newLatLng.lng);
		                Log.info("[GeoLeaf.UI.FilterPanel] Point de proximit√© GPS d√©plac√©:", {
		                    lat: newLatLng.lat,
		                    lng: newLatLng.lng,
		                    radius: radius
		                });
		            });
		        } else {
		            GeoLeaf.UI._proximityMarker = null;
		            Log.info("[GeoLeaf.UI.FilterPanel] Cercle de proximit√© affich√© autour du marqueur GPS");
		        }

		        // D√©finir les attributs sur le wrapper
		        wrapper.setAttribute("data-proximity-lat", gpsLatLng.lat);
		        wrapper.setAttribute("data-proximity-lng", gpsLatLng.lng);
		        wrapper.setAttribute("data-proximity-radius", radius);
		        wrapper.setAttribute("data-proximity-active", "true");

		        // Centrer la carte sur la position GPS
		        map.setView(gpsLatLng, Math.max(map.getZoom(), 14), {
		            animate: true,
		            duration: 0.5
		        });

		        Log.info("[GeoLeaf.UI.FilterPanel] Point de proximit√© GPS d√©fini:", {
		            lat: gpsLatLng.lat,
		            lng: gpsLatLng.lng,
		            radius: radius
		        });

		        // Pas de handler de clic n√©cessaire en mode GPS
		        GeoLeaf.UI._proximityClickHandler = null;
		    };

		    /**
		     * Active le mode manuel (clic sur la carte)
		     * @param {HTMLElement} container - Container de proximit√©
		     * @param {L.Map} map - Instance de carte
		     */
		    GeoLeaf._UIFilterPanelProximity.activateManualMode = function(container, map) {
		        const Log = getLog();

		        Log.info("[GeoLeaf.UI.FilterPanel] Mode manuel : cliquez sur la carte pour d√©finir le point de recherche");

		        map.getContainer().style.cursor = "crosshair";

		        // Cr√©er le handler pour pouvoir le retirer plus tard
		        GeoLeaf.UI._proximityClickHandler = function(e) {
		            const radiusInput = container.querySelector("[data-filter-proximity-radius]");
		            const radius = radiusInput ? parseFloat(radiusInput.value) : 10;
		            const radiusMeters = radius * 1000;

		            const wrapper = container.closest("[data-gl-filter-id='proximity']");
		            if (!wrapper) {
		                Log.warn("[GeoLeaf.UI.FilterPanel] Wrapper proximity non trouv√©");
		                return;
		            }

		            if (GeoLeaf.UI._proximityCircle) {
		                map.removeLayer(GeoLeaf.UI._proximityCircle);
		            }
		            if (GeoLeaf.UI._proximityMarker) {
		                map.removeLayer(GeoLeaf.UI._proximityMarker);
		            }

		            const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		            GeoLeaf.UI._proximityCircle = global.L.circle(e.latlng, {
		                radius: radiusMeters,
		                color: "#c2410c",
		                fillColor: "#c2410c",
		                fillOpacity: 0.2,
		                weight: 2,
		                interactive: interactiveShapes
		            }).addTo(map);

		            GeoLeaf.UI._proximityMarker = global.L.marker(e.latlng, {
		                draggable: true
		            }).addTo(map);

		            // G√©rer le d√©placement du marqueur
		            GeoLeaf.UI._proximityMarker.on('dragend', function() {
		                const newLatLng = GeoLeaf.UI._proximityMarker.getLatLng();

		                if (GeoLeaf.UI._proximityCircle) {
		                    GeoLeaf.UI._proximityCircle.setLatLng(newLatLng);
		                }

		                wrapper.setAttribute("data-proximity-lat", newLatLng.lat);
		                wrapper.setAttribute("data-proximity-lng", newLatLng.lng);

		                Log.info("[GeoLeaf.UI.FilterPanel] Point de proximit√© d√©plac√©:", {
		                    lat: newLatLng.lat,
		                    lng: newLatLng.lng,
		                    radius: radius
		                });
		            });

		            // D√©finir les attributs sur le wrapper
		            wrapper.setAttribute("data-proximity-lat", e.latlng.lat);
		            wrapper.setAttribute("data-proximity-lng", e.latlng.lng);
		            wrapper.setAttribute("data-proximity-radius", radius);
		            wrapper.setAttribute("data-proximity-active", "true");

		            map.getContainer().style.cursor = "";

		            Log.info("[GeoLeaf.UI.FilterPanel] Point de proximit√© d√©fini:", {
		                lat: e.latlng.lat,
		                lng: e.latlng.lng,
		                radius: radius
		            });

		            // Nettoyer le handler apr√®s le premier clic
		            map.off('click', GeoLeaf.UI._proximityClickHandler);
		            GeoLeaf.UI._proximityClickHandler = null;
		        };

		        // Attacher le handler √† la carte
		        map.on('click', GeoLeaf.UI._proximityClickHandler);
		    };

		    /**
		     * D√©sactive le mode de proximit√©
		     * @param {HTMLElement} btn - Bouton de proximit√©
		     * @param {HTMLElement} container - Container de proximit√©
		     * @param {L.Map} map - Instance de carte
		     */
		    GeoLeaf._UIFilterPanelProximity.deactivateProximityMode = function(btn, container, map) {
		        const Log = getLog();

		        btn.textContent = "Activer";
		        btn.classList.remove("is-active");

		        const rangeWrapper = container.querySelector(".gl-filter-panel__proximity-range");
		        const instruction = container.querySelector(".gl-filter-panel__proximity-instruction");

		        if (rangeWrapper) rangeWrapper.style.display = "none";
		        if (instruction) instruction.style.display = "none";

		        map.getContainer().style.cursor = "";

		        // Retirer le handler de clic
		        if (GeoLeaf.UI._proximityClickHandler) {
		            map.off('click', GeoLeaf.UI._proximityClickHandler);
		            GeoLeaf.UI._proximityClickHandler = null;
		        }

		        // Retirer le cercle et le marqueur
		        if (GeoLeaf.UI._proximityCircle) {
		            map.removeLayer(GeoLeaf.UI._proximityCircle);
		            GeoLeaf.UI._proximityCircle = null;
		        }
		        if (GeoLeaf.UI._proximityMarker) {
		            map.removeLayer(GeoLeaf.UI._proximityMarker);
		            GeoLeaf.UI._proximityMarker = null;
		        }

		        // Retirer les attributs du wrapper
		        const wrapper = container.closest("[data-gl-filter-id='proximity']");
		        if (wrapper) {
		            wrapper.removeAttribute("data-proximity-active");
		            wrapper.removeAttribute("data-proximity-lat");
		            wrapper.removeAttribute("data-proximity-lng");
		        }

		        Log.info("[GeoLeaf.UI.FilterPanel] Mode proximit√© d√©sactiv√©");
		    };

		})(window);
		return proximity;
	}

	requireProximity();

	var core$4 = {};

	/**
	 * GeoLeaf UI Filter Panel - Core
	 * API publique et d√©l√©gation vers les sous-modules
	 *
	 * @module ui/filter-panel/core
	 */

	var hasRequiredCore$4;

	function requireCore$4 () {
		if (hasRequiredCore$4) return core$4;
		hasRequiredCore$4 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);
		    const getShared = () => GeoLeaf._UIFilterPanelShared;
		    const getStateReader = () => GeoLeaf._UIFilterPanelStateReader;
		    const getApplier = () => GeoLeaf._UIFilterPanelApplier;
		    const getRenderer = () => GeoLeaf._UIFilterPanelRenderer;
		    const getProximity = () => GeoLeaf._UIFilterPanelProximity;

		    // Cr√©er le namespace si n√©cessaire
		    GeoLeaf._UIFilterPanel = GeoLeaf._UIFilterPanel || {};

		    // ========================================
		    //   API PUBLIQUE - D√©l√©gation vers sous-modules
		    // ========================================

		    /**
		     * Construit le panneau de filtres depuis la configuration du profil actif
		     * @param {Object} options - Options
		     */
		    GeoLeaf._UIFilterPanel.buildFilterPanelFromActiveProfile = function(options) {
		        const Renderer = getRenderer();
		        if (Renderer && Renderer.buildFilterPanelFromActiveProfile) {
		            return Renderer.buildFilterPanelFromActiveProfile(options);
		        }
		        getLog().error("[GeoLeaf.UI.FilterPanel] Module Renderer non charg√©");
		    };

		    /**
		     * Bascule la visibilit√© du panneau de filtres
		     * @param {boolean} [forceState]
		     */
		    GeoLeaf._UIFilterPanel.toggleFilterPanelVisibility = function(forceState) {
		        const Renderer = getRenderer();
		        if (Renderer && Renderer.toggleFilterPanelVisibility) {
		            return Renderer.toggleFilterPanelVisibility(forceState);
		        }
		    };

		    /**
		     * Initialise le bouton toggle du panneau de filtres
		     */
		    GeoLeaf._UIFilterPanel.initFilterToggle = function() {
		        const Renderer = getRenderer();
		        if (Renderer && Renderer.initFilterToggle) {
		            return Renderer.initFilterToggle();
		        }
		    };

		    /**
		     * Rafra√Æchit les badges de tags
		     */
		    GeoLeaf._UIFilterPanel.refreshFilterTags = function() {
		        const Renderer = getRenderer();
		        if (Renderer && Renderer.refreshFilterTags) {
		            return Renderer.refreshFilterTags();
		        }
		    };

		    /**
		     * Applique les filtres initiaux
		     */
		    GeoLeaf._UIFilterPanel.applyFiltersInitial = function() {
		        const Applier = getApplier();
		        if (Applier && Applier.applyFiltersInitial) {
		            return Applier.applyFiltersInitial();
		        }
		    };

		    /**
		     * Initialise le filtre de proximit√©
		     * @param {L.Map} map
		     */
		    GeoLeaf._UIFilterPanel.initProximityFilter = function(map) {
		        const Proximity = getProximity();
		        if (Proximity && Proximity.initProximityFilter) {
		            return Proximity.initProximityFilter(map);
		        }
		    };

		    /**
		     * Retourne l'√©l√©ment DOM du panneau de filtres
		     * @returns {HTMLElement|null}
		     */
		    GeoLeaf._UIFilterPanel._getFilterPanelElement = function() {
		        const Shared = getShared();
		        if (Shared && Shared.getFilterPanelElement) {
		            return Shared.getFilterPanelElement();
		        }
		        return null;
		    };

		    /**
		     * R√©cup√®re les POI de base
		     * @returns {Array}
		     */
		    GeoLeaf._UIFilterPanel._getBasePois = function() {
		        const Shared = getShared();
		        if (Shared && Shared.getBasePois) {
		            return Shared.getBasePois();
		        }
		        return [];
		    };

		    /**
		     * R√©cup√®re les routes de base
		     * @returns {Array}
		     */
		    GeoLeaf._UIFilterPanel._getBaseRoutes = function() {
		        const Shared = getShared();
		        if (Shared && Shared.getBaseRoutes) {
		            return Shared.getBaseRoutes();
		        }
		        return [];
		    };

		    /**
		     * Lit l'√©tat des filtres depuis le panneau
		     * @param {HTMLElement} panelEl
		     * @returns {Object}
		     */
		    GeoLeaf._UIFilterPanel._readFiltersFromPanel = function(panelEl) {
		        const StateReader = getStateReader();
		        if (StateReader && StateReader.readFiltersFromPanel) {
		            return StateReader.readFiltersFromPanel(panelEl);
		        }
		        return {};
		    };

		    /**
		     * Filtre une liste de POI
		     * @param {Array} basePois
		     * @param {Object} filterState
		     * @returns {Array}
		     */
		    GeoLeaf._UIFilterPanel._filterPoiList = function(basePois, filterState) {
		        const Applier = getApplier();
		        if (Applier && Applier.filterPoiList) {
		            return Applier.filterPoiList(basePois, filterState);
		        }
		        return basePois || [];
		    };

		    /**
		     * Filtre une liste de routes
		     * @param {Array} baseRoutes
		     * @param {Object} filterState
		     * @returns {Array}
		     */
		    GeoLeaf._UIFilterPanel._filterRouteList = function(baseRoutes, filterState) {
		        const Applier = getApplier();
		        if (Applier && Applier.filterRouteList) {
		            return Applier.filterRouteList(baseRoutes, filterState);
		        }
		        return baseRoutes || [];
		    };

		    /**
		     * Rafra√Æchit la couche POI
		     * @param {Array} filteredPois
		     */
		    GeoLeaf._UIFilterPanel._refreshPoiLayer = function(filteredPois) {
		        const Applier = getApplier();
		        if (Applier && Applier.refreshPoiLayer) {
		            return Applier.refreshPoiLayer(filteredPois);
		        }
		    };

		})(window);
		return core$4;
	}

	requireCore$4();

	var filterPanel = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredFilterPanel;

	function requireFilterPanel () {
		if (hasRequiredFilterPanel) return filterPanel;
		hasRequiredFilterPanel = 1;
		/**
		 * GeoLeaf UI Module - Filter Panel (Aggregator)
		 *
		 * Ce fichier est un agr√©gateur pour la r√©trocompatibilit√©.
		 * La logique a √©t√© d√©plac√©e dans les sous-modules :
		 * - filter-panel/shared.js       : Helpers de donn√©es partag√©s
		 * - filter-panel/state-reader.js : Lecture de l'√©tat des filtres
		 * - filter-panel/applier.js      : Application des filtres
		 * - filter-panel/renderer.js     : Construction du panneau HTML
		 * - filter-panel/proximity.js    : Gestion des filtres de proximit√©
		 * - filter-panel/core.js         : API publique et d√©l√©gation
		 *
		 * @module ui/filter-panel
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // V√©rifier que les sous-modules sont charg√©s
		    const requiredModules = [
		        '_UIFilterPanelShared',
		        '_UIFilterPanelStateReader',
		        '_UIFilterPanelApplier',
		        '_UIFilterPanelRenderer',
		        '_UIFilterPanelProximity',
		        '_UIFilterPanel'
		    ];

		    const missingModules = requiredModules.filter(m => !GeoLeaf[m]);

		    if (missingModules.length > 0) {
		        const Log = GeoLeaf.Log || console;
		        Log.error("[GeoLeaf.UI.FilterPanel] Sous-modules manquants:", missingModules.join(', '));
		        Log.error("[GeoLeaf.UI.FilterPanel] Assurez-vous de charger les modules filter-panel/*.js avant filter-panel.js");
		    }

		    // L'API publique est expos√©e via GeoLeaf._UIFilterPanel (dans core.js)
		    // Ce fichier sert uniquement de point de validation

		})(window);
		return filterPanel;
	}

	requireFilterPanel();

	var geoleaf_ui = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_ui;

	function requireGeoleaf_ui () {
		if (hasRequiredGeoleaf_ui) return geoleaf_ui;
		hasRequiredGeoleaf_ui = 1;
		/**
		 * GeoLeaf UI Module - Main Orchestrator (Sprint 4.4 Refactored)
		 * Orchestrateur principal pour l'interface utilisateur avec d√©l√©gation compl√®te vers sous-modules
		 *
		 * @module geoleaf.ui
		 * @author Assistant
		 * @version 4.4.0 - Modular Architecture
		 *
		 * RESPONSABILIT√âS:
		 * ‚úÖ Exposition de l'API publique unifi√©e
		 * ‚úÖ D√©l√©gation vers sous-modules sp√©cialis√©s
		 * ‚úÖ Initialisation et coordination des composants
		 * ‚úÖ Compatibility layer pour le code legacy
		 *
		 * MODULES D√âL√âGU√âS:
		 * - Theme Management    ‚Üí _UITheme (ui/theme.js)
		 * - Controls            ‚Üí _UIControls (ui/controls.js)
		 * - Panel Builder       ‚Üí _UIPanelBuilder (ui/panel-builder.js)
		 * - Filter Panel        ‚Üí _UIFilterPanel (ui/filter-panel.js)
		 * - Notifications       ‚Üí _UINotifications (ui/notifications.js)
		 * - Event Delegation    ‚Üí _UIEventDelegation (ui/event-delegation.js)
		 * - Filter State Mgmt   ‚Üí _UIFilterStateManager (ui/filter-state-manager.js)
		 */
		(function (window) {

		    // ========================================
		    //   NAMESPACE & DEPENDENCIES
		    // ========================================

		    const GeoLeaf = window.GeoLeaf || (window.GeoLeaf = {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf.UI = GeoLeaf.UI || {};

		    // Helper pour createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        if (GeoLeaf.Utils && GeoLeaf.Utils.createElement) {
		            return GeoLeaf.Utils.createElement(tag, props, ...children);
		        }
		        // Fallback to native if DomHelpers not loaded yet
		        const el = document.createElement(tag);
		        if (props) {
		            if (props.className) el.className = props.className;
		            if (props.textContent) el.textContent = props.textContent;
		        }
		        return el;
		    };

		    // ========================================
		    //   MODULE AVAILABILITY CHECKS
		    // ========================================

		    /**
		     * V√©rifie la disponibilit√© des modules requis
		     * @returns {Object} Status de disponibilit√© des modules
		     */
		    function checkModuleAvailability() {
		        const modules = {
		            theme: !!GeoLeaf._UITheme,
		            controls: !!GeoLeaf._UIControls,
		            panelBuilder: !!(GeoLeaf._UIPanelBuilder || GeoLeaf.UI.PanelBuilder),
		            filterPanel: !!GeoLeaf._UIFilterPanel,
		            notifications: !!GeoLeaf._UINotifications,
		            eventDelegation: !!GeoLeaf._UIEventDelegation,
		            filterStateManager: !!GeoLeaf._UIFilterStateManager
		        };

		        const missing = Object.entries(modules)
		            .filter(([name, available]) => !available)
		            .map(([name]) => name);

		        if (missing.length > 0 && Log) {
		            Log.warn("[UI.Orchestrator] Modules manquants:", missing.join(', '));
		        }

		        return { modules, missing, allAvailable: missing.length === 0 };
		    }

		    // ========================================
		    //   API DELEGATION - THEME MANAGEMENT
		    // ========================================

		    if (GeoLeaf._UITheme) {
		        // D√©l√©gation directe des fonctions th√®me
		        GeoLeaf.UI.initThemeToggle = GeoLeaf._UITheme.initThemeToggle;
		        GeoLeaf.UI.toggleTheme = GeoLeaf._UITheme.toggleTheme;
		        GeoLeaf.UI.applyTheme = GeoLeaf._UITheme.applyTheme;
		        GeoLeaf.UI.getCurrentTheme = GeoLeaf._UITheme.getCurrentTheme;

		        // Compatibility aliases
		        GeoLeaf.UI.setTheme = GeoLeaf._UITheme.applyTheme;
		    }

		    // ========================================
		    //   API DELEGATION - CONTROLS
		    // ========================================

		    if (GeoLeaf._UIControls) {
		        // D√©l√©gation des contr√¥les Leaflet
		        GeoLeaf.UI.initFullscreenControl = GeoLeaf._UIControls.initFullscreenControl;
		        GeoLeaf.UI.initGeolocationControl = GeoLeaf._UIControls.initGeolocationControl;
		        GeoLeaf.UI.initPoiAddControl = GeoLeaf._UIControls.initPoiAddControl;
		        GeoLeaf.UI.initScaleControl = GeoLeaf._UIControls.initScaleControl;

		        // √âtat g√©olocalisation (maintenu pour compatibilit√©)
		        GeoLeaf.UI._userPosition = null;
		        GeoLeaf.UI._geolocationActive = false;
		        GeoLeaf.UI._geolocationWatchId = null;
		    }

		    // ========================================
		    //   API DELEGATION - PANEL BUILDER
		    // ========================================

		    if (GeoLeaf._UIPanelBuilder || GeoLeaf.UI.PanelBuilder) {
		        // D√©l√©gation vers panel builder
		        GeoLeaf.UI.buildSidePanel = (GeoLeaf._UIPanelBuilder && GeoLeaf._UIPanelBuilder.buildSidePanel) ||
		                                   (GeoLeaf.UI.PanelBuilder && GeoLeaf.UI.PanelBuilder.buildSidePanel);
		        GeoLeaf.UI.renderPoiSidePanel = (GeoLeaf._UIPanelBuilder && GeoLeaf._UIPanelBuilder.renderPoiSidePanel) ||
		                                       (GeoLeaf.UI.PanelBuilder && GeoLeaf.UI.PanelBuilder.renderPoiSidePanel);

		        // Legacy compatibility pour POI panels
		        GeoLeaf.UI.renderPoiPanelWithLayout = function(poi, layout, container) {
		            if (GeoLeaf.UI.renderPoiSidePanel) {
		                return GeoLeaf.UI.renderPoiSidePanel(poi, layout, container);
		            }
		            if (Log) Log.warn("[UI.Orchestrator] renderPoiPanelWithLayout: PanelBuilder non disponible");
		        };

		        // Helper functions (deprecated, pour compatibilit√©)
		        GeoLeaf.UI._resolveField = function(poi, fieldPath) {
		            if (GeoLeaf._UIDomUtils && GeoLeaf._UIDomUtils.resolveField) {
		                return GeoLeaf._UIDomUtils.resolveField(poi, fieldPath);
		            }
		            return null;
		        };

		        GeoLeaf.UI._createPlainSection = function(label, innerContent, extraClass) {
		            if (GeoLeaf.UI.PanelBuilder && GeoLeaf.UI.PanelBuilder.createPlainSection) {
		                return GeoLeaf.UI.PanelBuilder.createPlainSection(label, innerContent, extraClass);
		            }
		            return $create("section", { className: "gl-poi-panel__section " + (extraClass || "") });
		        };

		        GeoLeaf.UI._createAccordionSection = function(label, innerContent, options) {
		            if (GeoLeaf.UI.PanelBuilder && GeoLeaf.UI.PanelBuilder.createAccordionSection) {
		                return GeoLeaf.UI.PanelBuilder.createAccordionSection(label, innerContent, options);
		            }
		            return $create("section", { className: "gl-poi-panel__section--accordion" });
		        };
		    }

		    // ========================================
		    //   API DELEGATION - FILTER PANEL
		    // ========================================

		    if (GeoLeaf._UIFilterPanel) {
		        // D√©l√©gation des fonctions filtres
		        GeoLeaf.UI.buildFilterPanelFromActiveProfile = GeoLeaf._UIFilterPanel.buildFilterPanelFromActiveProfile;
		        GeoLeaf.UI.refreshFilterTags = GeoLeaf._UIFilterPanel.refreshFilterTags;
		        GeoLeaf.UI.initFilterToggle = GeoLeaf._UIFilterPanel.initFilterToggle;
		        GeoLeaf.UI.initProximityFilter = GeoLeaf._UIFilterPanel.initProximityFilter;
		        GeoLeaf.UI._getBasePois = GeoLeaf._UIFilterPanel.getBasePois;
		        GeoLeaf.UI._getBaseRoutes = GeoLeaf._UIFilterPanel.getBaseRoutes;

		        // Filter state integration si disponible
		        if (GeoLeaf._UIFilterStateManager) {
		            // Bridge entre filter panel et state manager
		            GeoLeaf.UI.resetAllFilters = function() {
		                GeoLeaf._UIFilterStateManager.resetAllFilters();
		                if (GeoLeaf._UIFilterPanel.refreshFilterTags) {
		                    GeoLeaf._UIFilterPanel.refreshFilterTags();
		                }
		            };

		            GeoLeaf.UI.getActiveFilters = GeoLeaf._UIFilterStateManager.getActiveFiltersSummary;
		            GeoLeaf.UI.hasActiveFilters = GeoLeaf._UIFilterStateManager.hasActiveFilters;
		        }
		    }

		    // ========================================
		    //   API DELEGATION - NOTIFICATIONS
		    // ========================================

		    if (GeoLeaf._UINotifications) {
		        // Cr√©er un namespace d√©di√© pour l'acc√®s complet
		        GeoLeaf.UI.Notifications = {
		            show: GeoLeaf._UINotifications.show.bind(GeoLeaf._UINotifications),
		            success: GeoLeaf._UINotifications.success.bind(GeoLeaf._UINotifications),
		            error: GeoLeaf._UINotifications.error.bind(GeoLeaf._UINotifications),
		            warning: GeoLeaf._UINotifications.warning.bind(GeoLeaf._UINotifications),
		            info: GeoLeaf._UINotifications.info.bind(GeoLeaf._UINotifications),
		            clearAll: GeoLeaf._UINotifications.clearAll.bind(GeoLeaf._UINotifications),
		            enable: GeoLeaf._UINotifications.enable.bind(GeoLeaf._UINotifications),
		            disable: GeoLeaf._UINotifications.disable.bind(GeoLeaf._UINotifications),
		            getStatus: GeoLeaf._UINotifications.getStatus.bind(GeoLeaf._UINotifications)
		        };

		        // Raccourcis globaux pour l'API publique (r√©trocompatibilit√©)
		        GeoLeaf.UI.showNotification = GeoLeaf._UINotifications.show.bind(GeoLeaf._UINotifications);
		        GeoLeaf.UI.showSuccess = GeoLeaf._UINotifications.success.bind(GeoLeaf._UINotifications);
		        GeoLeaf.UI.showError = GeoLeaf._UINotifications.error.bind(GeoLeaf._UINotifications);
		        GeoLeaf.UI.showWarning = GeoLeaf._UINotifications.warning.bind(GeoLeaf._UINotifications);
		        GeoLeaf.UI.showInfo = GeoLeaf._UINotifications.info.bind(GeoLeaf._UINotifications);
		        GeoLeaf.UI.clearNotifications = GeoLeaf._UINotifications.clearAll.bind(GeoLeaf._UINotifications);
		    }

		    // ========================================
		    //   EVENT DELEGATION INTEGRATION
		    // ========================================

		    let _delegationInitialized = false;

		    /**
		     * Initialise la d√©l√©gation d'√©v√©nements pour l'interface
		     * @param {Object} options - Options d'initialisation
		     */
		    function initializeEventDelegation(options = {}) {
		        if (_delegationInitialized || !GeoLeaf._UIEventDelegation) return;

		        const { filterContainer } = options;

		        // Event listeners pour les filtres si disponible
		        if (filterContainer && GeoLeaf._UIFilterStateManager) {
		            GeoLeaf._UIEventDelegation.attachFilterInputEvents(
		                filterContainer,
		                () => {
		                    // Callback de changement de filtre - d√©l√©guer vers FilterPanel
		                    if (GeoLeaf._UIFilterPanel && GeoLeaf._UIFilterPanel.refreshFilterTags) {
		                        GeoLeaf._UIFilterPanel.refreshFilterTags();
		                    }
		                }
		            );
		        }

		        // Event listeners pour les accord√©ons
		        document.addEventListener('DOMContentLoaded', () => {
		            const accordionContainers = document.querySelectorAll('.gl-poi-panel, .gl-filter-panel');
		            accordionContainers.forEach(container => {
		                GeoLeaf._UIEventDelegation.attachAccordionEvents(container);
		            });
		        });

		        _delegationInitialized = true;
		        if (Log) Log.info("[UI.Orchestrator] Event delegation initialis√©e");
		    }

		    // ========================================
		    //   MAIN INITIALIZATION
		    // ========================================

		    /**
		     * Point d'entr√©e principal pour l'initialisation UI
		     * @param {Object} options - Options d'initialisation
		     * @param {HTMLElement} options.map - Instance carte Leaflet
		     * @param {HTMLElement} options.mapContainer - Conteneur DOM de la carte
		     * @param {HTMLElement} options.filterContainer - Conteneur des filtres
		     * @param {string} options.buttonSelector - S√©lecteur du bouton th√®me
		     * @param {boolean} options.autoInitOnDomReady - Auto-init au DOMContentLoaded
		     * @param {boolean} options.enableEventDelegation - Active la d√©l√©gation d'√©v√©nements (d√©faut: true)
		     */
		    GeoLeaf.UI.init = function(options = {}) {
		        const config = {
		            buttonSelector: options.buttonSelector || '[data-gl-role="theme-toggle"]',
		            autoInitOnDomReady: !!options.autoInitOnDomReady,
		            enableEventDelegation: options.enableEventDelegation !== false
		        };

		        // V√©rification des modules
		        const { missing, allAvailable } = checkModuleAvailability();
		        if (!allAvailable && Log) {
		            Log.warn("[UI.Orchestrator] Initialisation avec modules manquants:", missing);
		        }

		        // Initialisation du th√®me
		        if (GeoLeaf.UI.initThemeToggle) {
		            try {
		                GeoLeaf.UI.initThemeToggle(config);
		            } catch (error) {
		                if (Log) Log.error("[UI.Orchestrator] Erreur init th√®me:", error);
		            }
		        }

		        // Initialisation des contr√¥les si carte disponible
		        if (options.map && options.mapContainer) {
		            // Fullscreen control
		            if (GeoLeaf.UI.initFullscreenControl) {
		                try {
		                    GeoLeaf.UI.initFullscreenControl(options.map, options.mapContainer);
		                } catch (error) {
		                    if (Log) Log.error("[UI.Orchestrator] Erreur fullscreen control:", error);
		                }
		            }

		            // Geolocation control - forcer l'initialisation
		            if (GeoLeaf.UI.initGeolocationControl) {
		                try {
		                    GeoLeaf.UI.initGeolocationControl(options.map, options.config);
		                } catch (error) {
		                    if (Log) Log.error("[UI.Orchestrator] Erreur geolocation control:", error);
		                }
		            }

		            // POI Add control - forcer l'initialisation
		            if (GeoLeaf.UI.initPoiAddControl) {
		                try {
		                    GeoLeaf.UI.initPoiAddControl(options.map, options.config);
		                } catch (error) {
		                    if (Log) Log.error("[UI.Orchestrator] Erreur POI add control:", error);
		                }
		            }

		            // Scale control
		            if (GeoLeaf.UI.initScaleControl) {
		                try {
		                    GeoLeaf.UI.initScaleControl(options.map);
		                } catch (error) {
		                    if (Log) Log.error("[UI.Orchestrator] Erreur scale control:", error);
		                }
		            }
		        }

		        // Initialisation de la d√©l√©gation d'√©v√©nements
		        if (config.enableEventDelegation) {
		            initializeEventDelegation({
		                filterContainer: options.filterContainer
		            });
		        }

		        // Initialisation du filter state manager si profil disponible
		        if (GeoLeaf._UIFilterStateManager && GeoLeaf.Config) {
		            const activeProfile = GeoLeaf.Config.getActiveProfile?.() || null;
		            if (activeProfile && activeProfile.filters) {
		                try {
		                    GeoLeaf._UIFilterStateManager.initializeFromProfile(activeProfile);
		                } catch (error) {
		                    if (Log) Log.error("[UI.Orchestrator] Erreur init filter state:", error);
		                }
		            }
		        }

		        if (Log) {
		            Log.info(`[UI.Orchestrator] Initialisation termin√©e (modules: ${Object.keys(checkModuleAvailability().modules).length})`);
		        }
		    };

		    // ========================================
		    //   UTILITY & DEBUG FUNCTIONS
		    // ========================================

		    /**
		     * Informations de debug sur l'√©tat des modules
		     * @returns {Object} Status d√©taill√© des modules
		     */
		    GeoLeaf.UI.getModuleStatus = function() {
		        return checkModuleAvailability();
		    };

		    /**
		     * Nettoyage g√©n√©ral des resources UI
		     */
		    GeoLeaf.UI.cleanup = function() {
		        // Nettoyage des event listeners
		        if (GeoLeaf._UIEventDelegation && GeoLeaf._UIEventDelegation.cleanupAllListeners) {
		            const cleaned = GeoLeaf._UIEventDelegation.cleanupAllListeners();
		            if (Log && cleaned > 0) {
		                Log.info(`[UI.Orchestrator] ${cleaned} event listeners nettoy√©s`);
		            }
		        }

		        // Reset flag d√©l√©gation
		        _delegationInitialized = false;

		        if (Log) Log.info("[UI.Orchestrator] Nettoyage termin√©");
		    };

		    // ========================================
		    //   LEGACY COMPATIBILITY LAYER
		    // ========================================

		    // Fonctions legacy maintenues pour compatibilit√©
		    GeoLeaf.UI._attachAccordionBehavior = function(container) {
		        if (GeoLeaf._UIEventDelegation && GeoLeaf._UIEventDelegation.attachAccordionEvents) {
		            return GeoLeaf._UIEventDelegation.attachAccordionEvents(container);
		        }
		        if (Log) Log.warn("[UI.Orchestrator] _attachAccordionBehavior: EventDelegation module manquant");
		    };

		    GeoLeaf.UI._getActiveProfileConfig = function() {
		        if (GeoLeaf._UIDomUtils && GeoLeaf._UIDomUtils.getActiveProfileConfig) {
		            return GeoLeaf._UIDomUtils.getActiveProfileConfig();
		        }
		        return GeoLeaf.Config?.getActiveProfile?.() || null;
		    };

		    // Version info
		    GeoLeaf.UI.VERSION = "4.4.0";
		    GeoLeaf.UI.BUILD = "Sprint-4.4-Modular";

		    if (Log) {
		        Log.info(`[UI.Orchestrator] Module initialis√© v${GeoLeaf.UI.VERSION}`);
		    }

		})(window);
		return geoleaf_ui;
	}

	requireGeoleaf_ui();

	var normalizer = {};

	/**
	 * GeoLeaf Data Normalizer Module
	 * Module central pour la normalisation des donn√©es provenant de diff√©rentes sources.
	 * Convertit JSON, GeoJSON, GPX (future) et Routes vers un format POI unifi√©.
	 *
	 * @module data/normalizer
	 * @version 1.0.0
	 */

	var hasRequiredNormalizer;

	function requireNormalizer () {
		if (hasRequiredNormalizer) return normalizer;
		hasRequiredNormalizer = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._Normalizer = GeoLeaf._Normalizer || {};

		    // ========================================
		    //   TYPES DE SOURCES
		    // ========================================

		    const SOURCE_TYPES = {
		        JSON: 'json',
		        GEOJSON: 'geojson',
		        GPX: 'gpx',
		        ROUTE: 'route'
		    };

		    // ========================================
		    //   UTILITAIRES
		    // ========================================

		    /**
		     * R√©cup√®re le Log
		     * @returns {Object}
		     */
		    function getLog() {
		        return GeoLeaf.Log || console;
		    }

		    /**
		     * G√©n√®re un ID unique
		     * @returns {string}
		     */
		    function generateUniqueId() {
		        return 'poi_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
		    }

		    /**
		     * D√©termine le type de g√©om√©trie √† partir des coordonn√©es Leaflet
		     * @param {Object} layer - Layer Leaflet
		     * @returns {string} 'Point', 'Polygon', 'LineString' ou 'Unknown'
		     */
		    function detectGeometryType(layer) {
		        if (!layer) return 'Unknown';

		        if (typeof layer.getLatLng === 'function') {
		            return 'Point';
		        }
		        if (typeof layer.getLatLngs === 'function') {
		            const latLngs = layer.getLatLngs();
		            // Polygon : tableau de tableaux de points (anneau ext√©rieur + trous √©ventuels)
		            // LineString : tableau de points
		            if (Array.isArray(latLngs) && latLngs.length > 0) {
		                if (Array.isArray(latLngs[0]) && Array.isArray(latLngs[0][0])) {
		                    return 'Polygon';
		                }
		                if (Array.isArray(latLngs[0])) {
		                    // Peut √™tre Polygon ou LineString selon si ferm√©
		                    return 'Polygon';
		                }
		                return 'LineString';
		            }
		        }
		        return 'Unknown';
		    }

		    /**
		     * Extrait les coordonn√©es d'un layer Leaflet
		     * @param {Object} layer - Layer Leaflet
		     * @returns {Array|null} Coordonn√©es [lat, lng] ou null
		     */
		    function extractCoordinates(layer) {
		        if (!layer) return null;

		        if (typeof layer.getLatLng === 'function') {
		            const ll = layer.getLatLng();
		            return ll ? [ll.lat, ll.lng] : null;
		        }

		        if (typeof layer.getCenter === 'function') {
		            const center = layer.getCenter();
		            return center ? [center.lat, center.lng] : null;
		        }

		        if (typeof layer.getBounds === 'function') {
		            try {
		                const bounds = layer.getBounds();
		                if (bounds && bounds.isValid()) {
		                    const center = bounds.getCenter();
		                    return center ? [center.lat, center.lng] : null;
		                }
		            } catch (e) {
		                // Bounds invalides
		            }
		        }

		        return null;
		    }

		    // ========================================
		    //   NORMALISEURS PAR TYPE DE SOURCE
		    // ========================================

		    /**
		     * Normalise une entr√©e JSON en POI
		     * @param {Object} data - Donn√©es JSON brutes
		     * @param {Object} layerConfig - Configuration du layer
		     * @returns {Object} POI normalis√©
		     */
		    function normalizeFromJSON(data, layerConfig = {}) {
		        if (!data) return null;

		        const id = data.id || data.uid || data.guid || generateUniqueId();
		        const dataMapping = layerConfig.dataMapping || {};

		        // Extraction du titre
		        const titleField = dataMapping.title || 'title';
		        const title = data[titleField] || data.title || data.name || data.label || data.nom || 'Sans titre';

		        // Extraction de la description
		        const descField = dataMapping.description || 'description';
		        const description = data[descField] || data.description || data.shortDescription || '';

		        // Extraction des coordonn√©es
		        const latField = dataMapping.lat || 'lat';
		        const lngField = dataMapping.lng || 'lng';
		        let lat = data[latField];
		        let lng = data[lngField];

		        // Fallbacks pour coordonn√©es
		        if (lat === undefined) lat = data.latitude || data.y;
		        if (lng === undefined) lng = data.longitude || data.lng || data.x;

		        // Extraction cat√©gorie/sous-cat√©gorie
		        const catField = dataMapping.categoryId || 'categoryId';
		        const subCatField = dataMapping.subCategoryId || 'subCategoryId';
		        const categoryId = data[catField] || data.categoryId || data.category || null;
		        const subCategoryId = data[subCatField] || data.subCategoryId || data.subcategory || null;

		        // Construction des attributs (toutes les propri√©t√©s)
		        const attributes = { ...data };

		        return {
		            id: String(id),
		            sourceType: SOURCE_TYPES.JSON,
		            geometryType: 'Point',
		            title: String(title),
		            description: String(description || ''),
		            lat: lat !== undefined ? parseFloat(lat) : null,
		            lng: lng !== undefined ? parseFloat(lng) : null,
		            categoryId: categoryId,
		            subCategoryId: subCategoryId,
		            attributes: attributes,
		            rawData: data
		        };
		    }

		    /**
		     * Normalise une feature GeoJSON en POI
		     * @param {Object} feature - Feature GeoJSON
		     * @param {Object} layerConfig - Configuration du layer
		     * @param {Object} layer - Layer Leaflet (optionnel, pour coordonn√©es)
		     * @returns {Object} POI normalis√©
		     */
		    function normalizeFromGeoJSON(feature, layerConfig = {}, layer = null) {
		        if (!feature) return null;

		        const props = feature.properties || {};
		        const geometry = feature.geometry || {};
		        const dataMapping = layerConfig.dataMapping || {};

		        // ID
		        const id = feature.id || props.id || props.uid || props.guid || generateUniqueId();

		        // Type de g√©om√©trie
		        let geometryType = geometry.type || 'Unknown';
		        if (layer && geometryType === 'Unknown') {
		            geometryType = detectGeometryType(layer);
		        }

		        // Extraction du titre
		        const titleField = dataMapping.title || 'title';
		        const titlePath = titleField.includes('.') ? titleField.split('.').pop() : titleField;
		        const title = props[titlePath] || props.name || props.nom || props.title || props.label || 'Sans titre';

		        // Extraction de la description
		        const descField = dataMapping.description || 'description';
		        const descPath = descField.includes('.') ? descField.split('.').pop() : descField;
		        const description = props[descPath] || props.description || props.shortDescription || '';

		        // Coordonn√©es
		        let lat = null, lng = null;
		        if (geometry.coordinates) {
		            if (geometryType === 'Point') {
		                // GeoJSON : [lng, lat]
		                lng = geometry.coordinates[0];
		                lat = geometry.coordinates[1];
		            } else if (layer) {
		                const coords = extractCoordinates(layer);
		                if (coords) {
		                    lat = coords[0];
		                    lng = coords[1];
		                }
		            } else if (geometry.coordinates.length > 0) {
		                // Calculer le centre approximatif
		                const flatCoords = flattenCoordinates(geometry.coordinates, geometry.type);
		                if (flatCoords.length > 0) {
		                    let sumLat = 0, sumLng = 0;
		                    flatCoords.forEach(c => {
		                        sumLng += c[0];
		                        sumLat += c[1];
		                    });
		                    lng = sumLng / flatCoords.length;
		                    lat = sumLat / flatCoords.length;
		                }
		            }
		        } else if (layer) {
		            const coords = extractCoordinates(layer);
		            if (coords) {
		                lat = coords[0];
		                lng = coords[1];
		            }
		        }

		        // Cat√©gorie/sous-cat√©gorie
		        const catField = dataMapping.categoryId || 'categoryId';
		        const catPath = catField.includes('.') ? catField.split('.').pop() : catField;
		        const subCatField = dataMapping.subCategoryId || 'subCategoryId';
		        const subCatPath = subCatField.includes('.') ? subCatField.split('.').pop() : subCatField;

		        const categoryId = props[catPath] || props.categoryId || props.category || null;
		        const subCategoryId = props[subCatPath] || props.subCategoryId || props.subcategory || null;

		        // Construction des attributs
		        const attributes = { ...props };

		        return {
		            id: String(id),
		            sourceType: SOURCE_TYPES.GEOJSON,
		            geometryType: geometryType,
		            title: String(title),
		            description: String(description || ''),
		            lat: lat !== null ? parseFloat(lat) : null,
		            lng: lng !== null ? parseFloat(lng) : null,
		            categoryId: categoryId,
		            subCategoryId: subCategoryId,
		            attributes: attributes,
		            properties: props, // Conserve aussi properties pour compatibilit√©
		            rawData: feature
		        };
		    }

		    /**
		     * Aplatit les coordonn√©es GeoJSON selon le type de g√©om√©trie
		     * @param {Array} coords - Coordonn√©es imbriqu√©es
		     * @param {string} type - Type de g√©om√©trie
		     * @returns {Array} Tableau de [lng, lat]
		     */
		    function flattenCoordinates(coords, type) {
		        if (!coords || !Array.isArray(coords)) return [];

		        switch (type) {
		            case 'Point':
		                return [coords];
		            case 'MultiPoint':
		            case 'LineString':
		                return coords;
		            case 'MultiLineString':
		            case 'Polygon':
		                return coords.flat();
		            case 'MultiPolygon':
		                return coords.flat(2);
		            default:
		                // Aplatir r√©cursivement
		                const flat = [];
		                const flatten = (arr) => {
		                    if (!Array.isArray(arr)) return;
		                    if (typeof arr[0] === 'number') {
		                        flat.push(arr);
		                    } else {
		                        arr.forEach(flatten);
		                    }
		                };
		                flatten(coords);
		                return flat;
		        }
		    }

		    /**
		     * Normalise un waypoint GPX en POI (placeholder pour futur module)
		     * @param {Object} waypoint - Waypoint GPX
		     * @param {Object} layerConfig - Configuration du layer
		     * @returns {Object} POI normalis√©
		     */
		    function normalizeFromGPX(waypoint, layerConfig = {}) {
		        if (!waypoint) return null;

		        getLog().info('[Normalizer] GPX normalization - placeholder for future implementation');

		        // Structure de base pour GPX
		        const id = waypoint.name || waypoint.sym || generateUniqueId();
		        const title = waypoint.name || waypoint.cmt || 'Point GPX';
		        const description = waypoint.desc || waypoint.cmt || '';

		        return {
		            id: String(id),
		            sourceType: SOURCE_TYPES.GPX,
		            geometryType: 'Point',
		            title: String(title),
		            description: String(description),
		            lat: waypoint.lat !== undefined ? parseFloat(waypoint.lat) : null,
		            lng: waypoint.lon !== undefined ? parseFloat(waypoint.lon) : null,
		            categoryId: waypoint.type || null,
		            subCategoryId: null,
		            attributes: { ...waypoint },
		            rawData: waypoint
		        };
		    }

		    /**
		     * Normalise un point de route en POI
		     * @param {Object} routePoint - Point de route
		     * @param {Object} routeConfig - Configuration de la route
		     * @returns {Object} POI normalis√©
		     */
		    function normalizeFromRoute(routePoint, routeConfig = {}) {
		        if (!routePoint) return null;

		        const id = routePoint.id || routePoint.placeId || generateUniqueId();
		        const title = routePoint.name || routePoint.title || routePoint.address || 'Point de route';
		        const description = routePoint.description || routePoint.comment || '';

		        let lat = null, lng = null;
		        if (routePoint.latLng) {
		            lat = routePoint.latLng.lat;
		            lng = routePoint.latLng.lng;
		        } else if (routePoint.lat !== undefined && routePoint.lng !== undefined) {
		            lat = routePoint.lat;
		            lng = routePoint.lng;
		        }

		        return {
		            id: String(id),
		            sourceType: SOURCE_TYPES.ROUTE,
		            geometryType: 'Point',
		            title: String(title),
		            description: String(description),
		            lat: lat !== null ? parseFloat(lat) : null,
		            lng: lng !== null ? parseFloat(lng) : null,
		            categoryId: routePoint.type || 'route-point',
		            subCategoryId: routePoint.order !== undefined ? `stop-${routePoint.order}` : null,
		            order: routePoint.order,
		            address: routePoint.address,
		            attributes: { ...routePoint },
		            rawData: routePoint
		        };
		    }

		    // ========================================
		    //   FONCTION PRINCIPALE
		    // ========================================

		    /**
		     * Normalise des donn√©es selon leur type de source
		     * @param {string} sourceType - Type de source ('json', 'geojson', 'gpx', 'route')
		     * @param {Object} data - Donn√©es brutes
		     * @param {Object} layerConfig - Configuration du layer
		     * @param {Object} options - Options additionnelles (layer Leaflet, etc.)
		     * @returns {Object} POI normalis√©
		     */
		    function normalizeFeature(sourceType, data, layerConfig = {}, options = {}) {
		        if (!data) {
		            getLog().warn('[Normalizer] Donn√©es nulles pour normalisation');
		            return null;
		        }

		        switch (sourceType) {
		            case SOURCE_TYPES.JSON:
		                return normalizeFromJSON(data, layerConfig);

		            case SOURCE_TYPES.GEOJSON:
		                return normalizeFromGeoJSON(data, layerConfig, options.layer);

		            case SOURCE_TYPES.GPX:
		                return normalizeFromGPX(data, layerConfig);

		            case SOURCE_TYPES.ROUTE:
		                return normalizeFromRoute(data, layerConfig);

		            default:
		                getLog().warn('[Normalizer] Type de source non reconnu:', sourceType);
		                // Tenter une d√©tection automatique
		                return autoDetectAndNormalize(data, layerConfig, options);
		        }
		    }

		    /**
		     * D√©tecte automatiquement le type de source et normalise
		     * @param {Object} data - Donn√©es brutes
		     * @param {Object} layerConfig - Configuration du layer
		     * @param {Object} options - Options additionnelles
		     * @returns {Object} POI normalis√©
		     */
		    function autoDetectAndNormalize(data, layerConfig = {}, options = {}) {
		        // D√©tection GeoJSON
		        if (data.type === 'Feature' && data.geometry) {
		            return normalizeFromGeoJSON(data, layerConfig, options.layer);
		        }

		        // D√©tection GPX (waypoint)
		        if (data.lat !== undefined && data.lon !== undefined && (data.name || data.sym)) {
		            return normalizeFromGPX(data, layerConfig);
		        }

		        // D√©tection Route
		        if (data.latLng || (data.order !== undefined && data.address)) {
		            return normalizeFromRoute(data, layerConfig);
		        }

		        // Par d√©faut : JSON
		        return normalizeFromJSON(data, layerConfig);
		    }

		    /**
		     * Normalise un tableau de donn√©es
		     * @param {string} sourceType - Type de source
		     * @param {Array} dataArray - Tableau de donn√©es brutes
		     * @param {Object} layerConfig - Configuration du layer
		     * @param {Object} options - Options additionnelles
		     * @returns {Array} Tableau de POIs normalis√©s
		     */
		    function normalizeCollection(sourceType, dataArray, layerConfig = {}, options = {}) {
		        if (!Array.isArray(dataArray)) {
		            getLog().warn('[Normalizer] normalizeCollection attend un tableau');
		            return [];
		        }

		        return dataArray
		            .map(data => normalizeFeature(sourceType, data, layerConfig, options))
		            .filter(poi => poi !== null);
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._Normalizer = {
		        // Types de sources
		        SOURCE_TYPES,

		        // Normaliseurs par type
		        normalizeFromJSON,
		        normalizeFromGeoJSON,
		        normalizeFromGPX,
		        normalizeFromRoute,

		        // Fonctions principales
		        normalizeFeature,
		        autoDetectAndNormalize,
		        normalizeCollection,

		        // Utilitaires
		        detectGeometryType,
		        extractCoordinates,
		        generateUniqueId
		    };

		    getLog().info('[GeoLeaf._Normalizer] Module Normalizer charg√©');

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return normalizer;
	}

	requireNormalizer();

	var styleLoader = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredStyleLoader;

	function requireStyleLoader () {
		if (hasRequiredStyleLoader) return styleLoader;
		hasRequiredStyleLoader = 1;
		/**
		 * @fileoverview Chargeur centralis√© de styles GeoLeaf
		 * G√®re le chargement, la validation et le cache des fichiers style.json
		 * Supporte les labels int√©gr√©s et la d√©tection automatique
		 * @module loaders/style-loader
		 */

		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		/**
		 * Cache en m√©moire des styles charg√©s
		 * Cl√©: "profileId:layerId:styleId"
		 * Valeur: { styleData, labelConfig, timestamp }
		 */
		const styleCache = new Map();

		/**
		 * Configuration du loader
		 */
		let loaderConfig = {
		    debug: false,
		    throwOnValidationError: true
		};

		function getProfilesBasePath() {
		    const cfg = GeoLeaf.Config;

		    if (cfg && typeof cfg.get === "function") {
		        const configured = cfg.get("data.profilesBasePath", "profiles");
		        if (typeof configured === "string" && configured.trim().length > 0) {
		            return configured.endsWith("/") ? configured.slice(0, -1) : configured;
		        }
		    }

		    return "profiles";
		}

		/**
		 * Initialise le style loader avec la configuration GeoLeaf
		 * @param {Object} config - Configuration GeoLeaf (doit contenir { debug: boolean })
		 */
		function initStyleLoader(config = {}) {
		    loaderConfig.debug = config.debug === true;

		    if (loaderConfig.debug) {
		        console.log('[StyleLoader] Mode debug activ√© - cache d√©sactiv√©');
		    }
		}

		/**
		 * Charge et valide un fichier de style
		 * @param {string} profileId - ID du profil
		 * @param {string} layerId - ID de la couche
		 * @param {string} styleId - ID du style
		 * @param {string} styleFileName - Nom du fichier de style (ex: "default.json")
		 * @param {string} layerDirectory - R√©pertoire de la couche (ex: "layers/tourism_poi_all")
		 * @returns {Promise<Object>} Style charg√© et valid√© avec labels extraits
		 * @throws {Error} Si le fichier est invalide ou introuvable
		 */
		async function loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory) {
		    const cacheKey = `${profileId}:${layerId}:${styleId}`;

		    // V√©rifier le cache (sauf en mode debug)
		    if (!loaderConfig.debug && styleCache.has(cacheKey)) {
		        const cached = styleCache.get(cacheKey);
		        console.log(`[StyleLoader] Style charg√© depuis le cache: ${cacheKey}`);
		        return cached;
		    }

		    try {
		        // Construire le chemin du fichier de style
		        const profilesBasePath = getProfilesBasePath();
		        const stylePath = `${profilesBasePath}/${profileId}/${layerDirectory}/styles/${styleFileName}`;

		        console.log(`[StyleLoader] Chargement du style: ${stylePath}`);

		        // Charger le fichier JSON
		        const response = await fetch(stylePath);

		        if (!response.ok) {
		            throw new Error(
		                `Impossible de charger le fichier de style: ${stylePath}\n` +
		                `HTTP ${response.status}: ${response.statusText}`
		            );
		        }

		        let styleData;
		        try {
		            styleData = await response.json();
		        } catch (jsonError) {
		            // Erreur de parsing JSON - format d√©taill√©
		            const errorContext = {
		                profileId,
		                layerId,
		                styleId,
		                stylePath,
		                httpStatus: response.status,
		                parseError: jsonError.message
		            };

		            console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		            console.error('‚ùå ERREUR DE PARSING JSON - FICHIER STYLE MALFORM√â');
		            console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		            console.error(`Fichier: ${stylePath}`);
		            console.error(`Erreur: ${jsonError.message}`);
		            console.error('Contexte:', JSON.stringify(errorContext, null, 2));
		            console.error('Stack trace:', jsonError.stack);
		            console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

		            throw new Error(
		                `Le fichier de style contient du JSON malform√©: ${stylePath}\n` +
		                `Erreur de parsing: ${jsonError.message}\n` +
		                `Veuillez v√©rifier la syntaxe JSON du fichier.`
		            );
		        }

		        // VALIDATION STRICTE: Ajouter visibleByDefault si manquant et label.enabled: true
		        if (styleData.label && styleData.label.enabled === true) {
		            if (styleData.label.visibleByDefault === undefined) {
		                // Fallback automatique √† false
		                styleData.label.visibleByDefault = false;
		                console.warn(
		                    `[StyleLoader] ‚ö†Ô∏è Param√®tre "visibleByDefault" manquant dans le style: ${stylePath}\n` +
		                    `Le style a "label.enabled: true" mais pas de "visibleByDefault".\n` +
		                    `Fallback appliqu√©: visibleByDefault = false\n` +
		                    `Ajoutez explicitement "visibleByDefault": false ou true dans le fichier de style.`
		                );
		            }
		        }

		        // Valider le style contre le sch√©ma
		        {
		            const StyleValidator = GeoLeaf._StyleValidator;
		            if (!StyleValidator) {
		                console.warn('[StyleLoader] GeoLeaf._StyleValidator non disponible, validation ignor√©e');
		            }

		            const validationResult = StyleValidator ? StyleValidator.validateStyle(styleData, {
		                profileId,
		                layerId,
		                styleId,
		                stylePath
		            }) : { valid: true, errors: [], warnings: [] };

		            if (!validationResult.valid) {
		                const errorMessage = StyleValidator ? StyleValidator.formatValidationErrors(validationResult, stylePath) : 'Erreurs de validation';
		                console.error(errorMessage);

		                if (loaderConfig.throwOnValidationError) {
		                    throw new Error(
		                        `Le fichier de style ne respecte pas le sch√©ma GeoLeaf: ${stylePath}\n` +
		                        `Consultez la console pour les d√©tails des erreurs.`
		                    );
		                }
		            }

		            // Afficher les avertissements m√™me si validation OK
		            if (validationResult.warnings.length > 0) {
		                console.warn(`[StyleLoader] ${validationResult.warnings.length} avertissement(s) pour ${stylePath}:`);
		                validationResult.warnings.forEach(warning => {
		                    console.warn(`  - ${warning.field}: ${warning.message}`);
		                });
		            }
		        }

		        // Extraire la configuration de labels int√©gr√©s
		        const labelConfig = extractLabelConfig(styleData);

		        // Pr√©parer l'objet de retour
		        const result = {
		            styleData,
		            labelConfig,
		            metadata: {
		                profileId,
		                layerId,
		                styleId,
		                stylePath,
		                hasIntegratedLabels: labelConfig !== null,
		                loadedAt: new Date().toISOString()
		            }
		        };

		        // Mettre en cache (sauf en mode debug)
		        if (!loaderConfig.debug) {
		            styleCache.set(cacheKey, result);
		        }

		        console.log(
		            `[StyleLoader] Style charg√© avec succ√®s: ${styleId}` +
		            (labelConfig ? ' (avec labels int√©gr√©s)' : '')
		        );

		        return result;

		    } catch (error) {
		        // Re-throw les erreurs avec contexte complet
		        if (error.message.includes('JSON malform√©') || error.message.includes('sch√©ma GeoLeaf')) {
		            throw error;
		        }

		        // Erreur r√©seau ou autre
		        const errorContext = {
		            profileId,
		            layerId,
		            styleId,
		            styleFileName,
		            layerDirectory,
		            originalError: error.message
		        };

		        console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		        console.error('‚ùå ERREUR DE CHARGEMENT DE STYLE');
		        console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
		        console.error('Contexte:', JSON.stringify(errorContext, null, 2));
		        console.error('Stack trace:', error.stack);
		        console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

		        throw error;
		    }
		}

		/**
		 * Extrait la configuration de labels depuis un style charg√©
		 * D√©tecte automatiquement si les labels sont int√©gr√©s dans le style
		 * @param {Object} styleData - Donn√©es du style
		 * @returns {Object|null} Configuration de labels ou null si absents/d√©sactiv√©s
		 */
		function extractLabelConfig(styleData) {
		    if (!styleData || typeof styleData !== 'object') {
		        return null;
		    }

		    // V√©rifier si le champ label est un objet de configuration
		    if (styleData.label && typeof styleData.label === 'object' && styleData.label !== null) {
		        // V√©rifier que enabled est true
		        if (styleData.label.enabled === true) {
		            return {
		                ...styleData.label,
		                isIntegrated: true
		            };
		        }
		    }

		    // Pas de labels int√©gr√©s ou d√©sactiv√©s
		    return null;
		}

		/**
		 * Charge un style avec gestion simplifi√©e (sans validation stricte)
		 * Utilis√© pour les cas o√π on veut charger m√™me si validation √©choue
		 * @param {string} profileId - ID du profil
		 * @param {string} layerId - ID de la couche
		 * @param {string} styleId - ID du style
		 * @param {string} styleFileName - Nom du fichier
		 * @param {string} layerDirectory - R√©pertoire de la couche
		 * @returns {Promise<Object>} Style charg√© (peut contenir des erreurs)
		 */
		async function loadStyleLenient(profileId, layerId, styleId, styleFileName, layerDirectory) {
		    const previousThrowSetting = loaderConfig.throwOnValidationError;
		    loaderConfig.throwOnValidationError = false;

		    try {
		        return await loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory);
		    } finally {
		        loaderConfig.throwOnValidationError = previousThrowSetting;
		    }
		}

		/**
		 * Pr√©charge plusieurs styles en parall√®le
		 * @param {Array<Object>} styleConfigs - Tableau de { profileId, layerId, styleId, styleFileName, layerDirectory }
		 * @returns {Promise<Array<Object>>} R√©sultats de chargement
		 */
		async function preloadStyles(styleConfigs) {
		    console.log(`[StyleLoader] Pr√©chargement de ${styleConfigs.length} style(s)...`);

		    const promises = styleConfigs.map(config =>
		        loadAndValidateStyle(
		            config.profileId,
		            config.layerId,
		            config.styleId,
		            config.styleFileName,
		            config.layerDirectory
		        ).catch(error => ({
		            error: true,
		            message: error.message,
		            config
		        }))
		    );

		    const results = await Promise.all(promises);

		    const successCount = results.filter(r => !r.error).length;
		    const errorCount = results.filter(r => r.error).length;

		    console.log(`[StyleLoader] Pr√©chargement termin√©: ${successCount} succ√®s, ${errorCount} erreurs`);

		    return results;
		}

		/**
		 * Efface le cache des styles
		 * @param {string} [cacheKey] - Cl√© sp√©cifique √† effacer (optionnel, sinon tout le cache)
		 */
		function clearStyleCache(cacheKey = null) {
		    if (cacheKey) {
		        styleCache.delete(cacheKey);
		        console.log(`[StyleLoader] Cache effac√© pour: ${cacheKey}`);
		    } else {
		        const count = styleCache.size;
		        styleCache.clear();
		        console.log(`[StyleLoader] Cache complet effac√© (${count} entr√©e(s))`);
		    }
		}

		/**
		 * Obtient les statistiques du cache
		 * @returns {Object} Statistiques { size, keys, debug }
		 */
		function getCacheStats() {
		    return {
		        size: styleCache.size,
		        keys: Array.from(styleCache.keys()),
		        debug: loaderConfig.debug,
		        cacheEnabled: !loaderConfig.debug
		    };
		}

		/**
		 * Charge un style depuis une configuration de couche
		 * D√©tecte automatiquement les r√©f√©rences obsol√®tes √† styleFile
		 * @param {string} profileId - ID du profil
		 * @param {Object} layerConfig - Configuration de la couche
		 * @param {string} styleIdOrFileName - ID du style ou nom de fichier
		 * @returns {Promise<Object>} Style charg√©
		 */
		async function loadStyleFromLayerConfig(profileId, layerConfig, styleIdOrFileName) {
		    const layerId = layerConfig.id;
		    const layerDirectory = layerConfig._layerDirectory || `layers/${layerId}`;

		    // V√©rifier si styleFile est pr√©sent dans labels (configuration obsol√®te)
		    if (layerConfig.labels && layerConfig.labels.styleFile) {
		        const errorMessage =
		            `‚ùå CONFIGURATION OBSOL√àTE D√âTECT√âE\n` +
		            `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
		            `La couche "${layerId}" utilise une r√©f√©rence obsol√®te √† un fichier\n` +
		            `de labels s√©par√© via "labels.styleFile".\n\n` +
		            `GeoLeaf ne supporte plus les fichiers de labels s√©par√©s (styleLabel.json).\n` +
		            `Les labels doivent √™tre int√©gr√©s dans les fichiers de style.\n\n` +
		            `Valeur d√©tect√©e: ${layerConfig.labels.styleFile}\n` +
		            `Profil: ${profileId}\n` +
		            `Couche: ${layerId}\n\n` +
		            `Action requise:\n` +
		            `1. Supprimez la propri√©t√© "labels.styleFile" de la configuration\n` +
		            `2. Int√©grez les labels dans les fichiers de style (propri√©t√© "label")\n` +
		            `3. Consultez docs/STYLE_FORMAT_SPEC.md pour la syntaxe\n` +
		            `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`;

		        console.error(errorMessage);
		        throw new Error(`Configuration obsol√®te: labels.styleFile d√©tect√© dans la couche ${layerId}`);
		    }

		    // Trouver le fichier de style dans styles.available
		    let styleFileName = styleIdOrFileName;
		    let styleId = styleIdOrFileName;

		    if (layerConfig.styles && layerConfig.styles.available) {
		        const styleConfig = layerConfig.styles.available.find(s => s.id === styleIdOrFileName || s.file === styleIdOrFileName);
		        if (styleConfig) {
		            styleFileName = styleConfig.file;
		            styleId = styleConfig.id;
		        }
		    }

		    return loadAndValidateStyle(profileId, layerId, styleId, styleFileName, layerDirectory);
		}

		/**
		 * Construit le chemin complet d'un fichier de style
		 * @param {string} profileId - ID du profil
		 * @param {string} layerDirectory - R√©pertoire de la couche
		 * @param {string} styleFileName - Nom du fichier
		 * @returns {string} Chemin complet
		 */
		function getStylePath(profileId, layerDirectory, styleFileName) {
		    return `profiles/${profileId}/${layerDirectory}/styles/${styleFileName}`;
		}

		/**
		 * Module Style Loader
		 * Expose toutes les fonctions publiques
		 */
		const StyleLoader = {
		    initStyleLoader,
		    loadAndValidateStyle,
		    extractLabelConfig,
		    loadStyleLenient,
		    preloadStyles,
		    clearStyleCache,
		    getCacheStats,
		    loadStyleFromLayerConfig,
		    getStylePath,
		    styleCache // Export pour tests/debugging
		};

		// Exposer le module
		GeoLeaf._StyleLoader = StyleLoader;

		})(window);
		return styleLoader;
	}

	requireStyleLoader();

	var loader = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredLoader;

	function requireLoader () {
		if (hasRequiredLoader) return loader;
		hasRequiredLoader = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Config.Loader
		     *
		     * Responsabilit√©s :
		     * - Chargement HTTP via fetch() avec validation CSRF/XSS
		     * - Validation Content-Type stricte
		     * - Gestion des headers personnalis√©s
		     * - Helper g√©n√©rique _fetchJson()
		     */
		    const LoaderModule = {
		        /**
		         * Charge une configuration depuis une URL JSON et retourne l'objet.
		         *
		         * @param {string} url - URL du fichier JSON
		         * @param {Object} [options] - Options de chargement
		         * @param {Object} [options.headers] - Headers HTTP personnalis√©s (ex: CSRF token)
		         * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type
		         * @returns {Promise<Object>}
		         * @example
		         * Loader.loadUrl('/api/config.json', {
		         *     headers: { 'X-CSRF-Token': '...' },
		         *     strictContentType: true
		         * })
		         */
		        loadUrl(url, options = {}) {
		            if (!url) {
		                Log.warn("[GeoLeaf.Config.Loader] URL JSON manquante dans loadUrl().");
		                return Promise.resolve({});
		            }

		            const { headers = {}, strictContentType = true } = options;

		            // Validation de l'URL avec le module Security
		            const Security =
		                typeof GeoLeaf !== "undefined" && GeoLeaf.Security
		                    ? GeoLeaf.Security
		                    : null;

		            // Pour les URLs relatives (commen√ßant par ./ ou ../ ou /), on les laisse passer
		            const isRelative = /^\.{0,2}\//.test(url) || /^\/[^/]/.test(url);

		            if (!isRelative) {
		                // URL absolue : validation stricte avec Security.validateUrl
		                if (Security && typeof Security.validateUrl === "function") {
		                    try {
		                        url = Security.validateUrl(url);
		                    } catch (e) {
		                        const errMsg = "[GeoLeaf.Config.Loader] " + e.message;
		                        Log.error(errMsg);
		                        return Promise.reject(new Error(errMsg));
		                    }
		                } else {
		                    // Fallback : v√©rification basique si Security pas disponible
		                    if (!/^https?:\/\//i.test(url)) {
		                        const errMsg =
		                            "[GeoLeaf.Config.Loader] URL doit √™tre relative ou commencer par http:// ou https://";
		                        Log.error(errMsg);
		                        return Promise.reject(new Error(errMsg));
		                    }
		                }
		            }

		            // Configuration fetch avec headers personnalis√©s
		            const fetchOptions = {
		                method: "GET",
		                headers: {
		                    Accept: "application/json",
		                    ...headers
		                }
		            };

		            return fetch(url, fetchOptions)
		                .then((response) => {
		                    if (!response.ok) {
		                        throw new Error("HTTP " + response.status + " pour " + url);
		                    }

		                    // Validation Content-Type stricte
		                    const contentType = response.headers.get("content-type");
		                    if (strictContentType) {
		                        if (!contentType || !contentType.includes("application/json")) {
		                            throw new Error(
		                                "[GeoLeaf.Config.Loader] Content-Type invalide: attendu 'application/json', re√ßu '" +
		                                (contentType || "null") +
		                                "'. Cela peut indiquer une attaque XSS ou un serveur mal configur√©."
		                            );
		                        }
		                    } else if (contentType && !contentType.includes("application/json")) {
		                        Log.warn("[GeoLeaf.Config.Loader] Content-Type inattendu:", contentType);
		                    }

		                    // Security: Wrap response.json() to handle parse errors
		                    return response.json().catch((parseErr) => {
		                        const errMsg = "[GeoLeaf.Config.Loader] Erreur de parsing JSON pour " + url + ": " + parseErr.message;
		                        Log.error(errMsg);
		                        throw new Error(errMsg);
		                    });
		                })
		                .then((jsonCfg) => {
		                    if (typeof jsonCfg !== "object" || jsonCfg === null) {
		                        throw new Error("Le JSON de configuration n'est pas un objet valide.");
		                    }

		                    return jsonCfg;
		                })
		                .catch((err) => {
		                    Log.error("[GeoLeaf.Config.Loader] Erreur lors du chargement JSON :", err);
		                    throw err;
		                });
		        },

		        /**
		         * Helper interne pour charger un JSON sans le fusionner dans la configuration.
		         *
		         * @param {string} url
		         * @param {Object} [options]
		         * @param {Object} [options.headers]
		         * @param {boolean} [options.strictContentType=true]
		         * @returns {Promise<Object|null>}
		         */
		        fetchJson(url, options = {}) {
		            if (!url) {
		                Log.warn("[GeoLeaf.Config.Loader] fetchJson() appel√© sans URL.");
		                return Promise.resolve(null);
		            }

		            const { headers = {}, strictContentType = true } = options;

		            const Security =
		                typeof GeoLeaf !== "undefined" && GeoLeaf.Security
		                    ? GeoLeaf.Security
		                    : null;

		            const isRelative =
		                /^\.{0,2}\//.test(url) || /^\/[^/]/.test(url);

		            if (!isRelative) {
		                if (Security && typeof Security.validateUrl === "function") {
		                    try {
		                        url = Security.validateUrl(url);
		                    } catch (e) {
		                        const errMsg =
		                            "[GeoLeaf.Config.Loader] " + e.message;
		                        Log.error(errMsg);
		                        return Promise.reject(new Error(errMsg));
		                    }
		                } else {
		                    if (!/^https?:\/\//i.test(url)) {
		                        const errMsg =
		                            "[GeoLeaf.Config.Loader] URL doit √™tre relative ou commencer par http:// ou https://";
		                        Log.error(errMsg);
		                        return Promise.reject(new Error(errMsg));
		                    }
		                }
		            }

		            const fetchOptions = {
		                method: "GET",
		                headers: {
		                    Accept: "application/json",
		                    ...headers
		                }
		            };

		            return fetch(url, fetchOptions)
		                .then((response) => {
		                    if (!response.ok) {
		                        throw new Error("HTTP " + response.status + " pour " + url);
		                    }

		                    const contentType = response.headers.get("content-type");
		                    if (strictContentType) {
		                        if (!contentType || !contentType.includes("application/json")) {
		                            throw new Error(
		                                "[GeoLeaf.Config.Loader] Content-Type invalide dans fetchJson: attendu 'application/json', re√ßu '" +
		                                (contentType || "null") +
		                                "'."
		                            );
		                        }
		                    } else if (contentType && !contentType.includes("application/json")) {
		                        Log.warn("[GeoLeaf.Config.Loader] fetchJson() Content-Type inattendu:", contentType);
		                    }

		                    // Security: Wrap response.json() to handle parse errors
		                    return response.json().catch((parseErr) => {
		                        const errMsg = "[GeoLeaf.Config.Loader] Erreur de parsing JSON dans fetchJson pour " + url + ": " + parseErr.message;
		                        Log.error(errMsg);
		                        throw new Error(errMsg);
		                    });
		                })
		                .then((json) => {
		                    if (typeof json !== "object" || json === null) {
		                        Log.warn(
		                            "[GeoLeaf.Config.Loader] fetchJson() a re√ßu un JSON non-objet pour l'URL :",
		                            url
		                        );
		                    }
		                    return json;
		                })
		                .catch((err) => {
		                    Log.error(
		                        "[GeoLeaf.Config.Loader] Erreur fetchJson() pour " + url + " :",
		                        err
		                    );
		                    throw err; // Re-throw pour que l'appelant puisse g√©rer l'erreur
		                });
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ConfigLoader = LoaderModule;
		})(window);
		return loader;
	}

	requireLoader();

	var storage = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredStorage;

	function requireStorage () {
		if (hasRequiredStorage) return storage;
		hasRequiredStorage = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Config.Storage
		     *
		     * Responsabilit√©s :
		     * - Stockage et gestion de la configuration consolid√©e
		     * - API get/set avec chemins "a.b.c"
		     * - Fusion profonde (deep merge)
		     * - Helpers de navigation dans l'arbre de config
		     */
		    const StorageModule = {
		        /**
		         * Configuration interne (r√©f√©rence partag√©e)
		         * @type {Object}
		         * @private
		         */
		        _config: null,

		        /**
		         * Initialise le module avec une r√©f√©rence √† la config.
		         *
		         * @param {Object} config - R√©f√©rence √† l'objet de configuration global
		         */
		        init(config) {
		            this._config = config;
		        },

		        /**
		         * Retourne la configuration compl√®te (objet).
		         *
		         * @returns {Object}
		         */
		        getAll() {
		            return this._config || {};
		        },

		        /**
		         * R√©cup√®re une valeur via un chemin de type "map.center" ou "basemaps.street.url".
		         *
		         * @param {string} path - Chemin avec des points.
		         * @param {*} [defaultValue] - Valeur renvoy√©e si le chemin n'existe pas.
		         * @returns {*}
		         */
		        get(path, defaultValue) {
		            if (!this._config) {
		                return typeof defaultValue === "undefined" ? undefined : defaultValue;
		            }

		            if (!path || typeof path !== "string") {
		                return typeof defaultValue === "undefined" ? undefined : defaultValue;
		            }

		            const segments = path.split(".");
		            let current = this._config;

		            for (let i = 0; i < segments.length; i++) {
		                const key = segments[i];
		                if (current && Object.prototype.hasOwnProperty.call(current, key)) {
		                    current = current[key];
		                } else {
		                    return typeof defaultValue === "undefined" ? undefined : defaultValue;
		                }
		            }

		            return current;
		        },

		        /**
		         * D√©finit une valeur via un chemin de type "map.center" ou "basemaps.street.url".
		         * Cr√©e les objets interm√©diaires si n√©cessaire.
		         *
		         * @param {string} path
		         * @param {*} value
		         */
		        set(path, value) {
		            if (!this._config) {
		                Log.warn("[GeoLeaf.Config.Storage] Configuration non initialis√©e.");
		                return;
		            }

		            if (!path || typeof path !== "string") {
		                Log.warn("[GeoLeaf.Config.Storage] set() requiert un chemin string.");
		                return;
		            }

		            const segments = path.split(".");
		            let current = this._config;

		            for (let i = 0; i < segments.length; i++) {
		                const key = segments[i];

		                if (i === segments.length - 1) {
		                    current[key] = value;
		                } else {
		                    if (
		                        !Object.prototype.hasOwnProperty.call(current, key) ||
		                        typeof current[key] !== "object" ||
		                        current[key] === null
		                    ) {
		                        current[key] = {};
		                    }
		                    current = current[key];
		                }
		            }
		        },

		        /**
		         * Retourne une section de configuration (ex : "basemaps", "map").
		         *
		         * @param {string} sectionName
		         * @param {Object} [defaultValue]
		         * @returns {Object|*}
		         */
		        getSection(sectionName, defaultValue) {
		            if (!sectionName) {
		                return typeof defaultValue === "undefined" ? undefined : defaultValue;
		            }
		            const value = this.get(sectionName);
		            if (typeof value === "undefined") {
		                return typeof defaultValue === "undefined" ? undefined : defaultValue;
		            }
		            return value;
		        },

		        /**
		         * Fusion profonde (deep merge) simple pour objets JSON.
		         *
		         * @param {Object} target
		         * @param {Object} source
		         * @returns {Object}
		         */
		        deepMerge(target, source) {
		            const output = Object.assign({}, target || {});
		            if (!source || typeof source !== "object") {
		                return output;
		            }

		            Object.keys(source).forEach((key) => {
		                const srcVal = source[key];
		                const tgtVal = output[key];

		                if (
		                    srcVal &&
		                    typeof srcVal === "object" &&
		                    !Array.isArray(srcVal) &&
		                    tgtVal &&
		                    typeof tgtVal === "object" &&
		                    !Array.isArray(tgtVal)
		                ) {
		                    output[key] = this.deepMerge(tgtVal, srcVal);
		                } else {
		                    output[key] = srcVal;
		                }
		            });

		            return output;
		        },

		        /**
		         * Lecture d'une valeur via un chemin "a.b.c".
		         *
		         * @param {Object} source
		         * @param {string} path
		         * @returns {*}
		         */
		        getValueByPath(source, path) {
		            if (!source || !path) return undefined;
		            const parts = path.split(".");
		            let current = source;

		            for (let i = 0; i < parts.length; i += 1) {
		                if (current == null) {
		                    return undefined;
		                }
		                current = current[parts[i]];
		            }

		            return current;
		        },

		        /**
		         * √âcriture d'une valeur via un chemin "a.b.c".
		         * Cr√©e les sous-objets interm√©diaires si n√©cessaire.
		         *
		         * @param {Object} target
		         * @param {string} path
		         * @param {*} value
		         */
		        setValueByPath(target, path, value) {
		            if (!target || !path) return;
		            const parts = path.split(".");
		            let current = target;

		            for (let i = 0; i < parts.length - 1; i += 1) {
		                const key = parts[i];
		                if (
		                    !Object.prototype.hasOwnProperty.call(current, key) ||
		                    current[key] == null
		                ) {
		                    current[key] = {};
		                }
		                current = current[key];
		            }

		            current[parts[parts.length - 1]] = value;
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ConfigStorage = StorageModule;
		})(window);
		return storage;
	}

	requireStorage();

	var normalization = {};

	var hasRequiredNormalization;

	function requireNormalization () {
		if (hasRequiredNormalization) return normalization;
		hasRequiredNormalization = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Config.Normalization
		     *
		     * Responsabilit√©s :
		     * - Normalisation structurelle des POI (mapping brut ‚Üí format GeoLeaf)
		     * - Application de mapping.json sur POI non normalis√©s
		     * - Normalisation des avis (reviews) : ancien/nouveau format
		     * - Validation de la structure POI : id/title/location
		     */
		    const NormalizationModule = {
		        /**
		         * Safe object assignment that prevents prototype pollution.
		         * Blocks dangerous keys: __proto__, constructor, prototype
		         * @param {Object} target
		         * @param {Object} source
		         * @returns {Object}
		         * @private
		         */
		        _safeAssign(target, source) {
		            const dangerousKeys = ['__proto__', 'constructor', 'prototype'];

		            for (const key in source) {
		                if (!source.hasOwnProperty(key)) continue;
		                if (dangerousKeys.includes(key)) {
		                    Log.warn('[GeoLeaf.Config.Normalization] Tentative de pollution de prototype bloqu√©e', { key });
		                    continue;
		                }
		                target[key] = source[key];
		            }

		            return target;
		        },

		        /**
		         * V√©rifie si un POI est d√©j√† normalis√© au format GeoLeaf :
		         * {
		         *   id: string,
		         *   title: string,
		         *   location: { lat: number, lng: number },
		         *   attributes?: object
		         * }
		         *
		         * @param {Object} poi
		         * @returns {boolean}
		         */
		        isPoiStructNormalized(poi) {
		            if (!poi || typeof poi !== "object") return false;

		            if (typeof poi.id !== "string" || poi.id.trim() === "") {
		                return false;
		            }

		            // Supporter les deux formats de label/titre
		            const hasTitle = typeof poi.title === "string" && poi.title.trim() !== "";
		            const hasLabel = typeof poi.label === "string" && poi.label.trim() !== "";
		            if (!hasTitle && !hasLabel) {
		                return false;
		            }

		            // Nouveau format : latlng = [lat, lng]
		            if (Array.isArray(poi.latlng) && poi.latlng.length >= 2) {
		                const lat = poi.latlng[0];
		                const lng = poi.latlng[1];
		                if (typeof lat === "number" && !Number.isNaN(lat) &&
		                    typeof lng === "number" && !Number.isNaN(lng)) {
		                    return true;
		                }
		            }

		            // Ancien format : location.lat/lng
		            if (poi.location && typeof poi.location === "object") {
		                const lat = poi.location.lat;
		                const lng = poi.location.lng;
		                if (typeof lat === "number" && !Number.isNaN(lat) &&
		                    typeof lng === "number" && !Number.isNaN(lng)) {
		                    return true;
		                }
		            }

		            return false;
		        },

		        /**
		         * Applique un mapping brut ‚Üí POI normalis√© pour un POI donn√©.
		         *
		         * @param {Object} rawPoi
		         * @param {Object} mappingDef  mappingConfig.mapping
		         * @returns {Object|null}
		         */
		        mapRawPoiToNormalized(rawPoi, mappingDef) {
		            if (!rawPoi || !mappingDef || typeof mappingDef !== "object") {
		                return null;
		            }

		            const Storage = GeoLeaf._ConfigStorage;
		            if (!Storage) {
		                Log.error("[GeoLeaf.Config.Normalization] Module Storage non disponible.");
		                return null;
		            }

		            // Socle minimal conforme au cahier des charges POI
		            const normalized = {
		                id: "",
		                title: "",
		                location: { lat: 0, lng: 0 },
		                attributes: {}
		            };

		            Object.keys(mappingDef).forEach((targetPath) => {
		                const sourcePath = mappingDef[targetPath];
		                if (!sourcePath) return;

		                const value = Storage.getValueByPath(rawPoi, sourcePath);
		                if (typeof value === "undefined") return;

		                Storage.setValueByPath(normalized, targetPath, value);
		            });

		            if (
		                !normalized.attributes ||
		                typeof normalized.attributes !== "object" ||
		                Array.isArray(normalized.attributes)
		            ) {
		                normalized.attributes = {};
		            }

		            return normalized;
		        },

		        /**
		         * Normalise structurellement un tableau de POI en utilisant
		         * √©ventuellement mapping.json du profil actif.
		         *
		         * R√®gles :
		         *  - SANS mapping.json :
		         *      ‚Üí on renvoie les POI tels quels (comportement 100 % r√©trocompatible).
		         *  - AVEC mapping.json :
		         *      ‚Üí si le POI est d√©j√† normalis√© ‚Üí on le garde tel quel ;
		         *      ‚Üí sinon, on applique le mapping ;
		         *      ‚Üí si apr√®s mapping le POI reste non normalis√© ‚Üí POI ignor√© (warning).
		         *
		         * @param {Array} rawPoiArray
		         * @param {Object|null} mappingConfig  mapping.json complet ou null
		         * @returns {Array}
		         */
		        normalizePoiWithMapping(rawPoiArray, mappingConfig) {
		            if (!Array.isArray(rawPoiArray)) {
		                return [];
		            }

		            const hasMapping =
		                mappingConfig &&
		                typeof mappingConfig === "object" &&
		                mappingConfig.mapping &&
		                typeof mappingConfig.mapping === "object";

		            // üîÅ CAS 1 ‚Äî AUCUN mapping.json fourni :
		            // on ne touche √† rien, on renvoie les POI du profil tels quels.
		            if (!hasMapping) {
		                Log.debug(
		                    "[GeoLeaf.Config.Normalization] Aucun mapping.json fourni ; " +
		                    "les POI sont utilis√©s tels quels (aucune normalisation structurelle)."
		                );
		                return rawPoiArray;
		            }

		            // üîÅ CAS 2 ‚Äî mapping.json pr√©sent : on applique vraiment la normalisation
		            const mappingDef = mappingConfig.mapping;
		            const result = [];

		            rawPoiArray.forEach((rawPoi, index) => {
		                // 1) D√©j√† normalis√© ‚Üí on garde
		                if (this.isPoiStructNormalized(rawPoi)) {
		                    result.push(rawPoi);
		                    return;
		                }

		                // 2) Non normalis√© + mapping ‚Üí tentative de normalisation
		                const normalized = this.mapRawPoiToNormalized(rawPoi, mappingDef);
		                if (normalized && this.isPoiStructNormalized(normalized)) {
		                    result.push(normalized);
		                } else {
		                    Log.warn(
		                        "[GeoLeaf.Config.Normalization] POI non normalis√© m√™me apr√®s application du mapping ; POI ignor√©.",
		                        {
		                            poiIndex: index,
		                            poiId: rawPoi && rawPoi.id
		                        }
		                    );
		                }
		            });

		            return result;
		        },

		        /**
		         * Normalise le tableau de POI, notamment pour les avis (reviews).
		         *
		         * - Alimente syst√©matiquement `attributes.reviews` si des avis sont pr√©sents.
		         * - Supporte l'ancien format (tableau simple) et le nouveau format objet
		         *   `{ rating, count, summary, recent[] }`.
		         *
		         * @param {Array} poiArray
		         * @returns {Array}
		         */
		        normalizePoiArray(poiArray) {
		            if (!Array.isArray(poiArray)) {
		                return poiArray;
		            }

		            return poiArray.map((poi, index) => {
		                if (!poi || typeof poi !== "object") {
		                    return poi;
		                }

		                // Copie superficielle du POI avec protection contre la pollution de prototype
		                // Protection: on cr√©e un objet vide sans prototype et copie les propri√©t√©s
		                // en excluant __proto__, constructor, prototype
		                const normalized = this._safeAssign({}, poi);

		                // Bloc attributes existant ou nouveau
		                const baseAttributes =
		                    normalized.attributes &&
		                    typeof normalized.attributes === "object" &&
		                    !Array.isArray(normalized.attributes)
		                        ? normalized.attributes
		                        : {};

		                const attributes = this._safeAssign({}, baseAttributes);

		                // Handle reviews - preserve full structure when it exists
		                // 1) If attributes.reviews is already an object with recent array (new format), preserve it
		                if (
		                    attributes.reviews &&
		                    typeof attributes.reviews === "object" &&
		                    !Array.isArray(attributes.reviews) &&
		                    Array.isArray(attributes.reviews.recent)
		                ) {
		                    // Keep the full reviews object: { rating, count, summary, recent: [...] }
		                    // Just limit the recent array to 5
		                    attributes.reviews = {
		                        ...attributes.reviews,
		                        recent: attributes.reviews.recent.slice(0, 5)
		                    };
		                }
		                // 2) If poi.reviews is an object with recent array (new format at root), move to attributes
		                else if (
		                    normalized.reviews &&
		                    typeof normalized.reviews === "object" &&
		                    !Array.isArray(normalized.reviews) &&
		                    Array.isArray(normalized.reviews.recent)
		                ) {
		                    attributes.reviews = {
		                        ...normalized.reviews,
		                        recent: normalized.reviews.recent.slice(0, 5)
		                    };
		                }
		                // 3) Legacy: attributes.reviews is already a flat array
		                else if (Array.isArray(attributes.reviews)) {
		                    attributes.reviews = attributes.reviews.slice(0, 5);
		                }
		                // 4) Legacy: poi.reviews is a flat array at root
		                else if (Array.isArray(normalized.reviews)) {
		                    attributes.reviews = normalized.reviews.slice(0, 5);
		                }
		                // 5) Unexpected format
		                else if (normalized.reviews !== undefined || attributes.reviews !== undefined) {
		                    Log.warn("[GeoLeaf.Config.Normalization] Format de `reviews` inattendu pour le POI :", {
		                        poiIndex: index,
		                        poiId: normalized.id,
		                        reviewsType: typeof normalized.reviews,
		                        attributesReviewsType: typeof attributes.reviews
		                    });
		                    attributes.reviews = [];
		                }
		                // 6) No reviews at all
		                else {
		                    attributes.reviews = [];
		                }

		                normalized.attributes = attributes;

		                return normalized;
		            });
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ConfigNormalization = NormalizationModule;
		})(window);
		return normalization;
	}

	requireNormalization();

	var taxonomy = {};

	var hasRequiredTaxonomy;

	function requireTaxonomy () {
		if (hasRequiredTaxonomy) return taxonomy;
		hasRequiredTaxonomy = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Config.Taxonomy
		     *
		     * Responsabilit√©s :
		     * - Chargement et gestion de la taxonomie (cat√©gories/sous-cat√©gories)
		     * - Lecture des cat√©gories depuis mapping.json (ancienne taxonomie)
		     * - Lecture des cat√©gories depuis profile.json (nouvelle taxonomie)
		     * - API de consultation : getCategories(), getCategory(), getSubcategory()
		     */
		    const TaxonomyModule = {
		        /**
		         * Configuration interne (r√©f√©rence partag√©e)
		         * @type {Object}
		         * @private
		         */
		        _config: null,

		        /**
		         * Initialise le module avec une r√©f√©rence √† la config.
		         *
		         * @param {Object} config - R√©f√©rence √† l'objet de configuration global
		         */
		        init(config) {
		            this._config = config;
		        },

		        /**
		         * Charge un fichier de taxonomie (mapping cat√©gories / sous-cat√©gories)
		         * et le fusionne dans la configuration existante.
		         *
		         * @param {string} [url] - URL du fichier de mapping (depuis le profil)
		         * @param {Object} [options]
		         * @param {Object} [options.headers]
		         * @param {boolean} [options.strictContentType=true]
		         * @returns {Promise<Object>} - Objet categories consolid√©
		         */
		        loadTaxonomy(url = null, options = {}) {
		            const Loader = GeoLeaf._ConfigLoader;
		            if (!Loader) {
		                Log.error("[GeoLeaf.Config.Taxonomy] Module Loader non disponible.");
		                return Promise.reject(new Error("Loader module not available"));
		            }

		            if (!url) {
		                Log.info("[GeoLeaf.Config.Taxonomy] Aucune URL de mapping fournie ‚Äî skip.");
		                return Promise.resolve({});
		            }

		            return Loader.loadUrl(url, options)
		                .then((cfg) => {
		                    const hasCategories =
		                        cfg &&
		                        typeof cfg === "object" &&
		                        cfg.categories &&
		                        typeof cfg.categories === "object" &&
		                        !Array.isArray(cfg.categories);

		                    if (!hasCategories) {
		                        Log.warn(
		                            "[GeoLeaf.Config.Taxonomy] Fichier de mapping cat√©gories charg√© mais " +
		                            "aucune propri√©t√© 'categories' valide trouv√©e (attendu: { \"categories\": { ... } })."
		                        );
		                    } else {
		                        // Fusionner dans la config
		                        if (!this._config.categories || typeof this._config.categories !== "object") {
		                            this._config.categories = {};
		                        }
		                        Object.assign(this._config.categories, cfg.categories);

		                        Log.info(
		                            "[GeoLeaf.Config.Taxonomy] Mapping cat√©gories fusionn√© avec succ√®s."
		                        );
		                    }

		                    return this.getCategories();
		                })
		                .catch((err) => {
		                    Log.error("[GeoLeaf.Config.Taxonomy] Erreur lors du chargement de la taxonomie :", err);
		                    return {};
		                });
		        },

		        /**
		         * Retourne l'objet complet des cat√©gories (mapping interne).
		         *
		         * @returns {Object} - { [categoryId]: { label, icon, colorFill, colorStroke, subcategories? } }
		         */
		        getCategories() {
		            if (!this._config) return {};
		            const cats = this._config.categories;
		            return (cats && typeof cats === "object" && !Array.isArray(cats)) ? cats : {};
		        },

		        /**
		         * Retourne une cat√©gorie √† partir de son identifiant.
		         *
		         * @param {string} categoryId
		         * @returns {Object|undefined}
		         */
		        getCategory(categoryId) {
		            if (!categoryId || typeof categoryId !== "string") {
		                return undefined;
		            }

		            const cats = this.getCategories();
		            if (!Object.prototype.hasOwnProperty.call(cats, categoryId)) {
		                return undefined;
		            }

		            return cats[categoryId];
		        },

		        /**
		         * Retourne une sous-cat√©gorie √† partir de son identifiant et de celui
		         * de la cat√©gorie parente.
		         *
		         * @param {string} categoryId
		         * @param {string} subCategoryId
		         * @returns {Object|undefined}
		         */
		        getSubcategory(categoryId, subCategoryId) {
		            if (
		                !categoryId || typeof categoryId !== "string" ||
		                !subCategoryId || typeof subCategoryId !== "string"
		            ) {
		                return undefined;
		            }

		            const category = this.getCategory(categoryId);
		            if (
		                !category ||
		                !category.subcategories ||
		                typeof category.subcategories !== "object" ||
		                Array.isArray(category.subcategories)
		            ) {
		                return undefined;
		            }

		            const subs = category.subcategories;
		            if (!Object.prototype.hasOwnProperty.call(subs, subCategoryId)) {
		                return undefined;
		            }

		            return subs[subCategoryId];
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ConfigTaxonomy = TaxonomyModule;
		})(window);
		return taxonomy;
	}

	requireTaxonomy();

	var profileV3Loader = {};

	/**
	 * @fileoverview Chargeur de profil V3.0 pour GeoLeaf
	 * G√®re le chargement modulaire des profils avec structure V3:
	 * - profile.json (m√©tadonn√©es)
	 * - taxonomy.json (cat√©gories/sous-cat√©gories)
	 * - themes.json (th√®mes visuels)
	 * - layers.json (index des couches)
	 * - layers/{layerId}/{layerId}_config.json (config par couche)
	 * @module config/profile-v3-loader
	 */

	var hasRequiredProfileV3Loader;

	function requireProfileV3Loader () {
		if (hasRequiredProfileV3Loader) return profileV3Loader;
		hasRequiredProfileV3Loader = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Module de chargement de profils V3.0
		     * @namespace ProfileV3Loader
		     */
		    const ProfileV3Loader = {
		        /**
		         * Charge un profil v3.0 avec structure modulaire
		         * @param {Object} profile - Objet profile.json v3.0
		         * @param {string} baseUrl - URL de base du profil
		         * @param {string} profileId - ID du profil
		         * @param {number} timestamp - Timestamp pour cache busting
		         * @param {Object} fetchOptions - Options de fetch
		         * @returns {Promise<Object>} Profil enrichi avec toutes les donn√©es charg√©es
		         */
		        async loadV3Profile(profile, baseUrl, profileId, timestamp = Date.now(), fetchOptions = {}) {
		            const Loader = GeoLeaf._ConfigLoader;

		            if (!Loader) {
		                throw new Error("GeoLeaf._ConfigLoader non disponible");
		            }

		            Log.info(`[ProfileV3Loader] Chargement profil V3.0: ${profileId}`);

		            try {
		                // 1. Charger les ressources en parall√®le
		                const [taxonomyData, themesData, layersFileData] = await Promise.all([
		                    this._loadTaxonomy(profile, baseUrl, timestamp, fetchOptions),
		                    this._loadThemes(profile, baseUrl, timestamp, fetchOptions),
		                    this._loadLayersFile(profile, baseUrl, timestamp, fetchOptions)
		                ]);

		                // 2. D√©terminer la source des layers
		                const layersSource = layersFileData || profile.layers || [];

		                // 3. Charger les configurations individuelles des layers
		                const layersConfigs = await this._loadLayerConfigs(
		                    layersSource,
		                    baseUrl,
		                    timestamp,
		                    fetchOptions
		                );

		                // 4. Construire le profil enrichi
		                const enrichedProfile = this._buildEnrichedProfile({
		                    profile,
		                    baseUrl,
		                    profileId,
		                    taxonomy: taxonomyData,
		                    themes: themesData,
		                    layersSource,
		                    layersConfigs
		                });

		                Log.info("[ProfileV3Loader] Profil V3.0 charg√© avec succ√®s", {
		                    profileId,
		                    hasTaxonomy: !!enrichedProfile.taxonomy,
		                    hasThemes: !!enrichedProfile.themes,
		                    layersCount: enrichedProfile.layers ? enrichedProfile.layers.length : 0
		                });

		                return enrichedProfile;

		            } catch (error) {
		                Log.error("[ProfileV3Loader] Erreur chargement profil V3.0:", error);
		                throw error;
		            }
		        },

		        /**
		         * V√©rifie si des features GeoJSON ont des categoryId/subCategoryId
		         * @private
		         * @returns {boolean} true si au moins une feature a des cat√©gories
		         */
		        _shouldLoadTaxonomy() {
		            // Toujours charger la taxonomie si elle est r√©f√©renc√©e dans le profil
		            // Les features GeoJSON ne sont pas encore charg√©es √† ce stade
		            return true;
		        },

		        /**
		         * Charge taxonomy.json si r√©f√©renc√© ET si des features ont des cat√©gories
		         * @private
		         */
		        async _loadTaxonomy(profile, baseUrl, timestamp, fetchOptions) {
		            const Loader = GeoLeaf._ConfigLoader;
		            const taxonomyFile = profile.Files?.taxonomyFile || profile.taxonomyFile;

		            if (!taxonomyFile && !profile.taxonomy) {
		                return null;
		            }

		            // V√©rifier si on doit charger la taxonomy (si features ont des cat√©gories)
		            const shouldLoad = this._shouldLoadTaxonomy();
		            if (!shouldLoad) {
		                Log.info("[ProfileV3Loader] Taxonomy.json non charg√© (aucune cat√©gorie d√©tect√©e dans les donn√©es)");
		                return null;
		            }

		            if (taxonomyFile) {
		                try {
		                    const taxonomy = await Loader.fetchJson(
		                        `${baseUrl}/${taxonomyFile}?t=${timestamp}`,
		                        fetchOptions
		                    );
		                    Log.info("[ProfileV3Loader] Taxonomy.json charg√© avec succ√®s");
		                    return taxonomy;
		                } catch (err) {
		                    Log.warn("[ProfileV3Loader] Erreur chargement taxonomy.json:", err);
		                    return null;
		                }
		            }

		            return profile.taxonomy || null;
		        },

		        /**
		         * Charge themes.json si r√©f√©renc√©
		         * @private
		         */
		        async _loadThemes(profile, baseUrl, timestamp, fetchOptions) {
		            const Loader = GeoLeaf._ConfigLoader;
		            const themesFile = profile.Files?.themesFile || profile.themesFile;

		            if (themesFile) {
		                try {
		                    const themes = await Loader.fetchJson(
		                        `${baseUrl}/${themesFile}?t=${timestamp}`,
		                        fetchOptions
		                    );
		                    return themes;
		                } catch (err) {
		                    Log.warn("[ProfileV3Loader] Erreur chargement themes.json:", err);
		                    return null;
		                }
		            }

		            return profile.themes || null;
		        },

		        /**
		         * Charge layers.json si r√©f√©renc√©
		         * @private
		         */
		        async _loadLayersFile(profile, baseUrl, timestamp, fetchOptions) {
		            const Loader = GeoLeaf._ConfigLoader;
		            const layersFile = profile.Files?.layersFile;

		            if (layersFile) {
		                try {
		                    const layers = await Loader.fetchJson(
		                        `${baseUrl}/${layersFile}?t=${timestamp}`,
		                        fetchOptions
		                    );
		                    return layers;
		                } catch (err) {
		                    Log.warn("[ProfileV3Loader] Erreur chargement layers.json:", err);
		                    return null;
		                }
		            }

		            return null;
		        },

		        /**
		         * Charge les configurations individuelles des layers
		         * @private
		         */
		        async _loadLayerConfigs(layersSource, baseUrl, timestamp, fetchOptions) {
		            const Loader = GeoLeaf._ConfigLoader;

		            if (!Array.isArray(layersSource) || layersSource.length === 0) {
		                return [];
		            }

		            const promises = layersSource.map(async (layerRef) => {
		                if (!layerRef.configFile) {
		                    return {
		                        id: layerRef.id,
		                        config: null,
		                        layerDirectory: null,
		                        layerManagerId: layerRef.layerManagerId || null
		                    };
		                }

		                const layerDirectory = layerRef.configFile.replace(/\/[^\/]+$/, '');

		                try {
		                    const layerConfig = await Loader.fetchJson(
		                        `${baseUrl}/${layerRef.configFile}?t=${timestamp}`,
		                        fetchOptions
		                    );

		                    return {
		                        id: layerRef.id,
		                        config: layerConfig,
		                        layerDirectory: layerDirectory,
		                        layerManagerId: layerRef.layerManagerId || null
		                    };
		                } catch (err) {
		                    Log.error(`[ProfileV3Loader] Erreur chargement ${layerRef.configFile}:`, err);
		                    return {
		                        id: layerRef.id,
		                        config: null,
		                        layerDirectory: layerDirectory,
		                        layerManagerId: layerRef.layerManagerId || null
		                    };
		                }
		            });

		            return Promise.all(promises);
		        },

		        /**
		         * Construit le profil enrichi avec toutes les donn√©es charg√©es
		         * @private
		         */
		        _buildEnrichedProfile(params) {
		            const { profile, baseUrl, profileId, taxonomy, themes, layersSource, layersConfigs } = params;

		            const enrichedProfile = { ...profile };

		            // Ajouter le basePath pour r√©solution des chemins
		            enrichedProfile.basePath = baseUrl;
		            enrichedProfile._profileId = profileId;

		            // Int√©grer la taxonomie
		            if (taxonomy) {
		                enrichedProfile.taxonomy = taxonomy;
		            }

		            // Int√©grer les th√®mes
		            if (themes) {
		                enrichedProfile.themes = themes;
		            }

		            // Int√©grer les configurations de couches
		            if (layersConfigs && layersConfigs.length > 0) {
		                enrichedProfile.layers = layersConfigs.map(layerData => {
		                    if (layerData.config) {
		                        // Ajouter le layerDirectory, profileId ET layerManagerId √† la config
		                        const normalized = {
		                            ...layerData.config,
		                            _layerDirectory: layerData.layerDirectory,
		                            _profileId: profileId,
		                            layerManagerId: layerData.layerManagerId || layerData.config.layerManagerId || 'geojson-default'
		                        };

		                        // Normaliser data.file ‚Üí dataFile pour compatibilit√© GeoJSON loader
		                        if (normalized.data && normalized.data.file && !normalized.dataFile) {
		                            const dataDir = normalized.data.directory || 'data';
		                            normalized.dataFile = `${dataDir}/${normalized.data.file}`;
		                        }

		                        return normalized;
		                    }
		                    // Fallback si erreur de chargement
		                    const original = layersSource.find(l => l.id === layerData.id);
		                    return original || { id: layerData.id, error: "Failed to load config" };
		                });
		            }

		            return enrichedProfile;
		        },

		        /**
		         * D√©termine si un profil utilise la structure V3.0
		         * @param {Object} profile - Objet profile.json
		         * @returns {boolean} True si V3.0
		         */
		        isV3Profile(profile) {
		            if (!profile || typeof profile !== 'object') {
		                return false;
		            }

		            // D√©tection V3.0: pr√©sence de Files ou version >= 3.0.0
		            if (profile.Files && typeof profile.Files === 'object') {
		                return true;
		            }

		            if (profile.version) {
		                const versionMatch = profile.version.match(/^(\d+)\.(\d+)/);
		                if (versionMatch) {
		                    const major = parseInt(versionMatch[1], 10);
		                    return major >= 3;
		                }
		            }

		            return false;
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ProfileV3Loader = ProfileV3Loader;

		})(window);
		return profileV3Loader;
	}

	requireProfileV3Loader();

	var profile$1 = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredProfile$1;

	function requireProfile$1 () {
		if (hasRequiredProfile$1) return profile$1;
		hasRequiredProfile$1 = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Config.Profile
		     *
		     * Responsabilit√©s :
		     * - Chargement des profils m√©tier (tourism, etc.)
		     * - Gestion des ressources de profil : profile.json, poi.json, routes.json, mapping.json
		     * - API de consultation : getActiveProfile*()
		     * - √âv√©nements DOM : geoleaf:profile:loaded
		     */
		    const ProfileModule = {
		        /**
		         * Configuration interne (r√©f√©rence partag√©e)
		         * @type {Object}
		         * @private
		         */
		        _config: null,

		        /**
		         * Profil actuellement actif (ID du profil).
		         * @type {string|null}
		         * @private
		         */
		        _activeProfileId: null,

		        /**
		         * Description du profil actif (contenu de profile.json).
		         * @type {Object|null}
		         * @private
		         */
		        _activeProfile: null,

		        /**
		         * Donn√©es rattach√©es au profil actif :
		         * - poi.json normalis√©
		         * - routes.json
		         * - mapping.json
		         * @type {{poi: Array, routes: Array, mapping: Object|null}}
		         * @private
		         */
		        _activeProfileData: {
		            poi: [],
		            routes: [],
		            mapping: null
		        },

		        /**
		         * Initialise le module avec une r√©f√©rence √† la config.
		         *
		         * @param {Object} config - R√©f√©rence √† l'objet de configuration global
		         */
		        init(config) {
		            this._config = config;
		        },

		        /**
		         * Indique si l'usage de mapping.json pour normaliser les POI de profil est activ√©.
		         *
		         * üîé Cherche plusieurs noms possibles dans config.data pour rester robuste :
		         *   - config.data.enableProfilePoiMapping (nom recommand√©)
		         *   - config.data.useProfilePoiMapping
		         *   - config.data.useMapping (compatibilit√© √©ventuelle)
		         *
		         * @returns {boolean} true si le mapping doit √™tre utilis√©, false sinon.
		         */
		        isProfilePoiMappingEnabled() {
		            const dataCfg = this._config && this._config.data;
		            if (!dataCfg || typeof dataCfg !== "object") {
		                return true; // par d√©faut : mapping actif
		            }

		            if (typeof dataCfg.enableProfilePoiMapping === "boolean") {
		                return dataCfg.enableProfilePoiMapping;
		            }
		            if (typeof dataCfg.useProfilePoiMapping === "boolean") {
		                return dataCfg.useProfilePoiMapping;
		            }
		            if (typeof dataCfg.useMapping === "boolean") {
		                return dataCfg.useMapping;
		            }

		            return true;
		        },

		        /**
		         * Charge les ressources li√©es au profil actif :
		         * - profile.json
		         * - poi.json
		         * - mapping.json
		         * - routes.json
		         *
		         * Utilise config.data.activeProfile et config.data.profilesBasePath.
		         * Injecte aussi, pour compatibilit√©, les POI et routes dans this._config.poi / this._config.routes.
		         * Injecte d√©sormais la taxonomie (categories) depuis profile.json dans this._config.categories.
		         *
		         * @param {Object} [options]
		         * @param {Object} [options.headers] - Headers HTTP optionnels.
		         * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
		         * @returns {Promise<Object>} Configuration consolid√©e incluant les donn√©es du profil.
		         */
		        loadActiveProfileResources(options = {}) {
		            const dataCfg = this._config && this._config.data;
		            if (!dataCfg || !dataCfg.activeProfile) {
		                Log.info(
		                    "[GeoLeaf.Config.Profile] Aucun profil actif d√©fini dans config.data.activeProfile ; aucun chargement de profil effectu√©."
		                );
		                return Promise.resolve(this._config);
		            }

		            // Nouveau : mode layers-only (pas de poi.json / routes.json). Par d√©faut activ√©.
		            const useLegacyProfileData =
		                typeof dataCfg.useLegacyProfileData === "boolean"
		                    ? dataCfg.useLegacyProfileData
		                    : false;

		            const profileId = dataCfg.activeProfile;
		            const basePath = dataCfg.profilesBasePath || "data/profiles";
		            const baseUrl = `${basePath}/${profileId}`;

		            Log.info("[GeoLeaf.Config.Profile] D√©but du chargement du profil :", {
		                profileId,
		                baseUrl,
		                configData: dataCfg
		            });

		            const fetchOptions = {
		                headers: options.headers || {},
		                strictContentType:
		                    typeof options.strictContentType === "boolean"
		                        ? options.strictContentType
		                        : true
		            };

		            const Loader = GeoLeaf._ConfigLoader;
		            const Normalization = GeoLeaf._ConfigNormalization;

		            if (!Loader || !Normalization) {
		                Log.error("[GeoLeaf.Config.Profile] Modules Loader ou Normalization non disponibles.");
		                return Promise.reject(new Error("Required modules not available"));
		            }

		            // üîß Nouveau : pilotage global de l'usage de mapping.json via config.data.*
		            const isPoiMappingEnabled = this.isProfilePoiMappingEnabled();
		            if (!isPoiMappingEnabled) {
		                Log.info(
		                    "[GeoLeaf.Config.Profile] Mapping de POI d√©sactiv√© via configuration globale ; " +
		                    "les POI du profil seront consid√©r√©s comme d√©j√† normalis√©s."
		                );
		            }

		            Log.info("[GeoLeaf.Config.Profile] Chargement des ressources du profil actif :", {
		                profileId,
		                baseUrl
		            });

		            const timestamp = Date.now();

		            // Branche legacy (maintien backward compat) : charge poi.json/routes.json
		            if (useLegacyProfileData) {
		                // Si le mapping est d√©sactiv√©, on ne charge pas mapping.json (Promise.resolve(null))
		                const mappingPromise = isPoiMappingEnabled
		                    ? Loader.fetchJson(`${baseUrl}/mapping.json?t=${timestamp}`, fetchOptions)
		                    : Promise.resolve(null);

		                // routes.json est optionnel - on tente de le charger mais on tol√®re son absence
		                const routesPromise = Loader.fetchJson(`${baseUrl}/routes.json?t=${timestamp}`, fetchOptions)
		                    .catch(() => {
		                        Log.info("[GeoLeaf.Config.Profile] routes.json non disponible ou invalide, utilisation d'un tableau vide.");
		                        return [];
		                    });

		                return Promise.all([
		                    Loader.fetchJson(`${baseUrl}/profile.json?t=${timestamp}`, fetchOptions),
		                    Loader.fetchJson(`${baseUrl}/poi.json?t=${timestamp}`, fetchOptions),
		                    mappingPromise,
		                    routesPromise
		                ])
		                    .then(([profile, poi, mapping, routes]) => {
		                        return this._finalizeProfileLoad({
		                            profile,
		                            poi,
		                            routes,
		                            mapping,
		                            mappingEnabled: isPoiMappingEnabled
		                        });
		                    })
		                    .catch((err) => {
		                        Log.error(
		                            "[GeoLeaf.Config.Profile] Erreur lors du chargement des ressources du profil actif :",
		                            err
		                        );
		                        return this._config;
		                    });
		            }

		            // Nouveau chemin : layers-only. On charge d'abord profile.json pour v√©rifier si mapping est requis.
		            return Loader.fetchJson(`${baseUrl}/profile.json?t=${timestamp}`, fetchOptions)
		                .then((profile) => {
		                    // Utiliser la logique de d√©tection du ProfileV3Loader pour coh√©rence
		                    const isV3 = GeoLeaf._ProfileV3Loader && GeoLeaf._ProfileV3Loader.isV3Profile(profile);

		                    if (isV3) {
		                        Log.info("[GeoLeaf.Config.Profile] Profil v3.0 d√©tect√© - Chargement modulaire");
		                        // Pour v3.0, retourner directement la config (pas besoin du .then suivant)
		                        return this._loadV3Profile(profile, baseUrl, timestamp, fetchOptions);
		                    }

		                    // Version 2.0 (ancien comportement)
		                    // V√©rifier si au moins une couche a normalized:false (n√©cessite mapping)
		                    let requiresMapping = false;
		                    if (profile && Array.isArray(profile.layers)) {
		                        requiresMapping = profile.layers.some(layer => layer.normalized === false);
		                    }

		                    // Charger mapping seulement si requis
		                    const mappingPromise = isPoiMappingEnabled && requiresMapping
		                        ? Loader.fetchJson(`${baseUrl}/mapping.json?t=${timestamp}`, fetchOptions).catch((err) => {
		                              Log.error("[GeoLeaf.Config.Profile] mapping.json requis (normalized:false) mais non trouv√© ou invalide.", err);
		                              return null;
		                          })
		                        : Promise.resolve(null);

		                    return Promise.all([Promise.resolve(profile), mappingPromise]);
		                })
		                .then((result) => {
		                    // Si c'est un profil v3.0, on le retourne directement (pas un array)
		                    if (result && !Array.isArray(result)) {
		                        return result;
		                    }

		                    // Sinon c'est un array [profile, mapping] (v2.0)
		                    const [profile, mapping] = result;
		                    this._activeProfileId = profileId;
		                    this._activeProfile = profile || null;

		                    Log.info("[GeoLeaf.Config.Profile] Profil charg√© (layers-only)", {
		                        profileId,
		                        profileLoaded: !!profile,
		                        profileKeys: profile ? Object.keys(profile) : []
		                    });

		                    // Dans ce mode, on ne pr√©charge pas les POI/Routes : ils seront lus via GeoJSON layers.
		                    this._activeProfileData = {
		                        poi: [],
		                        routes: [],
		                        mapping: mapping && typeof mapping === "object" ? mapping : null
		                    };

		                    // Taxonomie : reste depuis profile.json
		                    if (
		                        profile &&
		                        typeof profile === "object" &&
		                        profile.taxonomy &&
		                        profile.taxonomy.categories &&
		                        typeof profile.taxonomy.categories === "object" &&
		                        !Array.isArray(profile.taxonomy.categories)
		                    ) {
		                        this._config.categories = profile.taxonomy.categories;
		                        Log.info(
		                            "[GeoLeaf.Config.Profile] Taxonomie des cat√©gories charg√©e (layers-only).",
		                            {
		                                profileId,
		                                categoriesCount: Object.keys(profile.taxonomy.categories || {}).length
		                            }
		                        );
		                    }

		                    // Stockage par profil
		                    if (
		                        !this._config.profiles ||
		                        typeof this._config.profiles !== "object" ||
		                        Array.isArray(this._config.profiles)
		                    ) {
		                        this._config.profiles = {};
		                    }

		                    this._config.profiles[profileId] = {
		                        profile: this._activeProfile,
		                        poi: this._activeProfileData.poi,
		                        routes: this._activeProfileData.routes,
		                        mapping: this._activeProfileData.mapping
		                    };

		                    // √âv√©nement pour les autres modules
		                    this._fireProfileLoadedEvent(profileId, {
		                        profile: this._activeProfile,
		                        poi: this._activeProfileData.poi,
		                        routes: this._activeProfileData.routes,
		                        mapping: this._activeProfileData.mapping
		                    });

		                    return this._config;
		                })
		                .catch((err) => {
		                    Log.error(
		                        "[GeoLeaf.Config.Profile] Erreur lors du chargement des ressources du profil actif :",
		                        err
		                    );
		                    return this._config;
		                });
		        },

		        /**
		         * Charge un profil v3.0 avec structure modulaire
		         * @param {Object} profile - Objet profile.json v3.0
		         * @param {string} baseUrl - URL de base du profil
		         * @param {number} timestamp - Timestamp pour cache busting
		         * @param {Object} fetchOptions - Options de fetch
		         * @returns {Promise<Object>} Config consolid√©e
		         * @private
		         */
		        _loadV3Profile(profile, baseUrl, timestamp, fetchOptions) {
		            const profileId = this._config.data.activeProfile;

		            // Utiliser le ProfileV3Loader pour charger le profil
		            if (!GeoLeaf._ProfileV3Loader) {
		                Log.error("[GeoLeaf.Config.Profile] ProfileV3Loader non disponible");
		                return Promise.reject(new Error("ProfileV3Loader non disponible"));
		            }

		            return GeoLeaf._ProfileV3Loader.loadV3Profile(
		                profile,
		                baseUrl,
		                profileId,
		                timestamp,
		                fetchOptions
		            ).then(enrichedProfile => {
		                // Stocker le profil enrichi
		                this._activeProfileId = profileId;
		                this._activeProfile = enrichedProfile;

		                Log.info("[GeoLeaf.Config.Profile] Profil v3.0 charg√© avec succ√®s", {
		                    profileId,
		                    hasTaxonomy: !!enrichedProfile.taxonomy,
		                    hasThemes: !!enrichedProfile.themes,
		                    layersCount: enrichedProfile.layers ? enrichedProfile.layers.length : 0
		                });

		                this._activeProfileData = {
		                    poi: [],
		                    routes: [],
		                    mapping: null
		                };

		                // Stocker la taxonomie dans config.categories pour compatibilit√©
		                if (enrichedProfile.taxonomy && enrichedProfile.taxonomy.categories) {
		                    this._config.categories = enrichedProfile.taxonomy.categories;
		                    Log.info("[GeoLeaf.Config.Profile] Taxonomie charg√©e depuis v3.0", {
		                        categoriesCount: Object.keys(enrichedProfile.taxonomy.categories || {}).length
		                    });
		                }

		                // Copier toutes les propri√©t√©s du profil dans this._config
		                Object.keys(enrichedProfile).forEach(key => {
		                    if (key !== 'layers' && key !== 'taxonomy' && key !== 'themes') {
		                        this._config[key] = enrichedProfile[key];
		                    }
		                });

		                // Stocker par profil
		                if (!this._config.profiles || typeof this._config.profiles !== "object") {
		                    this._config.profiles = {};
		                }

		                this._config.profiles[profileId] = {
		                    profile: this._activeProfile,
		                    poi: [],
		                    routes: [],
		                    mapping: null
		                };

		                // √âv√©nement
		                this._fireProfileLoadedEvent(profileId, {
		                    profile: this._activeProfile,
		                    poi: [],
		                    routes: [],
		                    mapping: null
		                });

		                return enrichedProfile;
		            });
		        },

		        // Factorise la fin du chargement (branche legacy uniquement)
		        _finalizeProfileLoad({ profile, poi, routes, mapping, mappingEnabled }) {
		            const Normalization = GeoLeaf._ConfigNormalization;

		            this._activeProfile = profile || null;

		            Log.info(
		                "[GeoLeaf.Config.Profile] Profil charg√© depuis profile.json :",
		                {
		                    profileId: this._activeProfileId,
		                    profileLoaded: profile !== null && profile !== undefined,
		                    profileKeys: profile ? Object.keys(profile) : []
		                }
		            );

		            // Si le mapping est coup√© au niveau global, on l'ignore m√™me s'il existe
		            const mappingForNormalization =
		                mappingEnabled && mapping && typeof mapping === "object"
		                    ? mapping
		                    : null;

		            // 1) Normalisation STRUCTURELLE des POI
		            const structurallyNormalizedPoi = Array.isArray(poi)
		                ? Normalization.normalizePoiWithMapping(poi, mappingForNormalization)
		                : [];

		            // 2) Normalisation m√©tier des avis
		            const normalizedPoi = Normalization.normalizePoiArray(structurallyNormalizedPoi);

		            const safeMapping = mappingForNormalization;
		            const safeRoutes = Array.isArray(routes) ? routes : [];

		            this._activeProfileData = {
		                poi: normalizedPoi,
		                mapping: safeMapping,
		                routes: safeRoutes
		            };

		            // Injection r√©trocompatible dans la config globale
		            if (normalizedPoi.length) {
		                this._config.poi = normalizedPoi;
		            }
		            if (safeRoutes.length) {
		                this._config.routes = safeRoutes;
		            }

		            // Taxonomie
		            if (
		                profile &&
		                typeof profile === "object" &&
		                profile.taxonomy &&
		                profile.taxonomy.categories &&
		                typeof profile.taxonomy.categories === "object" &&
		                !Array.isArray(profile.taxonomy.categories)
		            ) {
		                this._config.categories = profile.taxonomy.categories;
		                Log.info(
		                    "[GeoLeaf.Config.Profile] Taxonomie des cat√©gories charg√©e depuis le profil actif.",
		                    {
		                        profileId: this._activeProfileId,
		                        categoriesCount: Object.keys(profile.taxonomy.categories || {}).length
		                    }
		                );
		            }

		            // Stockage par profil
		            if (
		                !this._config.profiles ||
		                typeof this._config.profiles !== "object" ||
		                Array.isArray(this._config.profiles)
		            ) {
		                this._config.profiles = {};
		            }

		            this._config.profiles[this._activeProfileId] = {
		                profile: this._activeProfile,
		                poi: this._activeProfileData.poi,
		                routes: this._activeProfileData.routes,
		                mapping: this._activeProfileData.mapping
		            };

		            // √âv√©nement
		            this._fireProfileLoadedEvent(this._activeProfileId, {
		                profile: this._activeProfile,
		                poi: this._activeProfileData.poi,
		                routes: this._activeProfileData.routes,
		                mapping: this._activeProfileData.mapping
		            });

		            return this._config;
		        },

		        /**
		         * Retourne l'identifiant du profil actuellement charg√© (ou null).
		         *
		         * @returns {string|null}
		         */
		        getActiveProfileId() {
		            return this._activeProfileId;
		        },

		        /**
		         * Retourne l'objet profile.json du profil actif (ou null).
		         *
		         * @returns {Object|null}
		         */
		        getActiveProfile() {
		            return this._activeProfile;
		        },

		        /**
		         * Retourne le tableau de POI normalis√©s du profil actif.
		         *
		         * @returns {Array}
		         */
		        getActiveProfilePoi() {
		            return (this._activeProfileData && Array.isArray(this._activeProfileData.poi))
		                ? this._activeProfileData.poi
		                : [];
		        },

		        /**
		         * Retourne le tableau de routes du profil actif.
		         *
		         * @returns {Array}
		         */
		        getActiveProfileRoutes() {
		            return (this._activeProfileData && Array.isArray(this._activeProfileData.routes))
		                ? this._activeProfileData.routes
		                : [];
		        },

		        /**
		         * Retourne l'objet de mapping du profil actif (mapping.json).
		         *
		         * @returns {Object|null}
		         */
		        getActiveProfileMapping() {
		            return (this._activeProfileData && this._activeProfileData.mapping)
		                ? this._activeProfileData.mapping
		                : null;
		        },

		        /**
		         * Retourne la configuration des ic√¥nes depuis la taxonomie du profil actif.
		         *
		         * @returns {Object|null}
		         */
		        getIconsConfig() {
		            return (this._activeProfile && this._activeProfile.taxonomy && this._activeProfile.taxonomy.icons)
		                ? this._activeProfile.taxonomy.icons
		                : null;
		        },

		        /**
		         * Retourne les configurations de couches charg√©es depuis le profil actif v3.0
		         *
		         * @returns {Array|null}
		         */
		        getActiveProfileLayersConfig() {
		            return (this._activeProfile && this._activeProfile.layers)
		                ? this._activeProfile.layers
		                : null;
		        },

		        /**
		         * √âmet un √©v√©nement DOM "geoleaf:profile:loaded" lorsque le profil
		         * actif et ses donn√©es associ√©es sont charg√©s.
		         *
		         * @param {string} profileId
		         * @param {Object} payload
		         * @private
		         */
		        _fireProfileLoadedEvent(profileId, payload) {
		            if (typeof document === "undefined" || typeof document.dispatchEvent !== "function") {
		                return;
		            }

		            try {
		                const event = new CustomEvent("geoleaf:profile:loaded", {
		                    detail: {
		                        profileId,
		                        data: payload
		                    }
		                });
		                document.dispatchEvent(event);
		            } catch (e) {
		                try {
		                    const legacyEvent = document.createEvent("CustomEvent");
		                    legacyEvent.initCustomEvent(
		                        "geoleaf:profile:loaded",
		                        false,
		                        false,
		                        {
		                            profileId,
		                            data: payload
		                        }
		                    );
		                    document.dispatchEvent(legacyEvent);
		                } catch (err) {
		                    Log.warn(
		                        "[GeoLeaf.Config.Profile] Impossible d'√©mettre l'√©v√©nement geoleaf:profile:loaded."
		                    );
		                }
		            }
		        }
		    };

		    // Exposer le module
		    GeoLeaf._ConfigProfile = ProfileModule;
		})(window);
		return profile$1;
	}

	requireProfile$1();

	var dataConverter = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredDataConverter;

	function requireDataConverter () {
		if (hasRequiredDataConverter) return dataConverter;
		hasRequiredDataConverter = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module DataConverter
		     *
		     * Responsabilit√©s :
		     * - Convertir les donn√©es brutes (Array de POI, Array de routes) vers GeoJSON FeatureCollection
		     * - Normaliser les g√©om√©tries
		     * - G√©rer les diff√©rents formats : POI, LineString, Polygon
		     *
		     * Utilis√© par GeoLeaf.GeoJSON lors du chargement depuis profile.json
		     */
		    const DataConverterModule = {
		        /**
		         * Convertit un array de POI en GeoJSON FeatureCollection.
		         *
		         * Chaque POI doit avoir :
		         * - id (string)
		         * - latlng (array [lat, lng])
		         * - title (string)
		         * - attributes (object)
		         *
		         * @param {Array} poiArray - Array de POI
		         * @returns {Object} FeatureCollection GeoJSON
		         */
		        convertPoiArrayToGeoJSON(poiArray) {
		            if (!Array.isArray(poiArray)) {
		                Log.warn("[DataConverter.convertPoiArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            const features = poiArray
		                .map((poi) => {
		                    if (!poi || typeof poi !== "object") {
		                        return null;
		                    }

		                    if (!poi.id) {
		                        Log.warn("[DataConverter.convertPoiArrayToGeoJSON] POI sans ID, ignor√©", poi);
		                        return null;
		                    }

		                    // Valider latlng
		                    let coordinates = null;
		                    if (Array.isArray(poi.latlng) && poi.latlng.length === 2) {
		                        // GeoJSON utilise [lon, lat], mais les donn√©es utilisent [lat, lon]
		                        coordinates = [poi.latlng[1], poi.latlng[0]];
		                    } else if (
		                        poi.location &&
		                        typeof poi.location.lat === "number" &&
		                        typeof poi.location.lng === "number"
		                    ) {
		                        coordinates = [poi.location.lng, poi.location.lat];
		                    } else {
		                        Log.warn(
		                            "[DataConverter.convertPoiArrayToGeoJSON] POI sans coordonn√©es valides, ignor√©",
		                            { id: poi.id }
		                        );
		                        return null;
		                    }

		                    // Construire la feature GeoJSON
		                    const feature = {
		                        type: "Feature",
		                        id: poi.id,
		                        geometry: {
		                            type: "Point",
		                            coordinates: coordinates
		                        },
		                        properties: {
		                            id: poi.id,
		                            title: poi.title || "Sans titre",
		                            description: poi.description || "",
		                            ...poi.attributes // Fusionner les attributs
		                        }
		                    };

		                    return feature;
		                })
		                .filter((f) => f !== null);

		            Log.debug("[DataConverter.convertPoiArrayToGeoJSON] Converti", {
		                input: poiArray.length,
		                output: features.length
		            });

		            return {
		                type: "FeatureCollection",
		                features: features
		            };
		        },

		        /**
		         * Convertit un array de routes (LineString) en GeoJSON FeatureCollection.
		         *
		         * Chaque route doit avoir :
		         * - id (string)
		         * - geometry avec type: "LineString" et coordinates
		         * - attributes (object optionnel)
		         *
		         * @param {Array} routeArray - Array de routes
		         * @returns {Object} FeatureCollection GeoJSON
		         */
		        convertRouteArrayToGeoJSON(routeArray) {
		            if (!Array.isArray(routeArray)) {
		                Log.warn("[DataConverter.convertRouteArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            const features = routeArray
		                .map((route) => {
		                    if (!route || typeof route !== "object") {
		                        return null;
		                    }

		                    if (!route.id) {
		                        Log.warn("[DataConverter.convertRouteArrayToGeoJSON] Route sans ID, ignor√©e", route);
		                        return null;
		                    }

		                    // Valider la g√©om√©trie
		                    if (!route.geometry || route.geometry.type !== "LineString" || !Array.isArray(route.geometry.coordinates)) {
		                        Log.warn(
		                            "[DataConverter.convertRouteArrayToGeoJSON] Route sans g√©om√©trie LineString valide, ignor√©e",
		                            { id: route.id }
		                        );
		                        return null;
		                    }

		                    // Construire la feature GeoJSON
		                    const feature = {
		                        type: "Feature",
		                        id: route.id,
		                        geometry: {
		                            type: "LineString",
		                            coordinates: route.geometry.coordinates
		                        },
		                        properties: {
		                            id: route.id,
		                            title: route.title || "Sans titre",
		                            description: route.description || "",
		                            categoryId: route.categoryId,
		                            subCategoryId: route.subCategoryId,
		                            ...route.attributes // Fusionner les attributs
		                        }
		                    };

		                    return feature;
		                })
		                .filter((f) => f !== null);

		            Log.debug("[DataConverter.convertRouteArrayToGeoJSON] Converti", {
		                input: routeArray.length,
		                output: features.length
		            });

		            return {
		                type: "FeatureCollection",
		                features: features
		            };
		        },

		        /**
		         * Convertit un array de zones (Polygon) en GeoJSON FeatureCollection.
		         *
		         * Chaque zone doit avoir :
		         * - id (string)
		         * - geometry avec type: "Polygon" et coordinates
		         * - attributes (object optionnel)
		         *
		         * @param {Array} zoneArray - Array de zones
		         * @returns {Object} FeatureCollection GeoJSON
		         */
		        convertZoneArrayToGeoJSON(zoneArray) {
		            if (!Array.isArray(zoneArray)) {
		                Log.warn("[DataConverter.convertZoneArrayToGeoJSON] Input n'est pas un array, retour FeatureCollection vide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            const features = zoneArray
		                .map((zone) => {
		                    if (!zone || typeof zone !== "object") {
		                        return null;
		                    }

		                    if (!zone.id) {
		                        Log.warn("[DataConverter.convertZoneArrayToGeoJSON] Zone sans ID, ignor√©e", zone);
		                        return null;
		                    }

		                    // Valider la g√©om√©trie
		                    if (!zone.geometry || zone.geometry.type !== "Polygon" || !Array.isArray(zone.geometry.coordinates)) {
		                        Log.warn(
		                            "[DataConverter.convertZoneArrayToGeoJSON] Zone sans g√©om√©trie Polygon valide, ignor√©e",
		                            { id: zone.id }
		                        );
		                        return null;
		                    }

		                    // Construire la feature GeoJSON
		                    const feature = {
		                        type: "Feature",
		                        id: zone.id,
		                        geometry: {
		                            type: "Polygon",
		                            coordinates: zone.geometry.coordinates
		                        },
		                        properties: {
		                            id: zone.id,
		                            title: zone.title || zone.siteName || "Sans titre",
		                            description: zone.description || "",
		                            ...zone.attributes // Fusionner les attributs
		                        }
		                    };

		                    return feature;
		                })
		                .filter((f) => f !== null);

		            Log.debug("[DataConverter.convertZoneArrayToGeoJSON] Converti", {
		                input: zoneArray.length,
		                output: features.length
		            });

		            return {
		                type: "FeatureCollection",
		                features: features
		            };
		        },

		        /**
		         * Convertit un string GPX en GeoJSON FeatureCollection.
		         *
		         * Parse les √©l√©ments waypoints et tracks, cr√©e des Points ou LineStrings.
		         *
		         * @param {string} gpxString - Contenu XML du fichier GPX
		         * @returns {Object} FeatureCollection GeoJSON
		         */
		        convertGpxToGeoJSON(gpxString) {
		            if (!gpxString || typeof gpxString !== "string") {
		                Log.warn("[DataConverter.convertGpxToGeoJSON] GPX string invalide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            try {
		                // Parser le XML
		                const parser = new DOMParser();
		                const gpxDoc = parser.parseFromString(gpxString, "text/xml");

		                const parseErrors = gpxDoc.getElementsByTagName("parsererror");
		                if (parseErrors.length > 0) {
		                    Log.error("[DataConverter.convertGpxToGeoJSON] Erreur parsing XML:", parseErrors[0].textContent);
		                    return {
		                        type: "FeatureCollection",
		                        features: []
		                    };
		                }

		                const features = [];

		                // 1. Parser les waypoints (wpt)
		                const waypoints = gpxDoc.getElementsByTagName("wpt");
		                for (let i = 0; i < waypoints.length; i++) {
		                    const wpt = waypoints[i];
		                    const lat = parseFloat(wpt.getAttribute("lat"));
		                    const lon = parseFloat(wpt.getAttribute("lon"));

		                    if (!isNaN(lat) && !isNaN(lon)) {
		                        const nameElem = wpt.getElementsByTagName("name")[0];
		                        const descElem = wpt.getElementsByTagName("desc")[0];
		                        const symElem = wpt.getElementsByTagName("sym")[0];

		                        // Extraire les extensions GeoLeaf si pr√©sentes
		                        const geoLeafExt = {};
		                        const tagsList = []; // Accumulateur pour les tags multiples
		                        const extensions = wpt.getElementsByTagName("extensions");
		                        if (extensions.length > 0) {
		                            const ext = extensions[0];
		                            // Utiliser childNodes pour √™tre s√ªr d'avoir tous les √©l√©ments
		                            for (let j = 0; j < ext.childNodes.length; j++) {
		                                const child = ext.childNodes[j];
		                                // Ignorer les n≈ìuds texte
		                                if (child.nodeType !== 1) continue;

		                                // R√©cup√©rer le nom du tag (g√®re les namespaces)
		                                const tagName = child.tagName || child.nodeName || '';
		                                const localName = child.localName || tagName.split(':').pop();

		                                // V√©rifier si c'est une extension GeoLeaf
		                                const isGeoLeaf = tagName.toLowerCase().startsWith("geoleaf:") ||
		                                    (child.namespaceURI && child.namespaceURI.includes("geoleaf"));

		                                if (isGeoLeaf || tagName.includes(':')) {
		                                    // Utiliser localName comme cl√© (sans pr√©fixe)
		                                    const key = localName || tagName.replace(/^[^:]+:/, '');
		                                    const value = child.textContent || '';

		                                    // Cas sp√©cial : les tags sont accumul√©s dans un tableau
		                                    if (key === 'tag' || key === 'tags') {
		                                        if (value) tagsList.push(value);
		                                    } else {
		                                        geoLeafExt[key] = value;
		                                    }
		                                }
		                            }
		                        }

		                        // Ajouter les tags comme tableau si pr√©sents
		                        if (tagsList.length > 0) {
		                            geoLeafExt.tags = tagsList;
		                        }

		                        const feature = {
		                            type: "Feature",
		                            id: geoLeafExt.id || (nameElem ? nameElem.textContent : `wpt-${i}`),
		                            geometry: {
		                                type: "Point",
		                                coordinates: [lon, lat]
		                            },
		                            properties: {
		                                id: geoLeafExt.id || (nameElem ? nameElem.textContent : `wpt-${i}`),
		                                title: nameElem ? nameElem.textContent : `Waypoint ${i + 1}`,
		                                description: descElem ? descElem.textContent : "",
		                                symbol: symElem ? symElem.textContent : "",
		                                ...geoLeafExt // Inclure les extensions GeoLeaf
		                            }
		                        };

		                        features.push(feature);
		                    }
		                }

		                // 2. Parser les tracks (trk)
		                const tracks = gpxDoc.getElementsByTagName("trk");
		                for (let i = 0; i < tracks.length; i++) {
		                    const trk = tracks[i];
		                    const nameElem = trk.getElementsByTagName("name")[0];
		                    const descElem = trk.getElementsByTagName("desc")[0];

		                    // Extraire les extensions GeoLeaf pour le track
		                    const trkGeoLeafExt = {};
		                    const trkTagsList = []; // Accumulateur pour les tags multiples
		                    const trkExtensions = trk.getElementsByTagName("extensions");
		                    if (trkExtensions.length > 0) {
		                        const ext = trkExtensions[0];
		                        for (let m = 0; m < ext.childNodes.length; m++) {
		                            const child = ext.childNodes[m];
		                            if (child.nodeType !== 1) continue;

		                            const tagName = child.tagName || child.nodeName || '';
		                            const localName = child.localName || tagName.split(':').pop();

		                            const isGeoLeaf = tagName.toLowerCase().startsWith("geoleaf:") ||
		                                (child.namespaceURI && child.namespaceURI.includes("geoleaf"));

		                            if (isGeoLeaf || tagName.includes(':')) {
		                                const key = localName || tagName.replace(/^[^:]+:/, '');
		                                const value = child.textContent || '';

		                                // Cas sp√©cial : les tags sont accumul√©s dans un tableau
		                                if (key === 'tag' || key === 'tags') {
		                                    if (value) trkTagsList.push(value);
		                                } else {
		                                    trkGeoLeafExt[key] = value;
		                                }
		                            }
		                        }
		                    }

		                    // Ajouter les tags comme tableau si pr√©sents
		                    if (trkTagsList.length > 0) {
		                        trkGeoLeafExt.tags = trkTagsList;
		                    }

		                    const segments = trk.getElementsByTagName("trkseg");
		                    for (let j = 0; j < segments.length; j++) {
		                        const segment = segments[j];
		                        const trkpts = segment.getElementsByTagName("trkpt");

		                        const coordinates = [];
		                        for (let k = 0; k < trkpts.length; k++) {
		                            const trkpt = trkpts[k];
		                            const lat = parseFloat(trkpt.getAttribute("lat"));
		                            const lon = parseFloat(trkpt.getAttribute("lon"));

		                            if (!isNaN(lat) && !isNaN(lon)) {
		                                coordinates.push([lon, lat]);
		                            }
		                        }

		                        if (coordinates.length > 0) {
		                            const feature = {
		                                type: "Feature",
		                                id: nameElem ? `${nameElem.textContent}-${j}` : `trk-${i}-${j}`,
		                                geometry: {
		                                    type: "LineString",
		                                    coordinates: coordinates
		                                },
		                                properties: {
		                                    id: nameElem ? `${nameElem.textContent}-${j}` : `trk-${i}-${j}`,
		                                    title: nameElem ? nameElem.textContent : `Track ${i + 1}`,
		                                    description: descElem ? descElem.textContent : "",
		                                    segmentIndex: j,
		                                    pointCount: coordinates.length,
		                                    ...trkGeoLeafExt // Inclure les extensions GeoLeaf du track
		                                }
		                            };

		                            features.push(feature);
		                        }
		                    }
		                }

		                Log.debug("[DataConverter.convertGpxToGeoJSON] Converti", {
		                    waypoints: waypoints.length,
		                    tracks: tracks.length,
		                    features: features.length
		                });

		                return {
		                    type: "FeatureCollection",
		                    features: features
		                };
		            } catch (err) {
		                Log.error("[DataConverter.convertGpxToGeoJSON] Erreur lors du parsing GPX:", err);
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }
		        },

		        /**
		         * D√©tecte automatiquement le type de donn√©es et les convertit en GeoJSON.
		         *
		         * Strat√©gie de d√©tection :
		         * 1. Si d√©j√† GeoJSON (type: "FeatureCollection"), retourner tel quel
		         * 2. Si array : analyser le premier √©l√©ment
		         *    - S'il a "latlng" ou "location" ‚Üí POI
		         *    - S'il a "geometry.type === 'LineString'" ‚Üí Route
		         *    - S'il a "geometry.type === 'Polygon'" ‚Üí Zone
		         * 3. Sinon : retourner vide
		         *
		         * @param {*} data - Donn√©es √† convertir
		         * @returns {Object} FeatureCollection GeoJSON
		         */
		        autoConvert(data) {
		            if (!data) {
		                Log.warn("[DataConverter.autoConvert] Donn√©es nulles, retour FeatureCollection vide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            // Cas 1 : D√©j√† GeoJSON
		            if (data.type === "FeatureCollection" && Array.isArray(data.features)) {
		                Log.debug("[DataConverter.autoConvert] Donn√©es d√©j√† en GeoJSON, passage direct");
		                return data;
		            }

		            if (data.type === "Feature" && data.geometry) {
		                Log.debug("[DataConverter.autoConvert] Feature unique, conversion en FeatureCollection");
		                return {
		                    type: "FeatureCollection",
		                    features: [data]
		                };
		            }

		            // Cas 2 : Array
		            if (!Array.isArray(data) || data.length === 0) {
		                Log.warn("[DataConverter.autoConvert] Donn√©es ne sont pas un array ou array vide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            const firstItem = data[0];

		            if (!firstItem || typeof firstItem !== "object") {
		                Log.warn("[DataConverter.autoConvert] Premier √©l√©ment invalide");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }

		            // Analyser le type
		            if (firstItem.latlng || (firstItem.location && typeof firstItem.location.lat === "number")) {
		                // POI
		                Log.debug("[DataConverter.autoConvert] D√©tect√© comme array de POI");
		                return this.convertPoiArrayToGeoJSON(data);
		            } else if (
		                firstItem.geometry &&
		                firstItem.geometry.type === "LineString" &&
		                Array.isArray(firstItem.geometry.coordinates)
		            ) {
		                // Route
		                Log.debug("[DataConverter.autoConvert] D√©tect√© comme array de routes");
		                return this.convertRouteArrayToGeoJSON(data);
		            } else if (
		                firstItem.geometry &&
		                firstItem.geometry.type === "Polygon" &&
		                Array.isArray(firstItem.geometry.coordinates)
		            ) {
		                // Zone
		                Log.debug("[DataConverter.autoConvert] D√©tect√© comme array de zones");
		                return this.convertZoneArrayToGeoJSON(data);
		            } else {
		                Log.warn("[DataConverter.autoConvert] Type de donn√©es non reconnu");
		                return {
		                    type: "FeatureCollection",
		                    features: []
		                };
		            }
		        }
		    };

		    // Exposition de l'API
		    GeoLeaf._DataConverter = DataConverterModule;
		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return dataConverter;
	}

	requireDataConverter();

	var configCore = {};

	/*!
	 * GeoLeaf Core ‚Äì Config / Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredConfigCore;

	function requireConfigCore () {
		if (hasRequiredConfigCore) return configCore;
		hasRequiredConfigCore = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√© (d√©fini par geoleaf.logger-shim.js charg√© en premier)
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module GeoLeaf.Config
		     *
		     * R√¥le :
		     * - Centraliser la configuration de GeoLeaf (options carte, basemaps, th√®mes, etc.)
		     * - Charger une configuration depuis un objet JS ou un fichier JSON externe (fetch)
		     * - Fournir des helpers pour lire / √©crire via chemins de type "map.center" ou "basemaps.street.url"
		     * - G√©rer les profils m√©tiers (tourism, etc.) et leurs ressources associ√©es
		     *
		     * Architecture Phase 4 :
		     * - config/loader.js       : Chargement HTTP, fetch, validation CSRF
		     * - config/taxonomy.js     : Gestion taxonomie (cat√©gories/sous-cat√©gories)
		     * - config/storage.js      : get/set/merge config, helpers paths
		     * - config/normalization.js: Normalisation POI (mapping brut‚ÜíGeoLeaf)
		     * - config/profile.js      : Gestion profils m√©tier (profile.json, poi.json, routes.json)
		     */
		    const Config = GeoLeaf.Config = GeoLeaf.Config || {};

		    /* ------------------------------------------------------------------ */
		    /*  Module-level state                                                 */
		    /* ------------------------------------------------------------------ */

		    /**
		     * Configuration interne consolid√©e
		     * @type {Object}
		     * @private
		     */
		    Config._config = {};

		    /**
		     * Indicateur de chargement
		     * @type {boolean}
		     * @private
		     */
		    Config._isLoaded = false;

		    /**
		     * Source de la configuration ("inline", "url", null)
		     * @type {string|null}
		     * @private
		     */
		    Config._source = null;

		    /**
		     * Options internes
		     * @type {{autoEvent: boolean}}
		     * @private
		     */
		    Config._options = {
		        /**
		         * Si true, √©met un √©v√©nement DOM "geoleaf:config:loaded" apr√®s chargement.
		         */
		        autoEvent: true
		    };

		    /* ------------------------------------------------------------------ */
		    /*  Core methods                                                       */
		    /* ------------------------------------------------------------------ */

		    /**
		     * Initialisation du module de configuration.
		     *
		     * @param {Object} [options]
		     * @param {Object} [options.config] - Objet de configuration fourni directement.
		     * @param {string} [options.url] - URL d'un fichier JSON √† charger.
		     * @param {Object} [options.headers] - Headers HTTP personnalis√©s pour loadUrl (ex: CSRF token).
		     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
		     * @param {boolean} [options.autoEvent] - D√©sactiver ou non l'√©v√©nement auto.
		     * @param {Function} [options.onLoaded] - Callback appel√© une fois la config disponible (apr√®s mapping).
		     *
		     * @param {Object}  [options.mappingHeaders]
		     *        Headers HTTP sp√©cifiques pour le mapping (sinon ceux de headers sont r√©utilis√©s).
		     * @param {boolean} [options.mappingStrictContentType]
		     *        Si d√©fini, surcharge strictContentType pour le mapping.
		     *
		     * @returns {Promise<Object>} - Promesse r√©solue avec l'objet de configuration.
		     */
		    Config.init = function (options = {}) {
		        this._options = Object.assign({}, this._options, {
		            autoEvent:
		                typeof options.autoEvent === "boolean"
		                    ? options.autoEvent
		                    : this._options.autoEvent
		        });

		        // Cas 1 : configuration inline (objet JS directement fourni)
		        if (options.config && typeof options.config === "object") {
		            this._applyConfig(options.config, "inline");

		            // Si un profileId est sp√©cifi√©, le mettre √† jour apr√®s l'application de la config
		            if (typeof options.profileId === "string" && options.profileId.length > 0) {
		                if (!this._config.data) {
		                    this._config.data = {};
		                }
		                this._config.data.activeProfile = options.profileId;
		                Log.info("[GeoLeaf.Config] Profil actif chang√© vers:", options.profileId);
		            }

		            this._maybeFireLoadedEvent();

		            if (typeof options.onLoaded === "function") {
		                try {
		                    options.onLoaded(this._config);
		                } catch (e) {
		                    Log.error("[GeoLeaf.Config] Erreur dans onLoaded (inline) :", e);
		                }
		            }

		            return Promise.resolve(this._config);
		        }

		        // Cas 2 : chargement via URL JSON
		        if (typeof options.url === "string" && options.url.length > 0) {
		            const loadOptions = {
		                headers: options.headers,
		                strictContentType:
		                    typeof options.strictContentType === "boolean"
		                        ? options.strictContentType
		                        : true
		            };

		            const mappingUrl =
		                typeof options.mappingUrl === "string" && options.mappingUrl.length > 0
		                    ? options.mappingUrl
		                    : null;

		            const mappingOptions = {
		                headers: options.mappingHeaders || options.headers,
		                strictContentType:
		                    typeof options.mappingStrictContentType === "boolean"
		                        ? options.mappingStrictContentType
		                        : loadOptions.strictContentType
		            };

		            // 1) Charger la config principale
		            return this.loadUrl(options.url, loadOptions)
		                .then((cfg) => {
		                    // Appliquer le profileId APR√àS le chargement de l'URL
		                    if (typeof options.profileId === "string" && options.profileId.length > 0) {
		                        if (!cfg.data) {
		                            cfg.data = {};
		                        }
		                        cfg.data.activeProfile = options.profileId;
		                        this._config.data.activeProfile = options.profileId;
		                        Log.info("[GeoLeaf.Config] Profil actif chang√© vers:", options.profileId);
		                    }
		                    return cfg;
		                })
		                // 2) Charger le mapping cat√©gories (si URL fournie)
		                .then((cfg) => {
		                    if (!mappingUrl) {
		                        return cfg;
		                    }

		                    return this.loadTaxonomy(mappingUrl, mappingOptions)
		                        .then(() => cfg)
		                        .catch((err) => {
		                            Log.warn(
		                                "[GeoLeaf.Config] √âchec du chargement du mapping cat√©gories depuis " +
		                                mappingUrl +
		                                " (GeoLeaf continuera sans mapping d√©di√©) :",
		                                err
		                            );
		                            return cfg;
		                        });
		                })
		                // 3) Appeler onLoaded une fois TOUT charg√© (config + mapping)
		                .then((cfg) => {
		                    if (typeof options.onLoaded === "function") {
		                        try {
		                            options.onLoaded(cfg);
		                        } catch (e) {
		                            Log.error("[GeoLeaf.Config] Erreur dans onLoaded (url+mapping) :", e);
		                        }
		                    }
		                    return cfg;
		                })
		                .catch((err) => {
		                    Log.error("[GeoLeaf.Config] Erreur init() avec url :", err);

		                    // Appeler onError si fourni
		                    if (typeof options.onError === "function") {
		                        try {
		                            options.onError(err);
		                        } catch (e) {
		                            Log.error("[GeoLeaf.Config] Erreur dans onError :", e);
		                        }
		                    }

		                    throw err; // Re-throw pour que la Promise soit rejet√©e
		                });
		        }

		        // Cas 3 : Aucun param√®tre fourni : on se contente d'un objet vide
		        this._applyConfig({}, "inline");

		        // Si un profileId est sp√©cifi√©, le mettre √† jour
		        if (typeof options.profileId === "string" && options.profileId.length > 0) {
		            if (!this._config.data) {
		                this._config.data = {};
		            }
		            this._config.data.activeProfile = options.profileId;
		            Log.info("[GeoLeaf.Config] Profil actif chang√© vers:", options.profileId);
		        }

		        this._maybeFireLoadedEvent();

		        if (typeof options.onLoaded === "function") {
		            try {
		                options.onLoaded(this._config);
		            } catch (e) {
		                Log.error("[GeoLeaf.Config] Erreur dans onLoaded (vide) :", e);
		            }
		        }

		        return Promise.resolve(this._config);
		    };

		    /**
		     * Initialise les sous-modules avec la r√©f√©rence partag√©e √† la config.
		     *
		     * @private
		     */
		    Config._initSubModules = function () {
		        const Storage = GeoLeaf._ConfigStorage;
		        const Taxonomy = GeoLeaf._ConfigTaxonomy;
		        const Profile = GeoLeaf._ConfigProfile;

		        if (Storage && typeof Storage.init === "function") {
		            Storage.init(this._config);
		        }
		        if (Taxonomy && typeof Taxonomy.init === "function") {
		            Taxonomy.init(this._config);
		        }
		        if (Profile && typeof Profile.init === "function") {
		            Profile.init(this._config);
		        }
		    };

		    /**
		     * Applique une configuration brute (remplace la pr√©c√©dente de mani√®re fusionn√©e).
		     *
		     * @param {Object} cfg
		     * @param {string} source
		     * @private
		     */
		    Config._applyConfig = function (cfg, source) {
		        if (typeof cfg !== "object" || cfg === null) {
		            cfg = {};
		        }

		        // Validation de la structure du JSON
		        this._validateConfig(cfg);

		        // Fusion profonde avec la configuration existante
		        const Storage = GeoLeaf._ConfigStorage;
		        if (Storage && typeof Storage.deepMerge === "function") {
		            this._config = Storage.deepMerge(this._config, cfg);
		        } else {
		            this._config = Object.assign({}, this._config, cfg);
		        }

		        // Normalisation des POI (avis) apr√®s fusion
		        const Normalization = GeoLeaf._ConfigNormalization;
		        if (Array.isArray(this._config.poi) && Normalization) {
		            this._config.poi = Normalization.normalizePoiArray(this._config.poi);
		        }

		        this._isLoaded = true;
		        this._source = source || "inline";

		        // Initialiser les sous-modules maintenant que _config est charg√©
		        this._initSubModules();

		        try {
		            // On r√©cup√®re le bloc "logging" soit depuis le cfg brut, soit depuis la configuration consolid√©e
		            const loggingCfg =
		                (cfg && typeof cfg === "object" && cfg.logging)
		                    ? cfg.logging
		                    : (this._config && this._config.logging ? this._config.logging : null);

		            // Prise en compte du flag global debug
		            let level = loggingCfg && loggingCfg.level;
		            let debugFlag = false;
		            if ((cfg && typeof cfg.debug !== 'undefined')) {
		                debugFlag = !!cfg.debug;
		            } else if (this._config && typeof this._config.debug !== 'undefined') {
		                debugFlag = !!this._config.debug;
		            }

		            if (!level) {
		                level = debugFlag ? 'debug' : 'info';
		            }

		            if (level && GeoLeaf.Log && typeof GeoLeaf.Log.setLevel === "function") {
		                GeoLeaf.Log.setLevel(level);
		                Log.info("[GeoLeaf.Config] Niveau de log appliqu√© depuis la configuration :", level, "(debug:", debugFlag, ")");
		            }
		        } catch (e) {
		            Log.warn("[GeoLeaf.Config] Impossible d'appliquer le niveau de log depuis la configuration :", e);
		        }
		    };

		    /**
		     * Indique si la configuration est consid√©r√©e comme "charg√©e".
		     *
		     * @returns {boolean}
		     */
		    Config.isLoaded = function () {
		        return this._isLoaded;
		    };

		    /**
		     * Retourne la source de la config ("inline", "url", null).
		     *
		     * @returns {string|null}
		     */
		    Config.getSource = function () {
		        return this._source;
		    };

		    /**
		     * Envoie un √©v√©nement DOM "geoleaf:config:loaded" si autoEvent = true.
		     *
		     * @private
		     */
		    Config._maybeFireLoadedEvent = function () {
		        if (!this._options.autoEvent) {
		            return;
		        }

		        if (typeof document === "undefined" || typeof document.dispatchEvent !== "function") {
		            return;
		        }

		        try {
		            const event = new CustomEvent("geoleaf:config:loaded", {
		                detail: {
		                    config: this._config,
		                    source: this._source
		                }
		            });
		            document.dispatchEvent(event);
		        } catch (e) {
		            // En environnement tr√®s ancien, CustomEvent peut ne pas exister
		            try {
		                const legacyEvent = document.createEvent("CustomEvent");
		                legacyEvent.initCustomEvent(
		                    "geoleaf:config:loaded",
		                    false,
		                    false,
		                    {
		                        config: this._config,
		                        source: this._source
		                    }
		                );
		                document.dispatchEvent(legacyEvent);
		            } catch (err) {
		                // On ne bloque pas le fonctionnement si l'√©v√©nement √©choue
		                Log.warn("[GeoLeaf.Config] Impossible d'√©mettre l'√©v√©nement geoleaf:config:loaded.");
		            }
		        }
		    };

		})(window);
		return configCore;
	}

	requireConfigCore();

	var configValidation = {};

	/*!
	 * GeoLeaf Core ‚Äì Config / Validation
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredConfigValidation;

	function requireConfigValidation () {
		if (hasRequiredConfigValidation) return configValidation;
		hasRequiredConfigValidation = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf;
		    const Log = GeoLeaf.Log;
		    const Config = GeoLeaf.Config;

		    /**
		     * Valide la structure du JSON de configuration.
		     * Lance une erreur si les donn√©es critiques sont invalides.
		     *
		     * @param {Object} cfg - Configuration √† valider
		     * @throws {Error} Si la structure est invalide
		     * @private
		     */
		    Config._validateConfig = function (cfg) {
		        if (!cfg || typeof cfg !== "object") {
		            return; // Pas de validation si vide
		        }

		        // Validation de map.center
		        if (cfg.map && cfg.map.center !== undefined) {
		            if (
		                !Array.isArray(cfg.map.center) ||
		                cfg.map.center.length !== 2 ||
		                typeof cfg.map.center[0] !== "number" ||
		                typeof cfg.map.center[1] !== "number"
		            ) {
		                throw new Error(
		                    "[GeoLeaf.Config] map.center doit √™tre un tableau de 2 nombres [lat, lng]."
		                );
		            }
		        }

		        // Validation de map.zoom
		        if (cfg.map && cfg.map.zoom !== undefined) {
		            if (typeof cfg.map.zoom !== "number" || cfg.map.zoom < 0 || cfg.map.zoom > 20) {
		                throw new Error(
		                    "[GeoLeaf.Config] map.zoom doit √™tre un nombre entre 0 et 20."
		                );
		            }
		        }

		        // Validation de basemaps
		        if (cfg.basemaps !== undefined) {
		            if (typeof cfg.basemaps !== "object" || cfg.basemaps === null) {
		                throw new Error(
		                    "[GeoLeaf.Config] basemaps doit √™tre un objet."
		                );
		            }
		        }

		        // Validation de poi
		        if (cfg.poi !== undefined) {
		            if (!Array.isArray(cfg.poi)) {
		                throw new Error(
		                    "[GeoLeaf.Config] poi doit √™tre un tableau."
		                );
		            }
		        }

		        // Validation de geojson
		        if (cfg.geojson !== undefined) {
		            if (!Array.isArray(cfg.geojson)) {
		                throw new Error(
		                    "[GeoLeaf.Config] geojson doit √™tre un tableau."
		                );
		            }
		        }

		        // Validation de categories
		        if (cfg.categories !== undefined) {
		            if (
		                typeof cfg.categories !== "object" ||
		                cfg.categories === null ||
		                Array.isArray(cfg.categories)
		            ) {
		                throw new Error(
		                    "[GeoLeaf.Config] categories doit √™tre un objet."
		                );
		            }

		            // Valider chaque cat√©gorie
		            Object.entries(cfg.categories).forEach(([catId, catData]) => {
		                if (!catData || typeof catData !== "object") {
		                    Log.warn(
		                        `[GeoLeaf.Config] Cat√©gorie '${catId}' invalide (doit √™tre un objet).`
		                    );
		                    return;
		                }

		                if (!catData.label || typeof catData.label !== "string") {
		                    Log.warn(
		                        `[GeoLeaf.Config] Cat√©gorie '${catId}' : le champ 'label' est manquant ou invalide.`
		                    );
		                }

		                // Validation couleurs : accepter soit 'color' (ancien format), soit 'colorFill'/'colorStroke' (nouveau format)
		                const hasOldFormat = catData.color && typeof catData.color === "string";
		                const hasNewFormat =
		                    (catData.colorFill && typeof catData.colorFill === "string") ||
		                    (catData.colorStroke && typeof catData.colorStroke === "string");

		                if (!hasOldFormat && !hasNewFormat) {
		                    Log.warn(
		                        `[GeoLeaf.Config] Cat√©gorie '${catId}' : aucune couleur d√©finie (ni 'color', ni 'colorFill'/'colorStroke').`
		                    );
		                }

		                // Valider les sous-cat√©gories
		                if (catData.subcategories !== undefined) {
		                    if (
		                        typeof catData.subcategories !== "object" ||
		                        catData.subcategories === null ||
		                        Array.isArray(catData.subcategories)
		                    ) {
		                        Log.warn(
		                            `[GeoLeaf.Config] Cat√©gorie '${catId}' : subcategories doit √™tre un objet.`
		                        );
		                        return;
		                    }

		                    Object.entries(catData.subcategories).forEach(([subId, subData]) => {
		                        if (!subData || typeof subData !== "object") {
		                            Log.warn(
		                                `[GeoLeaf.Config] Sous-cat√©gorie '${subId}' dans '${catId}' invalide (doit √™tre un objet).`
		                            );
		                            return;
		                        }

		                        if (!subData.label || typeof subData.label !== "string") {
		                            Log.warn(
		                                `[GeoLeaf.Config] Sous-cat√©gorie '${subId}' dans '${catId}' : le champ 'label' est manquant ou invalide.`
		                            );
		                        }

		                        const hasOldFormatSub =
		                            subData.color && typeof subData.color === "string";
		                        const hasNewFormatSub =
		                            (subData.colorFill && typeof subData.colorFill === "string") ||
		                            (subData.colorStroke && typeof subData.colorStroke === "string");

		                        if (!hasOldFormatSub && !hasNewFormatSub) {
		                            Log.warn(
		                                `[GeoLeaf.Config] Sous-cat√©gorie '${subId}' dans '${catId}' : aucune couleur d√©finie (ni 'color', ni 'colorFill'/'colorStroke').`
		                            );
		                        }
		                    });
		                }
		            });
		        }

		        Log.debug("[GeoLeaf.Config] Validation de la structure r√©ussie.");
		    };

		})(window);
		return configValidation;
	}

	requireConfigValidation();

	var configLoaders = {};

	/*!
	 * GeoLeaf Core ‚Äì Config / Loaders
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredConfigLoaders;

	function requireConfigLoaders () {
		if (hasRequiredConfigLoaders) return configLoaders;
		hasRequiredConfigLoaders = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf;
		    const Log = GeoLeaf.Log;
		    const Config = GeoLeaf.Config;

		    /**
		     * Charge une configuration depuis une URL JSON et la fusionne.
		     *
		     * @param {string} url - URL du fichier JSON
		     * @param {Object} [options] - Options de chargement
		     * @param {Object} [options.headers] - Headers HTTP personnalis√©s (ex: CSRF token)
		     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type
		     * @returns {Promise<Object>}
		     * @example
		     * Config.loadUrl('/api/config.json', {
		     *     headers: { 'X-CSRF-Token': '...' },
		     *     strictContentType: true
		     * })
		     */
		    Config.loadUrl = function (url, options = {}) {
		        const Loader = GeoLeaf._ConfigLoader;
		        if (!Loader) {
		            Log.error("[GeoLeaf.Config] Module Loader non disponible.");
		            return Promise.reject(new Error("Loader module not available"));
		        }

		        return Loader.loadUrl(url, options)
		            .then((jsonCfg) => {
		                // Validation de la structure du JSON
		                this._validateConfig(jsonCfg);

		                // Fusion profonde avec la configuration existante
		                const Storage = GeoLeaf._ConfigStorage;
		                if (Storage && typeof Storage.deepMerge === "function") {
		                    this._config = Storage.deepMerge(this._config, jsonCfg);
		                } else {
		                    // Fallback si Storage pas disponible
		                    this._config = Object.assign({}, this._config, jsonCfg);
		                }

		                // Normalisation des POI (avis) √©ventuels dans la config
		                const Normalization = GeoLeaf._ConfigNormalization;
		                if (Array.isArray(this._config.poi) && Normalization) {
		                    this._config.poi = Normalization.normalizePoiArray(this._config.poi);
		                }

		                this._isLoaded = true;
		                this._source = "url";

		                // Initialiser les sous-modules maintenant que _config est charg√©
		                this._initSubModules();

		                this._maybeFireLoadedEvent();

		                return this._config;
		            })
		            .catch((err) => {
		                Log.error("[GeoLeaf.Config] Erreur lors du chargement JSON :", err);
		                return this._config;
		            });
		    };

		    /**
		     * Charge un fichier de taxonomie (mapping cat√©gories / sous-cat√©gories)
		     * et le fusionne dans la configuration existante.
		     *
		     * @param {string} [url] - URL du fichier de mapping (depuis le profil)
		     * @param {Object} [options]
		     * @param {Object} [options.headers]
		     * @param {boolean} [options.strictContentType=true]
		     * @returns {Promise<Object>} - Objet categories consolid√©
		     */
		    Config.loadTaxonomy = function (url = null, options = {}) {
		        const Taxonomy = GeoLeaf._ConfigTaxonomy;
		        if (!Taxonomy) {
		            Log.error("[GeoLeaf.Config] Module Taxonomy non disponible.");
		            return Promise.reject(new Error("Taxonomy module not available"));
		        }

		        return Taxonomy.loadTaxonomy(url, options);
		    };

		    /**
		     * Charge les ressources li√©es au profil actif :
		     * - profile.json
		     * - poi.json
		     * - mapping.json
		     * - routes.json
		     *
		     * @param {Object} [options]
		     * @param {Object} [options.headers] - Headers HTTP optionnels.
		     * @param {boolean} [options.strictContentType=true] - Validation stricte du Content-Type.
		     * @returns {Promise<Object>} Configuration consolid√©e incluant les donn√©es du profil.
		     */
		    Config.loadActiveProfileResources = function (options = {}) {
		        const Profile = GeoLeaf._ConfigProfile;
		        if (!Profile) {
		            Log.error("[GeoLeaf.Config] Module Profile non disponible.");
		            return Promise.reject(new Error("Profile module not available"));
		        }

		        return Profile.loadActiveProfileResources(options);
		    };

		})(window);
		return configLoaders;
	}

	requireConfigLoaders();

	var configAccessors = {};

	/*!
	 * GeoLeaf Core ‚Äì Config / Accessors
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredConfigAccessors;

	function requireConfigAccessors () {
		if (hasRequiredConfigAccessors) return configAccessors;
		hasRequiredConfigAccessors = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf;
		    const Log = GeoLeaf.Log;
		    const Config = GeoLeaf.Config;

		    /* ------------------------------------------------------------------ */
		    /*  Storage accessors                                                  */
		    /* ------------------------------------------------------------------ */

		    /**
		     * Retourne la configuration compl√®te (objet).
		     *
		     * @returns {Object}
		     */
		    Config.getAll = function () {
		        // S'assurer que les sous-modules sont initialis√©s
		        if (!this._isLoaded) {
		            this._initSubModules();
		        }

		        const Storage = GeoLeaf._ConfigStorage;
		        return Storage && typeof Storage.getAll === "function"
		            ? Storage.getAll()
		            : this._config;
		    };

		    /**
		     * R√©cup√®re une valeur via un chemin de type "map.center" ou "basemaps.street.url".
		     *
		     * @param {string} path - Chemin avec des points.
		     * @param {*} [defaultValue] - Valeur renvoy√©e si le chemin n'existe pas.
		     * @returns {*}
		     */
		    Config.get = function (path, defaultValue) {
		        // S'assurer que les sous-modules sont initialis√©s
		        if (!this._isLoaded) {
		            this._initSubModules();
		        }

		        const Storage = GeoLeaf._ConfigStorage;
		        return Storage && typeof Storage.get === "function"
		            ? Storage.get(path, defaultValue)
		            : defaultValue;
		    };

		    /**
		     * D√©finit une valeur via un chemin de type "map.center" ou "basemaps.street.url".
		     * Cr√©e les objets interm√©diaires si n√©cessaire.
		     *
		     * @param {string} path
		     * @param {*} value
		     */
		    Config.set = function (path, value) {
		        const Storage = GeoLeaf._ConfigStorage;
		        if (Storage && typeof Storage.set === "function") {
		            Storage.set(path, value);
		        } else {
		            Log.warn("[GeoLeaf.Config] Module Storage non disponible pour set().");
		        }
		    };

		    /**
		     * Retourne une section de configuration (ex : "basemaps", "map").
		     *
		     * @param {string} sectionName
		     * @param {Object} [defaultValue]
		     * @returns {Object|*}
		     */
		    Config.getSection = function (sectionName, defaultValue) {
		        const Storage = GeoLeaf._ConfigStorage;
		        return Storage && typeof Storage.getSection === "function"
		            ? Storage.getSection(sectionName, defaultValue)
		            : defaultValue;
		    };

		    /* ------------------------------------------------------------------ */
		    /*  Taxonomy accessors                                                 */
		    /* ------------------------------------------------------------------ */

		    /**
		     * Retourne l'objet complet des cat√©gories (mapping interne).
		     *
		     * @returns {Object} - { [categoryId]: { label, icon, colorFill, colorStroke, subcategories? } }
		     */
		    Config.getCategories = function () {
		        // S'assurer que les sous-modules sont initialis√©s
		        if (!this._isLoaded) {
		            this._initSubModules();
		        }

		        const Taxonomy = GeoLeaf._ConfigTaxonomy;
		        return Taxonomy && typeof Taxonomy.getCategories === "function"
		            ? Taxonomy.getCategories()
		            : {};
		    };

		    /**
		     * Retourne une cat√©gorie √† partir de son identifiant.
		     *
		     * @param {string} categoryId
		     * @returns {Object|undefined}
		     */
		    Config.getCategory = function (categoryId) {
		        const Taxonomy = GeoLeaf._ConfigTaxonomy;
		        return Taxonomy && typeof Taxonomy.getCategory === "function"
		            ? Taxonomy.getCategory(categoryId)
		            : undefined;
		    };

		    /**
		     * Retourne une sous-cat√©gorie √† partir de son identifiant et de celui
		     * de la cat√©gorie parente.
		     *
		     * @param {string} categoryId
		     * @param {string} subCategoryId
		     * @returns {Object|undefined}
		     */
		    Config.getSubcategory = function (categoryId, subCategoryId) {
		        const Taxonomy = GeoLeaf._ConfigTaxonomy;
		        return Taxonomy && typeof Taxonomy.getSubcategory === "function"
		            ? Taxonomy.getSubcategory(categoryId, subCategoryId)
		            : undefined;
		    };

		    /* ------------------------------------------------------------------ */
		    /*  Profile accessors                                                  */
		    /* ------------------------------------------------------------------ */

		    /**
		     * Retourne l'identifiant du profil actuellement charg√© (ou null).
		     *
		     * @returns {string|null}
		     */
		    Config.getActiveProfileId = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getActiveProfileId === "function"
		            ? Profile.getActiveProfileId()
		            : null;
		    };

		    /**
		     * Retourne l'objet profile.json du profil actif (ou null).
		     *
		     * @returns {Object|null}
		     */
		    Config.getActiveProfile = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getActiveProfile === "function"
		            ? Profile.getActiveProfile()
		            : null;
		    };

		    /**
		     * Retourne le tableau de POI normalis√©s du profil actif.
		     *
		     * @returns {Array}
		     */
		    Config.getActiveProfilePoi = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getActiveProfilePoi === "function"
		            ? Profile.getActiveProfilePoi()
		            : [];
		    };

		    /**
		     * Retourne le tableau de routes du profil actif.
		     *
		     * @returns {Array}
		     */
		    Config.getActiveProfileRoutes = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getActiveProfileRoutes === "function"
		            ? Profile.getActiveProfileRoutes()
		            : [];
		    };

		    /**
		     * Retourne l'objet de mapping du profil actif (mapping.json).
		     *
		     * @returns {Object|null}
		     */
		    Config.getActiveProfileMapping = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getActiveProfileMapping === "function"
		            ? Profile.getActiveProfileMapping()
		            : null;
		    };

		    /**
		     * Retourne la configuration des ic√¥nes depuis la taxonomie du profil actif.
		     *
		     * @returns {Object|null}
		     */
		    Config.getIconsConfig = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.getIconsConfig === "function"
		            ? Profile.getIconsConfig()
		            : null;
		    };

		    /**
		     * Indique si l'usage de mapping.json pour normaliser les POI de profil est activ√©.
		     *
		     * @returns {boolean} true si le mapping doit √™tre utilis√©, false sinon.
		     */
		    Config.isProfilePoiMappingEnabled = function () {
		        const Profile = GeoLeaf._ConfigProfile;
		        return Profile && typeof Profile.isProfilePoiMappingEnabled === "function"
		            ? Profile.isProfilePoiMappingEnabled()
		            : true;
		    };

		})(window);
		return configAccessors;
	}

	requireConfigAccessors();

	var geoleaf_baselayers = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_baselayers;

	function requireGeoleaf_baselayers () {
		if (hasRequiredGeoleaf_baselayers) return geoleaf_baselayers;
		hasRequiredGeoleaf_baselayers = 1;
		(function (global) {

		    // ---------------------------------------------------------
		    // Namespace global + logger unifi√© (avec fallback console)
		    // ---------------------------------------------------------
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // Logger unifi√© (d√©fini par geoleaf.logger-shim.js charg√© en premier)
		    const Log = GeoLeaf.Log;

		    // V√©rification Leaflet
		    if (!global.L) {
		        Log.error("[GeoLeaf.Baselayers] Leaflet (L) est introuvable. Charge d'abord Leaflet 1.9.");
		        return;
		    }

		    const L = global.L;

		    const Baselayers = (function () {
		        let _map = null;
		        let _activeKey = null;
		        let _uiBound = false;
		        const _baseLayers = Object.create(null);

		        // Fallback : basemaps par d√©faut (100 % utilisables sans cl√©)
		        const DEFAULT_BASELAYERS = {
		            street: {
		                label: "Street",
		                url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
		                options: {
		                    maxZoom: 19,
		                    attribution: "&copy; OpenStreetMap contributors"
		                }
		            },
		            topo: {
		                label: "Topo",
		                url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
		                options: {
		                    maxZoom: 17,
		                    attribution:
		                        "Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap"
		                }
		            },
		            satellite: {
		                label: "Satellite",
		                url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
		                options: {
		                    maxZoom: 19,
		                    attribution:
		                        "Tiles &copy; Esri ‚Äî Source: Esri, Earthstar Geographics, and the GIS user community"
		                }
		            }
		        };

		        function _ensureMap(explicitMap) {
		            if (_map && typeof _map.setView === "function") {
		                return;
		            }
		            const gl = global.GeoLeaf || {};
		            if (gl.Core && typeof gl.Core.getMap === "function") {
		                const m = gl.Core.getMap();
		                if (m && typeof m.setView === "function") {
		                    _map = m;
		                    Log.info("[GeoLeaf.Baselayers] _ensureMap: acquired map from GeoLeaf.Core.getMap()", _map);
		                }
		            }
		        }

		        function _registerDefaultBaseLayers() {
		            Object.keys(DEFAULT_BASELAYERS).forEach(function (key) {
		                if (!_baseLayers[key]) {
		                    registerBaseLayer(key, DEFAULT_BASELAYERS[key]);
		                    Log.info("[GeoLeaf.Baselayers] _registerDefaultBaseLayers: registered", key);
		                }
		            });
		        }

		        function _normalizeOptions(definition) {
		            const opts = Object.assign({}, definition.options || {});
		            // minZoom pour limiter le zoom arri√®re
		            if (typeof opts.minZoom !== "number") {
		                if (typeof definition.minZoom === "number") {
		                    opts.minZoom = definition.minZoom;
		                }
		            }
		            // maxZoom minimal pour √©viter les warnings "no maxZoom specified"
		            if (typeof opts.maxZoom !== "number") {
		                opts.maxZoom = typeof definition.maxZoom === "number" ? definition.maxZoom : 19;
		            }
		            if (!opts.attribution && definition.attribution) {
		                opts.attribution = definition.attribution;
		            }
		            return opts;
		        }

		        function registerBaseLayer(key, definition) {
		            if (!key) {
		                Log.warn("[GeoLeaf.Baselayers] registerBaseLayer appel√© sans cl√©.");
		                return;
		            }
		            if (!definition) {
		                Log.warn("[GeoLeaf.Baselayers] D√©finition manquante pour la couche :", key);
		                return;
		            }

		            // Utiliser definition.id si disponible, sinon la cl√©
		            const actualKey = definition.id || key;
		            let layerInstance = null;
		            const label = definition.label || actualKey;

		            // Cas 1 : on re√ßoit directement une instance de L.TileLayer
		            if (definition instanceof L.TileLayer) {
		                layerInstance = definition;
		            }
		            // Cas 2 : on re√ßoit un objet contenant .layer d√©j√† pr√™t
		            else if (definition.layer && definition.layer instanceof L.TileLayer) {
		                layerInstance = definition.layer;
		            }
		            // Cas 3 : on re√ßoit une config { url, options, ... } ‚Üí on cr√©e la tileLayer
		            else if (definition.url) {
		                const options = _normalizeOptions(definition);
		                layerInstance = L.tileLayer(definition.url, options);
		            } else {
		                Log.warn(
		                    "[GeoLeaf.Baselayers] D√©finition invalide pour la couche :",
		                    actualKey,
		                    "(aucune url / aucun layer fourni)"
		                );
		                return;
		            }

		            _baseLayers[actualKey] = {
		                key: actualKey,
		                label: label,
		                layer: layerInstance
		            };
		        }

		        function registerBaseLayers(definitions) {
		            if (!definitions || typeof definitions !== "object") {
		                Log.warn("[GeoLeaf.Baselayers] registerBaseLayers attend un objet de d√©finitions.");
		                return;
		            }
		            Object.keys(definitions).forEach(function (key) {
		                registerBaseLayer(key, definitions[key]);
		            });
		        }

		        function _refreshUI() {
		            if (!global.document) {
		                return;
		            }
		            const elements = global.document.querySelectorAll("[data-gl-baselayer]");
		            const leftPanel = global.document.getElementById('gl-left-panel');
		            let activeElement = null;

		            elements.forEach(function (el) {
		                const key = el.getAttribute("data-gl-baselayer");
		                if (!key) {
		                    return;
		                }
		                const isActive = key === _activeKey;
		                if (isActive) {
		                    el.classList.add("gl-baselayer-active", "is-active");
		                    el.setAttribute("aria-pressed", "true");
		                    activeElement = el;
		                } else {
		                    el.classList.remove("gl-baselayer-active", "is-active");
		                    el.setAttribute("aria-pressed", "false");
		                }
		            });

		            // Animer l'indicateur vers le bouton actif
		            if (leftPanel && activeElement) {
		                _updateActiveIndicator(leftPanel, activeElement);
		            }
		        }

		        function _updateActiveIndicator(panel, activeButton) {
		            if (!panel || !activeButton) {
		                return;
		            }

		            const panelRect = panel.getBoundingClientRect();
		            const buttonRect = activeButton.getBoundingClientRect();

		            // Calculer la position relative du bouton par rapport au panneau
		            const left = buttonRect.left - panelRect.left;
		            const width = buttonRect.width;

		            // Mettre √† jour la position et la largeur de l'indicateur (::before)
		            panel.style.setProperty('--indicator-left', left + 'px');
		            panel.style.setProperty('--indicator-width', width + 'px');
		        }

		        function _createBaseLayerControlsUI(config) {
		            if (!global.document) {
		                return;
		            }

		            // Si config n'est pas fourni, essayer de le r√©cup√©rer depuis GeoLeaf.Config
		            if (!config && global.GeoLeaf && global.GeoLeaf.Config && typeof global.GeoLeaf.Config.get === 'function') {
		                config = {
		                    ui: global.GeoLeaf.Config.get('ui'),
		                    basemaps: global.GeoLeaf.Config.get('basemaps') || {}
		                };
		            }

		            // V√©rifier si showBaseLayerControls est activ√©
		            const showControls = config && config.ui && config.ui.showBaseLayerControls !== false;

		            let leftPanel = global.document.getElementById('gl-left-panel');

		            if (showControls) {
		                // Cr√©er le panneau s'il n'existe pas
		                if (!leftPanel) {
		                    leftPanel = global.document.createElement('div');
		                    leftPanel.id = 'gl-left-panel';
		                    leftPanel.className = 'gl-left-panel';

		                    // Trouver le conteneur de la carte pour y ins√©rer le panneau
		                    const mapContainer = global.document.getElementById('geoleaf-map') ||
		                                       global.document.querySelector('.gl-map');

		                    if (mapContainer) {
		                        mapContainer.appendChild(leftPanel);
		                    } else {
		                        // Fallback: ajouter au body
		                        global.document.body.appendChild(leftPanel);
		                    }
		                }

		                // Cr√©er les boutons de s√©lection de fond de carte
		                // SAFE: Cha√Æne vide pour nettoyer le contenu avant reconstruction
		                GeoLeaf.DOMSecurity.clearElementFast(leftPanel);

		                // Utiliser _baseLayers enregistr√©s plut√¥t que config.basemaps
		                // car les basemaps par d√©faut peuvent avoir √©t√© ajout√©s
		                Object.keys(_baseLayers).forEach(function(key) {
		                    const def = _baseLayers[key];
		                    const button = global.document.createElement('button');
		                    button.className = 'gl-baselayer-btn';
		                    button.setAttribute('data-gl-baselayer', key);
		                    button.setAttribute('aria-label', def.label || key);
		                    button.textContent = def.label || key;
		                    leftPanel.appendChild(button);
		                });
		                leftPanel.style.display = 'flex';

		                Log.info("[GeoLeaf.Baselayers] Contr√¥les de fond de carte cr√©√©s avec", Object.keys(_baseLayers).length, "boutons");

		                // Initialiser la position de l'indicateur apr√®s un court d√©lai
		                // pour s'assurer que le DOM est compl√®tement rendu
		                setTimeout(function() {
		                    _refreshUI();
		                }, 50);
		            } else {
		                // Masquer ou supprimer le panneau si showBaseLayerControls est false
		                if (leftPanel) {
		                    leftPanel.style.display = 'none';
		                }
		            }
		        }

		        function _bindUIOnce() {
		            if (_uiBound || !global.document) {
		                return;
		            }
		            _uiBound = true;

		            // Un seul listener global : tout √©l√©ment avec data-gl-baselayer utilise le m√™me setBaseLayer()
		            global.document.addEventListener("click", function (evt) {
		                const target = evt.target.closest("[data-gl-baselayer]");
		                if (!target) {
		                    return;
		                }
		                const key = target.getAttribute("data-gl-baselayer");
		                if (!key) {
		                    return;
		                }
		                evt.preventDefault();
		                setBaseLayer(key);
		            });

		            // Recalculer la position de l'indicateur lors du redimensionnement de la fen√™tre
		            let resizeTimeout;
		            global.addEventListener('resize', function() {
		                clearTimeout(resizeTimeout);
		                resizeTimeout = setTimeout(function() {
		                    _refreshUI();
		                }, 100);
		            });
		        }

		        function setBaseLayer(key, options) {
		            options = options || {};

		            if (!key) {
		                Log.warn("[GeoLeaf.Baselayers] setBaseLayer appel√© sans cl√©.");
		                return;
		            }

		            const previousKey = _activeKey;

		            _ensureMap();
		            Log.info(
		                "[GeoLeaf.Baselayers] setBaseLayer called: key=",
		                key,
		                "_map=",
		                _map ? true : false
		            );
		            if (!_map) {
		                Log.warn(
		                    "[GeoLeaf.Baselayers] Aucun L.Map disponible. Assure-toi que GeoLeaf.Core est initialis√©."
		                );
		                return;
		            }

		            if (!_baseLayers[key]) {
		                Log.warn("[GeoLeaf.Baselayers] Couche inconnue :", key);
		                const keys = Object.keys(_baseLayers);
		                if (!previousKey && keys.length > 0) {
		                    const fallbackKey = keys[0];
		                    if (!options.silent) {
		                        Log.warn(
		                            "[GeoLeaf.Baselayers] Bascule vers la premi√®re couche disponible :",
		                            fallbackKey
		                        );
		                    }
		                    setBaseLayer(fallbackKey, { silent: true });
		                }
		                return;
		            }

		            // Si la couche est d√©j√† active, on ne fait que rafra√Æchir l'UI
		            if (_activeKey === key) {
		                _refreshUI();
		                return;
		            }

		            // Retirer l'ancienne couche si pr√©sente (avec garde-fous)
		            if (previousKey && _baseLayers[previousKey]) {
		                const prev = _baseLayers[previousKey].layer;
		                try {
		                    if (
		                        prev &&
		                        _map &&
		                        typeof _map.hasLayer === "function" &&
		                        _map.hasLayer(prev)
		                    ) {
		                        _map.removeLayer(prev);
		                    }
		                } catch (e) {
		                    Log.warn(
		                        "[GeoLeaf.Baselayers] Impossible de retirer la couche pr√©c√©dente:",
		                        e
		                    );
		                }
		            }

		            const nextLayer = _baseLayers[key].layer;
		            if (!nextLayer || typeof nextLayer.addTo !== "function") {
		                Log.error("[GeoLeaf.Baselayers] Couche invalide pour la cl√©:", key);
		                return;
		            }

		            try {
		                nextLayer.addTo(_map);
		            } catch (e) {
		                Log.error(
		                    "[GeoLeaf.Baselayers] Impossible d'ajouter la couche au L.Map:",
		                    e
		                );
		                return;
		            }

		            _activeKey = key;
		            _refreshUI();

		            Log.info("[GeoLeaf.Baselayers] Activated base layer:", key);

		            // √âv√©nement personnalis√© : geoleaf:basemap:change
		            if (!options.silent) {
		                if (
		                    typeof document !== "undefined" &&
		                    typeof document.dispatchEvent === "function"
		                ) {
		                    const detail = {
		                        key,
		                        previousKey,
		                        map: _map,
		                        layer: nextLayer,
		                        source: "geoleaf.baselayers"
		                    };

		                    try {
		                        if (typeof CustomEvent === "function") {
		                            const event = new CustomEvent("geoleaf:basemap:change", {
		                                detail
		                            });
		                            document.dispatchEvent(event);
		                        } else {
		                            const legacyEvent = document.createEvent("CustomEvent");
		                            legacyEvent.initCustomEvent(
		                                "geoleaf:basemap:change",
		                                true,
		                                true,
		                                detail
		                            );
		                            document.dispatchEvent(legacyEvent);
		                        }
		                    } catch (err) {
		                        Log.warn(
		                            "[GeoLeaf.Baselayers] Impossible d'√©mettre l'√©v√©nement geoleaf:basemap:change.",
		                            err
		                        );
		                    }
		                }

		                Log.info("[GeoLeaf.Baselayers] Couche de fond active :", key);
		            }
		        }

		        function getBaseLayers() {
		            return Object.assign({}, _baseLayers);
		        }

		        function getActiveKey() {
		            return _activeKey;
		        }

		        function getActiveLayer() {
		            return _activeKey && _baseLayers[_activeKey]
		                ? _baseLayers[_activeKey].layer
		                : null;
		        }

		        /**
		         * Initialisation du module Baselayers.
		         *
		         * Usage flexible :
		         * GeoLeaf.Baselayers.init({
		         *   map: mapLeaflet,              // optionnel si GeoLeaf.Core est d√©j√† initialis√©
		         *   baselayers: { street: {...}, topo: {...}, satellite: {...} },
		         *   defaultKey: "street"          // ou activeKey / initialKey
		         * });
		         *
		         * Si aucune couche n‚Äôest fournie, les 3 basemaps par d√©faut (OSM / OpenTopoMap / Esri WorldImagery)
		         * sont automatiquement enregistr√©es, et une est activ√©e.
		         */
		                function init(options) {
		            options = options || {};

		            if (options.map) {
		                _map = options.map;
		            } else {
		                _ensureMap();
		            }

		            _registerDefaultBaseLayers();

		            if (options.baselayers && typeof options.baselayers === "object") {
		                registerBaseLayers(options.baselayers);
		            }

		            if (options.activeKey) {
		                setBaseLayer(options.activeKey, { silent: true });
		            }

		            // Si aucune couche n'est active, on prend la premi√®re disponible.
		            if (!_activeKey) {
		                const keys = Object.keys(_baseLayers);
		                if (keys.length > 0) {
		                    const defaultKey = keys[0];
		                    Log.info("[GeoLeaf.Baselayers] init: aucune couche active, bascule sur", defaultKey);
		                    setBaseLayer(defaultKey, { silent: true });
		                }
		            }

		            // Cr√©er les contr√¥les UI de fond de carte si la config le demande
		            _createBaseLayerControlsUI(options);

		            // Lie les boutons UI d√©clar√©s dans le DOM (data-gl-baselayer)
		            _bindUIOnce();

		            return {
		                map: _map,
		                activeKey: getActiveKey(),
		                layers: getBaseLayers()
		            };
		        }

		        return {
		            init: init,
		            registerBaseLayer: registerBaseLayer,
		            registerBaseLayers: registerBaseLayers,
		            setBaseLayer: setBaseLayer,
		            setActive: setBaseLayer, // alias pour compatibilit√©
		            getBaseLayers: getBaseLayers,
		            getActiveKey: getActiveKey,
		            getActiveLayer: getActiveLayer
		        };
		    })();

		    // Nommage stabilis√© : BaseLayers devient la forme officielle,
		    // Baselayers reste un alias de compatibilit√©.
		    GeoLeaf.Baselayers = Baselayers;
		    GeoLeaf.BaseLayers = Baselayers;
		})(window);
		return geoleaf_baselayers;
	}

	requireGeoleaf_baselayers();

	var geoleaf_filters = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_filters;

	function requireGeoleaf_filters () {
		if (hasRequiredGeoleaf_filters) return geoleaf_filters;
		hasRequiredGeoleaf_filters = 1;
		/**
		 * GeoLeaf Filters Module
		 * Filtrage des POI et Routes selon crit√®res (cat√©gories, tags, proximit√©, recherche, note)
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;
		    const Utils = GeoLeaf.Utils;

		    // ========================================
		    //   HELPER FUNCTIONS
		    // ========================================

		    /**
		     * Extrait une valeur depuis un chemin (ex: "attributes.shortDescription")
		     * @param {object} obj - Objet source
		     * @param {string} path - Chemin avec notation point
		     * @returns {*} Valeur trouv√©e ou null
		     * @private
		     */
		    function getNestedValue(obj, path) {
		        return path.split('.').reduce((current, prop) =>
		            current && current[prop] !== undefined ? current[prop] : null, obj);
		    }

		    /**
		     * R√©cup√®re les champs de recherche depuis le profil actif
		     * 1. Priorit√© : extrait les champs marqu√©s "search": true dans panels.detail.layout et panels.route.layout
		     * 2. Fallback : r√©cup√®re searchFields du filtre search dans le profil
		     * 3. Fallback final : champs par d√©faut
		     * @returns {Array<string>} Liste des chemins de champs √† rechercher
		     * @private
		     */
		    function getSearchFieldsFromProfile() {
		        try {
		            // Essayer de r√©cup√©rer depuis GeoLeaf.Config
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === 'function') {
		                const profile = GeoLeaf.Config.getActiveProfile();

		                // 1. PRIORIT√â : Extraire les champs avec "search": true depuis tous les layouts
		                const searchableFieldsSet = new Set();

		                // Extraire depuis panels.detail.layout (POI)
		                if (profile && profile.panels && profile.panels.detail && Array.isArray(profile.panels.detail.layout)) {
		                    profile.panels.detail.layout
		                        .filter(item => item.search === true && item.field)
		                        .forEach(item => searchableFieldsSet.add(item.field));
		                }

		                // Extraire depuis panels.route.layout (Routes)
		                if (profile && profile.panels && profile.panels.route && Array.isArray(profile.panels.route.layout)) {
		                    profile.panels.route.layout
		                        .filter(item => item.search === true && item.field)
		                        .forEach(item => searchableFieldsSet.add(item.field));
		                }

		                if (searchableFieldsSet.size > 0) {
		                    const searchableFields = Array.from(searchableFieldsSet);
		                    if (Log) Log.debug('[Filters] Champs de recherche depuis layouts (search:true):', searchableFields);
		                    return searchableFields;
		                }

		                // 2. FALLBACK : Chercher searchFields dans panels.search.filters
		                if (profile && profile.panels && profile.panels.search && Array.isArray(profile.panels.search.filters)) {
		                    const searchFilter = profile.panels.search.filters.find(f => f.type === 'search');
		                    if (searchFilter && Array.isArray(searchFilter.searchFields) && searchFilter.searchFields.length > 0) {
		                        if (Log) Log.debug('[Filters] Champs de recherche depuis searchFields (fallback):', searchFilter.searchFields);
		                        return searchFilter.searchFields;
		                    }
		                }
		            }
		        } catch (err) {
		            if (Log) Log.warn('[Filters] Erreur extraction searchFields du profil:', err);
		        }

		        // 3. FALLBACK FINAL : champs par d√©faut
		        const defaultFields = ['title', 'label', 'name'];
		        if (Log) Log.debug('[Filters] Utilisation des champs de recherche par d√©faut:', defaultFields);
		        return defaultFields;
		    }

		    /**
		     * Extrait les coordonn√©es d'une route dans diff√©rents formats
		     * @param {object} route - Objet route
		     * @returns {Array<[number, number]>} Tableau de coordonn√©es [lat, lng]
		     * @private
		     */
		    function extractRouteCoords(route) {
		        // Cas 1 : tableau direct de [lat, lng]
		        if (Array.isArray(route.geometry) && route.geometry.length > 0) {
		            if (
		                Array.isArray(route.geometry[0]) &&
		                typeof route.geometry[0][0] === "number" &&
		                typeof route.geometry[0][1] === "number"
		            ) {
		                return route.geometry.map((pair) => [pair[0], pair[1]]);
		            }

		            // Cas 2 : GeoJSON-like dans un tableau
		            if (
		                route.geometry[0] &&
		                typeof route.geometry[0] === "object" &&
		                route.geometry[0].type === "LineString" &&
		                Array.isArray(route.geometry[0].coordinates)
		            ) {
		                return route.geometry[0].coordinates.map((c) => [c[1], c[0]]);
		            }
		        }

		        // Cas 3 : vrai objet GeoJSON
		        if (
		            route.geometry &&
		            typeof route.geometry === "object" &&
		            route.geometry.type === "LineString" &&
		            Array.isArray(route.geometry.coordinates)
		        ) {
		            return route.geometry.coordinates.map((c) => [c[1], c[0]]);
		        }

		        return [];
		    }

		    // ========================================
		    //   PUBLIC API
		    // ========================================

		    /**
		     * Filtre une liste de POI selon les crit√®res fournis
		     * @param {Array} basePois - Liste compl√®te des POI
		     * @param {object} filterState - √âtat des filtres
		     * @param {Array<string>} [filterState.categoriesTree] - IDs des cat√©gories s√©lectionn√©es
		     * @param {Array<string>} [filterState.subCategoriesTree] - IDs des sous-cat√©gories s√©lectionn√©es
		     * @param {boolean} [filterState.hasMinRating] - Activer filtre note minimale
		     * @param {number} [filterState.minRating] - Note minimale
		     * @param {Array<string>} [filterState.selectedTags] - Tags s√©lectionn√©s
		     * @param {boolean} [filterState.hasTags] - Activer filtre tags
		     * @param {object} [filterState.dataTypes] - Types de donn√©es (poi, routes)
		     * @param {string} [filterState.searchText] - Texte de recherche
		     * @param {boolean} [filterState.hasSearchText] - Activer recherche textuelle
		     * @param {object} [filterState.proximity] - Filtre proximit√© {active, center, radius}
		     * @returns {Array} POI filtr√©s
		     */
		    function filterPoiList(basePois, filterState) {
		        const catsSel = filterState.categoriesTree || [];
		        const subsSel = filterState.subCategoriesTree || [];
		        const hasCats = catsSel.length > 0;
		        const hasSubs = subsSel.length > 0;
		        const hasMinRating = !!filterState.hasMinRating;
		        const minRating = filterState.minRating;
		        const selectedTags = filterState.selectedTags || [];
		        const hasTags = filterState.hasTags;
		        const dataTypes = filterState.dataTypes || { poi: true, routes: true };
		        const searchText = filterState.searchText || "";
		        const hasSearchText = filterState.hasSearchText || false;
		        const proximity = filterState.proximity || { active: false };

		        if (Log) {
		            Log.debug("[Filters] D√©but filtrage POI:", {
		                totalPOI: basePois.length,
		                hasCats,
		                hasSubs,
		                hasSearchText,
		                proximityActive: proximity.active
		            });
		        }

		        if (!Array.isArray(basePois) || basePois.length === 0) {
		            if (Log) Log.debug("[Filters] Aucun POI √† filtrer");
		            return [];
		        }

		        // Utilise GeoLeaf.Utils.getDistance() (formule de Haversine)
		        const getDistance = Utils ? Utils.getDistance : null;

		        return basePois.filter(function (poi) {
		            const attrs = poi.attributes || {};
		            const props = poi.properties || {};

		            // Filtre Type de donn√©es (POI / Routes)
		            const poiType = poi.type || attrs.type || props.type || 'poi';
		            if (poiType === 'route' || poiType === 'routes') {
		                if (!dataTypes.routes) return false;
		            } else {
		                if (!dataTypes.poi) return false;
		            }

		            // Filtre Recherche textuelle
		            if (hasSearchText) {
		                const searchFields = getSearchFieldsFromProfile();
		                let matchFound = false;

		                for (let i = 0; i < searchFields.length; i++) {
		                    const fieldPath = searchFields[i];
		                    const value = getNestedValue(poi, fieldPath);

		                    if (value && String(value).toLowerCase().includes(searchText)) {
		                        matchFound = true;
		                        break;
		                    }
		                }

		                if (!matchFound) return false;
		            }

		            // Filtre Proximit√©
		            if (proximity.active && proximity.center && getDistance) {
		                let lat, lng;

		                // V√©rifier d'abord le format latlng [lat, lng]
		                if (poi.latlng && Array.isArray(poi.latlng) && poi.latlng.length === 2) {
		                    lat = poi.latlng[0];
		                    lng = poi.latlng[1];
		                } else {
		                    lat = poi.lat || poi.latitude || attrs.latitude || props.latitude ||
		                              (poi.coordinates && poi.coordinates[1]) ||
		                              (poi.geometry && poi.geometry.coordinates && poi.geometry.coordinates[1]);
		                    lng = poi.lng || poi.longitude || attrs.longitude || props.longitude ||
		                              (poi.coordinates && poi.coordinates[0]) ||
		                              (poi.geometry && poi.geometry.coordinates && poi.geometry.coordinates[0]);
		                }

		                if (lat && lng) {
		                    const distance = getDistance(proximity.center.lat, proximity.center.lng, lat, lng);
		                    if (distance > proximity.radius) return false;
		                } else {
		                    // Si pas de coordonn√©es, on exclut du filtre proximit√©
		                    return false;
		                }
		            }

		            const catId =
		                attrs.categoryId ||
		                poi.categoryId ||
		                poi.category ||
		                props.categoryId ||
		                props.category ||
		                null;

		            const subId =
		                attrs.subCategoryId ||
		                poi.subCategoryId ||
		                poi.subCategory ||
		                poi.sub_category ||
		                props.subCategoryId ||
		                props.sub_category ||
		                null;

		            // Filtre cat√©gories / sous-cat√©gories (tree-view)
		            // Logique:
		            // - Si des sous-cat√©gories sont coch√©es: le POI doit avoir cette sous-cat√©gorie
		            // - Si seulement des cat√©gories sont coch√©es (sans sous-cat): le POI doit avoir cette cat√©gorie
		            if (hasCats || hasSubs) {
		                // Cas 1: Des sous-cat√©gories sont s√©lectionn√©es
		                if (hasSubs) {
		                    // Si le POI a une sous-cat√©gorie, v√©rifier qu'elle est dans la liste
		                    if (subId && subsSel.includes(String(subId))) ; else {
		                        // POI n'a pas la bonne sous-cat√©gorie
		                        // On v√©rifie si sa cat√©gorie est s√©lectionn√©e SANS sous-cat√©gorie coch√©e
		                        // (permet de garder les POI dont la cat√©gorie est coch√©e mais pas leurs sous-cat)
		                        if (hasCats && catId && catsSel.includes(String(catId))) {
		                            // V√©rifier si aucune sous-cat de cette cat√©gorie n'est coch√©e
		                            // Pour simplifier, on rejette si des sous-cat sont coch√©es
		                            return false;
		                        } else {
		                            return false;
		                        }
		                    }
		                }
		                // Cas 2: Seulement des cat√©gories (pas de sous-cat)
		                else if (hasCats) {
		                    if (!catId || !catsSel.includes(String(catId))) {
		                        return false;
		                    }
		                }
		            }

		            // Filtre note minimale
		            if (hasMinRating) {
		                let avg = 0;
		                let hasRating = false;

		                // Cas 1: reviews est un objet avec rating (format actuel)
		                let reviewsObj = attrs.reviews || poi.reviews || props.reviews;
		                if (reviewsObj && typeof reviewsObj === "object" && !Array.isArray(reviewsObj)) {
		                    if (typeof reviewsObj.rating === "number") {
		                        avg = reviewsObj.rating;
		                        hasRating = true;
		                    }
		                }

		                // Cas 2: reviews est un array (ancien format)
		                else if (Array.isArray(reviewsObj) && reviewsObj.length > 0) {
		                    const sum = reviewsObj.reduce(
		                        (acc, r) => acc + (Number(r.rating) || 0),
		                        0
		                    );
		                    avg = sum / reviewsObj.length;
		                    hasRating = avg > 0;
		                }

		                // Cas 3: rating directement sur l'objet
		                else if (typeof attrs.rating === "number") {
		                    avg = attrs.rating;
		                    hasRating = true;
		                } else if (typeof poi.rating === "number") {
		                    avg = poi.rating;
		                    hasRating = true;
		                } else if (typeof props.rating === "number") {
		                    avg = props.rating;
		                    hasRating = true;
		                }

		                // Exclure si: 1) pas de note OU 2) note < minRating
		                // Comportement: quand filtre actif, seuls les POI avec note >= minRating passent
		                if (!hasRating || avg < minRating) {
		                    return false;
		                }
		            }

		            // Tags (au moins UN des tags s√©lectionn√©s doit √™tre pr√©sent dans le POI)
		            if (hasTags) {
		                let poiTags =
		                    attrs.tags || poi.tags || props.tags || [];
		                if (!Array.isArray(poiTags)) {
		                    if (typeof poiTags === "string") {
		                        poiTags = poiTags.split(/[,;]+/);
		                    } else {
		                        poiTags = [];
		                    }
		                }
		                poiTags = poiTags
		                    .map((t) => String(t).trim())
		                    .filter(Boolean);

		                const hasAtLeastOne = selectedTags.some((tag) =>
		                    poiTags.includes(tag)
		                );
		                if (!hasAtLeastOne) {
		                    return false;
		                }
		            }

		            return true;
		        });
		    }

		    /**
		     * Filtre une liste de routes selon les crit√®res fournis
		     * @param {Array} baseRoutes - Liste compl√®te des routes
		     * @param {object} filterState - √âtat des filtres
		     * @param {Array<string>} [filterState.categoriesTree] - IDs des cat√©gories s√©lectionn√©es
		     * @param {Array<string>} [filterState.subCategoriesTree] - IDs des sous-cat√©gories s√©lectionn√©es
		     * @param {Array<string>} [filterState.selectedTags] - Tags s√©lectionn√©s
		     * @param {boolean} [filterState.hasTags] - Activer filtre tags
		     * @param {string} [filterState.searchText] - Texte de recherche
		     * @param {boolean} [filterState.hasSearchText] - Activer recherche textuelle
		     * @param {object} [filterState.proximity] - Filtre proximit√© {active, center, radius}
		     * @returns {Array} Routes filtr√©es
		     */
		    function filterRouteList(baseRoutes, filterState) {
		        const catsSel = filterState.categoriesTree || [];
		        const subsSel = filterState.subCategoriesTree || [];
		        const hasCats = catsSel.length > 0;
		        const hasSubs = subsSel.length > 0;
		        const selectedTags = filterState.selectedTags || [];
		        const hasTags = filterState.hasTags;
		        const hasMinRating = !!filterState.hasMinRating;
		        const minRating = filterState.minRating;
		        const searchText = filterState.searchText || "";
		        const hasSearchText = filterState.hasSearchText || false;
		        const proximity = filterState.proximity || { active: false };

		        if (Log) {
		            Log.debug("[Filters] D√©but filtrage routes:", {
		                totalRoutes: baseRoutes.length,
		                hasCats,
		                hasSubs,
		                hasMinRating,
		                minRating,
		                hasSearchText,
		                proximityActive: proximity.active
		            });
		        }

		        if (!Array.isArray(baseRoutes) || baseRoutes.length === 0) {
		            if (Log) Log.debug("[Filters] Aucune route √† filtrer");
		            return [];
		        }

		        // Utilise GeoLeaf.Utils.getDistance() (formule de Haversine)
		        const getDistance = Utils ? Utils.getDistance : null;

		        return baseRoutes.filter(function (route) {
		            const attrs = route.attributes || {};
		            const props = route.properties || {};

		            // Filtre Recherche textuelle
		            if (hasSearchText) {
		                const searchFields = getSearchFieldsFromProfile();
		                let matchFound = false;

		                for (let i = 0; i < searchFields.length; i++) {
		                    const fieldPath = searchFields[i];
		                    const value = getNestedValue(route, fieldPath);

		                    if (value && String(value).toLowerCase().includes(searchText)) {
		                        matchFound = true;
		                        break;
		                    }
		                }

		                if (!matchFound) return false;
		            }

		            // Filtre cat√©gories / sous-cat√©gories (tree-view)
		            const catId =
		                attrs.categoryId ||
		                route.categoryId ||
		                route.category ||
		                props.categoryId ||
		                props.category ||
		                null;

		            const subId =
		                attrs.subCategoryId ||
		                route.subCategoryId ||
		                route.subCategory ||
		                route.sub_category ||
		                props.subCategoryId ||
		                props.sub_category ||
		                null;

		            // Filtre cat√©gories / sous-cat√©gories (tree-view)
		            // Logique:
		            // - Si des sous-cat√©gories sont coch√©es: la route doit avoir cette sous-cat√©gorie
		            // - Si seulement des cat√©gories sont coch√©es (sans sous-cat): la route doit avoir cette cat√©gorie
		            if (hasCats || hasSubs) {
		                // Cas 1: Des sous-cat√©gories sont s√©lectionn√©es
		                if (hasSubs) {
		                    if (subId && subsSel.includes(String(subId))) ; else {
		                        // Route n'a pas la bonne sous-cat√©gorie
		                        if (hasCats && catId && catsSel.includes(String(catId))) {
		                            return false;
		                        } else {
		                            return false;
		                        }
		                    }
		                }
		                // Cas 2: Seulement des cat√©gories (pas de sous-cat)
		                else if (hasCats) {
		                    if (!catId || !catsSel.includes(String(catId))) {
		                        return false;
		                    }
		                }
		            }

		            // Filtre Tags (au moins UN des tags s√©lectionn√©s doit √™tre pr√©sent)
		            if (hasTags) {
		                let routeTags =
		                    attrs.tags || route.tags || props.tags || [];
		                if (!Array.isArray(routeTags)) {
		                    if (typeof routeTags === "string") {
		                        routeTags = routeTags.split(/[,;]+/);
		                    } else {
		                        routeTags = [];
		                    }
		                }
		                routeTags = routeTags
		                    .map((t) => String(t).trim())
		                    .filter(Boolean);

		                const hasAtLeastOne = selectedTags.some((tag) =>
		                    routeTags.includes(tag)
		                );
		                if (!hasAtLeastOne) {
		                    return false;
		                }
		            }

		            // Filtre note minimale (m√™me logique que pour les POI)
		            if (hasMinRating) {
		                let avg = 0;
		                let hasRating = false;

		                // Cas 1: reviews est un objet avec rating (format actuel)
		                let reviewsObj = attrs.reviews || route.reviews || props.reviews;
		                if (reviewsObj && typeof reviewsObj === "object" && !Array.isArray(reviewsObj)) {
		                    if (typeof reviewsObj.rating === "number") {
		                        avg = reviewsObj.rating;
		                        hasRating = true;
		                    }
		                }

		                // Cas 2: reviews est un array (ancien format)
		                else if (Array.isArray(reviewsObj) && reviewsObj.length > 0) {
		                    const sum = reviewsObj.reduce(
		                        (acc, r) => acc + (Number(r.rating) || 0),
		                        0
		                    );
		                    avg = sum / reviewsObj.length;
		                    hasRating = avg > 0;
		                }

		                // Cas 3: rating directement sur l'objet
		                else if (typeof attrs.rating === "number") {
		                    avg = attrs.rating;
		                    hasRating = true;
		                } else if (typeof route.rating === "number") {
		                    avg = route.rating;
		                    hasRating = true;
		                } else if (typeof props.rating === "number") {
		                    avg = props.rating;
		                    hasRating = true;
		                }

		                // Exclure si: 1) pas de note OU 2) note < minRating
		                // Comportement: quand filtre actif, seules les routes avec note >= minRating passent
		                if (!hasRating || avg < minRating) {
		                    return false;
		                }
		            }

		            // Filtre Proximit√© : v√©rifier si au moins un point de l'itin√©raire est dans le cercle
		            if (proximity.active && proximity.center && getDistance) {
		                const coords = extractRouteCoords(route);

		                if (coords.length === 0) {
		                    // Si pas de coordonn√©es, on exclut du filtre proximit√©
		                    return false;
		                }

		                // V√©rifier si au moins un point de l'itin√©raire est dans le rayon
		                let isInRadius = false;
		                for (let i = 0; i < coords.length; i++) {
		                    const lat = coords[i][0];
		                    const lng = coords[i][1];
		                    const distance = getDistance(proximity.center.lat, proximity.center.lng, lat, lng);
		                    if (distance <= proximity.radius) {
		                        isInRadius = true;
		                        break;
		                    }
		                }

		                if (!isInRadius) {
		                    return false;
		                }
		            }

		            return true;
		        });
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf.Filters = {
		        filterPoiList,
		        filterRouteList
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_filters;
	}

	requireGeoleaf_filters();

	var shared$2 = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredShared$2;

	function requireShared$2 () {
		if (hasRequiredShared$2) return shared$2;
		hasRequiredShared$2 = 1;
		/**
		 * GeoLeaf POI Module - √âtat Partag√©
		 * Variables et constantes partag√©es entre tous les sous-modules POI
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._POIShared = GeoLeaf._POIShared || {};

		    // ========================================
		    //   CONSTANTES
		    // ========================================

		    const POI_MARKER_SIZE = GeoLeaf.Constants?.POI_MARKER_SIZE || 16;
		    const POI_MAX_ZOOM = GeoLeaf.Constants?.POI_MAX_ZOOM || 18;

		    // Ic√¥ne par d√©faut (cercle bleu SVG en base64)
		    const defaultIconUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSIjNGE5MGU1IiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPjwvc3ZnPg==";

		    // ========================================
		    //   √âTAT PARTAG√â
		    // ========================================

		    /**
		     * √âtat mutable partag√© entre tous les sous-modules POI
		     * Accessible via GeoLeaf._POIShared.state
		     */
		    const state = {
		        // LayerGroup Leaflet contenant tous les marqueurs POI
		        poiLayerGroup: null,

		        // Cluster group (si activ√©)
		        poiClusterGroup: null,

		        // Tableau des donn√©es POI charg√©es
		        allPois: [],

		        // Map pour stocker les marqueurs Leaflet par ID de POI
		        poiMarkers: new Map(),

		        // Configuration du module POI
		        poiConfig: {},

		        // R√©f√©rence vers la carte Leaflet
		        mapInstance: null,

		        // Indicateur de chargement en cours
		        isLoading: false,

		        // √âl√©ment DOM pour le panneau lat√©ral POI
		        sidePanelElement: null,

		        // POI actuellement affich√© dans le panneau
		        currentPoiInPanel: null,

		        // Overlay de fond sombre pour le side panel
		        sidePanelOverlay: null,

		        // Index de l'image courante dans la galerie
		        currentGalleryIndex: 0
		    };

		    // ========================================
		    //   UTILITAIRES PARTAG√âS
		    // ========================================

		    /**
		     * Helper interne : garantit qu'un maxZoom num√©rique est d√©fini sur la carte.
		     * Utilis√© pour √©viter les erreurs du plugin de clustering ("Map has no maxZoom specified").
		     *
		     * @param {L.Map} map - Instance de la carte Leaflet
		     * @param {number} [fallback=18] - Valeur par d√©faut si map.options.maxZoom n'existe pas
		     */
		    function ensureMapMaxZoom(map, fallback = 18) {
		        if (!map || !map.options) return;
		        if (typeof map.options.maxZoom !== 'number' || isNaN(map.options.maxZoom)) {
		            map.options.maxZoom = fallback;
		        }
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POIShared = {
		        // Constantes (lecture seule)
		        constants: Object.freeze({
		            POI_MARKER_SIZE,
		            POI_MAX_ZOOM,
		            defaultIconUrl
		        }),

		        // √âtat mutable (accessible en lecture/√©criture par sous-modules)
		        state,

		        // Utilitaires
		        ensureMapMaxZoom
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return shared$2;
	}

	requireShared$2();

	var normalizers = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredNormalizers;

	function requireNormalizers () {
		if (hasRequiredNormalizers) return normalizers;
		hasRequiredNormalizers = 1;
		/**
		 * GeoLeaf POI Module - Normalizers
		 * Fonctions de normalisation et extraction de donn√©es POI
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;
		    const Security = GeoLeaf.Security || {};
		    const Utils = GeoLeaf.Utils || {};

		    GeoLeaf._POINormalizers = GeoLeaf._POINormalizers || {};

		    // ========================================
		    //   NORMALISATION POI
		    // ========================================

		    /**
		     * Normalise un POI vers la structure standard { id, latlng, title, attributes: {...} }.
		     * Transforme l'ancien format vers le nouveau format attendu par le profile.json.
		     *
		     * @param {object} poi - POI au format brut (ancien ou nouveau).
		     * @returns {object} POI normalis√©.
		     */
		    function normalizePoi(poi) {
		        if (!poi) return null;

		        const p = poi;
		        // Pr√©f√©rer les champs "attributes" du nouveau sch√©ma
		        const attr = (p && typeof p.attributes === 'object' && p.attributes) ? p.attributes : {};
		        const props = p.properties || {};

		        // Helper to sanitize URLs
		        const sanitizeUrl = (url) => {
		            if (!url || typeof url !== 'string') return null;
		            const trimmed = url.trim();
		            if (trimmed.match(/^(https?:\/\/|data:image\/)/i)) {
		                return trimmed;
		            }
		            return null;
		        };

		        // Helper to escape HTML - utilise Security.escapeHtml
		        const escapeHtml = Security.escapeHtml || ((str) => {
		            if (!str) return '';
		            const div = document.createElement('div');
		            div.textContent = str;
		            return div.innerHTML;
		        });

		        // Utilise resolveField si disponible
		        const resolveField = Utils.resolveField || ((obj, ...paths) => {
		            for (const path of paths) {
		                const keys = path.split('.');
		                let value = obj;
		                for (const key of keys) {
		                    if (value && typeof value === 'object' && key in value) {
		                        value = value[key];
		                    } else {
		                        value = null;
		                        break;
		                    }
		                }
		                if (value && typeof value === 'string' && value.trim()) {
		                    return value;
		                }
		            }
		            return '';
		        });

		        // Construire la structure normalis√©e
		        const normalized = {
		            id: p.id || null,
		            latlng: p.latlng || null,
		            // Le titre provient du champ label (nouvelle structure) ou des anciens champs
		            title: escapeHtml(resolveField(p, 'title', 'label', 'name', 'attributes.title', 'properties.label', 'properties.name') || 'Sans nom'),
		            // Pr√©server aussi label et name au niveau racine
		            label: escapeHtml(resolveField(p, 'label', 'name', 'title')),
		            name: escapeHtml(resolveField(p, 'name', 'label', 'title')),
		            description: escapeHtml(resolveField(p, 'description', 'attributes.description')),
		            // ‚úÖ IMPORTANT: Pr√©server les properties originales pour la r√©solution de champs comme "properties.Name"
		            properties: p.properties || {},
		            attributes: {
		                // D'abord, copier TOUS les attributs originaux pour pr√©server les champs sp√©cifiques
		                ...attr,
		                // Puis ajouter/surcharger avec les mappings normalis√©s
		                // Description courte : premier niveau du POI
		                shortDescription: escapeHtml(resolveField(p, 'description', 'attributes.shortDescription', 'properties.description')),
		                // Description longue : champ attributes.description_long ou anciens champs
		                longDescription: escapeHtml(resolveField(p, 'attributes.description_long', 'description_long', 'properties.description_long', 'attributes.longDescription')),
		                // Cat√©gories : pr√©f√©rer attributes.categoryId puis fallback anciens champs
		                categoryId: attr.categoryId || p.categoryId || p.category || props.category || null,
		                subCategoryId: attr.subCategoryId || p.subCategoryId || p.sub_category || props.sub_category || null,
		                // Image principale : attributes.photo ou attributes.mainImage, sinon premi√®re image de la galerie
		                mainImage: sanitizeUrl(attr.photo || attr.mainImage || props.photo || (attr.gallery && attr.gallery[0]) || (p.gallery && p.gallery[0]) || null),
		                // Galerie d'images : provenant de attributes.gallery ou anciens champs
		                gallery: ((attr.gallery || p.gallery || props.gallery || p.images || props.images) || [])
		                    .map(img => {
		                        if (typeof img === 'string') return sanitizeUrl(img);
		                        if (img && img.url) return sanitizeUrl(img.url);
		                        return null;
		                    })
		                    .filter(Boolean),
		                price: attr.price || p.price || props.price || null,
		                // Horaires d'ouverture : attributes.opening_hours (snake_case) ou openingHours camelCase
		                openingHours: attr.opening_hours || attr.openingHours || p.opening_hours || props.opening_hours || p.openingHours || props.openingHours || null,
		                openingHoursTable: null, // Sera construit √† partir de openingHours si n√©cessaire
		                reviews: attr.reviews || p.reviews || props.reviews || null,
		                // Tags : pr√©f√©rer attributes.tags
		                tags: (attr.tags || p.tags || props.tags || [])
		                    .map(t => escapeHtml(String(t))),
		                // Lien / site web : attributes.link (nouveau) ou anciens champs
		                website: sanitizeUrl(attr.link || attr.website || p.link || props.link || p.website || props.website || null),
		                address: escapeHtml(resolveField(p, 'attributes.address', 'address', 'properties.address')),
		                phone: escapeHtml(resolveField(p, 'attributes.phone', 'phone', 'properties.phone')),
		                email: escapeHtml(resolveField(p, 'attributes.email', 'email', 'properties.email')),
		                services: (attr.services || p.services || props.services || [])
		                    .map(s => escapeHtml(String(s)))
		            }
		        };

		        // Construire openingHoursTable si openingHours existe
		        if (normalized.attributes.openingHours && Array.isArray(normalized.attributes.openingHours)) {
		            normalized.attributes.openingHoursTable = normalized.attributes.openingHours.map(raw => {
		                if (raw == null) return null;
		                const text = String(raw).trim();
		                if (!text) return null;

		                const parts = text.split(':');
		                if (parts.length > 1) {
		                    const day = parts.shift().trim();
		                    const rest = parts.join(':').trim();

		                    let open = '';
		                    let close = '';
		                    const hoursParts = rest.split(/[‚Äì-]/);
		                    if (hoursParts.length > 1) {
		                        open = hoursParts[0].trim();
		                        close = hoursParts.slice(1).join('‚Äì').trim();
		                    } else {
		                        open = rest;
		                    }

		                    return { day, open, close };
		                }

		                return { day: text, open: '', close: '' };
		            }).filter(Boolean);
		        }

		        // ‚úÖ IMPORTANT: Pr√©server les m√©tadonn√©es de configuration de couche
		        // Ces champs sont ajout√©s par GeoJSON._convertFeatureToPOI
		        if (poi._sidepanelConfig) {
		            normalized._sidepanelConfig = poi._sidepanelConfig;
		        }
		        if (poi._layerConfig) {
		            normalized._layerConfig = poi._layerConfig;
		        }

		        return normalized;
		    }

		    /**
		     * Extrait la valeur d'un champ depuis un POI normalis√© en utilisant la notation point√©e.
		     *
		     * @param {object} normalizedPoi - POI normalis√©.
		     * @param {string} fieldPath - Chemin du champ (ex: "title", "attributes.gallery", "attributes.reviews.rating").
		     * @returns {*} Valeur du champ ou null si introuvable.
		     */
		    function getFieldValue(normalizedPoi, fieldPath) {
		        if (!normalizedPoi || !fieldPath) return null;

		        console.log('[DEBUG getFieldValue] Recherche:', fieldPath, 'dans POI:', {
		            id: normalizedPoi.id,
		            hasProperties: !!normalizedPoi.properties,
		            hasAttributes: !!normalizedPoi.attributes,
		            propertiesKeys: normalizedPoi.properties ? Object.keys(normalizedPoi.properties) : [],
		            attributesKeys: normalizedPoi.attributes ? Object.keys(normalizedPoi.attributes) : []
		        });

		        if (Log && typeof Log.debug === 'function') {
		            Log.debug("[POI.getFieldValue] Recherche fieldPath:", fieldPath, "| POI:", normalizedPoi.id);
		        }

		        const parts = fieldPath.split('.');
		        let value = normalizedPoi;

		        for (const part of parts) {
		            if (value == null || typeof value !== 'object') {
		                if (Log && typeof Log.debug === 'function') {
		                    Log.debug("[POI.getFieldValue] Chemin interrompu √† la partie:", part, "| value actuelle:", value);
		                }
		                return null;
		            }
		            value = value[part];
		        }

		        console.log('[DEBUG getFieldValue] Valeur trouv√©e:', value, 'pour fieldPath:', fieldPath);

		        if (Log && typeof Log.debug === 'function') {
		            Log.debug("[POI.getFieldValue] Valeur trouv√©e pour", fieldPath, ":", value);
		        }

		        // Retourner null pour les valeurs vides
		        if (value === undefined || value === '' || (Array.isArray(value) && value.length === 0)) {
		            console.log('[DEBUG getFieldValue] Valeur vide, retourne null');
		            if (Log && typeof Log.debug === 'function') {
		                Log.debug("[POI.getFieldValue] Valeur vide ou tableau vide, retourne null");
		            }
		            return null;
		        }

		        return value;
		    }

		    /**
		     * Extrait les coordonn√©es d'un POI et les normalise en [lat, lng].
		     *
		     * @param {object} poi - POI brut.
		     * @returns {Array<number>|null} Coordonn√©es [lat, lng] ou null si invalides.
		     */
		    function extractCoordinates(poi) {
		        if (!poi) return null;

		        let lat, lng;

		        // Format 1: poi.latlng = [lat, lng]
		        if (Array.isArray(poi.latlng) && poi.latlng.length >= 2) {
		            lat = poi.latlng[0];
		            lng = poi.latlng[1];
		        }
		        // Format 2: poi.latlng = {lat, lng}
		        else if (poi.latlng && typeof poi.latlng === 'object') {
		            lat = poi.latlng.lat;
		            lng = poi.latlng.lng || poi.latlng.lon;
		        }
		        // Format 3: poi.lat, poi.lng
		        else if (typeof poi.lat === 'number' && typeof poi.lng === 'number') {
		            lat = poi.lat;
		            lng = poi.lng;
		        }
		        // Format 4: poi.latitude, poi.longitude
		        else if (typeof poi.latitude === 'number' && typeof poi.longitude === 'number') {
		            lat = poi.latitude;
		            lng = poi.longitude;
		        }
		        // Format 5: poi.geometry.coordinates (GeoJSON)
		        else if (poi.geometry && Array.isArray(poi.geometry.coordinates)) {
		            // GeoJSON: [lng, lat] (invers√©!)
		            lng = poi.geometry.coordinates[0];
		            lat = poi.geometry.coordinates[1];
		        }

		        // Validation
		        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
		            return null;
		        }

		        // Validation bounds
		        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
		            return null;
		        }

		        return [lat, lng];
		    }

		    /**
		     * G√©n√®re un ID unique pour un POI sans ID.
		     *
		     * @param {object} poi - POI.
		     * @returns {string} ID g√©n√©r√©.
		     */
		    function generatePoiId(poi) {
		        const timestamp = Date.now();
		        const random = Math.floor(Math.random() * 10000);
		        const label = (poi.title || poi.label || poi.name || 'poi').toLowerCase().replace(/[^a-z0-9]/g, '-').substring(0, 20);
		        return `poi-${label}-${timestamp}-${random}`;
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POINormalizers = {
		        normalizePoi,
		        getFieldValue,
		        extractCoordinates,
		        generatePoiId
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return normalizers;
	}

	requireNormalizers();

	var popup = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredPopup;

	function requirePopup () {
		if (hasRequiredPopup) return popup;
		hasRequiredPopup = 1;
		/**
		 * GeoLeaf POI Module - Popup & Tooltips
		 * Gestion des popups rapides et tooltips sur les marqueurs.
		 * D√©l√®gue le rendu au module _ContentBuilder centralis√©.
		 *
		 * @module poi/popup
		 * @version 2.0.0
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;
		    const Security = GeoLeaf.Security || {};
		    const Utils = GeoLeaf.Utils || {};

		    GeoLeaf._POIPopup = GeoLeaf._POIPopup || {};

		    // ========================================
		    //   UTILITAIRES LOCAUX
		    // ========================================

		    /**
		     * R√©cup√®re le ContentBuilder
		     * @returns {Object|null}
		     */
		    function getContentBuilder() {
		        return GeoLeaf._ContentBuilder || null;
		    }

		    /**
		     * R√©sout la valeur d'un champ √† partir d'un objet POI.
		     * D√©l√®gue √† Utils.resolveField si disponible.
		     *
		     * @param {object} poi - Objet POI source.
		     * @param {string} field - Chemin du champ (ex: "attributes.photo").
		     * @returns {*} Valeur du champ ou null.
		     */
		    function resolveField(poi, field) {
		        if (!poi || !field) return null;

		        if (Utils.resolveField) {
		            return Utils.resolveField(poi, field);
		        }

		        // Fallback minimal
		        const parts = field.split('.');
		        let current = poi;
		        for (const part of parts) {
		            if (current && typeof current === 'object' && part in current) {
		                current = current[part];
		            } else {
		                return null;
		            }
		        }
		        return current;
		    }

		    /**
		     * √âchappe le HTML pour pr√©venir XSS.
		     * D√©l√®gue √† Security.escapeHtml si disponible.
		     *
		     * @param {string} str - Cha√Æne √† √©chapper.
		     * @returns {string} Cha√Æne √©chapp√©e.
		     */
		    function escapeHtml(str) {
		        if (!str) return '';
		        if (Security.escapeHtml) {
		            return Security.escapeHtml(str);
		        }
		        // Fallback
		        const div = document.createElement('div');
		        div.textContent = str;
		        return div.innerHTML;
		    }

		    // ========================================
		    //   CONFIGURATION
		    // ========================================

		    /**
		     * R√©cup√®re la configuration de popup pour une couche/POI.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {Array|null} Configuration detailPopup ou null.
		     */
		    function getPopupConfig(poi) {
		        // 1. Config attach√©e depuis la couche du POI
		        if (poi._layerConfig?.popup?.detailPopup) {
		            Log.info && Log.info('[POI Popup] Config popup depuis layerConfig');
		            return poi._layerConfig.popup.detailPopup;
		        }

		        // 2. Fallback: profil actif
		        const Config = GeoLeaf.Config;
		        if (Config && typeof Config.getActiveProfile === 'function') {
		            const profile = Config.getActiveProfile();

		            // Chercher la config dans les emplacements standards
		            if (profile?.popup?.detailPopup) {
		                Log.info && Log.info('[POI Popup] Config popup depuis profil actif (profile.popup.detailPopup)');
		                return profile.popup.detailPopup;
		            }

		            // ALTERNATIVE: V√©rifier aussi dans panels.poi (ancienne structure)
		            if (profile?.panels?.poi?.popup?.detailPopup) {
		                Log.info && Log.info('[POI Popup] Config popup depuis profil actif (profile.panels.poi.popup.detailPopup - ancienne structure)');
		                return profile.panels.poi.popup.detailPopup;
		            }
		        }

		        Log.warn && Log.warn('[POI Popup] Aucune configuration detailPopup trouv√©e pour POI:', poi.id || 'unknown');
		        return null;
		    }

		    /**
		     * R√©cup√®re la configuration de tooltip pour une couche/POI.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {Array|null} Configuration detailTooltip ou null.
		     */
		    function getTooltipConfig(poi) {
		        // 1. Config depuis popup.detailTooltip (structure standard)
		        if (poi._layerConfig?.popup?.detailTooltip) {
		            return poi._layerConfig.popup.detailTooltip;
		        }

		        // 2. Config depuis tooltip.detailTooltip
		        if (poi._layerConfig?.tooltip?.detailTooltip) {
		            return poi._layerConfig.tooltip.detailTooltip;
		        }

		        // 3. Config directe detailTooltip
		        if (poi._layerConfig?.detailTooltip) {
		            return poi._layerConfig.detailTooltip;
		        }

		        // 4. Fallback: profil actif
		        const Config = GeoLeaf.Config;
		        if (Config && typeof Config.getActiveProfile === 'function') {
		            const profile = Config.getActiveProfile();
		            if (profile?.popup?.detailTooltip) {
		                return profile.popup.detailTooltip;
		            }
		        }

		        return null;
		    }

		    // ========================================
		    //   CONSTRUCTION DU CONTENU
		    // ========================================

		    /**
		     * Construit le contenu HTML d'un popup rapide pour un POI.
		     * Utilise ContentBuilder si disponible, sinon logique interne.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @param {Function} resolveCategoryDisplay - Fonction pour r√©soudre l'affichage de cat√©gorie.
		     * @returns {string} HTML du popup.
		     */
		    function buildQuickPopupContent(poi, resolveCategoryDisplay) {
		        if (!poi) {
		            Log.warn && Log.warn('[POI Popup] POI invalide');
		            return '';
		        }

		        const config = getPopupConfig(poi);
		        const ContentBuilder = getContentBuilder();

		        // Si ContentBuilder disponible, d√©l√©guer
		        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === 'function') {
		            return ContentBuilder.buildPopupHTML(poi, config, {
		                resolveCategoryDisplay: resolveCategoryDisplay
		            });
		        }

		        // Fallback si ContentBuilder non charg√©
		        Log.warn && Log.warn('[POI Popup] ContentBuilder non disponible, fallback basique');
		        return buildFallbackPopup(poi);
		    }

		    /**
		     * Construit le contenu d'un tooltip pour un POI.
		     * Utilise ContentBuilder si disponible.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @param {Function} resolveCategoryDisplay - Fonction pour r√©soudre l'affichage de cat√©gorie.
		     * @returns {string} HTML du tooltip.
		     */
		    function buildTooltipContent(poi, resolveCategoryDisplay) {
		        if (!poi) {
		            Log.warn && Log.warn('[POI Tooltip] POI invalide');
		            return '';
		        }

		        const config = getTooltipConfig(poi);
		        const ContentBuilder = getContentBuilder();

		        // Si ContentBuilder disponible, d√©l√©guer
		        if (ContentBuilder && typeof ContentBuilder.buildTooltipHTML === 'function') {
		            return ContentBuilder.buildTooltipHTML(poi, config, {
		                resolveCategoryDisplay: resolveCategoryDisplay
		            });
		        }

		        // Fallback si ContentBuilder non charg√©
		        return escapeHtml(
		            resolveField(poi, 'title') ||
		            resolveField(poi, 'label') ||
		            resolveField(poi, 'name') ||
		            'POI'
		        );
		    }

		    /**
		     * Fallback pour construire un popup basique sans ContentBuilder.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @param {Array} config - Configuration detailPopup.
		     * @param {Function} resolveCategoryDisplay - Fonction pour r√©soudre l'affichage de cat√©gorie.
		     * @returns {string} HTML du popup.
		     */
		    function buildFallbackPopup(poi, config, resolveCategoryDisplay) {
		        const title = escapeHtml(
		            resolveField(poi, 'title') ||
		            resolveField(poi, 'label') ||
		            resolveField(poi, 'name') ||
		            'POI'
		        );

		        const description = resolveField(poi, 'attributes.description') ||
		                            resolveField(poi, 'description') || '';

		        let html = '<div class="gl-poi-popup">';
		        html += '<div class="gl-poi-popup__body">';
		        html += '<h3 class="gl-poi-popup__title"><span class="gl-poi-popup__title-text">' + title + '</span></h3>';
		        if (description) {
		            html += '<p class="gl-poi-popup__desc">' + escapeHtml(description) + '</p>';
		        }
		        html += '<a href="#" class="gl-poi-popup__link" data-poi-id="' + (poi.id || '') + '">Voir plus >>></a>';
		        html += '</div></div>';

		        return html;
		    }

		    // ========================================
		    //   ATTACHMENT LEAFLET
		    // ========================================

		    /**
		     * Attache un tooltip √† un marqueur Leaflet.
		     *
		     * @param {L.Marker} marker - Marqueur Leaflet.
		     * @param {string} content - Contenu du tooltip (texte).
		     * @param {object} options - Options du tooltip.
		     */
		    function attachTooltip(marker, content, options) {
		        if (!marker || typeof marker.bindTooltip !== 'function') {
		            Log.warn && Log.warn('[POI Popup] Marker invalide pour attachTooltip');
		            return;
		        }

		        const defaultOptions = {
		            direction: "top",
		            offset: [0, -10],
		            opacity: 0.9,
		            className: "gl-poi-tooltip"
		        };

		        const finalOptions = Object.assign({}, defaultOptions, options || {});
		        marker.bindTooltip(content, finalOptions);
		    }

		    /**
		     * G√®re le tooltip d'un marqueur selon la configuration.
		     *
		     * @param {L.Marker} marker - Marqueur Leaflet.
		     * @param {object} poi - Donn√©es du POI.
		     * @param {object} config - Configuration POI globale.
		     * @param {Function} resolveCategoryDisplay - Fonction pour r√©soudre l'affichage de cat√©gorie.
		     */
		    function manageTooltip(marker, poi, config, resolveCategoryDisplay) {
		        if (!marker || !poi) return;

		        const tooltipMode = config?.tooltipMode || "hover"; // "hover", "permanent", "none"

		        if (tooltipMode === "none") {
		            return;
		        }

		        // Construire le contenu du tooltip
		        const tooltipText = buildTooltipContent(poi, resolveCategoryDisplay);

		        if (tooltipMode === "permanent") {
		            attachTooltip(marker, tooltipText, { permanent: true });
		        } else {
		            attachTooltip(marker, tooltipText);
		        }
		    }

		    /**
		     * Attache un popup √† un marqueur Leaflet.
		     *
		     * @param {L.Marker} marker - Marqueur Leaflet.
		     * @param {string} content - Contenu HTML du popup.
		     * @param {object} options - Options du popup.
		     */
		    function attachPopup(marker, content, options) {
		        if (!marker || typeof marker.bindPopup !== 'function') {
		            Log.error && Log.error('[POI Popup] Marker invalide ou pas de bindPopup');
		            return;
		        }

		        const defaultOptions = {
		            maxWidth: 300,
		            minWidth: 200,
		            className: "gl-poi-popup-leaflet",
		            closeButton: true,
		            autoPan: true
		        };

		        const finalOptions = Object.assign({}, defaultOptions, options || {});
		        marker.bindPopup(content, finalOptions);
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POIPopup = {
		        // Construction de contenu
		        buildQuickPopupContent,
		        buildTooltipContent,

		        // Gestion Leaflet
		        attachTooltip,
		        manageTooltip,
		        attachPopup,

		        // Configuration
		        getPopupConfig,
		        getTooltipConfig
		    };

		    Log.info && Log.info('[GeoLeaf._POIPopup] Module POI Popup/Tooltip charg√© (v2.0.0)');

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return popup;
	}

	requirePopup();

	var markers = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredMarkers;

	function requireMarkers () {
		if (hasRequiredMarkers) return markers;
		hasRequiredMarkers = 1;
		/**
		 * GeoLeaf POI Module - Markers
		 * Cr√©ation et gestion des marqueurs Leaflet pour les POI
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._POIMarkers = GeoLeaf._POIMarkers || {};

		    // R√©f√©rences aux modules POI
		    const getShared = () => GeoLeaf._POIShared;
		    const getNormalizers = () => GeoLeaf._POINormalizers;
		    const getPopup = () => GeoLeaf._POIPopup;

		    /**
		     * Obtient la configuration de base des POI depuis le profil actif.
		     *
		     * @returns {object} Configuration de base { radius, weight, colorFill, colorStroke, fillOpacity, opacity, showIconsOnMap }.
		     */
		    function getPoiBaseConfig() {
		        const base = {
		            radius: 6,
		            weight: 1.5,
		            colorFill: "#4a90e5",
		            colorStroke: "#ffffff",
		            fillOpacity: 0.8,
		            opacity: 0.9,
		            showIconsOnMap: true
		        };

		        try {
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === "function") {
		                const activeProfile = GeoLeaf.Config.getActiveProfile();
		                const poiCfg =
		                    activeProfile &&
		                    activeProfile.appearance &&
		                    activeProfile.appearance.poi;

		                if (poiCfg) {
		                    if (typeof poiCfg.radius === "number") base.radius = poiCfg.radius;
		                    if (typeof poiCfg.weight === "number") base.weight = poiCfg.weight;
		                    if (typeof poiCfg.fillOpacity === "number") base.fillOpacity = poiCfg.fillOpacity;
		                    if (typeof poiCfg.opacity === "number") base.opacity = poiCfg.opacity;
		                    if (typeof poiCfg.showIconsOnMap === "boolean") base.showIconsOnMap = poiCfg.showIconsOnMap;

		                    if (typeof poiCfg.colorFill === "string") {
		                        base.colorFill = poiCfg.colorFill;
		                    }
		                    if (typeof poiCfg.colorStroke === "string") {
		                        base.colorStroke = poiCfg.colorStroke;
		                    }
		                }
		            }

		            // Fallback sur variables CSS
		            if (typeof document !== "undefined" && typeof window !== "undefined" && window.getComputedStyle) {
		                const root = getComputedStyle(document.documentElement);
		                const fillCss = root.getPropertyValue("--gl-color-poi-fill-default").trim();
		                const strokeCss = root.getPropertyValue("--gl-color-poi-stroke-default").trim();
		                if (fillCss && !base.colorFill) base.colorFill = fillCss;
		                if (strokeCss && !base.colorStroke) base.colorStroke = strokeCss;
		            }
		        } catch (err) {
		            if (Log) Log.warn("[POI] getPoiBaseConfig() : Erreur lecture config :", err);
		        }

		        return base;
		    }

		    /**
		     * R√©sout les couleurs d'un POI depuis category.style.json du profil actif.
		     * Ordre de priorit√© des couleurs :
		     * 1. Style de la couche (poi._layerConfig.style)
		     * 2. Style de cat√©gorie (category.style.json)
		     * 3. Style par d√©faut (baseConfig)
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @param {object} baseConfig - Configuration de base avec couleurs par d√©faut
		     * @returns {object} { colorFill, colorStroke, colorRoute, weight, radius, fillOpacity, opacity }
		     */
		    function resolveCategoryColors(poi, baseConfig) {
		        let colors = {
		            colorFill: baseConfig.colorFill,
		            colorStroke: baseConfig.colorStroke,
		            colorRoute: null,
		            weight: baseConfig.weight,
		            radius: baseConfig.radius,
		            fillOpacity: baseConfig.fillOpacity !== undefined ? baseConfig.fillOpacity : null,
		            opacity: baseConfig.opacity !== undefined ? baseConfig.opacity : null
		        };

		        // 1. Appliquer d'abord le style de la couche si disponible
		        if (poi._layerConfig && poi._layerConfig.style) {
		            const layerStyle = poi._layerConfig.style;
		            if (layerStyle.fillColor) colors.colorFill = layerStyle.fillColor;
		            if (layerStyle.color) colors.colorStroke = layerStyle.color;
		            if (typeof layerStyle.weight === 'number') colors.weight = layerStyle.weight;
		            if (typeof layerStyle.radius === 'number') colors.radius = layerStyle.radius;
		            if (typeof layerStyle.fillOpacity === 'number') colors.fillOpacity = layerStyle.fillOpacity;
		            if (typeof layerStyle.opacity === 'number') colors.opacity = layerStyle.opacity;
		        }

		        // 2. Appliquer ensuite les couleurs depuis les styleRules de la couche
		        if (GeoLeaf.Helpers && GeoLeaf.Helpers.StyleResolver) {
		            const styleColors = GeoLeaf.Helpers.StyleResolver.resolvePoiColors(poi);
		            if (styleColors.colorFill) colors.colorFill = styleColors.colorFill;
		            if (styleColors.colorStroke) colors.colorStroke = styleColors.colorStroke;
		            if (styleColors.colorRoute) colors.colorRoute = styleColors.colorRoute;
		        }

		        return colors;
		    }

		    /**
		     * R√©sout l'affichage d'un POI (ic√¥ne + couleurs) depuis la taxonomie et category.style.json du profil actif.
		     * Ordre de priorit√© des styles :
		     * 1. Style de la couche (poi._layerConfig.style) pour les couleurs
		     * 2. Style de cat√©gorie (category.style.json) pour les couleurs
		     * 3. Taxonomie pour les ic√¥nes
		     * 4. Style par d√©faut (baseConfig)
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {object} Configuration d'affichage { useIcon, iconId, colorFill, colorStroke, weight, radius, fillOpacity, opacity }.
		     */
		    function resolveCategoryDisplay(poi) {
		        const categoriesConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getCategories === "function")
		            ? GeoLeaf.Config.getCategories()
		            : {};

		        const shared = getShared();
		        const poiConfig = shared ? shared.state.poiConfig : {};
		        const showIconsOnMap = (poiConfig.showIconsOnMap !== false);

		        const baseConfig = getPoiBaseConfig();

		        // R√©soudre les couleurs via resolveCategoryColors
		        const colors = resolveCategoryColors(poi, baseConfig);

		        let result = {
		            useIcon: false,
		            iconId: null,
		            colorFill: colors.colorFill,
		            colorStroke: colors.colorStroke,
		            colorRoute: colors.colorRoute,
		            weight: colors.weight,
		            radius: colors.radius,
		            fillOpacity: colors.fillOpacity,
		            opacity: colors.opacity
		        };

		        // D√©terminer si on utilise les ic√¥nes
		        if (showIconsOnMap) {
		            try {
		                const iconsConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getIconsConfig === "function")
		                    ? GeoLeaf.Config.getIconsConfig()
		                    : null;

		                if (iconsConfig && iconsConfig.showOnMap !== false) {
		                    result.useIcon = true;
		                }
		            } catch (e) {
		                // Fallback showIconsOnMap reste true par d√©faut
		            }
		        }

		        const categoryId = poi.categoryId || poi.category ||
		            (poi.attributes && poi.attributes.categoryId) ||
		            (poi.properties && poi.properties.categoryId) ||
		            (poi.properties && poi.properties.category);

		        const subCategoryId = poi.subCategoryId || poi.subCategory || poi.sub_category ||
		            (poi.attributes && poi.attributes.subCategoryId) ||
		            (poi.properties && poi.properties.subCategoryId) ||
		            (poi.properties && poi.properties.sub_category);

		        // R√©solution de l'ic√¥ne depuis la taxonomie (pas les couleurs)
		        if (subCategoryId && categoryId && categoriesConfig[categoryId]?.subcategories) {
		            const subCat = categoriesConfig[categoryId].subcategories[subCategoryId];
		            const cat = categoriesConfig[categoryId];

		            if (subCat) {
		                result.iconId = subCat.icon || subCat.iconId || cat.icon || cat.iconId || null;
		            } else {
		                result.iconId = cat.icon || cat.iconId || null;
		            }
		        } else if (categoryId && categoriesConfig[categoryId]) {
		            const cat = categoriesConfig[categoryId];
		            result.iconId = cat.icon || cat.iconId || null;
		        } else {
		            // Ne logger que si une cat√©gorie est r√©ellement d√©finie (√©viter les warnings pour undefined/null)
		            if (categoryId && categoryId !== 'undefined' && categoryId !== 'null' && Log) {
		                Log.warn(`[POI] resolveCategoryDisplay() : Cat√©gorie '${categoryId}' non trouv√©e dans la taxonomie.`);
		            }
		        }

		        return result;
		    }

		    /**
		     * Injecte le sprite SVG du profil actif dans le DOM (asynchrone).
		     * Lit la configuration des ic√¥nes depuis taxonomy.icons.
		     * √âvite les duplications en v√©rifiant l'existence.
		     * Note: La fonction reste nomm√©e "Sync" pour la compatibilit√©, mais utilise fetch (async) en interne.
		     */
		    async function ensureProfileSpriteInjectedSync() {
		        try {
		            if (typeof GeoLeaf.Config === "undefined" || typeof GeoLeaf.Config.getIconsConfig !== "function") {
		                if (Log) Log.warn("[POI] GeoLeaf.Config.getIconsConfig non disponible");
		                return;
		            }

		            const iconsCfg = GeoLeaf.Config.getIconsConfig();
		            // Log seulement la premi√®re fois ou si la config change
		            if (!ensureProfileSpriteInjectedSync._lastConfig || JSON.stringify(iconsCfg) !== JSON.stringify(ensureProfileSpriteInjectedSync._lastConfig)) {
		                if (Log) Log.debug("[POI] IconsConfig r√©cup√©r√©:", iconsCfg);
		                ensureProfileSpriteInjectedSync._lastConfig = iconsCfg;
		            }
		            if (!iconsCfg) {
		                if (Log) Log.warn("[POI] Aucune configuration d'ic√¥nes trouv√©e");
		                return;
		            }

		            const spriteUrl = iconsCfg.spriteUrl;

		            if (!spriteUrl || typeof spriteUrl !== "string") {
		                if (Log) Log.warn("[POI] spriteUrl manquant ou invalide:", spriteUrl);
		                return;
		            }

		            // V√©rifier si le sprite est d√©j√† inject√©
		            const existing = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		            if (existing) {
		                if (Log) Log.debug("[POI] Sprite SVG d√©j√† inject√©");
		                return;
		            }

		            if (Log) Log.info("[POI] Chargement sprite depuis:", spriteUrl);

		            // ‚úÖ NOUVEAU: Utiliser fetch asynchrone pour √©viter l'avertissement de d√©pr√©ciation
		            // et am√©liorer les performances en √©vitant de bloquer le thread principal
		            try {
		                const response = await fetch(spriteUrl);

		                if (response.ok) {
		                    const svgText = await response.text();

		                    // SAFE: Utilisation de DOMParser au lieu de innerHTML pour √©viter l'ex√©cution de scripts
		                    const parser = new DOMParser();
		                    const doc = parser.parseFromString(svgText, "image/svg+xml");

		                    // V√©rifier les erreurs de parsing
		                    const parserError = doc.querySelector("parsererror");
		                    if (parserError) {
		                        if (Log) Log.warn("[POI] Erreur parsing SVG sprite :", parserError.textContent);
		                        return;
		                    }

		                    const svgEl = doc.documentElement;
		                    if (svgEl && svgEl.tagName.toLowerCase() === "svg") {
		                        svgEl.setAttribute("data-geoleaf-sprite", "profile");
		                        svgEl.style.position = "absolute";
		                        svgEl.style.width = "0";
		                        svgEl.style.height = "0";
		                        svgEl.style.overflow = "hidden";
		                        svgEl.setAttribute("aria-hidden", "true");

		                        if (document.body.firstChild) {
		                            document.body.insertBefore(svgEl, document.body.firstChild);
		                        } else {
		                            document.body.appendChild(svgEl);
		                        }

		                        const symbolCount = svgEl.querySelectorAll('symbol').length;
		                        if (Log) Log.info("[POI] Sprite SVG profil inject√© dans le DOM (async).", symbolCount, "symboles charg√©s.");
		                    }
		                } else {
		                    if (Log) Log.warn("[POI] Erreur chargement sprite profil: HTTP", response.status);
		                }
		            } catch (err) {
		                if (Log) Log.warn("[POI] Erreur chargement sprite profil (async):", err);
		            }
		        } catch (err) {
		            if (Log) Log.warn("[POI] Erreur chargement sprite profil :", err);
		        }
		    }

		    /**
		     * Extrait les coordonn√©es d'un POI pour la cr√©ation de marqueur.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {[number, number]|null} [latitude, longitude] ou null si invalides.
		     */
		    function extractMarkerCoordinates(poi) {
		        if (!poi) {
		            if (Log) Log.warn("[POI] extractMarkerCoordinates() : POI invalide.", poi);
		            return null;
		        }

		        const normalizers = getNormalizers();
		        if (!normalizers) {
		            if (Log) Log.error("[POI] extractMarkerCoordinates() : Module Normalizers non charg√©.");
		            return null;
		        }

		        const coords = normalizers.extractCoordinates(poi);
		        if (!coords) {
		            if (Log) Log.warn("[POI] extractMarkerCoordinates() : POI sans coordonn√©es valides.", poi);
		            return null;
		        }

		        return coords;
		    }

		    /**
		     * Construit l'ic√¥ne Leaflet (DivIcon) pour un marqueur POI.
		     * Mode ic√¥ne : utilise le sprite SVG profil avec cercle de fond.
		     * Mode simple : cercle simple sans ic√¥ne.
		     *
		     * @param {object} displayConfig - Configuration d'affichage { useIcon, iconId, colorFill, colorStroke, radius, weight, fillOpacity, opacity }.
		     * @returns {L.DivIcon} Ic√¥ne Leaflet configur√©e.
		     */
		    function buildMarkerIcon(displayConfig) {
		        const baseConfig = getPoiBaseConfig();
		        const radius = displayConfig.radius !== undefined ? displayConfig.radius : baseConfig.radius;
		        const weight = displayConfig.weight !== undefined ? displayConfig.weight : baseConfig.weight;
		        const fillOpacity = displayConfig.fillOpacity;
		        const strokeOpacity = displayConfig.opacity;

		        const iconSizeCircle = Math.max(Math.round((radius * 2) + (weight * 2)), 8);
		        const iconSizeIcon = Math.max(Math.round((radius * 2) + (weight * 2)), 16);

		        // Appliquer fillOpacity √† colorFill si d√©fini
		        let colorFill = displayConfig.colorFill;
		        if (fillOpacity !== null && typeof fillOpacity === 'number') {
		            // Convertir la couleur hex en rgba avec fillOpacity
		            if (colorFill && colorFill.startsWith('#')) {
		                const r = parseInt(colorFill.slice(1, 3), 16);
		                const g = parseInt(colorFill.slice(3, 5), 16);
		                const b = parseInt(colorFill.slice(5, 7), 16);
		                colorFill = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + fillOpacity + ')';
		            }
		        }

		        // Appliquer opacity au stroke (colorStroke) si d√©fini
		        let colorStroke = displayConfig.colorStroke;
		        if (strokeOpacity !== null && typeof strokeOpacity === 'number') {
		            // Convertir la couleur hex en rgba avec opacity
		            if (colorStroke && colorStroke.startsWith('#')) {
		                const r = parseInt(colorStroke.slice(1, 3), 16);
		                const g = parseInt(colorStroke.slice(3, 5), 16);
		                const b = parseInt(colorStroke.slice(5, 7), 16);
		                colorStroke = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + strokeOpacity + ')';
		            }
		        }

		        if (displayConfig.useIcon && displayConfig.iconId) {
		            // Mode ic√¥ne : DivIcon avec sprite m√©tier
		            const iconsConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getIconsConfig === "function")
		                ? GeoLeaf.Config.getIconsConfig()
		                : null;
		            const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || "gl-poi-cat-";

		            const iconIdNormalized = String(displayConfig.iconId)
		                .trim()
		                .toLowerCase()
		                .replace(/\s+/g, "-");

		            const symbolId = iconPrefix + iconIdNormalized;

		            const htmlIcon = [
		                '<div class="gl-poi-marker" style="',
		                "--gl-poi-fill:", colorFill, ";",
		                "--gl-poi-stroke:", colorStroke, ";",
		                "width:", iconSizeIcon, "px;",
		                "height:", iconSizeIcon, "px;",
		                '">',
		                '<svg class="gl-poi-marker__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24" style="overflow: visible;">',
		                '<circle cx="12" cy="12" r="10" fill="', colorFill, '" stroke="', colorStroke, '" stroke-width="', weight, '"/>',
		                '<svg x="2" y="2" width="20" height="20" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" overflow="visible">',
		                '<use href="#', symbolId, '" style="color: #ffffff"/>',
		                '</svg>',
		                "</svg>",
		                "</div>"
		            ].join("");

		            return L.divIcon({
		                html: htmlIcon,
		                className: "gl-poi-divicon",
		                iconSize: [iconSizeIcon, iconSizeIcon],
		                iconAnchor: [iconSizeIcon / 2, iconSizeIcon / 2],
		                popupAnchor: [0, -(iconSizeIcon / 2)]
		            });
		        } else {
		            // Mode point simple (sans ic√¥ne)
		            const htmlCircle = [
		                '<div class="gl-poi-marker" style="',
		                "--gl-poi-fill:", colorFill, ";",
		                "--gl-poi-stroke:", colorStroke, ";",
		                "width:", iconSizeCircle, "px;",
		                "height:", iconSizeCircle, "px;",
		                '">',
		                '<svg class="gl-poi-marker__circle" aria-hidden="true" focusable="false">',
		                '<circle cx="50%" cy="50%" r="', radius, '"',
		                ' fill="', colorFill, '"',
		                ' stroke="', colorStroke, '"',
		                ' stroke-width="', weight, '" />',
		                "</svg>",
		                "</div>"
		            ].join("");

		            return L.divIcon({
		                html: htmlCircle,
		                className: "gl-poi-divicon",
		                iconSize: [iconSizeCircle, iconSizeCircle],
		                iconAnchor: [iconSizeCircle / 2, iconSizeCircle / 2],
		                popupAnchor: [0, -(iconSizeCircle / 2)]
		            });
		        }
		    }

		    /**
		     * Attache les √©v√©nements et comportements √† un marqueur POI (tooltip, popup, side panel).
		     *
		     * @param {L.Marker} marker - Marqueur Leaflet √† configurer.
		     * @param {object} poi - Donn√©es du POI.
		     */
		    function attachMarkerEvents(marker, poi) {
		        // Attacher m√©tadonn√©es POI
		        marker._geoleafPoiData = poi;

		        const shared = getShared();
		        const poiConfig = shared ? shared.state.poiConfig : {};
		        const popupModule = getPopup();

		        // Gestion tooltip
		        if (popupModule && typeof popupModule.manageTooltip === 'function') {
		            popupModule.manageTooltip(marker, poi, poiConfig, resolveCategoryDisplay);
		        }

		        // V√©rifier si les popups sont activ√©s (par d√©faut: true)
		        const showPopup = (poiConfig.showPopup !== false);

		        if (showPopup) {
		            // Mode popup: afficher le popup avec lien "Voir plus"
		            if (popupModule && typeof popupModule.buildQuickPopupContent === 'function') {
		                const popupContent = popupModule.buildQuickPopupContent(poi, resolveCategoryDisplay);
		                if (popupContent) {
		                    if (popupModule.attachPopup) {
		                        popupModule.attachPopup(marker, popupContent);
		                    } else {
		                        marker.bindPopup(popupContent);
		                    }
		                } else {
		                    Log.error('[markers] Popup content vide pour POI:', poi.id);
		                }

		                // Initialiser le flag de popup actif
		                marker._geoleafPopupActive = false;

		                // Bloquer l'ouverture du tooltip pendant que le popup est actif
		                marker.on('tooltipopen', function() {
		                    if (marker._geoleafPopupActive) {
		                        marker.closeTooltip();
		                    }
		                });

		                // Attacher √©v√©nement pour le lien "Voir plus" du popup
		                marker.on('popupopen', function() {
		                    // Marquer le popup comme actif et fermer le tooltip
		                    marker._geoleafPopupActive = true;
		                    marker.closeTooltip();

		                    setTimeout(function() {
		                        const link = document.querySelector('.gl-poi-popup__link[data-poi-id="' + poi.id + '"]');
		                        if (link) {
		                            if (Log) Log.info('[POI] Lien "Voir plus" trouv√© pour POI:', poi.id);

		                            // Retirer les anciens listeners pour √©viter les doublons
		                            const newLink = link.cloneNode(true);
		                            link.parentNode.replaceChild(newLink, link);

		                            newLink.addEventListener('click', function(e) {
		                                e.preventDefault();
		                                e.stopPropagation();

		                                if (Log) Log.info('[POI] Clic sur "Voir plus" pour POI:', poi.id);

		                                // Fermer le popup
		                                if (marker && marker.closePopup) {
		                                    marker.closePopup();
		                                }

		                                // Ouvrir le side panel avec un petit d√©lai
		                                setTimeout(function() {
		                                    if (Log) Log.info('[POI] Appel de showPoiDetails pour:', poi.id);
		                                    if (GeoLeaf.POI && typeof GeoLeaf.POI.showPoiDetails === 'function') {
		                                        GeoLeaf.POI.showPoiDetails(poi);
		                                    } else {
		                                        if (Log) Log.error('[POI] GeoLeaf.POI.showPoiDetails non disponible');
		                                    }
		                                }, 100);
		                            });
		                        } else {
		                            if (Log) Log.warn('[POI] Lien "Voir plus" non trouv√© pour POI:', poi.id);
		                        }
		                    }, 50);
		                });

		                // R√©activer le tooltip quand le popup se ferme
		                marker.on('popupclose', function() {
		                    marker._geoleafPopupActive = false;

		                    // R√©ouvrir le tooltip s'il est permanent (mode "always")
		                    if (marker.getTooltip() && marker.getTooltip().options.permanent) {
		                        setTimeout(function() {
		                            if (marker.openTooltip && !marker._geoleafPopupActive) {
		                                marker.openTooltip();
		                            }
		                        }, 50);
		                    }
		                });
		            }
		        } else {
		            // Mode direct: ouvrir le side panel directement au clic sur le marker (sans popup)
		            marker.on('click', function(e) {
		                e.originalEvent.stopPropagation();

		                if (Log) Log.info('[POI] Clic direct sur marker (sans popup) pour POI:', poi.id);

		                if (GeoLeaf.POI && typeof GeoLeaf.POI.showPoiDetails === 'function') {
		                    GeoLeaf.POI.showPoiDetails(poi);
		                } else {
		                    if (Log) Log.error('[POI] GeoLeaf.POI.showPoiDetails non disponible');
		                }
		            });
		        }
		    }

		    /**
		     * Cr√©e un marqueur Leaflet pour un POI.
		     * Orchestrateur principal : coordonn√©es ‚Üí affichage ‚Üí ic√¥ne ‚Üí √©v√©nements.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {L.Marker|null} Marqueur Leaflet ou null si invalide.
		     */
		    /**
		     * Cr√©e un marqueur Leaflet pour un POI.
		     * Orchestrateur principal : coordonn√©es ‚Üí affichage ‚Üí ic√¥ne ‚Üí √©v√©nements.
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @param {object} [options] - Options de cr√©ation.
		     * @param {boolean} [options.attachEvents=true] - Si false, ne pas attacher les √©v√©nements (popup, tooltip).
		     * @param {string} [options.pane] - Nom du pane Leaflet √† utiliser pour le z-index.
		     * @returns {L.Marker|null} Marqueur Leaflet ou null si invalide.
		     */
		    function createMarker(poi, options = {}) {
		        if (!poi) {
		            if (Log) Log.warn("[POI] createMarker() : POI invalide.", poi);
		            return null;
		        }

		        const { attachEvents = true, pane } = options;

		        // Extraction coordonn√©es
		        const coords = extractMarkerCoordinates(poi);
		        if (!coords) {
		            return null;
		        }

		        const [lat, lon] = coords;

		        // R√©solution de l'affichage (ic√¥ne et couleurs)
		        const displayConfig = resolveCategoryDisplay(poi);

		        // Construction de l'ic√¥ne Leaflet
		        const customIcon = buildMarkerIcon(displayConfig);

		        // Options du marker avec pane si fourni
		        const markerOptions = { icon: customIcon };
		        if (pane) {
		            markerOptions.pane = pane;
		        }

		        // Cr√©ation du marqueur Leaflet avec le pane
		        const marker = L.marker([lat, lon], markerOptions);

		        // Attacher √©v√©nements et comportements (sauf si d√©sactiv√©)
		        if (attachEvents) {
		            attachMarkerEvents(marker, poi);
		        }

		        return marker;
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POIMarkers = {
		        getPoiBaseConfig,
		        resolveCategoryDisplay,
		        ensureProfileSpriteInjectedSync,
		        extractMarkerCoordinates,
		        buildMarkerIcon,
		        attachMarkerEvents,
		        createMarker
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return markers;
	}

	requireMarkers();

	var abstractRenderer = {};

	/**
	 * @fileoverview Abstract Renderer Base Class
	 * @description Base class providing common functionality for all renderers
	 * @version 1.0.0
	 * @phase Phase 5 - Code Optimization
	 *
	 * @author GeoLeaf Team
	 * @since 3.1.0
	 *
	 * @benefits
	 * - Eliminates ~20% code duplication across renderers
	 * - Unified dependency resolution pattern
	 * - Consistent error handling and logging
	 * - Easier testing and maintenance
	 */

	var hasRequiredAbstractRenderer;

	function requireAbstractRenderer () {
		if (hasRequiredAbstractRenderer) return abstractRenderer;
		hasRequiredAbstractRenderer = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    if (!GeoLeaf._Renderers) GeoLeaf._Renderers = {};

		    /**
		     * @class AbstractRenderer
		     * @description Base class for all renderer implementations
		     *
		     * Common Patterns Extracted:
		     * - Dependency resolution (Log, Security, Config, Utils)
		     * - DOM element creation helpers
		     * - Event handler registration/cleanup
		     * - State management
		     * - Error handling and logging
		     *
		     * @example
		     * class MyCustomRenderer extends AbstractRenderer {
		     *     constructor(options) {
		     *         super(options);
		     *         this.init();
		     *     }
		     *
		     *     render(data) {
		     *         this.log('info', 'Rendering data', data);
		     *         const element = this.createElement('div', 'my-class');
		     *         // ... custom rendering logic
		     *         return element;
		     *     }
		     * }
		     */
		    class AbstractRenderer {
		        /**
		         * @constructor
		         * @param {Object} [options={}] - Renderer configuration options
		         * @param {string} [options.name='Renderer'] - Renderer name for logging
		         * @param {Object} [options.config={}] - Custom configuration
		         * @param {boolean} [options.debug=false] - Enable debug logging
		         */
		        constructor(options = {}) {
		            /**
		             * @private
		             * @type {string}
		             */
		            this._name = options.name || 'Renderer';

		            /**
		             * @private
		             * @type {Object}
		             */
		            this._config = options.config || {};

		            /**
		             * @private
		             * @type {boolean}
		             */
		            this._debug = options.debug || false;

		            /**
		             * @private
		             * @type {Array<Function>}
		             */
		            this._eventListeners = [];

		            /**
		             * @private
		             * @type {boolean}
		             */
		            this._initialized = false;

		            /**
		             * @private
		             * @type {WeakMap<HTMLElement, Object>}
		             */
		            this._stateMap = new WeakMap();
		        }

		        // ========================================
		        //   DEPENDENCY RESOLUTION
		        // ========================================

		        /**
		         * Get Log utility with fallback
		         * @protected
		         * @returns {Object} Log object
		         */
		        getLog() {
		            return GeoLeaf.Log || console;
		        }

		        /**
		         * Get Security utilities with fallback
		         * @protected
		         * @returns {Object} Security object with escapeHtml function
		         */
		        getSecurity() {
		            if (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function') {
		                return GeoLeaf.Security;
		            }
		            // Fallback security utilities
		            return {
		                escapeHtml: (str) => {
		                    if (str == null) return '';
		                    const div = document.createElement('div');
		                    div.textContent = String(str);
		                    return div.innerHTML;
		                },
		                setSafeHTML: (element, html) => {
		                    if (!element) return;
		                    if (GeoLeaf.DOMSecurity && typeof GeoLeaf.DOMSecurity.setSafeHTML === 'function') {
		                        GeoLeaf.DOMSecurity.setSafeHTML(element, html);
		                    } else {
		                        element.textContent = html; // Safe fallback
		                    }
		                }
		            };
		        }

		        /**
		         * Get Utils with field resolution
		         * @protected
		         * @returns {Object} Utils object with resolveField function
		         */
		        getUtils() {
		            if (GeoLeaf.Utils && typeof GeoLeaf.Utils.resolveField === 'function') {
		                return GeoLeaf.Utils;
		            }
		            // Fallback resolveField implementation
		            return {
		                resolveField: (obj, ...paths) => {
		                    if (!obj) return null;
		                    for (const path of paths) {
		                        if (!path) continue;
		                        const parts = String(path).split('.');
		                        let current = obj;
		                        let found = true;
		                        for (const part of parts) {
		                            if (current && typeof current === 'object' && part in current) {
		                                current = current[part];
		                            } else {
		                                found = false;
		                                break;
		                            }
		                        }
		                        if (found && current !== undefined && current !== null) {
		                            return current;
		                        }
		                    }
		                    return null;
		                }
		            };
		        }

		        /**
		         * Get active profile configuration
		         * @protected
		         * @returns {Object|null} Active profile or null
		         */
		        getActiveProfile() {
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === 'function') {
		                return GeoLeaf.Config.getActiveProfile() || null;
		            }
		            return null;
		        }

		        // ========================================
		        //   LOGGING UTILITIES
		        // ========================================

		        /**
		         * Log message with level
		         * @protected
		         * @param {string} level - Log level (debug, info, warn, error)
		         * @param {string} message - Log message
		         * @param {...*} args - Additional arguments
		         */
		        log(level, message, ...args) {
		            if (level === 'debug' && !this._debug) return;

		            const log = this.getLog();
		            const prefix = `[${this._name}]`;

		            switch (level) {
		                case 'debug':
		                case 'info':
		                    log.info(prefix, message, ...args);
		                    break;
		                case 'warn':
		                    log.warn(prefix, message, ...args);
		                    break;
		                case 'error':
		                    log.error(prefix, message, ...args);
		                    break;
		                default:
		                    log.info(prefix, message, ...args);
		            }
		        }

		        /**
		         * Log debug message (if debug enabled)
		         * @protected
		         * @param {string} message - Debug message
		         * @param {...*} args - Additional arguments
		         */
		        debug(message, ...args) {
		            this.log('debug', message, ...args);
		        }

		        /**
		         * Log info message
		         * @protected
		         * @param {string} message - Info message
		         * @param {...*} args - Additional arguments
		         */
		        info(message, ...args) {
		            this.log('info', message, ...args);
		        }

		        /**
		         * Log warning message
		         * @protected
		         * @param {string} message - Warning message
		         * @param {...*} args - Additional arguments
		         */
		        warn(message, ...args) {
		            this.log('warn', message, ...args);
		        }

		        /**
		         * Log error message
		         * @protected
		         * @param {string} message - Error message
		         * @param {...*} args - Additional arguments
		         */
		        error(message, ...args) {
		            this.log('error', message, ...args);
		        }

		        // ========================================
		        //   DOM BUILDERS
		        // ========================================

		        /**
		         * Create DOM element with class and attributes
		         * @protected
		         * @param {string} tagName - HTML tag name
		         * @param {string|Array<string>} [className] - CSS class name(s)
		         * @param {Object} [attributes={}] - HTML attributes
		         * @returns {HTMLElement} Created element
		         *
		         * @example
		         * const div = this.createElement('div', 'my-class', { id: 'my-id', 'data-value': '123' });
		         * const button = this.createElement('button', ['btn', 'btn-primary'], { type: 'button' });
		         */
		        createElement(tagName, className, attributes = {}) {
		            const element = document.createElement(tagName);

		            if (className) {
		                if (Array.isArray(className)) {
		                    element.classList.add(...className);
		                } else {
		                    element.className = className;
		                }
		            }

		            Object.keys(attributes).forEach(key => {
		                element.setAttribute(key, attributes[key]);
		            });

		            return element;
		        }

		        /**
		         * Create text node with safe content
		         * @protected
		         * @param {string} text - Text content
		         * @returns {Text} Text node
		         */
		        createTextNode(text) {
		            return document.createTextNode(text || '');
		        }

		        /**
		         * Create element with safe text content
		         * @protected
		         * @param {string} tagName - HTML tag name
		         * @param {string} text - Text content
		         * @param {string} [className] - CSS class name
		         * @returns {HTMLElement} Element with text
		         */
		        createTextElement(tagName, text, className) {
		            const element = this.createElement(tagName, className);
		            element.textContent = text || '';
		            return element;
		        }

		        /**
		         * Create element with safe HTML content
		         * @protected
		         * @param {string} tagName - HTML tag name
		         * @param {string} html - HTML content (will be sanitized)
		         * @param {string} [className] - CSS class name
		         * @returns {HTMLElement} Element with HTML
		         */
		        createHTMLElement(tagName, html, className) {
		            const element = this.createElement(tagName, className);
		            const security = this.getSecurity();
		            security.setSafeHTML(element, html);
		            return element;
		        }

		        /**
		         * Append multiple children to parent element
		         * @protected
		         * @param {HTMLElement} parent - Parent element
		         * @param {...HTMLElement} children - Child elements to append
		         * @returns {HTMLElement} Parent element (for chaining)
		         */
		        appendChildren(parent, ...children) {
		            children.forEach(child => {
		                if (child) parent.appendChild(child);
		            });
		            return parent;
		        }

		        // ========================================
		        //   EVENT HANDLING
		        // ========================================

		        /**
		         * Register event listener with automatic cleanup
		         * @protected
		         * @param {HTMLElement} element - Target element
		         * @param {string} event - Event name
		         * @param {Function} handler - Event handler
		         * @param {Object} [options] - Event listener options
		         * @returns {Function} Cleanup function
		         */
		        addEventListener(element, event, handler, options) {
		            if (!element || !event || !handler) {
		                this.warn('addEventListener: invalid parameters');
		                return () => {};
		            }

		            const boundHandler = handler.bind(this);
		            element.addEventListener(event, boundHandler, options);

		            // Store for cleanup
		            const cleanup = () => {
		                element.removeEventListener(event, boundHandler, options);
		            };
		            this._eventListeners.push(cleanup);

		            return cleanup;
		        }

		        /**
		         * Remove all registered event listeners
		         * @protected
		         */
		        removeAllEventListeners() {
		            this._eventListeners.forEach(cleanup => cleanup());
		            this._eventListeners = [];
		        }

		        // ========================================
		        //   STATE MANAGEMENT
		        // ========================================

		        /**
		         * Set element state
		         * @protected
		         * @param {HTMLElement} element - Element to store state for
		         * @param {Object} state - State data
		         */
		        setState(element, state) {
		            if (element) {
		                this._stateMap.set(element, { ...state });
		            }
		        }

		        /**
		         * Get element state
		         * @protected
		         * @param {HTMLElement} element - Element to get state from
		         * @returns {Object|null} Element state or null
		         */
		        getState(element) {
		            return element ? this._stateMap.get(element) || null : null;
		        }

		        /**
		         * Update element state (merge with existing)
		         * @protected
		         * @param {HTMLElement} element - Element to update state for
		         * @param {Object} updates - State updates to merge
		         */
		        updateState(element, updates) {
		            if (element) {
		                const currentState = this.getState(element) || {};
		                this.setState(element, { ...currentState, ...updates });
		            }
		        }

		        /**
		         * Delete element state
		         * @protected
		         * @param {HTMLElement} element - Element to delete state for
		         */
		        deleteState(element) {
		            if (element) {
		                this._stateMap.delete(element);
		            }
		        }

		        // ========================================
		        //   LIFECYCLE METHODS
		        // ========================================

		        /**
		         * Initialize renderer (called in constructor or manually)
		         * Override in subclasses for custom initialization
		         * @protected
		         */
		        init() {
		            if (this._initialized) {
		                this.warn('Renderer already initialized');
		                return;
		            }

		            this.debug('Initializing renderer');
		            this._initialized = true;
		        }

		        /**
		         * Check if renderer is initialized
		         * @public
		         * @returns {boolean} true if initialized
		         */
		        isInitialized() {
		            return this._initialized;
		        }

		        /**
		         * Destroy renderer and cleanup resources
		         * @public
		         */
		        destroy() {
		            this.debug('Destroying renderer');
		            this.removeAllEventListeners();
		            this._stateMap = new WeakMap();
		            this._initialized = false;
		        }

		        // ========================================
		        //   ABSTRACT METHODS (to be overridden)
		        // ========================================

		        /**
		         * Render content (must be implemented by subclasses)
		         * @abstract
		         * @param {*} data - Data to render
		         * @param {Object} [options] - Render options
		         * @returns {HTMLElement|string|null} Rendered content
		         * @throws {Error} If not implemented
		         */
		        render(data, options) {
		            throw new Error(`${this._name}.render() must be implemented by subclass`);
		        }
		    }

		    // Export to GeoLeaf namespace
		    GeoLeaf._Renderers.AbstractRenderer = AbstractRenderer;

		    if (GeoLeaf.Log) {
		        GeoLeaf.Log.info('[GeoLeaf._Renderers.AbstractRenderer] Base class loaded');
		    }

		})(window);
		return abstractRenderer;
	}

	requireAbstractRenderer();

	var fieldRenderers = {};

	/**
	 * POI Renderers - Field Renderers Module (Migrated to AbstractRenderer)
	 * Rendu des champs simples: texte, badges, liens, tags
	 *
	 * @module poi/renderers/field-renderers
	 * @requires renderers/abstract-renderer
	 * @version 2.0.0 - Migrated to AbstractRenderer base class
	 */

	var hasRequiredFieldRenderers;

	function requireFieldRenderers () {
		if (hasRequiredFieldRenderers) return fieldRenderers;
		hasRequiredFieldRenderers = 1;
		((global) => {

		    const GeoLeaf = global.GeoLeaf || {};

		    // Ensure AbstractRenderer is loaded
		    if (!GeoLeaf._Renderers || !GeoLeaf._Renderers.AbstractRenderer) {
		        if (GeoLeaf.Log) {
		            GeoLeaf.Log.error('[FieldRenderers] AbstractRenderer not loaded! Load abstract-renderer.js first.');
		        }
		        return;
		    }

		    const AbstractRenderer = GeoLeaf._Renderers.AbstractRenderer;

		    /**
		     * @class FieldRenderers
		     * @extends AbstractRenderer
		     * @description Renders simple POI fields: text, badges, links, tags
		     */
		    class FieldRenderers extends AbstractRenderer {
		        constructor(options = {}) {
		            super({
		                name: 'FieldRenderers',
		                debug: options.debug || false,
		                config: options.config || {}
		            });
		            this.init();
		        }

		        /**
		         * Render method (required by AbstractRenderer)
		         * Delegates to specific render methods
		         * @param {Object} data - Render data {section, poi, value, type}
		         * @returns {HTMLElement|null} Rendered element
		         */
		        render(data) {
		            const { section, poi, value, type } = data;

		            switch (type) {
		                case 'text':
		                    return this.renderText(section, poi, value);
		                case 'badge':
		                    return this.renderBadge(section, value, poi);
		                case 'link':
		                    return this.renderLink(section, value);
		                case 'tags':
		                    return this.renderTags(section, value);
		                default:
		                    this.warn('Unknown render type:', type);
		                    return null;
		            }
		        }

		        /**
		         * Rend un champ texte (title, description, etc.)
		         * @param {Object} section - Section config
		         * @param {Object} poi - POI data
		         * @param {string} value - Text value
		         * @returns {HTMLElement|null}
		         */
		        async renderText(section, poi, value) {
		            this.getSecurity();

		            // Cas sp√©cial pour le titre avec ic√¥ne
		            if (section.style === 'title' || section.variant === 'title') {
		                return await this._renderTitleWithIcon(poi, value);
		            }

		            // Texte normal ou multiline
		            if (!value) {
		                this.warn('renderText: no value provided');
		                return null;
		            }

		            const element = this.createElement(
		                section.variant === 'multiline' ? 'div' : 'p',
		                'gl-poi-sidepanel__desc'
		            );

		            if (section.variant === 'multiline') {
		                element.style.whiteSpace = 'pre-wrap';
		                element.style.lineHeight = '1.6';
		            }

		            element.textContent = value;
		            this.info('renderText: element created, variant:', section.variant || 'normal');

		            return element;
		        }

		        /**
		         * Rend un titre avec ic√¥ne SVG
		         * @private
		         * @param {Object} poi - POI data
		         * @param {string} value - Title text
		         * @returns {HTMLElement}
		         */
		        async _renderTitleWithIcon(poi, value) {
		            const titleH2 = this.createElement('h2', 'gl-poi-sidepanel__title');

		            // Ajouter l'ic√¥ne SVG au titre
		            const markers = this._getMarkers();
		            if (markers && markers.resolveCategoryDisplay && markers.ensureProfileSpriteInjectedSync) {
		                const displayInfo = markers.resolveCategoryDisplay(poi);
		                this.debug('_renderTitleWithIcon: displayInfo =', displayInfo);

		                if (displayInfo.iconId) {
		                    await markers.ensureProfileSpriteInjectedSync();

		                    const svgIcon = this._createCategoryIcon(displayInfo);
		                    if (svgIcon) {
		                        this.debug('_renderTitleWithIcon: SVG icon created successfully');
		                        titleH2.appendChild(svgIcon);
		                    } else {
		                        this.warn('_renderTitleWithIcon: SVG icon creation failed');
		                    }
		                } else {
		                    this.debug('_renderTitleWithIcon: No iconId in displayInfo');
		                }
		            } else {
		                this.warn('_renderTitleWithIcon: Markers or required methods not available');
		            }

		            // Ajouter le texte du titre
		            const titleSpan = this.createTextElement('span',
		                value || poi.title || poi.label || poi.name || 'POI',
		                'gl-poi-sidepanel__title-text'
		            );
		            titleH2.appendChild(titleSpan);

		            this.info('renderText: title element created with icon');
		            return titleH2;
		        }

		        /**
		         * Cr√©e une ic√¥ne SVG de cat√©gorie
		         * @private
		         * @param {Object} displayInfo - Display information {iconId, colorFill, colorStroke}
		         * @returns {SVGElement|null}
		         */
		        _createCategoryIcon(displayInfo) {
		            // R√©cup√©rer la config d'ic√¥nes depuis GeoLeaf.Config
		            const iconsConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getIconsConfig === 'function')
		                ? GeoLeaf.Config.getIconsConfig()
		                : null;

		            const iconPrefix = (iconsConfig && iconsConfig.symbolPrefix) || "gl-poi-cat-";
		            const iconIdNormalized = String(displayInfo.iconId).trim().toLowerCase().replace(/\s+/g, '-');
		            const symbolId = iconPrefix + iconIdNormalized;

		            this.debug('_createCategoryIcon: symbolId =', symbolId, ', colors =', displayInfo.colorFill, displayInfo.colorStroke);
		            this.debug('_createCategoryIcon: iconPrefix from config =', iconPrefix);

		            // V√©rifier si le sprite existe dans le DOM
		            const sprite = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		            if (!sprite) {
		                this.warn('_createCategoryIcon: Sprite SVG non trouv√© dans le DOM! Le sprite doit √™tre charg√© avant.');
		            } else {
		                this.debug('_createCategoryIcon: Sprite trouv√©, nombre de symboles:', sprite.querySelectorAll('symbol').length);
		            }

		            // V√©rifier si le symbole existe dans le sprite
		            const spriteSymbol = sprite ? sprite.querySelector(`#${symbolId}`) : null;
		            if (!spriteSymbol) {
		                this.warn('_createCategoryIcon: Symbole non trouv√© dans le sprite:', symbolId);
		                if (sprite) {
		                    // Lister les symboles disponibles pour debug
		                    const availableSymbols = Array.from(sprite.querySelectorAll('symbol')).map(s => s.id).slice(0, 5);
		                    this.debug('_createCategoryIcon: Premiers symboles disponibles:', availableSymbols);
		                }
		            }

		            const svgIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
		            svgIcon.setAttribute('width', '32');
		            svgIcon.setAttribute('height', '32');
		            svgIcon.setAttribute('viewBox', '0 0 24 24');
		            svgIcon.setAttribute('class', 'gl-poi-sidepanel__icon');
		            svgIcon.style.marginRight = '10px';
		            svgIcon.style.flexShrink = '0';

		            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		            circle.setAttribute('cx', '12');
		            circle.setAttribute('cy', '12');
		            circle.setAttribute('r', '10');
		            circle.setAttribute('fill', displayInfo.colorFill || '#3388ff');
		            circle.setAttribute('stroke', displayInfo.colorStroke || '#fff');
		            circle.setAttribute('stroke-width', '1.5');

		            svgIcon.appendChild(circle);

		            // Ajouter le symbole uniquement s'il existe
		            if (spriteSymbol) {
		                // SVG imbriqu√© pour le symbole (comme dans le popup)
		                const innerSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
		                innerSvg.setAttribute('x', '4');
		                innerSvg.setAttribute('y', '4');
		                innerSvg.setAttribute('width', '16');
		                innerSvg.setAttribute('height', '16');
		                innerSvg.setAttribute('viewBox', '0 0 32 32');

		                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
		                use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + symbolId);
		                use.setAttribute('href', '#' + symbolId);
		                use.style.color = '#ffffff';

		                innerSvg.appendChild(use);
		                svgIcon.appendChild(innerSvg);
		            }

		            this.debug('_createCategoryIcon: SVG structure created');
		            return svgIcon;
		        }

		        /**
		         * Rend un badge (cat√©gorie, sous-cat√©gorie)
		         * @param {Object} section - Section config
		         * @param {string} value - Badge text
		         * @param {Object} poi - POI data
		         * @returns {HTMLElement|null}
		         */
		        renderBadge(section, value, poi) {
		            if (!value) return null;

		            const container = this.createElement('div', 'gl-poi-badge-container');
		            const badge = this.createTextElement('span', value, 'gl-poi-badge');

		            // R√©cup√©rer les couleurs depuis la taxonomie
		            const markers = this._getMarkers();
		            if (markers && markers.resolveCategoryDisplay) {
		                const displayInfo = markers.resolveCategoryDisplay(poi);
		                if (displayInfo.colorFill) {
		                    badge.style.background = displayInfo.colorFill;
		                    badge.style.color = '#fff';
		                }
		            }

		            container.appendChild(badge);
		            return container;
		        }

		        /**
		         * Rend un lien (website, etc.)
		         * @param {Object} section - Section config
		         * @param {string} url - URL
		         * @returns {HTMLElement|null}
		         */
		        renderLink(section, url) {
		            if (!url) return null;

		            const linkP = this.createElement('p', 'gl-poi-sidepanel__link');
		            const anchor = this.createElement('a', null, {
		                href: url,
		                target: '_blank',
		                rel: 'noopener noreferrer'
		            });

		            anchor.textContent = section.linkText || url;
		            linkP.appendChild(anchor);

		            return linkP;
		        }

		        /**
		         * Rend une liste de tags
		         * @param {Object} section - Section config
		         * @param {Array<string>} tags - Tags array
		         * @returns {HTMLElement|null}
		         */
		        renderTags(section, tags) {
		            if (!tags || !Array.isArray(tags) || tags.length === 0) return null;

		            const tagsDiv = this.createElement('div', 'gl-poi-sidepanel__tags');

		            tags.forEach(tag => {
		                if (tag) {
		                    const tagSpan = this.createTextElement('span', tag, 'gl-poi-tag');
		                    tagsDiv.appendChild(tagSpan);
		                }
		            });

		            return tagsDiv;
		        }

		        /**
		         * Get POI Markers module
		         * @private
		         * @returns {Object|null}
		         */
		        _getMarkers() {
		            return GeoLeaf._POIMarkers || null;
		        }
		    }

		    // Export to namespace
		    if (!GeoLeaf.POI) GeoLeaf.POI = {};
		    if (!GeoLeaf.POI.Renderers) GeoLeaf.POI.Renderers = {};

		    GeoLeaf.POI.Renderers.FieldRenderers = FieldRenderers;

		    // Lazy singleton instance for backward compatibility
		    let instance = null;
		    const getInstance = () => {
		        if (!instance) {
		            instance = new FieldRenderers();
		        }
		        return instance;
		    };

		    GeoLeaf.POI.Renderers.renderText = (section, poi, value) =>
		        getInstance().renderText(section, poi, value);

		    GeoLeaf.POI.Renderers.renderBadge = (section, value, poi) =>
		        getInstance().renderBadge(section, value, poi);

		    GeoLeaf.POI.Renderers.renderLink = (section, url) =>
		        getInstance().renderLink(section, url);

		    GeoLeaf.POI.Renderers.renderTags = (section, tags) =>
		        getInstance().renderTags(section, tags);

		    if (GeoLeaf.Log) {
		        GeoLeaf.Log.info('[POI.Renderers.FieldRenderers] Loaded (v2.0 - AbstractRenderer)');
		    }

		})(window);
		return fieldRenderers;
	}

	requireFieldRenderers();

	var mediaRenderers = {};

	/**
	 * POI Renderers - Media Renderers Module (Migrated to AbstractRenderer)
	 * Rendu des m√©dias: images, galeries, lightbox
	 *
	 * @module poi/renderers/media-renderers
	 * @requires renderers/abstract-renderer
	 * @version 2.0.0 - Migrated to AbstractRenderer base class
	 */

	var hasRequiredMediaRenderers;

	function requireMediaRenderers () {
		if (hasRequiredMediaRenderers) return mediaRenderers;
		hasRequiredMediaRenderers = 1;
		((global) => {

		    const GeoLeaf = global.GeoLeaf || {};

		    // Ensure AbstractRenderer is loaded
		    if (!GeoLeaf._Renderers || !GeoLeaf._Renderers.AbstractRenderer) {
		        console.error('[MediaRenderers] AbstractRenderer not loaded! Load abstract-renderer.js first.');
		        return;
		    }

		    const AbstractRenderer = GeoLeaf._Renderers.AbstractRenderer;

		    /**
		     * @class MediaRenderers
		     * @extends AbstractRenderer
		     * @description Renders media elements: images, galleries, lightbox
		     */
		    class MediaRenderers extends AbstractRenderer {
		        constructor(options = {}) {
		            super({
		                name: 'MediaRenderers',
		                debug: options.debug || false,
		                config: options.config || {}
		            });
		            this.init();
		        }

		        /**
		         * Render method (required by AbstractRenderer)
		         * @param {Object} data - Render data {section, value, type}
		         * @returns {HTMLElement|null} Rendered element
		         */
		        render(data) {
		            const { section, value, type } = data;

		            switch (type) {
		                case 'image':
		                    return this.renderImage(section, value);
		                case 'gallery':
		                    return this.renderGallery(section, value);
		                default:
		                    this.warn('Unknown media render type:', type);
		                    return null;
		            }
		        }

		        /**
		         * Rend une image (hero ou normale)
		         * @param {Object} section - Section config
		         * @param {string} imageUrl - Image URL
		         * @returns {HTMLElement|null}
		         */
		        renderImage(section, imageUrl) {
		            if (!imageUrl) return null;

		            const className = section.variant === 'hero'
		                ? 'gl-poi-sidepanel__photo gl-poi-sidepanel__photo--hero'
		                : 'gl-poi-sidepanel__photo';

		            const photoDiv = this.createElement('div', className);
		            const img = this.createElement('img', null, {
		                src: imageUrl,
		                alt: section.label || 'Photo',
		                loading: 'lazy'
		            });

		            photoDiv.appendChild(img);
		            return photoDiv;
		        }

		        /**
		         * Rend une galerie d'images avec miniatures
		         * @param {Object} section - Section config
		         * @param {Array<string>} gallery - Array of image URLs
		         * @returns {HTMLElement|null}
		         */
		        renderGallery(section, gallery) {
		            if (!gallery || !Array.isArray(gallery) || gallery.length === 0) {
		                this.warn('renderGallery: invalid gallery data', gallery);
		                return null;
		            }

		            this.info('renderGallery: rendering', gallery.length, 'images');

		            const galleryDiv = this.createElement('div', 'gl-poi-gallery');

		            // Image principale
		            const mainDiv = this._createMainImage(gallery[0]);
		            galleryDiv.appendChild(mainDiv);

		            // Miniatures si plusieurs images
		            if (gallery.length > 1) {
		                const thumbsDiv = this._createThumbnails(gallery, mainDiv);
		                galleryDiv.appendChild(thumbsDiv);
		            }

		            return galleryDiv;
		        }

		        /**
		         * Cr√©e l'image principale de la galerie
		         * @private
		         * @param {string} imageUrl - Image URL
		         * @returns {HTMLElement}
		         */
		        _createMainImage(imageUrl) {
		            const mainDiv = this.createElement('div', 'gl-poi-gallery__main', {
		                'data-gallery-index': '0'
		            });

		            const mainImg = this.createElement('img', null, {
		                src: imageUrl,
		                alt: 'Image 1',
		                loading: 'lazy'
		            });

		            mainDiv.appendChild(mainImg);
		            return mainDiv;
		        }

		        /**
		         * Cr√©e les miniatures de la galerie
		         * @private
		         * @param {Array<string>} gallery - Array of image URLs
		         * @param {HTMLElement} mainDiv - Main image container
		         * @returns {HTMLElement}
		         */
		        _createThumbnails(gallery, mainDiv) {
		            const thumbsDiv = this.createElement('div', 'gl-poi-gallery__thumbnails');
		            const mainImg = mainDiv.querySelector('img');

		            gallery.forEach((imgUrl, index) => {
		                const thumbDiv = this._createThumbnail(imgUrl, index, mainImg, mainDiv, thumbsDiv);
		                thumbsDiv.appendChild(thumbDiv);
		            });

		            return thumbsDiv;
		        }

		        /**
		         * Cr√©e une miniature individuelle
		         * @private
		         * @param {string} imgUrl - Image URL
		         * @param {number} index - Image index
		         * @param {HTMLElement} mainImg - Main image element
		         * @param {HTMLElement} mainDiv - Main image container
		         * @param {HTMLElement} thumbsDiv - Thumbnails container
		         * @returns {HTMLElement}
		         */
		        _createThumbnail(imgUrl, index, mainImg, mainDiv, thumbsDiv) {
		            const thumbDiv = this.createElement('div',
		                index === 0 ? 'gl-poi-gallery__thumb active' : 'gl-poi-gallery__thumb',
		                { 'data-index': index.toString() }
		            );

		            const imgThumb = this.createElement('img', null, {
		                src: imgUrl,
		                alt: `Image ${index + 1}`,
		                loading: 'lazy'
		            });

		            thumbDiv.appendChild(imgThumb);

		            // Event listener pour changer l'image principale
		            this.addEventListener(thumbDiv, 'click', (e) => {
		                e.preventDefault();
		                e.stopPropagation();

		                // Retirer la classe active de toutes les miniatures
		                const allThumbs = thumbsDiv.querySelectorAll('.gl-poi-gallery__thumb');
		                allThumbs.forEach(t => t.classList.remove('active'));

		                // Ajouter la classe active √† la miniature cliqu√©e
		                thumbDiv.classList.add('active');

		                // Changer l'image principale
		                mainImg.src = imgUrl;
		                mainImg.alt = `Image ${index + 1}`;
		                mainDiv.setAttribute('data-gallery-index', index.toString());

		                this.info('Gallery: Switched to image', index + 1);
		            }, true);

		            return thumbDiv;
		        }

		        /**
		         * Cleanup when gallery is destroyed
		         * @override
		         */
		        destroy() {
		            this.debug('Destroying MediaRenderers');
		            super.destroy();
		        }
		    }

		    // Export to namespace
		    if (!GeoLeaf.POI) GeoLeaf.POI = {};
		    if (!GeoLeaf.POI.Renderers) GeoLeaf.POI.Renderers = {};

		    GeoLeaf.POI.Renderers.MediaRenderers = MediaRenderers;

		    // Lazy singleton instance for backward compatibility
		    let instance = null;
		    const getInstance = () => {
		        if (!instance) {
		            instance = new MediaRenderers();
		        }
		        return instance;
		    };

		    GeoLeaf.POI.Renderers.renderImage = (section, imageUrl) =>
		        getInstance().renderImage(section, imageUrl);

		    GeoLeaf.POI.Renderers.renderGallery = (section, gallery) =>
		        getInstance().renderGallery(section, gallery);

		    if (GeoLeaf.Log) {
		        GeoLeaf.Log.info('[POI.Renderers.MediaRenderers] Loaded (v2.0 - AbstractRenderer)');
		    }

		})(window);
		return mediaRenderers;
	}

	requireMediaRenderers();

	var lightboxManager = {};

	/**
	 * GeoLeaf POI Module - Lightbox Manager
	 * Gestion de l'affichage lightbox pour les images
	 * Phase 6.2 - Extraction depuis core.js
	 */

	var hasRequiredLightboxManager;

	function requireLightboxManager () {
		if (hasRequiredLightboxManager) return lightboxManager;
		hasRequiredLightboxManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Gestionnaire de lightbox pour affichage d'images en plein √©cran
		     */
		    class LightboxManager {
		        constructor() {
		            this.currentLightbox = null;
		            this.closeHandler = null;
		        }

		        /**
		         * Ouvre une lightbox pour afficher une image en plein √©cran
		         * @param {string} imageSrc - URL de l'image √† afficher
		         */
		        open(imageSrc) {
		            // Fermer lightbox pr√©c√©dente si existe
		            this.close();

		            const lightbox = document.createElement('div');
		            lightbox.className = 'gl-poi-lightbox';
		            lightbox.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.95);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;

		            const img = document.createElement('img');
		            img.src = imageSrc;
		            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;

		            lightbox.appendChild(img);
		            document.body.appendChild(lightbox);

		            // Stocker r√©f√©rence
		            this.currentLightbox = lightbox;

		            // Fermer en cliquant n'importe o√π
		            lightbox.addEventListener('click', () => {
		                this.close();
		            });

		            // Fermer avec Escape
		            this.closeHandler = (e) => {
		                if (e.key === 'Escape') {
		                    this.close();
		                }
		            };
		            document.addEventListener('keydown', this.closeHandler);
		        }

		        /**
		         * Ferme la lightbox active
		         */
		        close() {
		            if (this.currentLightbox && document.body.contains(this.currentLightbox)) {
		                document.body.removeChild(this.currentLightbox);
		            }

		            if (this.closeHandler) {
		                document.removeEventListener('keydown', this.closeHandler);
		                this.closeHandler = null;
		            }

		            this.currentLightbox = null;
		        }

		        /**
		         * V√©rifie si une lightbox est actuellement ouverte
		         * @returns {boolean}
		         */
		        isOpen() {
		            return this.currentLightbox !== null && document.body.contains(this.currentLightbox);
		        }
		    }

		    // Export global
		    GeoLeaf.LightboxManager = LightboxManager;

		    // Instance singleton pour usage simple
		    GeoLeaf._lightboxManager = new LightboxManager();

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return lightboxManager;
	}

	requireLightboxManager();

	var uiBehaviors = {};

	/**
	 * GeoLeaf POI Module - UI Behaviors
	 * Comportements interactifs pour le side panel (accord√©ons, galeries)
	 * Phase 6.2 - Extraction depuis core.js
	 */

	var hasRequiredUiBehaviors;

	function requireUiBehaviors () {
		if (hasRequiredUiBehaviors) return uiBehaviors;
		hasRequiredUiBehaviors = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Comportements UI pour le side panel POI
		     */
		    const UIBehaviors = {
		        /**
		         * Attache le comportement d'accord√©on exclusif (un seul ouvert √† la fois)
		         * @param {HTMLElement} container - Conteneur parent des accord√©ons
		         */
		        attachSingleAccordionBehavior(container) {
		            const accordions = container.querySelectorAll('details.gl-accordion');
		            if (accordions.length === 0) return;

		            accordions.forEach(accordion => {
		                accordion.addEventListener('toggle', (event) => {
		                    // Si cet accord√©on vient d'√™tre ouvert
		                    if (event.target.open) {
		                        // Fermer tous les autres accord√©ons
		                        accordions.forEach(otherAccordion => {
		                            if (otherAccordion !== event.target && otherAccordion.open) {
		                                otherAccordion.removeAttribute('open');
		                            }
		                        });
		                    }
		                });
		            });

		            if (Log) Log.info('[POI] Comportement singleAccordion activ√©:', accordions.length, 'accord√©ons');
		        },

		        /**
		         * Attache les √©v√©nements de navigation pour une galerie d'images
		         * @param {HTMLElement} sidePanelElement - √âl√©ment du side panel
		         * @param {LightboxManager} lightboxManager - Instance du gestionnaire de lightbox
		         */
		        attachGalleryEvents(sidePanelElement, lightboxManager) {
		            if (!sidePanelElement) return;

		            // Navigation par miniatures
		            const thumbs = sidePanelElement.querySelectorAll('.gl-poi-gallery__thumb');
		            const mainImg = sidePanelElement.querySelector('.gl-poi-gallery__main img');

		            if (!mainImg || thumbs.length === 0) return;

		            thumbs.forEach((thumb) => {
		                thumb.addEventListener('click', () => {
		                    const index = parseInt(thumb.getAttribute('data-index'), 10);
		                    const imgSrc = thumb.querySelector('img').src;

		                    // Mettre √† jour l'image principale
		                    mainImg.src = imgSrc;
		                    mainImg.alt = `Image ${index + 1}`;

		                    // Mettre √† jour l'√©tat actif des miniatures
		                    thumbs.forEach(t => t.classList.remove('active'));
		                    thumb.classList.add('active');
		                });
		            });

		            // Clic sur l'image principale pour lightbox
		            mainImg.addEventListener('click', () => {
		                if (lightboxManager) {
		                    lightboxManager.open(mainImg.src);
		                }
		            });
		        },

		        /**
		         * Configure tous les comportements UI pour le side panel
		         * @param {HTMLElement} container - Conteneur du side panel
		         * @param {LightboxManager} lightboxManager - Instance du gestionnaire de lightbox
		         */
		        setupAll(container, lightboxManager) {
		            this.attachSingleAccordionBehavior(container);
		            this.attachGalleryEvents(container, lightboxManager);
		        }
		    };

		    // Export global
		    GeoLeaf._POIUIBehaviors = UIBehaviors;

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return uiBehaviors;
	}

	requireUiBehaviors();

	var componentRenderers = {};

	/**
	 * GeoLeaf POI Module - Component Renderers
	 * Rendu des composants UI (badges, liens, listes, tableaux, tags)
	 * Phase 6.2 - Extraction depuis core.js
	 */

	var hasRequiredComponentRenderers;

	function requireComponentRenderers () {
		if (hasRequiredComponentRenderers) return componentRenderers;
		hasRequiredComponentRenderers = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Renderers pour les composants UI du side panel
		     */
		    class ComponentRenderers {
		        constructor() {
		            // R√©f√©rence aux modules POI
		            this.getMarkers = () => GeoLeaf._POIMarkers;
		        }

		        /**
		         * Rend un badge avec style de cat√©gorie
		         * @param {object} section - Configuration de section
		         * @param {string} value - Valeur du badge
		         * @param {object} poi - POI complet
		         * @returns {HTMLElement|null}
		         */
		        renderBadge(section, value, poi) {
		            if (!value) return null;

		            const container = document.createElement('div');
		            container.className = 'gl-poi-badge-container';

		            const badge = document.createElement('span');
		            badge.className = 'gl-poi-badge';
		            badge.textContent = value;

		            // R√©cup√©rer les couleurs depuis la taxonomie si disponible
		            const markers = this.getMarkers();
		            if (markers && markers.resolveCategoryDisplay) {
		                const displayInfo = markers.resolveCategoryDisplay(poi);
		                if (displayInfo.colorFill) {
		                    badge.style.background = displayInfo.colorFill;
		                    badge.style.color = '#fff';
		                }
		            }

		            container.appendChild(badge);
		            return container;
		        }

		        /**
		         * Rend un lien externe
		         * @param {object} section - Configuration de section
		         * @param {string} url - URL du lien
		         * @returns {HTMLElement|null}
		         */
		        renderLink(section, url) {
		            if (!url) return null;

		            const container = document.createElement('div');
		            container.className = 'gl-poi-link-container';

		            const link = document.createElement('a');
		            link.className = 'gl-poi-website-link';
		            link.href = url;
		            link.target = '_blank';
		            link.rel = 'noopener noreferrer';
		            link.textContent = section.label || 'Visiter le site web ‚Üí';

		            container.appendChild(link);
		            return container;
		        }

		        /**
		         * Rend une liste (tableau de prix, etc.)
		         * @param {object} section - Configuration de section
		         * @param {Array|object} data - Donn√©es √† afficher
		         * @returns {HTMLElement|null}
		         */
		        renderList(section, data) {
		            if (!data) {
		                if (Log) Log.warn('[POI] renderList: data is null/undefined');
		                return null;
		            }

		            const div = document.createElement('div');
		            div.className = 'gl-poi-section';

		            // Cas sp√©cial pour price (objet)
		            if (typeof data === 'object' && !Array.isArray(data)) {
		                if (Log) Log.info('[POI] renderList: price object:', data);

		                if (data.from || data.to) {
		                    const p = document.createElement('p');
		                    const strong = document.createElement('strong');

		                    const safeFrom = Number.isFinite(Number(data.from)) ? Number(data.from) : null;
		                    const safeTo = Number.isFinite(Number(data.to)) ? Number(data.to) : null;
		                    const safeCurrency = data.currency || 'USD';

		                    if (safeFrom !== null && safeTo !== null) {
		                        strong.textContent = `De ${safeFrom} √† ${safeTo} ${safeCurrency}`;
		                    } else if (safeFrom !== null) {
		                        strong.textContent = `√Ä partir de ${safeFrom} ${safeCurrency}`;
		                    } else if (safeTo !== null) {
		                        strong.textContent = `Jusqu'√† ${safeTo} ${safeCurrency}`;
		                    }

		                    if (strong.textContent) {
		                        p.appendChild(strong);
		                        div.appendChild(p);
		                    }
		                }
		                if (data.description) {
		                    const desc = document.createElement('p');
		                    desc.textContent = data.description;
		                    desc.style.fontSize = '0.85rem';
		                    desc.style.color = 'var(--gl-color-text-muted)';
		                    div.appendChild(desc);
		                }

		                if (div.children.length === 0) {
		                    if (Log) Log.warn('[POI] renderList: price object has no displayable content');
		                    return null;
		                }
		                return div;
		            }

		            // Liste normale (array)
		            if (Array.isArray(data)) {
		                const variant = section.variant || 'disc';

		                const ul = document.createElement('ul');
		                ul.className = 'gl-poi-list-unordered';

		                // Appliquer le style de puce selon le variant
		                if (variant === 'disc' || variant === 'circle' || variant === 'square') {
		                    ul.style.listStyleType = variant;
		                } else {
		                    ul.style.listStyleType = 'disc'; // Par d√©faut
		                }

		                data.forEach(item => {
		                    const li = document.createElement('li');
		                    li.textContent = item;
		                    ul.appendChild(li);
		                });

		                div.appendChild(ul);
		            }

		            return div;
		        }

		        /**
		         * Rend un tableau avec en-t√™tes et bordures
		         * @param {object} section - Configuration de section
		         * @param {Array} data - Donn√©es du tableau
		         * @returns {HTMLElement|null}
		         */
		        renderTable(section, data) {
		            if (!data || !Array.isArray(data)) {
		                if (Log) Log.warn('[POI] renderTable: data is', data ? 'not an array' : 'null/undefined', '- type:', typeof data);
		                return null;
		            }

		            if (Log) Log.info('[POI] renderTable: rendering', data.length, 'rows');

		            // Transformer les cha√Ænes en objets si n√©cessaire
		            let tableData = data;
		            if (data.length > 0 && typeof data[0] === 'string' && section.columns && section.columns.length === 2) {
		                // D√©tecter le format "Cl√© : Valeur" ou "Cl√© ‚Äì Valeur"
		                tableData = data.map(str => {
		                    const separators = [' : ', ': ', ' ‚Äì ', '‚Äì', ' - ', '-'];
		                    for (const sep of separators) {
		                        const parts = str.split(sep);
		                        if (parts.length >= 2) {
		                            return {
		                                [section.columns[0].key]: parts[0].trim(),
		                                [section.columns[1].key]: parts.slice(1).join(sep).trim()
		                            };
		                        }
		                    }
		                    // Si aucun s√©parateur trouv√©, tout dans la premi√®re colonne
		                    return {
		                        [section.columns[0].key]: str,
		                        [section.columns[1].key]: ''
		                    };
		                });
		                if (Log) Log.info('[POI] renderTable: transformed string array to object array');
		            }

		            const table = document.createElement('table');
		            table.className = 'gl-poi-table';

		            // Gestion des bordures selon la configuration
		            const borders = section.borders || {};
		            if (borders.outer !== false) {
		                table.style.border = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
		            }

		            // En-t√™tes
		            if (section.columns) {
		                const thead = document.createElement('thead');
		                const tr = document.createElement('tr');
		                section.columns.forEach((col, index) => {
		                    const th = document.createElement('th');
		                    th.textContent = col.label;
		                    th.style.padding = '8px';
		                    th.style.textAlign = 'left';
		                    th.style.fontWeight = '600';
		                    th.style.backgroundColor = 'var(--gl-color-bg-subtle)';

		                    if (borders.row !== false) {
		                        th.style.borderBottom = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
		                    }
		                    if (borders.column && index > 0) {
		                        th.style.borderLeft = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
		                    }

		                    tr.appendChild(th);
		                });
		                thead.appendChild(tr);
		                table.appendChild(thead);
		            }

		            // Lignes de donn√©es
		            const tbody = document.createElement('tbody');
		            tableData.forEach((row, rowIndex) => {
		                const tr = document.createElement('tr');
		                if (section.columns) {
		                    section.columns.forEach((col, colIndex) => {
		                        const td = document.createElement('td');
		                        td.textContent = row[col.key] || '';
		                        td.style.padding = '8px';

		                        if (borders.row !== false && rowIndex < tableData.length - 1) {
		                            td.style.borderBottom = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
		                        }
		                        if (borders.column && colIndex > 0) {
		                            td.style.borderLeft = `1px solid ${borders.color || 'var(--gl-color-border-soft)'}`;
		                        }

		                        tr.appendChild(td);
		                    });
		                }
		                tbody.appendChild(tr);
		            });
		            table.appendChild(tbody);

		            return table;
		        }

		        /**
		         * Rend des tags
		         * @param {object} section - Configuration de section
		         * @param {Array<string>} tags - Liste de tags
		         * @returns {HTMLElement|null}
		         */
		        renderTags(section, tags) {
		            if (!tags || !Array.isArray(tags)) {
		                if (Log) Log.warn('[POI] renderTags: tags is', tags ? 'not an array' : 'null/undefined', '- type:', typeof tags, '- value:', tags);
		                return null;
		            }

		            if (tags.length === 0) {
		                if (Log) Log.warn('[POI] renderTags: tags array is empty');
		                return null;
		            }

		            if (Log) Log.info('[POI] renderTags: rendering', tags.length, 'tags');

		            const div = document.createElement('div');
		            div.className = 'gl-poi-sidepanel__tags';
		            div.style.display = 'flex';
		            div.style.flexWrap = 'wrap';
		            div.style.gap = '6px';

		            tags.forEach(tag => {
		                const tagSpan = document.createElement('span');
		                tagSpan.className = 'gl-poi-tag';
		                tagSpan.textContent = tag;
		                div.appendChild(tagSpan);
		            });

		            return div;
		        }

		        /**
		         * Rend les avis (reviews)
		         * @param {object} section - Configuration de section
		         * @param {Array} reviews - Liste d'avis
		         * @returns {HTMLElement|null}
		         */
		        renderReviews(section, reviews) {
		            if (!reviews || !Array.isArray(reviews)) {
		                if (Log) Log.warn('[POI] renderReviews: reviews is', reviews ? 'not an array' : 'null/undefined', '- type:', typeof reviews);
		                return null;
		            }

		            if (Log) Log.info('[POI] renderReviews: rendering', reviews.length, 'reviews');

		            const div = document.createElement('div');
		            div.className = 'gl-poi-reviews';

		            const maxCount = section.maxCount || 5;
		            reviews.slice(0, maxCount).forEach(review => {
		                const reviewDiv = document.createElement('div');
		                reviewDiv.className = 'gl-poi-review';
		                reviewDiv.style.borderLeft = '3px solid var(--gl-color-accent-soft)';
		                reviewDiv.style.paddingLeft = '12px';
		                reviewDiv.style.marginBottom = '12px';

		                const header = document.createElement('p');
		                header.style.fontSize = '0.875rem';
		                header.style.fontWeight = '600';
		                header.style.marginBottom = '4px';

		                const safeAuthor = review.authorName || 'Anonyme';
		                const safeRating = Number.isFinite(review.rating) ? review.rating : 0;
		                const verifiedMark = review.verified ? ' ‚úì' : '';
		                header.textContent = `${safeAuthor} - ‚≠ê${safeRating}/5${verifiedMark}`;
		                reviewDiv.appendChild(header);

		                if (review.comment) {
		                    const comment = document.createElement('p');
		                    comment.textContent = review.comment;
		                    comment.style.fontSize = '0.85rem';
		                    comment.style.marginBottom = '4px';
		                    reviewDiv.appendChild(comment);
		                }

		                if (review.createdAt) {
		                    const date = document.createElement('p');
		                    date.style.fontSize = '0.75rem';
		                    date.style.color = 'var(--gl-color-text-muted)';
		                    date.textContent = review.createdAt;
		                    reviewDiv.appendChild(date);
		                }

		                div.appendChild(reviewDiv);
		            });

		            return div;
		        }
		    }

		    // Export global
		    GeoLeaf.ComponentRenderers = ComponentRenderers;

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return componentRenderers;
	}

	requireComponentRenderers();

	var sectionOrchestrator = {};

	/**
	 * GeoLeaf POI Module - Section Orchestrator
	 * Orchestration du rendu des sections (dispatcher, extraction valeurs, accord√©ons)
	 * Phase 6.2 - Extraction depuis core.js
	 */

	var hasRequiredSectionOrchestrator;

	function requireSectionOrchestrator () {
		if (hasRequiredSectionOrchestrator) return sectionOrchestrator;
		hasRequiredSectionOrchestrator = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;
		    const Utils = GeoLeaf.Utils || {};

		    /**
		     * Orchestrateur de sections pour le side panel POI
		     */
		    class SectionOrchestrator {
		        constructor() {
		            // Initialiser les renderers
		            this.componentRenderers = null;
		            this.fieldRenderers = null;
		            this.mediaRenderers = null;
		        }

		        /**
		         * Initialise les renderers (lazy loading)
		         * @private
		         */
		        _initRenderers() {
		            if (!this.componentRenderers) {
		                this.componentRenderers = new GeoLeaf.ComponentRenderers();
		            }
		            if (!this.fieldRenderers && GeoLeaf.POI && GeoLeaf.POI.Renderers && GeoLeaf.POI.Renderers.FieldRenderers) {
		                this.fieldRenderers = new GeoLeaf.POI.Renderers.FieldRenderers({ debug: true });
		            }
		            if (!this.mediaRenderers && GeoLeaf.POI && GeoLeaf.POI.Renderers && GeoLeaf.POI.Renderers.MediaRenderers) {
		                this.mediaRenderers = new GeoLeaf.POI.Renderers.MediaRenderers({ debug: true });
		            }
		        }

		        /**
		         * R√©cup√®re la valeur d'un champ avec support du dot notation
		         * @param {object} poi - POI complet
		         * @param {string} fieldPath - Chemin du champ (ex: "attributes.address.city")
		         * @returns {*}
		         */
		        getFieldValue(poi, fieldPath) {
		            if (!fieldPath) return null;

		            const resolveField = Utils.resolveField || function(obj, path) {
		                const parts = path.split('.');
		                let current = obj;
		                for (const part of parts) {
		                    if (current && typeof current === 'object' && part in current) {
		                        current = current[part];
		                    } else {
		                        return null;
		                    }
		                }
		                return current;
		            };

		            const value = resolveField(poi, fieldPath);

		            if (Log && Log.info) {
		                Log.info('[POI] getFieldValue:', fieldPath, '‚Üí',
		                    value === undefined ? 'undefined' :
		                    value === null ? 'null' :
		                    value === '' ? '""(empty string)' :
		                    Array.isArray(value) ? `Array(${value.length})` :
		                    (value && typeof value === 'object') ? `Object(${Object.keys(value).length} keys)` :
		                    value);
		            }

		            return value;
		        }

		        /**
		         * Wrappe un contenu dans un accord√©on <details>
		         * @param {object} section - Configuration de section
		         * @param {HTMLElement} content - Contenu √† wrapper
		         * @param {boolean} isOpen - Ouvrir par d√©faut
		         * @returns {HTMLElement}
		         */
		        wrapInAccordion(section, content, isOpen = false) {
		            const details = document.createElement('details');
		            details.className = 'gl-accordion';
		            if (isOpen) details.setAttribute('open', '');

		            const summary = document.createElement('summary');
		            summary.className = 'gl-accordion__header';
		            summary.textContent = section.label || 'Section';

		            const arrow = document.createElement('span');
		            arrow.className = 'gl-accordion__arrow';
		            arrow.textContent = '‚ñº';
		            summary.appendChild(arrow);

		            const panel = document.createElement('div');
		            panel.className = 'gl-accordion__panel';

		            const panelContent = document.createElement('div');
		            panelContent.className = 'gl-accordion__panel-content';
		            panelContent.appendChild(content);

		            panel.appendChild(panelContent);

		            details.appendChild(summary);
		            details.appendChild(panel);

		            return details;
		        }

		        /**
		         * Rend une section compl√®te selon son type
		         * @param {object} section - Configuration de section
		         * @param {object} poi - POI complet
		         * @param {object} state - √âtat partag√© POI
		         * @returns {Promise<HTMLElement|null>}
		         */
		        async renderSection(section, poi, state) {
		            if (!section || !section.type) return null;

		            // Initialiser les renderers si n√©cessaire
		            this._initRenderers();

		            // R√©soudre la valeur du champ
		            const fieldValue = this.getFieldValue(poi, section.field);

		            if (Log) {
		                const valueType = Array.isArray(fieldValue) ? `Array(${fieldValue.length})` :
		                                 (fieldValue && typeof fieldValue === 'object') ? `Object(${Object.keys(fieldValue).length} keys)` :
		                                 typeof fieldValue;
		                Log.debug('[POI] Section:', section.label || section.type, '- Field:', section.field, '- ValueType:', valueType, '- Value:', fieldValue);
		            }

		            // Ne pas afficher si la valeur est vide, SAUF pour:
		            // - text avec style='title' (le titre est obligatoire)
		            // - badge (peut avoir un comportement par d√©faut)
		            const isRequiredField = (section.type === 'text' && section.style === 'title') || section.type === 'badge';

		            // V√©rifier si la valeur est vraiment vide (null, undefined, '', [], {})
		            // ATTENTION: 0 est une valeur valide (pour les prix, m√©triques, etc.)
		            const isEmpty = (fieldValue === null || fieldValue === undefined || fieldValue === '') ||
		                           (Array.isArray(fieldValue) && fieldValue.length === 0) ||
		                           (typeof fieldValue === 'object' && !Array.isArray(fieldValue) && Object.keys(fieldValue).length === 0);

		            if (Log) {
		                Log.info('[POI] Check isEmpty for:', section.label,
		                    '- fieldValue:', fieldValue,
		                    '- isArray:', Array.isArray(fieldValue),
		                    '- arrayLength:', Array.isArray(fieldValue) ? fieldValue.length : 'N/A',
		                    '- isEmpty:', isEmpty);
		            }

		            if (isEmpty && !isRequiredField) {
		                if (Log) Log.warn('[POI] Section ignor√©e (valeur vide):', section.label || section.type);
		                return null;
		            }

		            if (Log) Log.info('[POI] ‚Üí Appel render pour:', section.label, '- Type:', section.type, '- Value:',
		                Array.isArray(fieldValue) ? `Array(${fieldValue.length})` :
		                (fieldValue && typeof fieldValue === 'object') ? 'Object' :
		                fieldValue);

		            // Cr√©er l'√©l√©ment selon le type
		            let content = null;

		            switch (section.type) {
		                case 'text':
		                case 'longtext': // Alias pour text avec plus de contenu
		                    if (this.fieldRenderers) {
		                        content = await this.fieldRenderers.renderText(section, poi, fieldValue);
		                    }
		                    break;
		                case 'number': // Afficher un nombre simple comme du texte
		                    if (this.fieldRenderers) {
		                        content = await this.fieldRenderers.renderText(section, poi, String(fieldValue));
		                    }
		                    break;
		                case 'metric': // Nombre avec suffixe/pr√©fixe
		                    const suffix = section.suffix || '';
		                    const prefix = section.prefix || '';
		                    if (this.fieldRenderers) {
		                        content = await this.fieldRenderers.renderText(section, poi, prefix + String(fieldValue) + suffix);
		                    }
		                    break;
		                case 'image':
		                    if (this.mediaRenderers) {
		                        content = this.mediaRenderers.renderImage(section, fieldValue);
		                    }
		                    break;
		                case 'gallery':
		                    if (this.mediaRenderers) {
		                        content = this.mediaRenderers.renderGallery(section, fieldValue);
		                    }
		                    break;
		                case 'badge':
		                    content = this.componentRenderers.renderBadge(section, fieldValue, poi);
		                    break;
		                case 'link':
		                    content = this.componentRenderers.renderLink(section, fieldValue);
		                    break;
		                case 'list':
		                    content = this.componentRenderers.renderList(section, fieldValue);
		                    break;
		                case 'table':
		                    content = this.componentRenderers.renderTable(section, fieldValue);
		                    break;
		                case 'tags':
		                    content = this.componentRenderers.renderTags(section, fieldValue);
		                    break;
		                case 'reviews':
		                    content = this.componentRenderers.renderReviews(section, fieldValue);
		                    break;
		                default:
		                    if (Log) Log.warn('[POI] Type de section inconnu:', section.type);
		                    return null;
		            }

		            if (!content) {
		                if (Log) Log.debug('[POI] Aucun contenu g√©n√©r√© pour:', section.label || section.type);
		                return null;
		            }

		            if (Log) Log.debug('[POI] Contenu g√©n√©r√© pour:', section.label || section.type, '- Accordion:', section.accordion);

		            // Wraper dans un accord√©on si n√©cessaire
		            if (section.accordion) {
		                return this.wrapInAccordion(section, content, section.defaultOpen);
		            }

		            return content;
		        }
		    }

		    // Export global
		    GeoLeaf.SectionOrchestrator = SectionOrchestrator;

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return sectionOrchestrator;
	}

	requireSectionOrchestrator();

	var links = {};

	/**
	 * Module Renderers/Links pour POI
	 * Rendu des liens
	 */

	var hasRequiredLinks;

	function requireLinks () {
		if (hasRequiredLinks) return links;
		hasRequiredLinks = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    /**
		     * Module Links Renderer
		     * @namespace _POIRendererLinks
		     * @private
		     */
		    const _POIRendererLinks = {
		        /**
		         * Rend un lien (website, etc.)
		         * @param {Object} section - Configuration de la section
		         * @param {string} url - URL du lien
		         * @returns {HTMLElement|null}
		         */
		        renderLink(section, url) {
		            if (!url) return null;

		            const container = document.createElement('div');
		            container.className = 'gl-poi-link-container';

		            const link = document.createElement('a');
		            link.className = 'gl-poi-website-link';
		            link.href = url;
		            link.target = '_blank';
		            link.rel = 'noopener noreferrer';
		            link.textContent = section.label || url;

		            container.appendChild(link);
		            return container;
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._POIRendererLinks = _POIRendererLinks;

		})(window);
		return links;
	}

	requireLinks();

	var core$3 = {};

	/**
	 * GeoLeaf POI Module - Renderers Core
	 * Orchestrateur principal pour le rendu du side panel POI
	 * Phase 6.2 - Version refactoris√©e (837 LOC ‚Üí ~140 LOC)
	 *
	 * Architecture modulaire:
	 * - lightbox-manager.js: Gestion lightbox
	 * - ui-behaviors.js: Comportements UI (accord√©ons, galerie)
	 * - component-renderers.js: Renderers composants (badges, links, lists, tables, tags)
	 * - section-orchestrator.js: Dispatcher de sections + extraction valeurs
	 * - field-renderers-v2.js: Renderers texte
	 * - media-renderers-v2.js: Renderers media
	 */

	var hasRequiredCore$3;

	function requireCore$3 () {
		if (hasRequiredCore$3) return core$3;
		hasRequiredCore$3 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._POIRenderers = GeoLeaf._POIRenderers || {};

		    // R√©f√©rence aux modules POI
		    const getShared = () => GeoLeaf._POIShared;
		    const getNormalizers = () => GeoLeaf._POINormalizers;

		    // Initialiser les nouveaux modules
		    let sectionOrchestrator = null;
		    let lightboxManager = null;
		    let uiBehaviors = null;

		    /**
		     * Initialise les modules (lazy loading)
		     * @private
		     */
		    function _initModules() {
		        if (!sectionOrchestrator && GeoLeaf.SectionOrchestrator) {
		            sectionOrchestrator = new GeoLeaf.SectionOrchestrator();
		        }
		        if (!lightboxManager) {
		            lightboxManager = GeoLeaf._lightboxManager || (GeoLeaf.LightboxManager ? new GeoLeaf.LightboxManager() : null);
		        }
		        if (!uiBehaviors) {
		            uiBehaviors = GeoLeaf._POIUIBehaviors;
		        }
		    }

		    /**
		     * Peuple le side panel avec les donn√©es du POI en utilisant le layout JSON.
		     *
		     * @param {object} poi - POI normalis√©.
		     * @param {object} customLayout - Layout personnalis√© (optionnel).
		     * @returns {Promise<void>}
		     */
		    async function populateSidePanel(poi, customLayout) {
		        console.log('[SIDEPANEL] populateSidePanel called for POI:', poi?.title || poi?.label);
		        // Initialiser les modules
		        _initModules();

		        const shared = getShared();
		        if (!shared) {
		            console.log('[SIDEPANEL] ERROR: shared is null');
		            return;
		        }
		        const state = shared.state;

		        if (!state.sidePanelElement) {
		            console.log('[SIDEPANEL] ERROR: sidePanelElement not found');
		            return;
		        }

		        const contentDiv = state.sidePanelElement.querySelector('.gl-poi-sidepanel__content');
		        if (!contentDiv) return;

		        // Clear contenu pr√©c√©dent
		        GeoLeaf.DOMSecurity.clearElementFast(contentDiv);

		        // Normaliser le POI
		        const normalizers = getNormalizers();
		        const normalized = normalizers ? normalizers.normalizePoi(poi) : poi;

		        if (Log) {
		            Log.debug('[POI] POI normalis√©:', normalized.title || normalized.label);
		            Log.debug('[POI] Champs attributes disponibles:', Object.keys(normalized.attributes || {}));
		        }

		        // R√©cup√©rer le layout depuis la config du profile
		        let layout = customLayout;

		        // ‚úÖ PRIORIT√â 1: V√©rifier si le POI a une configuration sidepanel attach√©e (depuis sa couche)
		        if (!layout && normalized._sidepanelConfig && normalized._sidepanelConfig.detailLayout) {
		            layout = normalized._sidepanelConfig.detailLayout;
		            if (Log) Log.info('[POI] Layout r√©cup√©r√© depuis la configuration de couche attach√©e au POI');
		        }

		        // ‚úÖ PRIORIT√â 2: Essayer de r√©cup√©rer depuis le profil actif
		        if (!layout) {
		            const Config = GeoLeaf.Config;
		            if (Config && typeof Config.getActiveProfile === 'function') {
		                const activeProfile = Config.getActiveProfile();
		                if (activeProfile && activeProfile.panels && activeProfile.panels.detail) {
		                    layout = activeProfile.panels.detail.layout;
		                    if (Log) Log.info('[POI] Layout r√©cup√©r√© depuis le profil actif:', activeProfile.id || 'unknown');
		                }
		            }
		        }

		        // Fallback sur poiConfig si disponible
		        if (!layout && state.poiConfig?.panels?.detail?.layout) {
		            layout = state.poiConfig.panels.detail.layout;
		        }

		        // Si toujours pas de layout, utiliser le layout par d√©faut
		        if (!layout || layout.length === 0) {
		            if (Log) Log.warn('[POI] Aucun layout trouv√©, utilisation du layout par d√©faut');
		            layout = _getDefaultLayout();
		        }

		        // ‚úÖ IMPORTANT: Trier les sections par leur propri√©t√© 'order' (si d√©finie)
		        const sortedLayout = [...layout].sort((a, b) => {
		            const orderA = typeof a.order === 'number' ? a.order : 999;
		            const orderB = typeof b.order === 'number' ? b.order : 999;
		            return orderA - orderB;
		        });

		        if (Log) Log.info('[POI] G√©n√©ration du side panel avec', sortedLayout.length, 'sections');

		        // Body du panneau
		        const body = document.createElement('div');
		        body.className = 'gl-poi-sidepanel__body';
		        console.log('[SIDEPANEL] Body created, will process', sortedLayout.length, 'sections');

		        // G√©n√©rer chaque section selon le layout tri√© (d√©l√©guer √† SectionOrchestrator)
		        for (const section of sortedLayout) {
		            try {
		                const element = sectionOrchestrator
		                    ? await sectionOrchestrator.renderSection(section, normalized, state)
		                    : null;

		                if (element) {
		                    body.appendChild(element);
		                    console.log('[SIDEPANEL] ‚úì Section added:', section.label || section.type);
		                    if (Log) Log.info('[POI] ‚úì Section ajout√©e:', section.label || section.type);
		                } else {
		                    console.log('[SIDEPANEL] ‚úó Section NULL:', section.label || section.type, '- field:', section.field);
		                    if (Log) Log.warn('[POI] ‚úó Section ignor√©e (element null):', section.label || section.type, '- field:', section.field);
		                }
		            } catch (error) {
		                console.error('[SIDEPANEL] ERROR rendering section:', section.label, error);
		                if (Log) Log.error('[POI] Erreur lors du rendu de la section:', section.label, error);
		            }
		        }

		        console.log('[SIDEPANEL] Appending body to contentDiv. Body has', body.children.length, 'children');
		        contentDiv.appendChild(body);
		        console.log('[SIDEPANEL] Body appended. ContentDiv now has', contentDiv.children.length, 'children');

		        // G√©rer le comportement singleAccordion si configur√©
		        const singleAccordion = normalized._sidepanelConfig?.singleAccordion;
		        if (singleAccordion === true && uiBehaviors) {
		            uiBehaviors.attachSingleAccordionBehavior(body);
		        }

		        // Attacher les √©v√©nements apr√®s le rendu
		        if (uiBehaviors) {
		            uiBehaviors.attachGalleryEvents(state.sidePanelElement, lightboxManager);
		        }
		    }

		    /**
		     * Retourne un layout par d√©faut si aucun n'est configur√©.
		     * @private
		     */
		    function _getDefaultLayout() {
		        return [
		            { type: 'text', field: 'title', style: 'title', accordion: false },
		            { type: 'image', field: 'attributes.mainImage', variant: 'hero', accordion: false },
		            { type: 'text', field: 'attributes.shortDescription', variant: 'short', accordion: false },
		            { type: 'text', label: 'Informations', field: 'attributes.longDescription', variant: 'multiline', accordion: true, defaultOpen: true },
		            { type: 'text', label: 'Description', field: 'attributes.description_long', variant: 'multiline', accordion: true, defaultOpen: true },
		            { type: 'gallery', label: 'Galerie photos', field: 'attributes.gallery', accordion: true, defaultOpen: true },
		            { type: 'list', label: 'Prix', field: 'attributes.price', accordion: true, defaultOpen: false },
		            { type: 'reviews', label: 'Avis r√©cents', field: 'attributes.reviews.recent', maxCount: 5, accordion: true, defaultOpen: false },
		            { type: 'tags', label: 'Tags', field: 'attributes.tags', accordion: false },
		            { type: 'link', label: 'Visiter le site web ‚Üí', field: 'attributes.website', accordion: false }
		        ];
		    }

		    // Export public dans un namespace s√©par√© pour √©viter d'√©craser l'agr√©gateur
		    GeoLeaf._POIRenderersCore = {
		        populateSidePanel
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return core$3;
	}

	requireCore$3();

	var renderers = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredRenderers;

	function requireRenderers () {
		if (hasRequiredRenderers) return renderers;
		hasRequiredRenderers = 1;
		/**
		 * Module POI Renderers (Agr√©gateur)
		 * Fa√ßade publique pour tous les renderers POI
		 *
		 * ARCHITECTURE REFACTORIS√âE :
		 * - poi/renderers/fields.js : Champs texte et badges
		 * - poi/renderers/media.js : Images et galeries
		 * - poi/renderers/links.js : Liens externes
		 * - poi/renderers/core.js : Logique de rendu principale (legacy)
		 * - poi/renderers.js (ce fichier) : Agr√©gateur/fa√ßade publique
		 */
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    /**
		     * Module POI Renderers
		     * D√©l√®gue aux sous-modules sp√©cialis√©s
		     * @namespace _POIRenderers
		     * @private
		     */
		    const _POIRenderers = {
		        /**
		         * Rend le contenu complet d'un POI
		         * (D√©l√©gu√© au core pour compatibilit√©)
		         * @param {Object} poi - Donn√©es du POI
		         * @param {Object} state - √âtat
		         * @returns {DocumentFragment}
		         */
		        renderContent(poi, state) {
		            // D√©l√©gation au module core (fichier original)
		            if (GeoLeaf._POIRenderersCore && typeof GeoLeaf._POIRenderersCore.renderContent === 'function') {
		                return GeoLeaf._POIRenderersCore.renderContent(poi, state);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRenderersCore non disponible');
		            return document.createDocumentFragment();
		        },

		        /**
		         * Rend un champ texte
		         * (D√©l√©gu√© au module fields)
		         */
		        renderText(section, poi, value) {
		            if (GeoLeaf._POIRendererFields) {
		                return GeoLeaf._POIRendererFields.renderText(section, poi, value);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRendererFields non disponible pour renderText');
		            return null;
		        },

		        /**
		         * Rend un badge
		         * (D√©l√©gu√© au module fields)
		         */
		        renderBadge(section, value, poi) {
		            if (GeoLeaf._POIRendererFields) {
		                return GeoLeaf._POIRendererFields.renderBadge(section, value, poi);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRendererFields non disponible pour renderBadge');
		            return null;
		        },

		        /**
		         * Rend une image
		         * (D√©l√©gu√© au module media)
		         */
		        renderImage(section, imageUrl) {
		            if (GeoLeaf._POIRendererMedia) {
		                return GeoLeaf._POIRendererMedia.renderImage(section, imageUrl);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRendererMedia non disponible pour renderImage');
		            return null;
		        },

		        /**
		         * Rend une galerie
		         * (D√©l√©gu√© au module media)
		         */
		        renderGallery(section, gallery) {
		            if (GeoLeaf._POIRendererMedia) {
		                return GeoLeaf._POIRendererMedia.renderGallery(section, gallery);
		            }
		            return null;
		        },

		        /**
		         * Rend un lien
		         * (D√©l√©gu√© au module links)
		         */
		        renderLink(section, url) {
		            if (GeoLeaf._POIRendererLinks) {
		                return GeoLeaf._POIRendererLinks.renderLink(section, url);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRendererLinks non disponible pour renderLink');
		            return null;
		        },

		        /**
		         * Peuple le side panel avec les donn√©es du POI
		         * (D√©l√©gu√© au module core)
		         * @returns {Promise<void>}
		         */
		        async populateSidePanel(poi, customLayout) {
		            if (GeoLeaf._POIRenderersCore && typeof GeoLeaf._POIRenderersCore.populateSidePanel === 'function') {
		                return await GeoLeaf._POIRenderersCore.populateSidePanel(poi, customLayout);
		            }
		            if (GeoLeaf.Log) GeoLeaf.Log.error('[POI] Module _POIRenderersCore non disponible pour populateSidePanel');
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._POIRenderers = _POIRenderers;

		})(window);
		return renderers;
	}

	requireRenderers();

	var sidepanel = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredSidepanel;

	function requireSidepanel () {
		if (hasRequiredSidepanel) return sidepanel;
		hasRequiredSidepanel = 1;
		/**
		 * GeoLeaf POI Module - Side Panel
		 * Gestion du panneau lat√©ral d'affichage d√©taill√© des POI
		 * TODO Phase 4: D√©couper fonctions complexes en sous-fonctions <80 lignes
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Shorthand for createElement
		     */
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    GeoLeaf._POISidePanel = GeoLeaf._POISidePanel || {};

		    // R√©f√©rence au module shared
		    const getShared = () => GeoLeaf._POIShared;
		    const getRenderers = () => GeoLeaf._POIRenderers;

		    /**
		     * Cr√©e l'√©l√©ment DOM du panneau lat√©ral si non existant.
		     */
		    function createSidePanel() {
		        const shared = getShared();
		        if (!shared) return;
		        const state = shared.state;

		        if (state.sidePanelElement) return; // D√©j√† cr√©√©

		        // Cr√©er l'overlay
		        const overlay = $create('div', {
		            className: 'gl-poi-sidepanel-overlay',
		            attributes: { 'aria-hidden': 'true' }
		        });
		        // Ajouter √† .gl-main pour support du mode plein √©cran
		        const glMain = document.querySelector('.gl-main');
		        if (glMain) {
		            glMain.appendChild(overlay);
		        } else {
		            document.body.appendChild(overlay);
		        }
		        state.sidePanelOverlay = overlay;

		        // Cr√©er le panneau
		        const panel = $create('aside', {
		            className: 'gl-poi-sidepanel',
		            attributes: {
		                'aria-hidden': 'true',
		                'role': 'complementary'
		            }
		        });

		        // Cr√©er le header avec bouton fermer
		        const header = $create('div', { className: 'gl-poi-sidepanel__header' });
		        const closeBtn = $create('button', {
		            className: 'gl-poi-sidepanel__close',
		            attributes: { 'aria-label': 'Fermer' },
		            textContent: '√ó',
		            onClick: closeSidePanel
		        });
		        header.appendChild(closeBtn);

		        // Cr√©er le content
		        const content = $create('div', { className: 'gl-poi-sidepanel__content' });

		        panel.appendChild(header);
		        panel.appendChild(content);
		        // Ajouter √† .gl-main pour support du mode plein √©cran
		        if (glMain) {
		            glMain.appendChild(panel);
		        } else {
		            document.body.appendChild(panel);
		        }
		        state.sidePanelElement = panel;
		        state.sidePanelContent = content;

		        // Event listeners
		        overlay.addEventListener('click', closeSidePanel);

		        if (Log) Log.info('[POI] Side panel cr√©√©.');
		    }

		    /**
		     * Ouvre le panneau lat√©ral avec les infos compl√®tes du POI.
		     *
		     * @param {object} poi - Donn√©es compl√®tes du POI.
		     * @param {object} customLayout - Layout personnalis√© (optionnel).
		     * @returns {Promise<void>}
		     */
		    async function openSidePanel(poi, customLayout) {
		        console.log('[SIDEPANEL-OPEN] openSidePanel called for POI:', poi?.id || poi?.name);
		        if (!poi) {
		            console.log('[SIDEPANEL-OPEN] ERROR: POI is null/undefined');
		            if (Log) Log.warn('[POI] openSidePanel() : POI invalide.');
		            return;
		        }

		        if (Log) {
		            Log.debug('[POI] openSidePanel:', poi.id || poi.name);
		        }

		        const shared = getShared();
		        if (!shared) {
		            console.log('[SIDEPANEL-OPEN] ERROR: shared is null');
		            return;
		        }
		        const state = shared.state;

		        // S'assurer que le panneau existe
		        if (!state.sidePanelElement) {
		            console.log('[SIDEPANEL-OPEN] Creating side panel element');
		            createSidePanel();
		        }

		        if (!state.sidePanelElement) {
		            console.log('[SIDEPANEL-OPEN] ERROR: sidePanelElement still null after creation');
		            if (Log) Log.error('[POI] openSidePanel() : Impossible de cr√©er le panneau lat√©ral.');
		            return;
		        }

		        state.currentPoiInPanel = poi;
		        state.currentGalleryIndex = 0;

		        // Peupler le panneau (la lightbox sera cr√©√©e par renderers.js si n√©cessaire)
		        const renderers = getRenderers();
		        console.log('[SIDEPANEL-OPEN] renderers:', !!renderers, '- populateSidePanel:', typeof renderers?.populateSidePanel);
		        if (renderers && typeof renderers.populateSidePanel === 'function') {
		            console.log('[SIDEPANEL-OPEN] Calling renderers.populateSidePanel');
		            await renderers.populateSidePanel(poi, customLayout);
		            console.log('[SIDEPANEL-OPEN] populateSidePanel completed');
		        } else {
		            console.log('[SIDEPANEL-OPEN] ERROR: renderers.populateSidePanel not available');
		        }

		        // Afficher l'overlay et le panneau avec animation
		        if (state.sidePanelOverlay) {
		            state.sidePanelOverlay.classList.add('open');
		        }
		        state.sidePanelElement.classList.add('open');
		        state.sidePanelElement.setAttribute('aria-hidden', 'false');

		        // Ajouter classe au body pour d√©caler la carte
		        document.body.classList.add('gl-poi-sidepanel-open');

		        if (Log) Log.info('[POI] Panneau lat√©ral ouvert pour :', poi.title || poi.name || poi.label);
		    }

		    /**
		     * Ferme le panneau lat√©ral.
		     */
		    function closeSidePanel() {
		        const shared = getShared();
		        if (!shared) return;
		        const state = shared.state;

		        if (!state.sidePanelElement) return;

		        state.sidePanelElement.classList.remove('open');
		        state.sidePanelElement.setAttribute('aria-hidden', 'true');

		        if (state.sidePanelOverlay) {
		            state.sidePanelOverlay.classList.remove('open');
		        }

		        // Retirer classe du body
		        document.body.classList.remove('gl-poi-sidepanel-open');

		        // Nettoyer la lightbox globale
		        const lightbox = document.querySelector('.gl-poi-lightbox-global');
		        if (lightbox) {
		            lightbox.remove();
		        }

		        state.currentPoiInPanel = null;

		        if (Log) Log.info('[POI] Panneau lat√©ral ferm√©.');
		    }

		    /**
		     * Alias pour fermer le panneau (API publique).
		     */
		    function hideSidePanel() {
		        closeSidePanel();
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POISidePanel = {
		        createSidePanel,
		        openSidePanel,
		        closeSidePanel,
		        hideSidePanel
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return sidepanel;
	}

	requireSidepanel();

	var core$2 = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredCore$2;

	function requireCore$2 () {
		if (hasRequiredCore$2) return core$2;
		hasRequiredCore$2 = 1;
		/**
		 * GeoLeaf POI Module - Core
		 * Fonctions principales d'initialisation, chargement et gestion des POI
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._POICore = GeoLeaf._POICore || {};

		    // R√©f√©rences aux modules POI
		    const getShared = () => GeoLeaf._POIShared;
		    const getMarkers = () => GeoLeaf._POIMarkers;
		    const getSidePanel = () => GeoLeaf._POISidePanel;
		    const getNormalizers = () => GeoLeaf._POINormalizers;

		    /**
		     * Fonction principale d'initialisation du module POI.
		     *
		     * @param {L.Map|object} mapOrOptions - Instance de la carte Leaflet ou objet {map, config}.
		     * @param {object} config - Configuration POI depuis GeoLeaf.config.json (optionnel si premier param est objet).
		     */
		    async function init(mapOrOptions, config) {
		        // Support pour les deux signatures: init(map, config) et init({map, config})
		        let map, opts;

		        if (mapOrOptions && typeof mapOrOptions === 'object' && mapOrOptions.map) {
		            map = mapOrOptions.map;
		            opts = mapOrOptions.config || mapOrOptions;
		        } else {
		            map = mapOrOptions;
		            opts = config;
		        }

		        if (!map || typeof map.addLayer !== 'function') {
		            if (Log) Log.error('[POI] Aucune carte Leaflet valide fournie. Impossible d\'initialiser le module POI.');
		            return;
		        }

		        const shared = getShared();
		        if (!shared) {
		            if (Log) Log.error('[POI] Module shared non charg√©.');
		            return;
		        }

		        const state = shared.state;
		        const constants = shared.constants;

		        state.mapInstance = map;
		        state.poiConfig = opts || {};

		        if (Log) Log.info('[POI] Initialisation du module POI...');

		        // Forcer un maxZoom valide sur la carte
		        if (shared.ensureMapMaxZoom) {
		            shared.ensureMapMaxZoom(map, constants.POI_MAX_ZOOM);
		        }

		        // Cr√©er le layer group principal
		        state.poiLayerGroup = L.layerGroup().addTo(map);

		        // Cr√©er le cluster group si clustering activ√©
		        const clustering = state.poiConfig.clustering !== false;
		        if (clustering && typeof L !== 'undefined' && typeof L.markerClusterGroup === 'function') {
		            state.poiClusterGroup = L.markerClusterGroup({
		                maxClusterRadius: state.poiConfig.clusterRadius || 80,
		                disableClusteringAtZoom: state.poiConfig.disableClusteringAtZoom || constants.POI_MAX_ZOOM,
		                animate: false,
		                showCoverageOnHover: false
		            });
		            state.mapInstance.addLayer(state.poiClusterGroup);
		            if (Log) Log.info('[POI] Clustering activ√© (MarkerClusterGroup cr√©√©).');
		        }

		        // Cr√©er le panneau lat√©ral (cach√© par d√©faut)
		        const sidePanel = getSidePanel();
		        if (sidePanel && typeof sidePanel.createSidePanel === 'function') {
		            sidePanel.createSidePanel();
		        }

		        // Charger le sprite SVG AVANT de charger les POIs
		        const markers = getMarkers();
		        if (markers && typeof markers.ensureProfileSpriteInjectedSync === 'function') {
		            await markers.ensureProfileSpriteInjectedSync();
		        }

		        // Charger et afficher les POIs avec d√©lai pour attendre Storage
		        if (state.poiConfig.enabled !== false) {
		            // ‚úÖ NOUVEAU: Retarder le chargement initial pour laisser le temps au Storage de s'initialiser
		            setTimeout(() => {
		                if (Log) Log.info('[POI] Chargement des POI apr√®s d√©lai d\'initialisation');
		                loadAndDisplay();
		            }, 1000);
		        }
		    }

		    /**
		     * ‚úÖ NOUVELLE FONCTION: Charge et fusionne les POI stock√©s localement avec les POI existants
		     */
		    function loadAndMergeStoredPois(existingPois, callback) {
		        if (typeof callback !== 'function') {
		            if (Log) Log.error('[POI] loadAndMergeStoredPois: callback requis');
		            return;
		        }

		        // ‚úÖ NOUVEAU: V√©rification renforc√©e de la disponibilit√© du module Storage
		        const checkStorageAvailable = () => {
		            const available = typeof GeoLeaf !== 'undefined' &&
		                   GeoLeaf.Storage &&
		                   GeoLeaf.Storage.DB &&
		                   typeof GeoLeaf.Storage.DB.getAllFromSyncQueue === 'function';

		            if (Log) {
		                if (!available) {
		                    Log.info('[POI] Debug Storage - GeoLeaf:', typeof GeoLeaf !== 'undefined');
		                    Log.info('[POI] Debug Storage - GeoLeaf.Storage:', !!(GeoLeaf && GeoLeaf.Storage));
		                    Log.info('[POI] Debug Storage - GeoLeaf.Storage.DB:', !!(GeoLeaf && GeoLeaf.Storage && GeoLeaf.Storage.DB));
		                    Log.info('[POI] Debug Storage - getAllFromSyncQueue:', !!(GeoLeaf && GeoLeaf.Storage && GeoLeaf.Storage.DB && typeof GeoLeaf.Storage.DB.getAllFromSyncQueue === 'function'));
		                }
		            }

		            return available;
		        };

		        if (!checkStorageAvailable()) {
		            // ‚úÖ NOUVEAU: Retry apr√®s un d√©lai si Storage pas encore pr√™t
		            if (Log) Log.warn('[POI] Module Storage pas encore pr√™t, retry dans 1000ms...');
		            setTimeout(() => {
		                if (checkStorageAvailable()) {
		                    if (Log) Log.info('[POI] Module Storage maintenant disponible, retry...');
		                    loadAndMergeStoredPois(existingPois, callback);
		                } else {
		                    if (Log) Log.error('[POI] Module Storage toujours non disponible apr√®s retry, abandon.');
		                    callback(existingPois);
		                }
		            }, 1000);
		            return;
		        }

		        if (Log) Log.info('[POI] Module Storage disponible, r√©cup√©ration des POI...');

		        // Utiliser le module de synchronisation pour r√©cup√©rer les POI du cache
		        GeoLeaf.Storage.DB.getAllFromSyncQueue()
		            .then(queueItems => {
		                if (Log) Log.info(`[POI] R√©cup√©ration cache: ${queueItems.length} items trouv√©s`);

		                if (!Array.isArray(queueItems) || queueItems.length === 0) {
		                    if (Log) Log.info('[POI] Aucun POI trouv√© dans la file de synchronisation.');
		                    callback(existingPois);
		                    return;
		                }

		                // D√©bugger les types d'items trouv√©s
		                if (Log) {
		                    const itemTypes = queueItems.map(item => `${item.action}:${item.data?.type || 'no-type'}`);
		                    Log.info(`[POI] Types d'items dans le cache: [${itemTypes.join(', ')}]`);

		                    // DEBUG: Structure compl√®te des premiers items
		                    queueItems.slice(0, 2).forEach((item, i) => {
		                        Log.info(`[POI] DEBUG Item ${i}:`, {
		                            action: item.action,
		                            type: item.type,
		                            data_type: item.data?.type,
		                            keys: Object.keys(item),
		                            data_keys: item.data ? Object.keys(item.data) : 'no data'
		                        });
		                    });
		                }

		                // Filtrer les √©l√©ments POI (action 'add' ou 'update') et extraire les donn√©es
		                const cachedPois = [];
		                const normalizers = getNormalizers();

		                if (!normalizers) {
		                    if (Log) Log.error('[POI] Module Normalizers non disponible pour les POI du cache.');
		                    callback(existingPois);
		                    return;
		                }

		                queueItems.forEach(item => {
		                    // Essayer diff√©rents formats de structure pour les POI
		                    let isPoi = false;
		                    let poiData = null;
		                    let itemAction = null;

		                    // Format 1: item.data.type === 'poi' && item.action contient 'add'
		                    if (item.data && item.data.type === 'poi' && item.action &&
		                        (item.action.includes('add') || item.action.includes('update'))) {
		                        isPoi = true;
		                        poiData = item.data;
		                        itemAction = item.action;
		                    }
		                    // Format 2: item.type === 'poi' directement
		                    else if (item.type === 'poi') {
		                        isPoi = true;
		                        poiData = item;
		                        itemAction = item.action || 'add';
		                    }
		                    // Format 3: Contient un id POI et des coordonn√©es (detection heuristique)
		                    else if (item.data && (item.data.id || item.data.latlng || item.data.latitude)) {
		                        isPoi = true;
		                        poiData = item.data;
		                        itemAction = item.action || 'add';
		                        if (Log) Log.info(`[POI] D√©tection heuristique POI: ${item.data.id || 'no-id'}`);
		                    }
		                    // Format 4: L'item lui-m√™me est un POI (pas d'enveloppe data)
		                    else if (item.id && (item.latlng || item.latitude)) {
		                        isPoi = true;
		                        poiData = item;
		                        itemAction = 'add';
		                        if (Log) Log.info(`[POI] D√©tection POI direct: ${item.id}`);
		                    }

		                    if (isPoi && poiData) {
		                        // Normaliser le POI stock√© comme les autres
		                        const normalizedPoi = normalizers.normalizePoi(poiData);
		                        if (normalizedPoi) {
		                            cachedPois.push(normalizedPoi);
		                            if (Log) Log.info(`[POI] POI du cache normalis√©: ${normalizedPoi.id || 'Sans ID'} (action: ${itemAction})`);
		                        } else {
		                            if (Log) Log.warn('[POI] √âchec normalisation POI du cache:', poiData);
		                        }
		                    } else {
		                        if (Log) Log.debug(`[POI] Item ignor√© - action: ${item.action}, type: ${item.type || item.data?.type}, keys: ${Object.keys(item).join(',')}`);
		                    }
		                });

		                if (cachedPois.length > 0) {
		                    if (Log) Log.info(`[POI] ${cachedPois.length} POI(s) r√©cup√©r√©(s) du cache local.`);

		                    // Fusionner avec les POI existants (√©viter les doublons par ID)
		                    const mergedPois = [...existingPois];
		                    cachedPois.forEach(cachedPoi => {
		                        if (!mergedPois.find(p => p.id === cachedPoi.id)) {
		                            mergedPois.push(cachedPoi);
		                        }
		                    });

		                    callback(mergedPois);
		                } else {
		                    callback(existingPois);
		                }
		            })
		            .catch(err => {
		                if (Log) Log.error('[POI] Erreur lors de la r√©cup√©ration des POI du cache :', err);
		                callback(existingPois);
		            });
		    }

		    /**
		     * Charge les POIs et les affiche sur la carte.
		     */
		    function loadAndDisplay() {
		        const shared = getShared();
		        if (!shared) return;
		        const state = shared.state;

		        if (state.isLoading) {
		            if (Log) Log.warn('[POI] Chargement d√©j√† en cours...');
		            return;
		        }

		        // 1) Essayer d'utiliser les POI normalis√©s du profil actif
		        try {
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfilePoi === 'function') {
		                const profilePois = GeoLeaf.Config.getActiveProfilePoi();
		                if (Array.isArray(profilePois) && profilePois.length > 0) {
		                    state.allPois = profilePois;
		                    if (Log) Log.info(`[POI] ${state.allPois.length} POI(s) provenant du profil actif.`);

		                    // ‚úÖ CORRECTION: Charger aussi les POI du cache apr√®s les POI du profil
		                    loadAndMergeStoredPois(state.allPois, function(mergedPois) {
		                        state.allPois = mergedPois;
		                        displayPois(state.allPois);
		                    });
		                    return;
		                }
		            }
		        } catch (err) {
		            if (Log) Log.error('[POI] Erreur lors de la r√©cup√©ration des POI du profil actif :', err);
		        }

		        // ‚úÖ CORRECTION: Essayer de charger les POI stock√©s en cache AVANT le fallback dataUrl
		        loadAndMergeStoredPois([], function(cachedPois) {
		            if (cachedPois.length > 0) {
		                state.allPois = cachedPois;
		                if (Log) Log.info(`[POI] ${cachedPois.length} POI(s) charg√©(s) depuis le cache local.`);
		                displayPois(cachedPois);
		                return;
		            }

		            // 2) Fallback : charger un fichier JSON depuis dataUrl (mode historique)
		            const dataUrl = state.poiConfig.dataUrl;
		            if (!dataUrl) {
		                if (Log) Log.info('[POI] Aucune dataUrl sp√©cifi√©e et aucun POI en cache. Mode ajout manuel.');
		                return;
		            }

		            state.isLoading = true;
		            if (Log) Log.info('[POI] Chargement des donn√©es POI depuis :', dataUrl);

		            fetch(dataUrl)
		                .then(response => {
		                    if (!response.ok) {
		                        throw new Error(`Erreur HTTP ${response.status} lors du chargement de ${dataUrl}`);
		                    }
		                    return response.json();
		                })
		                .then(data => {
		                    if (Array.isArray(data)) {
		                        state.allPois = data;
		                    } else if (data && Array.isArray(data.pois)) {
		                        state.allPois = data.pois;
		                    } else {
		                        state.allPois = [];
		                    }
		                    if (Log) Log.info(`[POI] ${state.allPois.length} POI(s) charg√©(s) depuis dataUrl.`);
		                    displayPois(state.allPois);
		                })
		                .catch(err => {
		                    if (Log) Log.error('[POI] Erreur lors du chargement des POIs :', err);
		                })
		                .finally(() => {
		                    state.isLoading = false;
		                });
		        });
		    }

		    /**
		     * Affiche tous les POIs pass√©s en param√®tre sur la carte.
		     *
		     * @param {array} pois - Tableau d'objets POI.
		     */
		    function displayPois(pois) {
		        if (!pois || !Array.isArray(pois)) {
		            if (Log) Log.warn('[POI] displayPois() : Aucune donn√©e POI valide √† afficher.');
		            return;
		        }

		        const shared = getShared();
		        if (!shared) return;
		        const state = shared.state;

		        // Nettoyer les layers existants
		        if (state.poiLayerGroup) {
		            state.poiLayerGroup.clearLayers();
		        }
		        if (state.poiClusterGroup) {
		            state.poiClusterGroup.clearLayers();
		        }

		        const clustering = state.poiConfig.clustering !== false;
		        const markers = getMarkers();

		        if (!markers || typeof markers.createMarker !== 'function') {
		            if (Log) Log.error('[POI] Module Markers non charg√©.');
		            return;
		        }

		        if (clustering && state.poiClusterGroup) {
		            // Mode clustering
		            pois.forEach(poi => {
		                const marker = markers.createMarker(poi);
		                if (marker) {
		                    state.poiClusterGroup.addLayer(marker);
		                    state.poiMarkers.set(poi.id || poi.title || poi.label, marker);
		                }
		            });

		            if (!state.mapInstance.hasLayer(state.poiClusterGroup)) {
		                state.mapInstance.addLayer(state.poiClusterGroup);
		            }

		            if (Log) Log.info('[POI] Affichage avec clustering.');
		        } else {
		            // Mode sans clustering
		            pois.forEach(poi => {
		                const marker = markers.createMarker(poi);
		                if (marker) {
		                    state.poiLayerGroup.addLayer(marker);
		                    state.poiMarkers.set(poi.id || poi.title || poi.label, marker);
		                }
		            });

		            if (!state.mapInstance.hasLayer(state.poiLayerGroup)) {
		                state.mapInstance.addLayer(state.poiLayerGroup);
		            }

		            if (Log) Log.info('[POI] Affichage sans clustering.');
		        }
		    }

		    /**
		     * Ajoute un POI manuellement sur la carte.
		     * CORRIG√â V3: Normalisation syst√©matique des nouveaux POI
		     *
		     * @param {object} poi - Donn√©es du POI.
		     * @returns {L.Marker|null} Marqueur cr√©√© ou null.
		     */
		    function addPoi(poi) {
		        if (!poi) {
		            if (Log) Log.warn('[POI] addPoi() : POI invalide.');
		            return null;
		        }

		        const shared = getShared();
		        if (!shared) return null;
		        const state = shared.state;

		        const normalizers = getNormalizers();
		        const markers = getMarkers();

		        if (!normalizers || !markers) {
		            if (Log) Log.error('[POI] Modules Normalizers ou Markers non charg√©s.');
		            return null;
		        }

		        // ‚úÖ CORRECTION V3: NORMALISER le POI avant traitement
		        // Ceci garantit une structure coh√©rente avec les POI existants
		        const normalizedPoi = normalizers.normalizePoi(poi);
		        if (!normalizedPoi) {
		            if (Log) Log.warn('[POI] addPoi() : √âchec de la normalisation du POI.', poi);
		            return null;
		        }

		        // G√©n√©rer un ID si manquant apr√®s normalisation
		        if (!normalizedPoi.id) {
		            normalizedPoi.id = normalizers.generatePoiId(normalizedPoi);
		        }

		        if (Log) {
		            Log.info('[POI] Adding normalized POI:', normalizedPoi.id);
		            Log.info('[POI] - Has _layerConfig:', !!normalizedPoi._layerConfig);
		            Log.info('[POI] - Has _sidepanelConfig:', !!normalizedPoi._sidepanelConfig);
		            Log.info('[POI] - Has _popupConfig:', !!normalizedPoi._popupConfig);
		            Log.info('[POI] - Attributes keys:', Object.keys(normalizedPoi.attributes || {}));
		        }

		        // Cr√©er le marqueur avec le POI normalis√©
		        const marker = markers.createMarker(normalizedPoi);
		        if (!marker) {
		            if (Log) Log.warn('[POI] addPoi() : Impossible de cr√©er le marqueur pour ce POI normalis√©.', normalizedPoi);
		            return null;
		        }

		        // Ajouter au bon layer group
		        const clustering = state.poiConfig.clustering !== false;
		        if (clustering && state.poiClusterGroup) {
		            state.poiClusterGroup.addLayer(marker);
		        } else {
		            state.poiLayerGroup.addLayer(marker);
		        }

		        // Stocker le POI NORMALIS√â dans la liste (important pour la coh√©rence)
		        state.allPois.push(normalizedPoi);
		        state.poiMarkers.set(normalizedPoi.id, marker);

		        // Note: La sauvegarde en cache est g√©r√©e par le submit-handler via SyncHandler
		        // pour √©viter la duplication et assurer la coh√©rence

		        if (Log) Log.info('[POI] ‚úÖ POI normalis√© ajout√© avec succ√®s :', normalizedPoi.id);

		        return marker;
		    }

		    /**
		     * R√©cup√®re tous les POI charg√©s.
		     *
		     * @returns {array} Tableau des POI.
		     */
		    function getAllPois() {
		        const shared = getShared();
		        return shared ? shared.state.allPois : [];
		    }

		    /**
		     * R√©cup√®re un POI par son ID.
		     *
		     * @param {string} id - ID du POI.
		     * @returns {object|null} POI trouv√© ou null.
		     */
		    function getPoiById(id) {
		        const shared = getShared();
		        if (!shared) return null;
		        const state = shared.state;

		        return state.allPois.find(p => p.id === id) || null;
		    }

		    /**
		     * Recharge les POI (efface et r√©affiche).
		     *
		     * @param {array} pois - Nouveau tableau de POI (optionnel).
		     */
		    function reload(pois) {
		        const shared = getShared();
		        if (!shared) return;
		        const state = shared.state;

		        if (pois && Array.isArray(pois)) {
		            state.allPois = pois;
		        }

		        displayPois(state.allPois);

		        if (Log) Log.info('[POI] POI recharg√©s.');
		    }

		    // ========================================
		    //   EXPORT
		    // ========================================

		    GeoLeaf._POICore = {
		        init,
		        loadAndDisplay,
		        displayPois,
		        addPoi,
		        getAllPois,
		        getPoiById,
		        reload,
		        getDisplayedPoisCount: function() {
		            const shared = getShared();
		            return shared && shared.state ? (shared.state.allPois || []).length : 0;
		        }
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return core$2;
	}

	requireCore$2();

	var geoleaf_poi = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_poi;

	function requireGeoleaf_poi () {
		if (hasRequiredGeoleaf_poi) return geoleaf_poi;
		hasRequiredGeoleaf_poi = 1;
		/**
		 * GeoLeaf POI Module - Aggregator
		 *
		 * Ce fichier est maintenant un agr√©gateur UMD qui expose l'API publique du module POI.
		 * Les fonctionnalit√©s principales sont impl√©ment√©es dans les sous-modules :
		 *
		 * - poi/shared.js      : √âtat partag√© et constantes
		 * - poi/normalizers.js : Normalisation des donn√©es POI
		 * - poi/popup.js       : Popups et tooltips
		 * - poi/markers.js     : Cr√©ation de marqueurs
		 * - poi/sidepanel.js   : Panneau lat√©ral
		 * - poi/renderers.js   : Rendu du contenu
		 * - poi/core.js        : Fonctions principales (init, load, display)
		 *
		 * En production, Rollup bundle automatiquement tous les modules ensemble.
		 * En d√©veloppement, chaque module est charg√© s√©par√©ment dans demo/index.html.
		 *
		 * Pour plus de d√©tails, voir docs/poi/POI_SPLIT_STRATEGY.md
		 *
		 * @version 2.1.0
		 * @since 2.0.0
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    // R√©f√©rences aux sous-modules POI (charg√©s via getters pour √©viter les d√©pendances circulaires)
		    const POICore = () => GeoLeaf._POICore;
		    const POISidePanel = () => GeoLeaf._POISidePanel;
		    const POIShared = () => GeoLeaf._POIShared;

		    /**
		     * API publique du module POI
		     * Toutes les fonctions d√©l√®guent aux sous-modules appropri√©s
		     */
		    // Pr√©server GeoLeaf.POI.Renderers s'il existe d√©j√† (d√©fini par field-renderers.js, etc.)
		    const existingRenderers = GeoLeaf.POI && GeoLeaf.POI.Renderers;

		    GeoLeaf.POI = (function () {
		        return {
		            // Restaurer les Renderers d√©finis avant
		            Renderers: existingRenderers || {},

		            /**
		             * Initialise le module POI avec la carte et la configuration.
		             * Supporte deux signatures: init(map, config) et init({map, config}).
		             *
		             * @param {L.Map|object} mapOrOptions - Instance Leaflet ou objet avec {map, config}
		             * @param {object} [config] - Configuration POI (optionnel si premier param est objet)
		             */
		            init: function (mapOrOptions, config) {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return;
		                }
		                core.init(mapOrOptions, config);
		            },

		            /**
		             * Charge et affiche les POIs sur la carte.
		             */
		            loadAndDisplay: function () {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return;
		                }
		                core.loadAndDisplay();
		            },

		            /**
		             * Affiche un tableau de POIs sur la carte.
		             *
		             * @param {array} pois - Tableau d'objets POI
		             */
		            displayPois: function (pois) {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return;
		                }
		                core.displayPois(pois);
		            },

		            /**
		             * Ajoute un POI manuellement √† la carte.
		             *
		             * @param {object} poi - Donn√©es du POI
		             * @returns {L.Marker|null} Marqueur cr√©√© ou null
		             */
		            addPoi: function (poi) {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return null;
		                }
		                return core.addPoi(poi);
		            },

		            /**             * Ajoute un nouveau POI √† la carte.
		             *
		             * @param {object} poi - Donn√©es du POI √† ajouter
		             * @returns {boolean} true si ajout r√©ussi, false sinon
		             */
		            add: function (poi) {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return false;
		                }
		                return core.addPoi(poi);
		            },

		            /**
		             * Alias pour add() - ajoute un POI.
		             *
		             * @param {object} poi - Donn√©es du POI
		             * @returns {boolean} true si ajout r√©ussi, false sinon
		             */
		            addPoi: function (poi) {
		                return this.add(poi);
		            },

		            /**             * R√©cup√®re tous les POI charg√©s.
		             *
		             * @returns {array} Tableau des POI
		             */
		            getAllPois: function () {
		                const core = POICore();
		                if (!core) return [];
		                return core.getAllPois();
		            },

		            /**
		             * R√©cup√®re un POI par son ID.
		             *
		             * @param {string} id - ID du POI
		             * @returns {object|null} POI trouv√© ou null
		             */
		            getPoiById: function (id) {
		                const core = POICore();
		                if (!core) return null;
		                return core.getPoiById(id);
		            },

		            /**
		             * Recharge les POIs (efface et r√©affiche).
		             *
		             * @param {array} [pois] - Nouveau tableau de POI (optionnel)
		             */
		            reload: function (pois) {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return;
		                }
		                core.reload(pois);
		            },

		            /**
		             * Affiche le panneau lat√©ral avec les d√©tails d'un POI.
		             *
		             * @param {object} poi - Donn√©es du POI
		             * @param {array} [customLayout] - Layout personnalis√© (optionnel)
		             * @returns {Promise<void>}
		             */
		            showPoiDetails: async function (poi, customLayout) {
		                const sidePanel = POISidePanel();
		                if (!sidePanel) {
		                    if (Log) Log.error('[POI] Module SidePanel non charg√©.');
		                    return;
		                }
		                await sidePanel.openSidePanel(poi, customLayout);
		            },

		            /**
		             * Ferme le panneau lat√©ral.
		             */
		            hideSidePanel: function () {
		                const sidePanel = POISidePanel();
		                if (!sidePanel) {
		                    if (Log) Log.error('[POI] Module SidePanel non charg√©.');
		                    return;
		                }
		                sidePanel.closeSidePanel();
		            },

		            /**
		             * Alias pour showPoiDetails avec layout personnalis√©.
		             *
		             * @param {object} poi - Donn√©es du POI
		             * @param {array} customLayout - Layout personnalis√©
		             */
		            openSidePanelWithLayout: function (poi, customLayout) {
		                this.showPoiDetails(poi, customLayout);
		            },

		            /**
		             * R√©cup√®re le layer group Leaflet actif (cluster ou simple).
		             *
		             * @returns {L.LayerGroup|L.MarkerClusterGroup|null} Layer group ou null
		             */
		            getLayer: function () {
		                const shared = POIShared();
		                if (!shared) return null;
		                const state = shared.state;
		                return state.poiClusterGroup || state.poiLayerGroup;
		            },

		            /**
		             * Obtient le nombre de POI actuellement affich√©s.
		             *
		             * @returns {number} Nombre de POI affich√©s
		             */
		            getDisplayedPoisCount: function () {
		                const core = POICore();
		                if (!core) {
		                    if (Log) Log.error('[POI] Module Core non charg√©.');
		                    return 0;
		                }
		                return core.getDisplayedPoisCount();
		            },

		            /**
		             * Helper pour tests unitaires : efface tous les POI.
		             * @private
		             */
		            _clearAllForTests: function () {
		                const shared = POIShared();
		                if (!shared) return;
		                const state = shared.state;

		                if (Log) Log.info('[POI] _clearAllForTests: Suppression de', state.allPois.length, 'POI(s) et', state.poiMarkers.size, 'marqueur(s)');

		                state.allPois = [];
		                state.poiMarkers.clear();
		                if (state.poiClusterGroup) state.poiClusterGroup.clearLayers();
		                if (state.poiLayerGroup) state.poiLayerGroup.clearLayers();
		            }
		        };
		    })();

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_poi;
	}

	requireGeoleaf_poi();

	var shared$1 = {};

	/**
	 * GeoLeaf GeoJSON Module - Shared State & Constants
	 * √âtat partag√© et constantes pour le module GeoJSON
	 *
	 * @module geojson/shared
	 */

	var hasRequiredShared$1;

	function requireShared$1 () {
		if (hasRequiredShared$1) return shared$1;
		hasRequiredShared$1 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * √âtat partag√© du module GeoJSON
		     * Accessible via GeoLeaf._GeoJSONShared.state
		     */
		    GeoLeaf._GeoJSONShared = GeoLeaf._GeoJSONShared || {};

		    /**
		     * √âtat interne partag√© entre les sous-modules
		     */
		    GeoLeaf._GeoJSONShared.state = {
		        /**
		         * R√©f√©rence vers la carte Leaflet.
		         * @type {L.Map|null}
		         */
		        map: null,

		        /**
		         * Groupe contenant toutes les couches GeoJSON (conteneur parent).
		         * @type {L.LayerGroup|null}
		         */
		        layerGroup: null,

		        /**
		         * LEGACY: Couche L.GeoJSON principale (pour compatibilit√© descendante).
		         * @deprecated Utiliser layers pour multi-couches.
		         * @type {L.GeoJSON|null}
		         */
		        geoJsonLayer: null,

		        /**
		         * Map des couches individuelles par ID.
		         * Structure: Map<layerId, {id, label, layer, visible, config, clusterGroup}>
		         * @type {Map<string, Object>}
		         */
		        layers: new Map(),

		        /**
		         * Compteur pour g√©n√©rer des IDs uniques si non fourni.
		         * @type {number}
		         */
		        layerIdCounter: 0,

		        /**
		         * Cache l√©ger des features par couche (geojson/features d√©j√† converties).
		         * Map<layerId, { features: Array, geometryType: string }>
		         * @type {Map<string, Object>}
		         */
		        featureCache: new Map(),

		        /**
		         * Options par d√©faut du module GeoJSON.
		         */
		        options: {
		            /**
		             * Style par d√©faut des g√©om√©tries (polygones / lignes).
		             */
		            defaultStyle: {
		                color: "#2E7D32",
		                weight: 2,
		                opacity: 0.9,
		                fillColor: "#66BB6A",
		                fillOpacity: 0.4
		            },
		            /**
		             * Style des points (circleMarker).
		             */
		            defaultPointStyle: {
		                radius: 6,
		                color: "#1B5E20",
		                weight: 2,
		                fillColor: "#66BB6A",
		                fillOpacity: 0.9
		            },
		            /**
		             * Fonction de rappel pour chaque feature.
		             * @param {Object} feature
		             * @param {L.Layer} layer
		             */
		            onEachFeature: null,
		            /**
		             * Fonction pointToLayer personnalis√©e (si fournie).
		             * @param {Object} feature
		             * @param {L.LatLng} latlng
		             * @returns {L.Layer}
		             */
		            pointToLayer: null,
		            /**
		             * Adapter automatiquement la vue sur les donn√©es charg√©es.
		             */
		            fitBoundsOnLoad: true,
		            /**
		             * ZOOM max lors du fitBounds (facultatif).
		             */
		            maxZoomOnFit: GeoLeaf.CONSTANTS ? GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18
		        }
		    };

		    /**
		     * Constantes pour la gestion des panes Leaflet et z-index
		     */
		    GeoLeaf._GeoJSONShared.PANE_CONFIG = {
		        BASEMAP_NAME: 'geoleaf-basemap',
		        BASEMAP_ZINDEX: 200,
		        LAYER_PREFIX: 'geoleaf-layer-',
		        LAYER_BASE_ZINDEX: 400,
		        MIN_LAYER_ZINDEX: 0,
		        MAX_LAYER_ZINDEX: 99
		    };

		    /**
		     * Helpers pour la gestion des panes
		     */
		    GeoLeaf._GeoJSONShared.PaneHelpers = {
		        /**
		         * G√©n√®re le nom du pane pour un zIndex donn√©
		         * @param {number} zIndex - zIndex de la couche (0-99)
		         * @returns {string} Nom du pane
		         */
		        getPaneName(zIndex) {
		            const config = GeoLeaf._GeoJSONShared.PANE_CONFIG;
		            return `${config.LAYER_PREFIX}${zIndex || 0}`;
		        },

		        /**
		         * Valide et clamp un zIndex dans la plage autoris√©e
		         * @param {number} zIndex - zIndex √† valider
		         * @returns {number} zIndex valide (0-99)
		         */
		        validateZIndex(zIndex) {
		            const config = GeoLeaf._GeoJSONShared.PANE_CONFIG;
		            return Math.max(config.MIN_LAYER_ZINDEX, Math.min(config.MAX_LAYER_ZINDEX, Math.floor(zIndex)));
		        },

		        /**
		         * Applique le pane √† un layer ou marker
		         * @param {L.Layer} layer - Layer Leaflet
		         * @param {number} zIndex - zIndex de la couche
		         */
		        applyPaneToLayer(layer, zIndex) {
		            if (layer && layer.options) {
		                layer.options.pane = this.getPaneName(zIndex);
		            }
		        }
		    };

		    /**
		     * Map des op√©rateurs de comparaison pour styleRules.
		     * Supporte : >, >=, <, <=, ==, ===, eq (alias ==), !=, !==, contains, startsWith, endsWith, in, notIn, between
		     */
		    GeoLeaf._GeoJSONShared.STYLE_OPERATORS = {
		        '>': (a, b) => Number(a) > Number(b),
		        '>=': (a, b) => Number(a) >= Number(b),
		        '<': (a, b) => Number(a) < Number(b),
		        '<=': (a, b) => Number(a) <= Number(b),
		        '==': (a, b) => a == b,
		        '===': (a, b) => a === b,
		        'eq': (a, b) => a == b,  // Alias pour ==
		        '!=': (a, b) => a != b,
		        '!==': (a, b) => a !== b,
		        'neq': (a, b) => a != b, // Alias pour !=
		        'contains': (a, b) => String(a).toLowerCase().includes(String(b).toLowerCase()),
		        'startsWith': (a, b) => String(a).toLowerCase().startsWith(String(b).toLowerCase()),
		        'endsWith': (a, b) => String(a).toLowerCase().endsWith(String(b).toLowerCase()),
		        'in': (a, b) => Array.isArray(b) && b.includes(a),
		        'notIn': (a, b) => Array.isArray(b) && !b.includes(a),
		        'between': (a, b) => {
		            if (!Array.isArray(b) || b.length !== 2) return false;
		            const num = Number(a);
		            const min = Number(b[0]);
		            const max = Number(b[1]);
		            return num >= min && num <= max;
		        }
		    };

		    /**
		     * R√©initialise l'√©tat partag√© (utile pour les tests)
		     */
		    GeoLeaf._GeoJSONShared.reset = function () {
		        const state = GeoLeaf._GeoJSONShared.state;
		        state.map = null;
		        state.layerGroup = null;
		        state.geoJsonLayer = null;
		        state.layers = new Map();
		        state.layerIdCounter = 0;
		        state.featureCache = new Map();
		        // R√©initialiser les options par d√©faut
		        state.options = {
		            defaultStyle: {
		                color: "#2E7D32",
		                weight: 2,
		                opacity: 0.9,
		                fillColor: "#66BB6A",
		                fillOpacity: 0.4
		            },
		            defaultPointStyle: {
		                radius: 6,
		                color: "#1B5E20",
		                weight: 2,
		                fillColor: "#66BB6A",
		                fillOpacity: 0.9
		            },
		            onEachFeature: null,
		            pointToLayer: null,
		            fitBoundsOnLoad: true,
		            maxZoomOnFit: GeoLeaf.CONSTANTS ? GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18
		        };
		    };

		    /**
		     * Getter pour le Log (lazy loading)
		     */
		    GeoLeaf._GeoJSONShared.getLog = function () {
		        return GeoLeaf.Log || console;
		    };

		})(window);
		return shared$1;
	}

	requireShared$1();

	var styleResolver$1 = {};

	/**
	 * GeoLeaf GeoJSON Module - Style Resolver
	 * √âvaluation des r√®gles de style dynamiques (styleRules)
	 *
	 * @module geojson/style-resolver
	 */

	var hasRequiredStyleResolver$1;

	function requireStyleResolver$1 () {
		if (hasRequiredStyleResolver$1) return styleResolver$1;
		hasRequiredStyleResolver$1 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendance lazy vers shared
		    const getShared = () => GeoLeaf._GeoJSONShared;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONStyleResolver = GeoLeaf._GeoJSONStyleResolver || {};

		    /**
		     * R√©sout une valeur imbriqu√©e dans un objet via un chemin (ex: "properties.name").
		     * @param {Object} obj - Objet source
		     * @param {string} path - Chemin (dot notation)
		     * @returns {*} Valeur trouv√©e ou null
		     */
		    GeoLeaf._GeoJSONStyleResolver.getNestedValue = function (obj, path) {
		        if (!obj || !path) return null;
		        return path.split('.').reduce((current, prop) =>
		            current && current[prop] !== undefined ? current[prop] : null, obj);
		    };

		    /**
		     * √âvalue une condition simple contre une feature GeoJSON.
		     * @param {Object} feature - Feature GeoJSON
		     * @param {Object} condition - {field, operator, value}
		     * @param {Object} STYLE_OPERATORS - Op√©rateurs de comparaison
		     * @param {Object} Log - Logger
		     * @returns {boolean} true si la condition est remplie
		     */
		    GeoLeaf._GeoJSONStyleResolver.evaluateCondition = function (feature, condition, STYLE_OPERATORS, Log) {
		        const { field, operator, value } = condition;
		        if (!field || !operator) return false;

		        // R√©soudre la valeur du champ depuis la feature
		        const fieldValue = GeoLeaf._GeoJSONStyleResolver.getNestedValue(feature, field);

		        // Si le champ n'existe pas, la condition n'est pas remplie
		        if (fieldValue === null || fieldValue === undefined) return false;

		        // Obtenir la fonction de comparaison
		        const compareFn = STYLE_OPERATORS[operator];
		        if (!compareFn) {
		            Log.warn && Log.warn('[GeoJSON] Op√©rateur styleRules inconnu:', operator);
		            return false;
		        }

		        // √âvaluer la condition
		        try {
		            return compareFn(fieldValue, value);
		        } catch (e) {
		            Log.warn && Log.warn('[GeoJSON] Erreur √©valuation condition:', e.message);
		            return false;
		        }
		    };

		    /**
		     * √âvalue les r√®gles de style (styleRules) contre une feature GeoJSON.
		     * Retourne le style de la PREMI√àRE r√®gle correspondante (ordre du tableau).
		     * Supporte les formats:
		     * - Simple: {when: {field, operator, value}, style: {...}}
		     * - Compos√©: {when: {all: [{field, operator, value}, ...]}, style: {...}}
		     *
		     * @param {Object} feature - Feature GeoJSON
		     * @param {Array} styleRules - Tableau de r√®gles
		     * @returns {Object|null} Style de la premi√®re r√®gle correspondante, ou null
		     */
		    GeoLeaf._GeoJSONStyleResolver.evaluateStyleRules = function (feature, styleRules) {
		        if (!Array.isArray(styleRules) || styleRules.length === 0) {
		            return null;
		        }

		        const shared = getShared();
		        const Log = getLog();
		        const STYLE_OPERATORS = shared.STYLE_OPERATORS;

		        for (const rule of styleRules) {
		            if (!rule || !rule.when || !rule.style) continue;

		            // Support du format compos√© avec "all": [conditions]
		            if (rule.when.all && Array.isArray(rule.when.all)) {
		                // V√©rifier que TOUTES les conditions sont remplies
		                const allConditionsMet = rule.when.all.every(condition =>
		                    GeoLeaf._GeoJSONStyleResolver.evaluateCondition(feature, condition, STYLE_OPERATORS, Log)
		                );

		                if (allConditionsMet) {
		                    return rule.style;
		                }
		            }
		            // Format simple avec field, operator, value
		            else if (rule.when.field && rule.when.operator) {
		                const conditionMet = GeoLeaf._GeoJSONStyleResolver.evaluateCondition(
		                    feature,
		                    rule.when,
		                    STYLE_OPERATORS,
		                    Log
		                );

		                if (conditionMet) {
		                    return rule.style;
		                }
		            }
		        }

		        return null;
		    };

		    /**
		     * Construit les options Leaflet pour L.geoJSON √† partir des options GeoLeaf.
		     *
		     * @param {Object} options - Options GeoLeaf
		     * @returns {Object} - Options Leaflet
		     */
		    GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions = function (options) {
		        const evaluateStyleRules = GeoLeaf._GeoJSONStyleResolver.evaluateStyleRules;

		        const normalizeStyle = (style) => {
		            if (!style || typeof style !== 'object') {
		                return {};
		            }

		            const normalized = {};

		            // Format imbriqu√© fill/stroke
		            if (style.fill || style.stroke) {
		                if (style.fill) {
		                    if (style.fill.color) normalized.fillColor = style.fill.color;
		                    if (typeof style.fill.opacity === 'number') {
		                        normalized.fillOpacity = style.fill.opacity;
		                    } else {
		                        normalized.fillOpacity = 1.0;
		                    }
		                }

		                if (style.stroke) {
		                    if (style.stroke.color) normalized.color = style.stroke.color;
		                    if (typeof style.stroke.opacity === 'number') normalized.opacity = style.stroke.opacity;
		                    if (typeof style.stroke.widthPx === 'number') normalized.weight = style.stroke.widthPx;
		                    if (style.stroke.dashArray) normalized.dashArray = style.stroke.dashArray;
		                    if (style.stroke.lineCap) normalized.lineCap = style.stroke.lineCap;
		                    if (style.stroke.lineJoin) normalized.lineJoin = style.stroke.lineJoin;
		                }

		                // Propri√©t√©s communes
		                if (style.shape) normalized.shape = style.shape;
		                if (typeof style.sizePx === 'number') {
		                    normalized.radius = style.sizePx;
		                    normalized.sizePx = style.sizePx;
		                }
		            } else {
		                Object.assign(normalized, style);
		                if (typeof normalized.fillOpacity !== 'number') {
		                    normalized.fillOpacity = 1.0;
		                }
		            }

		            return normalized;
		        };

		        const leafletOptions = {
		            /**
		             * Style pour polygones / lignes.
		             * Priorit√© : defaultStyle < styleRules (premi√®re correspondante) < feature.properties.style
		             */
		            style(feature) {
		                // 1. Commencer avec le style par d√©faut
		                let finalStyle = Object.assign({}, normalizeStyle(options.defaultStyle));

		                // 2. Appliquer les styleRules (premi√®re r√®gle correspondante gagne)
		                if (options.styleRules && Array.isArray(options.styleRules)) {
		                    const matchedStyle = evaluateStyleRules(feature, options.styleRules);
		                    if (matchedStyle) {
		                        finalStyle = Object.assign({}, finalStyle, normalizeStyle(matchedStyle));
		                    }
		                }

		                // 3. Mode interactif
		                const interactiveShapes = typeof options.interactiveShape === "boolean"
		                    ? options.interactiveShape
		                    : (GeoLeaf.Config && GeoLeaf.Config.get ? GeoLeaf.Config.get('ui.interactiveShapes', false) : false);
		                finalStyle.interactive = interactiveShapes;

		                return finalStyle;
		            },

		            /**
		             * Gestion des points (Point / MultiPoint).
		             */
		            pointToLayer: options.pointToLayer
		                ? function (feature, latlng) {
		                      return options.pointToLayer(feature, latlng);
		                  }
		                : function (feature, latlng) {
		                      // Utiliser le param√®tre interactiveShape d√©fini pour cette couche
		                      const interactiveShapes = typeof options.interactiveShape === "boolean"
		                          ? options.interactiveShape
		                          : (GeoLeaf.Config && GeoLeaf.Config.get ? GeoLeaf.Config.get('ui.interactiveShapes', false) : false);
		                      const pointStyle = GeoLeaf.Utils && GeoLeaf.Utils.mergeOptions
		                          ? GeoLeaf.Utils.mergeOptions(options.defaultPointStyle, { interactive: interactiveShapes })
		                          : Object.assign({}, options.defaultPointStyle, { interactive: interactiveShapes });
		                      return global.L.circleMarker(latlng, pointStyle);
		                  },

		            /**
		             * Callback pour chaque entit√©.
		             */
		            onEachFeature: function (feature, layer) {
		                // Popup simple par d√©faut si popupContent fourni
		                if (
		                    feature &&
		                    feature.properties &&
		                    typeof feature.properties.popupContent === "string"
		                ) {
		                    layer.bindPopup(feature.properties.popupContent);
		                }

		                // Callback custom utilisateur
		                if (typeof options.onEachFeature === "function") {
		                    options.onEachFeature(feature, layer);
		                }
		            }
		        };

		        return leafletOptions;
		    };

		    // Exposer aussi via _StyleRules pour compatibilit√© avec le module Themes
		    GeoLeaf._StyleRules = {
		        evaluate: GeoLeaf._GeoJSONStyleResolver.evaluateStyleRules,
		        operators: GeoLeaf._GeoJSONShared ? GeoLeaf._GeoJSONShared.STYLE_OPERATORS : {},
		        getNestedValue: GeoLeaf._GeoJSONStyleResolver.getNestedValue
		    };

		})(window);
		return styleResolver$1;
	}

	requireStyleResolver$1();

	var visibilityManager = {};

	/**
	 * GeoLeaf GeoJSON Module - Visibility Manager
	 * Gestionnaire centralis√© de visibilit√© des couches avec gestion des priorit√©s
	 *
	 * G√®re trois sources de modification de visibilit√© :
	 * - 'user': Action manuelle de l'utilisateur (toggle, show/hide explicite)
	 * - 'theme': Modification par application d'un th√®me
	 * - 'zoom': Modification automatique selon le niveau de zoom
	 *
	 * R√®gles de priorit√© :
	 * 1. user > theme > zoom (l'utilisateur a toujours le dernier mot)
	 * 2. Une action 'user' annule les flags 'theme' et 'zoom'
	 * 3. Une action 'theme' peut override 'zoom' mais pas 'user'
	 * 4. Une action 'zoom' ne change jamais l'√©tat si 'user' ou 'theme' est actif
	 *
	 * @module geojson/visibility-manager
	 */

	var hasRequiredVisibilityManager;

	function requireVisibilityManager () {
		if (hasRequiredVisibilityManager) return visibilityManager;
		hasRequiredVisibilityManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._LayerVisibilityManager = GeoLeaf._LayerVisibilityManager || {};

		    /**
		     * √âtats de visibilit√© possibles
		     * @private
		     */
		    const VisibilitySource = {
		        USER: 'user',
		        THEME: 'theme',
		        ZOOM: 'zoom',
		        SYSTEM: 'system'  // Chargement initial, etc.
		    };

		    /**
		     * Initialise les m√©tadonn√©es de visibilit√© pour une couche
		     * @param {Object} layerData - Donn√©es de la couche
		     * @private
		     */
		    function initVisibilityMetadata(layerData) {
		        if (!layerData._visibility) {
		            layerData._visibility = {
		                current: false,           // √âtat actuel physique sur la carte (true/false)
		                logicalState: false,      // √âtat logique (bouton ON/OFF, ind√©pendant du zoom)
		                source: VisibilitySource.SYSTEM,  // Derni√®re source de modification
		                userOverride: false,      // L'utilisateur a forc√© un √©tat
		                themeOverride: false,     // Un th√®me a forc√© un √©tat
		                themeDesired: null,       // Visibilit√© voulue par le th√®me (true/false)
		                zoomConstrained: false    // La couche est limit√©e par le zoom
		            };
		        }
		    }

		    /**
		     * D√©finit la visibilit√© d'une couche avec gestion de priorit√©
		     *
		     * @param {string} layerId - ID de la couche
		     * @param {boolean} visible - √âtat de visibilit√© souhait√©
		     * @param {string} source - Source de la modification ('user' | 'theme' | 'zoom' | 'system')
		     * @returns {boolean} - true si la visibilit√© a √©t√© modifi√©e, false sinon
		     */
		    GeoLeaf._LayerVisibilityManager.setVisibility = function (layerId, visible, source) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[VisibilityManager] Couche introuvable:", layerId);
		            return false;
		        }

		        // Initialiser les m√©tadonn√©es si n√©cessaire
		        initVisibilityMetadata(layerData);

		        const meta = layerData._visibility;
		        const oldVisible = meta.current;
		        const oldSource = meta.source;

		        // Appliquer les r√®gles de priorit√©
		        const canChange = this._canChangeVisibility(meta, source, visible);

		        if (!canChange) {
		            Log.debug(
		                `[VisibilityManager] Changement refus√© pour ${layerId}: ` +
		                `source=${source}, userOverride=${meta.userOverride}, themeOverride=${meta.themeOverride}`
		            );
		            return false;
		        }

		        // Mettre √† jour les flags selon la source
		        this._updateVisibilityFlags(meta, source, visible);

		        // Appliquer le changement effectif
		        const changed = this._applyVisibilityChange(layerId, layerData, visible);

		        if (changed) {
		            meta.current = visible;
		            meta.source = source;

		            Log.debug(
		                `[VisibilityManager] ${layerId}: ${oldVisible} ‚Üí ${visible} ` +
		                `(source: ${oldSource} ‚Üí ${source})`
		            );

		            // Mettre √† jour les anciens flags pour compatibilit√©
		            layerData.visible = visible;
		            layerData.userDisabled = meta.userOverride && !visible;
		            layerData.themeHidden = meta.themeOverride && !visible;

		            // Notifier la l√©gende
		            this._notifyLegend(layerId, visible);

		            // √âmettre l'√©v√©nement
		            this._fireVisibilityEvent(layerId, visible, source);
		        }

		        return changed;
		    };

		    /**
		     * V√©rifie si la visibilit√© peut √™tre modifi√©e selon les r√®gles de priorit√©
		     * @param {Object} meta - M√©tadonn√©es de visibilit√©
		     * @param {string} source - Source de la modification
		     * @returns {boolean}
		     * @private
		     */
		    GeoLeaf._LayerVisibilityManager._canChangeVisibility = function (meta, source, desiredVisible) {
		        // L'utilisateur peut toujours modifier
		        if (source === VisibilitySource.USER) {
		            return true;
		        }

		        // IMPORTANT: Le zoom DOIT TOUJOURS pouvoir modifier l'affichage physique (current)
		        // m√™me si userOverride est true. Cela permet d'afficher/masquer selon les seuils de zoom
		        // tout en gardant logicalState ind√©pendant.
		        if (source === VisibilitySource.ZOOM) {
		            return true;
		        }

		        // Si l'utilisateur a d√©fini un override, seul l'utilisateur peut changer l'√©tat logique
		        if (meta.userOverride) {
		            return false;
		        }

		        // Ne jamais r√©activer ce qu'un th√®me a explicitement masqu√©
		        if (source === VisibilitySource.ZOOM && meta.themeOverride && meta.themeDesired === false && desiredVisible === true) {
		            return false;
		        }

		        // Les th√®mes peuvent override le zoom mais pas l'utilisateur
		        if (source === VisibilitySource.THEME) {
		            return true;
		        }

		        // Par d√©faut, autoriser (pour 'system' et autres)
		        return true;
		    };

		    /**
		     * Met √† jour les flags de visibilit√© selon la source
		     * @param {Object} meta - M√©tadonn√©es de visibilit√©
		     * @param {string} source - Source de la modification
		     * @param {boolean} visible - √âtat de visibilit√©
		     * @private
		     */
		    GeoLeaf._LayerVisibilityManager._updateVisibilityFlags = function (meta, source, visible) {
		        switch (source) {
		            case VisibilitySource.USER:
		                meta.userOverride = true;
		                meta.themeOverride = false;  // Reset theme override
		                meta.zoomConstrained = false;
		                meta.logicalState = visible; // Mettre √† jour l'√©tat logique
		                break;

		            case VisibilitySource.THEME:
		                // Ne pas override userOverride si d√©j√† pr√©sent
		                if (!meta.userOverride) {
		                    meta.themeOverride = true;
		                    meta.themeDesired = visible;
		                    meta.zoomConstrained = false;
		                    meta.logicalState = visible; // Mettre √† jour l'√©tat logique
		                }
		                break;

		            case VisibilitySource.ZOOM:
		                // Marquer la contrainte zoom (sauf override utilisateur)
		                // NE PAS modifier logicalState - le zoom n'affecte pas l'√©tat logique
		                if (!meta.userOverride) {
		                    meta.zoomConstrained = true;
		                }
		                break;

		            case VisibilitySource.SYSTEM:
		                // Reset tous les overrides pour un chargement propre
		                meta.userOverride = false;
		                meta.themeOverride = false;
		                meta.themeDesired = null;
		                meta.zoomConstrained = false;
		                meta.logicalState = visible; // Initialiser l'√©tat logique
		                break;
		        }
		    };

		    /**
		     * Applique physiquement le changement de visibilit√© (add/remove layer)
		     * @param {string} layerId - ID de la couche
		     * @param {Object} layerData - Donn√©es de la couche
		     * @param {boolean} visible - √âtat de visibilit√© souhait√©
		     * @returns {boolean} - true si un changement a √©t√© effectu√©
		     * @private
		     */
		    GeoLeaf._LayerVisibilityManager._applyVisibilityChange = function (layerId, layerData, visible) {
		        const state = getState();
		        const Log = getLog();

		        if (!layerData.layer) {
		            Log.warn("[VisibilityManager] Layer Leaflet manquant pour:", layerId);
		            return false;
		        }

		        // D√©terminer quelle couche g√©rer (cluster ou layer)
		        const layerToManage = layerData.clusterGroup || layerData.layer;
		        const isCurrentlyOnMap = state.map && state.map.hasLayer(layerToManage);

		        // Si d√©j√† dans l'√©tat souhait√©, ne rien faire
		        if (visible && isCurrentlyOnMap) {
		            return false;
		        }
		        if (!visible && !isCurrentlyOnMap) {
		            return false;
		        }

		        try {
		            if (visible) {
		                // Cas 1 : Cluster partag√© avec POI
		                if (layerData.useSharedCluster && layerData.clusterGroup) {
		                    layerData.clusterGroup.addLayer(layerData.layer);
		                }
		                // Cas 2 : Cluster ind√©pendant
		                else if (layerData.clusterGroup) {
		                    state.map.addLayer(layerData.clusterGroup);
		                    if (layerData.clusterGroup.refreshClusters) {
		                        layerData.clusterGroup.refreshClusters();
		                    }
		                }
		                // Cas 3 : Pas de cluster - ajouter directement √† la map pour respecter le pane
		                else {
		                    state.map.addLayer(layerData.layer);
		                }
		            } else {
		                // Cas 1 : Cluster partag√© avec POI
		                if (layerData.useSharedCluster && layerData.clusterGroup) {
		                    layerData.clusterGroup.removeLayer(layerData.layer);
		                }
		                // Cas 2 : Cluster ind√©pendant
		                else if (layerData.clusterGroup) {
		                    state.map.removeLayer(layerData.clusterGroup);
		                }
		                // Cas 3 : Pas de cluster - retirer directement de la map
		                else {
		                    state.map.removeLayer(layerData.layer);
		                }
		            }

		            // Synchroniser l'UI du Layer Manager et le bouton labels apr√®s changement r√©ussi
		            // Utilise le refresh debounced pour grouper les changements multiples (ex: zoom)
		            if (GeoLeaf.LayerManager && typeof GeoLeaf.LayerManager.refresh === 'function') {
		                GeoLeaf.LayerManager.refresh(); // Debounced par d√©faut (100ms)
		            }

		            if (GeoLeaf._LabelButtonManager && typeof GeoLeaf._LabelButtonManager.syncImmediate === 'function') {
		                GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		            }

		            return true;

		        } catch (err) {
		            Log.error(`[VisibilityManager] Erreur lors du changement de visibilit√© de ${layerId}:`, err);
		            return false;
		        }
		    };

		    /**
		     * Notifie le module Legend d'un changement de visibilit√©
		     * @param {string} layerId - ID de la couche
		     * @param {boolean} visible - √âtat de visibilit√©
		     * @private
		     */
		    GeoLeaf._LayerVisibilityManager._notifyLegend = function (layerId, visible) {
		        if (GeoLeaf.Legend && typeof GeoLeaf.Legend.setLayerVisibility === "function") {
		            GeoLeaf.Legend.setLayerVisibility(layerId, visible);
		        }

		        // Notifier aussi le module Labels pour masquer/afficher les √©tiquettes
		        if (GeoLeaf.Labels) {
		            if (visible) {
		                // Si la couche devient visible, v√©rifier si les labels doivent √™tre affich√©s
		                // refreshLabels ne fait rien si les labels ne sont pas enabled
		                if (typeof GeoLeaf.Labels.refreshLabels === "function") {
		                    GeoLeaf.Labels.refreshLabels(layerId);
		                }
		            } else {
		                // Si la couche devient invisible, masquer les labels (sans changer enabled)
		                if (typeof GeoLeaf.Labels._hideLabelsForLayer === "function") {
		                    GeoLeaf.Labels._hideLabelsForLayer(layerId);
		                }
		            }
		        }

		        // Synchroniser le bouton de label pour refl√©ter la visibilit√© de la couche
		        if (GeoLeaf._LabelButtonManager && typeof GeoLeaf._LabelButtonManager.syncImmediate === "function") {
		            GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		        }
		    };

		    /**
		     * √âmet un √©v√©nement de changement de visibilit√©
		     * @param {string} layerId - ID de la couche
		     * @param {boolean} visible - √âtat de visibilit√©
		     * @param {string} source - Source du changement
		     * @private
		     */
		    GeoLeaf._LayerVisibilityManager._fireVisibilityEvent = function (layerId, visible, source) {
		        const state = getState();
		        if (!state.map) return;

		        try {
		            state.map.fire("geoleaf:geojson:visibility-changed", {
		                layerId: layerId,
		                visible: visible,
		                source: source
		            });
		        } catch (e) {
		            // Silencieux
		        }
		    };

		    /**
		     * R√©initialise les overrides utilisateur pour une couche
		     * Utilis√© par les th√®mes pour reprendre le contr√¥le
		     *
		     * @param {string} layerId - ID de la couche
		     */
		    GeoLeaf._LayerVisibilityManager.resetUserOverride = function (layerId) {
		        const state = getState();
		        const layerData = state.layers.get(layerId);

		        if (layerData && layerData._visibility) {
		            layerData._visibility.userOverride = false;
		            getLog().debug(`[VisibilityManager] User override r√©initialis√© pour ${layerId}`);
		        }
		    };

		    /**
		     * R√©initialise tous les overrides utilisateur
		     * Utilis√© par les th√®mes lors d'un changement complet de th√®me
		     */
		    GeoLeaf._LayerVisibilityManager.resetAllUserOverrides = function () {
		        const state = getState();
		        let count = 0;

		        state.layers.forEach((layerData, layerId) => {
		            if (layerData._visibility && layerData._visibility.userOverride) {
		                layerData._visibility.userOverride = false;
		                count++;
		            }
		        });

		        if (count > 0) {
		            getLog().debug(`[VisibilityManager] ${count} user override(s) r√©initialis√©(s)`);
		        }
		    };

		    /**
		     * Obtient l'√©tat de visibilit√© complet d'une couche
		     * @param {string} layerId - ID de la couche
		     * @returns {Object|null} - M√©tadonn√©es de visibilit√© ou null
		     */
		    GeoLeaf._LayerVisibilityManager.getVisibilityState = function (layerId) {
		        const state = getState();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            return null;
		        }

		        initVisibilityMetadata(layerData);

		        return {
		            current: layerData._visibility.current,
		            source: layerData._visibility.source,
		            userOverride: layerData._visibility.userOverride,
		            themeOverride: layerData._visibility.themeOverride,
		            zoomConstrained: layerData._visibility.zoomConstrained
		        };
		    };

		    /**
		     * Exporte les constantes pour utilisation externe
		     */
		    GeoLeaf._LayerVisibilityManager.VisibilitySource = VisibilitySource;

		    getLog().info("[GeoLeaf._LayerVisibilityManager] Module charg√©");

		})(window);
		return visibilityManager;
	}

	requireVisibilityManager();

	var store = {};

	/**
	 * GeoLeaf GeoJSON Layer Manager - Store
	 * Layer CRUD operations: get, query, remove, z-index
	 *
	 * @module geojson/layer-manager/store
	 */

	var hasRequiredStore;

	function requireStore () {
		if (hasRequiredStore) return store;
		hasRequiredStore = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getShared = () => GeoLeaf._GeoJSONShared;
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    const LayerManager = GeoLeaf._GeoJSONLayerManager = GeoLeaf._GeoJSONLayerManager || {};

		    /**
		     * R√©cup√®re une couche sp√©cifique par son ID.
		     *
		     * @param {string} layerId - ID de la couche
		     * @returns {Object|null} - { id, label, layer, visible, config, clusterGroup } ou null
		     */
		    LayerManager.getLayerById = function (layerId) {
		        const state = getState();
		        return state.layers.get(layerId) || null;
		    };

		    /**
		     * R√©cup√®re les donn√©es d'une couche (geojson, geometryType, config).
		     * Utilis√© par le module Themes pour appliquer les styles.
		     *
		     * @param {string} layerId - ID de la couche
		     * @returns {Object|null} - { geojson, geometryType, config } ou null
		     */
		    LayerManager.getLayerData = function (layerId) {
		        const state = getState();
		        const layerData = state.layers.get(layerId);
		        if (!layerData) return null;

		        return {
		            geojson: layerData.geojson || null,
		            features: layerData.features || [],
		            geometryType: layerData.geometryType || 'unknown',
		            config: layerData.config || {},
		            layer: layerData.layer
		        };
		    };

		    /**
		     * R√©cup√®re toutes les couches charg√©es.
		     *
		     * @returns {Array<Object>} - Tableau de { id, label, visible, type, featureCount }
		     *
		     * Note: 'visible' retourne l'√©tat LOGIQUE de la couche (activ√©e/d√©sactiv√©e par l'utilisateur ou le th√®me),
		     * pas l'√©tat physique sur la carte (qui peut √™tre masqu√©e par le zoom).
		     * C'est l'√©tat qui doit √™tre refl√©t√© par le bouton ON/OFF du gestionnaire de couches.
		     */
		    LayerManager.getAllLayers = function () {
		        const state = getState();
		        const Log = getLog();
		        const layers = [];
		        state.layers.forEach((layerData, id) => {
		            // Utiliser logicalState qui est ind√©pendant du zoom
		            const meta = layerData._visibility;
		            const logicalVisible = meta && typeof meta.logicalState === 'boolean'
		                ? meta.logicalState
		                : (layerData.visible || false);

		            // DEBUG
		            if (Log && id === 'hebergements') {
		                Log.info(`[getAllLayers] ${id}: logicalState=${meta?.logicalState}, current=${meta?.current}, visible=${layerData.visible}, userOverride=${meta?.userOverride}, themeOverride=${meta?.themeOverride}`);
		            }

		            layers.push({
		                id: id,
		                label: layerData.label,
		                visible: logicalVisible,
		                type: LayerManager.detectLayerType(layerData.layer),
		                featureCount: layerData.layer ? layerData.layer.getLayers().length : 0
		            });
		        });
		        return layers;
		    };

		    /**
		     * D√©tecte le type de g√©om√©trie dominant d'une couche.
		     *
		     * @param {L.GeoJSON} layer
		     * @returns {string} - "poi", "route", "area", ou "mixed"
		     */
		    LayerManager.detectLayerType = function (layer) {
		        if (!layer || typeof layer.eachLayer !== 'function') return "mixed";

		        const types = { Point: 0, LineString: 0, Polygon: 0 };

		        layer.eachLayer((l) => {
		            if (l.feature && l.feature.geometry) {
		                const geomType = l.feature.geometry.type;
		                if (geomType.includes("Point")) types.Point++;
		                else if (geomType.includes("LineString")) types.LineString++;
		                else if (geomType.includes("Polygon")) types.Polygon++;
		            }
		        });

		        const max = Math.max(types.Point, types.LineString, types.Polygon);
		        if (max === 0) return "mixed";
		        if (types.Point === max) return "poi";
		        if (types.LineString === max) return "route";
		        if (types.Polygon === max) return "area";
		        return "mixed";
		    };

		    /**
		     * Supprime une couche.
		     *
		     * @param {string} layerId - ID de la couche
		     */
		    LayerManager.removeLayer = function (layerId) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] removeLayer: couche introuvable :", layerId);
		            return;
		        }

		        // Retirer de la carte
		        if (layerData.visible) {
		            LayerManager.hideLayer(layerId);
		        }

		        // D√©truire les objets Leaflet
		        if (layerData.clusterGroup) {
		            layerData.clusterGroup.clearLayers();
		        }
		        if (layerData.layer) {
		            layerData.layer.clearLayers();
		        }

		        // Retirer de la Map
		        state.layers.delete(layerId);
		        state.featureCache.delete(layerId);

		        Log.debug("[GeoLeaf.GeoJSON] Couche supprim√©e :", layerId);
		    };

		    /**
		     * Met √† jour le zIndex d'une couche (ordre d'empilement sur la carte).
		     * Recr√©√©e la couche avec le nouveau pane si elle est visible.
		     *
		     * @param {string} layerId - ID de la couche
		     * @param {number} newZIndex - Nouveau zIndex (0-99)
		     * @returns {boolean} - true si la mise √† jour a r√©ussi
		     */
		    LayerManager.updateLayerZIndex = function (layerId, newZIndex) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] updateLayerZIndex: couche introuvable :", layerId);
		            return false;
		        }

		        // Validation et clamping 0-99
		        const PaneHelpers = getShared().PaneHelpers;
		        newZIndex = PaneHelpers.validateZIndex(newZIndex);

		        const oldZIndex = layerData.config.zIndex || 0;
		        if (oldZIndex === newZIndex) {
		            Log.debug("[GeoLeaf.GeoJSON] updateLayerZIndex: zIndex identique, aucun changement :", layerId);
		            return true;
		        }

		        Log.info(`[GeoLeaf.GeoJSON] Changement zIndex pour ${layerId}: ${oldZIndex} ‚Üí ${newZIndex}`);

		        // Mettre √† jour la config
		        layerData.config.zIndex = newZIndex;

		        // Si la couche n'est pas visible, juste mettre √† jour la config
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        const visState = VisibilityManager ? VisibilityManager.getVisibilityState(layerId) : null;
		        const isVisible = visState ? visState.current : layerData.visible;

		        if (!isVisible) {
		            Log.debug("[GeoLeaf.GeoJSON] Couche non visible, zIndex mis √† jour dans config uniquement");
		            return true;
		        }

		        // Couche visible : besoin de changer le pane
		        const newPaneName = PaneHelpers.getPaneName(newZIndex);
		        const newPane = state.map.getPane(newPaneName);

		        if (!newPane) {
		            Log.error(`[GeoLeaf.GeoJSON] Pane ${newPaneName} introuvable`);
		            return false;
		        }

		        try {
		            // Retirer temporairement de la carte
		            if (layerData.clusterGroup) {
		                state.map.removeLayer(layerData.clusterGroup);
		            } else {
		                state.map.removeLayer(layerData.layer);
		            }

		            // Changer le pane du layer Leaflet
		            if (layerData.layer && layerData.layer.options) {
		                layerData.layer.options.pane = newPaneName;

		                // Mettre √† jour chaque feature/layer individuelle
		                layerData.layer.eachLayer(function(subLayer) {
		                    if (subLayer.options) {
		                        subLayer.options.pane = newPaneName;
		                    }
		                    // Forcer le re-rendu en changeant le pane du path SVG
		                    if (subLayer._path && subLayer._path.parentNode) {
		                        const newPaneElement = state.map.getPane(newPaneName);
		                        if (newPaneElement) {
		                            newPaneElement.appendChild(subLayer._path);
		                        }
		                    }
		                });
		            }

		            // Changer le pane du clusterGroup si pr√©sent
		            if (layerData.clusterGroup && layerData.clusterGroup.options) {
		                layerData.clusterGroup.options.pane = newPaneName;
		            }

		            // Remettre sur la carte directement
		            if (layerData.clusterGroup) {
		                state.map.addLayer(layerData.clusterGroup);
		            } else {
		                state.map.addLayer(layerData.layer);
		            }

		            Log.debug(`[GeoLeaf.GeoJSON] Couche ${layerId} d√©plac√©e vers pane ${newPaneName}`);

		            // D√©clencher √©v√©nement de changement
		            if (state.map) {
		                state.map.fire("geoleaf:geojson:zindex-changed", {
		                    layerId: layerId,
		                    oldZIndex: oldZIndex,
		                    newZIndex: newZIndex
		                });
		            }

		            return true;
		        } catch (error) {
		            Log.error(`[GeoLeaf.GeoJSON] Erreur lors du changement de zIndex pour ${layerId}:`, error);
		            return false;
		        }
		    };

		})(window);
		return store;
	}

	requireStore();

	var visibility$1 = {};

	/**
	 * GeoLeaf GeoJSON Layer Manager - Visibility
	 * Show/hide/toggle layers, zoom-based visibility
	 *
	 * @module geojson/layer-manager/visibility
	 */

	var hasRequiredVisibility$1;

	function requireVisibility$1 () {
		if (hasRequiredVisibility$1) return visibility$1;
		hasRequiredVisibility$1 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);
		    const ScaleUtils = GeoLeaf.Utils && GeoLeaf.Utils.ScaleUtils;

		    const LayerManager = GeoLeaf._GeoJSONLayerManager = GeoLeaf._GeoJSONLayerManager || {};

		    /**
		     * Affiche une couche (rend visible).
		     *
		     * @param {string} layerId - ID de la couche
		     */
		    LayerManager.showLayer = function (layerId) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] showLayer: couche introuvable :", layerId);
		            return;
		        }

		        // Utiliser le gestionnaire de visibilit√© centralis√©
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
		            return;
		        }

		        const changed = VisibilityManager.setVisibility(
		            layerId,
		            true,
		            VisibilityManager.VisibilitySource.USER
		        );

		        // IMPORTANT: Recalculer la visibilit√© physique en fonction du zoom
		        // setVisibility met √† jour logicalState (bouton), mais il faut aussi recalculer current
		        LayerManager.updateLayerVisibilityByZoom();

		        // Charger la l√©gende si disponible (uniquement si changement effectu√©)
		        if (changed) {
		            LayerManager._loadLayerLegend(layerId, layerData);

		            // G√©rer les labels au moment de l'activation
		            if (GeoLeaf.Labels && GeoLeaf.Labels.hasLabelConfig(layerId)) {
		                // V√©rifier si visibleByDefault est true pour les labels
		                const visibleByDefault = layerData.currentStyle?.label?.visibleByDefault === true;

		                if (visibleByDefault) {
		                    // Activer et afficher les labels imm√©diatement
		                    GeoLeaf.Labels.enableLabels(layerId, {}, true);
		                } else if (GeoLeaf.Labels.areLabelsEnabled(layerId)) {
		                    // Sinon, juste rafra√Æchir si d√©j√† activ√©s
		                    GeoLeaf.Labels.refreshLabels(layerId);
		                }
		            }
		            if (GeoLeaf._LabelButtonManager) {
		                GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		            }

		            Log.debug("[GeoLeaf.GeoJSON] Couche affich√©e :", layerId);
		        }
		    };

		    /**
		     * Masque une couche (rend invisible).
		     *
		     * @param {string} layerId - ID de la couche
		     */
		    LayerManager.hideLayer = function (layerId) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] hideLayer: couche introuvable :", layerId);
		            return;
		        }

		        // Utiliser le gestionnaire de visibilit√© centralis√©
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
		            return;
		        }

		        const changed = VisibilityManager.setVisibility(
		            layerId,
		            false,
		            VisibilityManager.VisibilitySource.USER
		        );

		        // IMPORTANT: Recalculer la visibilit√© physique (even on hide, to ensure consistency)
		        LayerManager.updateLayerVisibilityByZoom();

		        if (changed) {
		            // Masquer les labels et mettre √† jour le bouton
		            if (GeoLeaf.Labels) {
		                GeoLeaf.Labels.disableLabels(layerId);
		            }
		            if (GeoLeaf._LabelButtonManager) {
		                GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		            }

		            Log.debug("[GeoLeaf.GeoJSON] Couche masqu√©e :", layerId);
		        }
		    };

		    /**
		     * Toggle la visibilit√© d'une couche.
		     *
		     * @param {string} layerId - ID de la couche
		     */
		    LayerManager.toggleLayer = function (layerId) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] toggleLayer: couche introuvable :", layerId);
		            return;
		        }

		        // Obtenir l'√©tat actuel via le gestionnaire de visibilit√©
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
		            return;
		        }

		        const visState = VisibilityManager.getVisibilityState(layerId);
		        const currentlyVisible = visState ? visState.current : layerData.visible;

		        // Toggle
		        if (currentlyVisible) {
		            LayerManager.hideLayer(layerId);
		        } else {
		            LayerManager.showLayer(layerId);
		        }
		    };

		    /**
		     * Affiche une couche (interne, sans v√©rifier visible).
		     * @deprecated Utiliser GeoLeaf._LayerVisibilityManager.setVisibility() √† la place
		     * @private
		     */
		    LayerManager._showLayerInternal = function (layerId, layerData) {
		        const Log = getLog();
		        Log.warn("[GeoLeaf.GeoJSON] _showLayerInternal() est d√©pr√©ci√©, utiliser LayerVisibilityManager");

		        // Rediriger vers le gestionnaire centralis√©
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (VisibilityManager) {
		            VisibilityManager.setVisibility(
		                layerId,
		                true,
		                VisibilityManager.VisibilitySource.SYSTEM
		            );
		        }
		    };

		    /**
		     * Masque une couche (interne, sans v√©rifier visible).
		     * @deprecated Utiliser GeoLeaf._LayerVisibilityManager.setVisibility() √† la place
		     * @private
		     */
		    LayerManager._hideLayerInternal = function (layerId, layerData) {
		        const Log = getLog();
		        Log.warn("[GeoLeaf.GeoJSON] _hideLayerInternal() est d√©pr√©ci√©, utiliser LayerVisibilityManager");

		        // Rediriger vers le gestionnaire centralis√©
		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (VisibilityManager) {
		            VisibilityManager.setVisibility(
		                layerId,
		                false,
		                VisibilityManager.VisibilitySource.SYSTEM
		            );
		        }
		    };

		    /**
		     * Met √† jour la visibilit√© des couches en fonction de layerScale du style actif.
		     * Respecte les pr√©f√©rences utilisateur (d√©sactivation manuelle ou par th√®me).
		     * Utilise le gestionnaire de visibilit√© centralis√© avec source 'zoom'.
		     * Ex√©cution imm√©diate pour r√©activit√© pendant le zoom (le debounce LayerManager.refresh √©vite les saccades d'UI).
		     */
		    LayerManager.updateLayerVisibilityByZoom = function () {
		        const state = getState();
		        const Log = getLog();
		        if (!state.map) return;

		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            Log.error("[GeoLeaf.GeoJSON] LayerVisibilityManager non disponible");
		            return;
		        }

		        const currentScale = (ScaleUtils && typeof ScaleUtils.calculateMapScale === "function")
		            ? ScaleUtils.calculateMapScale(state.map, { logger: Log })
		            : 0;

		        const normalizeScaleValue = (value) => {
		            if (typeof value !== "number") return null;
		            return value <= 0 ? null : value;
		        };

		        state.layers.forEach((layerData, layerId) => {
		            const config = layerData.config;
		            if (!config) return;

		            const hasCurrentStyle = !!layerData.currentStyle;
		            const styleScale = hasCurrentStyle ? layerData.currentStyle.layerScale : null;
		            if (!styleScale && hasCurrentStyle) {
		                if (Log && typeof Log.warn === "function") {
		                    Log.warn(`[GeoLeaf.GeoJSON] layerScale manquant pour ${layerId}, couche laiss√©e visible par d√©faut`);
		                }
		            }

		            const minScale = normalizeScaleValue(styleScale && styleScale.minScale);
		            const maxScale = normalizeScaleValue(styleScale && styleScale.maxScale);

		            const shouldBeVisibleByScale = (ScaleUtils && typeof ScaleUtils.isScaleInRange === "function")
		                ? ScaleUtils.isScaleInRange(currentScale, minScale, maxScale, Log)
		                : true;

		            // Base visibility: user override > theme intent > config default
		            const meta = layerData._visibility;
		            let baseVisible;
		            if (meta && meta.userOverride) {
		                // IMPORTANT: Pour userOverride, utiliser logicalState (√©tat bouton), pas current (√©tat zoom)
		                baseVisible = meta.logicalState;
		            } else if (meta && meta.themeOverride) {
		                baseVisible = meta.themeDesired;
		            } else {
		                // visibility.active parameter is deprecated - now managed by layerScale in style files
		                baseVisible = true;
		            }

		            // R√àGLE CRITIQUE :
		            // - L'AFFICHAGE sur la carte RESPECTE TOUJOURS les seuils de zoom
		            // - Le BOUTON (via logicalState) reste ind√©pendant du zoom
		            // - Utilisateur voit : bouton ON, mais couche cach√©e si hors zoom
		            const shouldBeVisible = baseVisible && shouldBeVisibleByScale;

		            VisibilityManager.setVisibility(
		                layerId,
		                shouldBeVisible,
		                VisibilityManager.VisibilitySource.ZOOM
		            );
		        });
		    };

		    /**
		     * √âmet un √©v√©nement de changement de visibilit√©.
		     *
		     * @param {string} layerId
		     * @param {boolean} visible
		     * @private
		     */
		    LayerManager._fireLayerVisibilityEvent = function (layerId, visible) {
		        const state = getState();
		        if (!state.map) return;

		        try {
		            state.map.fire("geoleaf:geojson:visibility-changed", {
		                layerId: layerId,
		                visible: visible
		            });
		        } catch (e) {
		            // Silencieux
		        }
		    };

		})(window);
		return visibility$1;
	}

	requireVisibility$1();

	var style = {};

	/**
	 * GeoLeaf GeoJSON Layer Manager - Style
	 * Style normalization, hatch patterns, style application
	 *
	 * @module geojson/layer-manager/style
	 */

	var hasRequiredStyle;

	function requireStyle () {
		if (hasRequiredStyle) return style;
		hasRequiredStyle = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    const LayerManager = GeoLeaf._GeoJSONLayerManager = GeoLeaf._GeoJSONLayerManager || {};

		    /**
		     * Cr√©e un pattern SVG pour le hachurage
		     * @private
		     * @param {string} layerId - ID de la couche (pour l'unicit√© du pattern)
		     * @param {Object} hatchConfig - Configuration du hachurage
		     * @returns {string} - ID du pattern SVG
		     */
		    function _createHatchPattern(layerId, hatchConfig) {
		        if (!hatchConfig || !hatchConfig.enabled) {
		            return null;
		        }

		        // Cr√©er un ID unique bas√© sur les param√®tres du hatch
		        const type = hatchConfig.type || 'diagonal';
		        const angle = hatchConfig.angleDeg || 0;
		        const spacing = hatchConfig.spacingPx || 10;
		        const strokeColor = (hatchConfig.stroke?.color || '#000000').replace('#', '');
		        const strokeWidth = hatchConfig.stroke?.widthPx || 1;
		        const strokeOpacity = hatchConfig.stroke?.opacity || 1;

		        // Hash des param√®tres pour cr√©er un ID unique
		        const configHash = `${type}-${angle}-${spacing}-${strokeColor}-${strokeWidth}-${strokeOpacity}`;
		        const patternId = `hatch-${layerId}-${configHash}`;

		        // Si le pattern existe d√©j√†, le r√©utiliser
		        const existingPattern = document.getElementById(patternId);
		        if (existingPattern) {
		            return patternId;
		        }

		        // Cr√©er le pattern SVG
		        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
		        pattern.setAttribute('id', patternId);
		        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
		        pattern.setAttribute('width', spacing);
		        pattern.setAttribute('height', spacing);

		        // Cr√©er les lignes selon le type
		        if (type === 'dot') {
		            // Pattern de points (stipple)
		            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		            circle.setAttribute('cx', spacing / 2);
		            circle.setAttribute('cy', spacing / 2);
		            circle.setAttribute('r', Math.max(0.5, strokeWidth / 2));
		            circle.setAttribute('fill', `#${strokeColor}`);
		            circle.setAttribute('fill-opacity', strokeOpacity);
		            pattern.appendChild(circle);
		        } else if (type === 'cross') {
		            // Croix (horizontal + vertical)
		            const lineH = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		            lineH.setAttribute('x1', '0');
		            lineH.setAttribute('y1', spacing / 2);
		            lineH.setAttribute('x2', spacing);
		            lineH.setAttribute('y2', spacing / 2);
		            lineH.setAttribute('stroke', `#${strokeColor}`);
		            lineH.setAttribute('stroke-width', strokeWidth);
		            lineH.setAttribute('stroke-opacity', strokeOpacity);
		            pattern.appendChild(lineH);

		            const lineV = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		            lineV.setAttribute('x1', spacing / 2);
		            lineV.setAttribute('y1', '0');
		            lineV.setAttribute('x2', spacing / 2);
		            lineV.setAttribute('y2', spacing);
		            lineV.setAttribute('stroke', `#${strokeColor}`);
		            lineV.setAttribute('stroke-width', strokeWidth);
		            lineV.setAttribute('stroke-opacity', strokeOpacity);
		            pattern.appendChild(lineV);
		        } else if (type === 'x') {
		            // Croix diagonale (45¬∞ + 135¬∞)
		            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		            line1.setAttribute('x1', '0');
		            line1.setAttribute('y1', '0');
		            line1.setAttribute('x2', spacing);
		            line1.setAttribute('y2', spacing);
		            line1.setAttribute('stroke', `#${strokeColor}`);
		            line1.setAttribute('stroke-width', strokeWidth);
		            line1.setAttribute('stroke-opacity', strokeOpacity);
		            pattern.appendChild(line1);

		            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		            line2.setAttribute('x1', spacing);
		            line2.setAttribute('y1', '0');
		            line2.setAttribute('x2', '0');
		            line2.setAttribute('y2', spacing);
		            line2.setAttribute('stroke', `#${strokeColor}`);
		            line2.setAttribute('stroke-width', strokeWidth);
		            line2.setAttribute('stroke-opacity', strokeOpacity);
		            pattern.appendChild(line2);
		        } else {
		            // Simple ligne (diagonal, horizontal, vertical)
		            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

		            if (type === 'horizontal' || angle === 0) {
		                line.setAttribute('x1', '0');
		                line.setAttribute('y1', spacing / 2);
		                line.setAttribute('x2', spacing);
		                line.setAttribute('y2', spacing / 2);
		            } else if (type === 'vertical' || angle === 90) {
		                line.setAttribute('x1', spacing / 2);
		                line.setAttribute('y1', '0');
		                line.setAttribute('x2', spacing / 2);
		                line.setAttribute('y2', spacing);
		            } else {
		                // Diagonal avec angle - cr√©er une vraie diagonale
		                line.setAttribute('x1', '0');
		                line.setAttribute('y1', '0');
		                line.setAttribute('x2', spacing);
		                line.setAttribute('y2', spacing);
		                // Appliquer la rotation depuis le centre du pattern
		                if (angle != null && angle !== 45) {
		                    const centerX = spacing / 2;
		                    const centerY = spacing / 2;
		                    pattern.setAttribute('patternTransform', `rotate(${angle} ${centerX} ${centerY})`);
		                }
		            }

		            line.setAttribute('stroke', `#${strokeColor}`);
		            line.setAttribute('stroke-width', strokeWidth);
		            line.setAttribute('stroke-opacity', strokeOpacity);
		            pattern.appendChild(line);
		        }

		        // Retourner juste l'ID du pattern
		        // Les patterns seront cr√©√©s dans _applyHatchToLayer quand le SVG Leaflet existe
		        return patternId;
		    }

		    /**
		     * Applique le hachurage SVG √† un layer Leaflet
		     * @private
		     * @param {L.Layer} layer - Layer Leaflet
		     * @param {string} patternId - ID du pattern SVG
		     */
		    function _applyHatchToLayer(layer, patternId, hatchConfig) {
		        if (!layer || !patternId) return;

		        // Log supprim√© pour √©viter des milliers de logs dans les boucles eachLayer
		        // ...log supprim√© pour √©viter du bruit inutile...

		        // S'assurer que le pattern existe dans le SVG de Leaflet
		        let mapSvg = document.querySelector('.leaflet-overlay-pane svg');
		        if (!mapSvg) {
		            // Retry avec d√©lai si SVG n'existe pas encore
		            const retryCount = 5;
		            const retryDelay = 100; // ms
		            let attempts = 0;
		            const tryApplyHatch = () => {
		                mapSvg = document.querySelector('.leaflet-overlay-pane svg');
		                if (mapSvg) {
		                    _applyHatchToLayer(layer, patternId, hatchConfig);
		                    return;
		                }
		                attempts++;
		                if (attempts < retryCount) {
		                    setTimeout(tryApplyHatch, retryDelay);
		                }
		            };
		            setTimeout(tryApplyHatch, retryDelay);
		            return;
		        }

		        // V√©rifier si le pattern existe d√©j√†
		        let pattern = mapSvg.querySelector(`#${patternId}`);
		        if (!pattern && hatchConfig) {
		            // Cr√©er le pattern maintenant
		            const spacing = hatchConfig.spacingPx || 10;
		            const type = hatchConfig.type || 'diagonal';
		            const angle = hatchConfig.angleDeg;
		            const strokeColor = hatchConfig.stroke?.color || '#000000';
		            const strokeWidth = hatchConfig.stroke?.widthPx || 1;
		            const strokeOpacity = hatchConfig.stroke?.opacity || 1;

		            // Assurer que la couleur a toujours le # pour les attributs SVG
		            const colorWithHash = strokeColor.startsWith('#') ? strokeColor : `#${strokeColor}`;

		            pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
		            pattern.setAttribute('id', patternId);
		            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
		            pattern.setAttribute('width', spacing);
		            pattern.setAttribute('height', spacing);

		            // Cr√©er le contenu selon le type
		            if (type === 'dot') {
		                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		                circle.setAttribute('cx', spacing / 2);
		                circle.setAttribute('cy', spacing / 2);
		                // Rayon proportionnel au spacing:
		                // Plus petit spacing (plus dense) = points plus petits
		                // Plus grand spacing (moins dense) = points plus gros pour compenser
		                // spacing 6px ‚Üí r=0.42, spacing 12px ‚Üí r=0.84
		                circle.setAttribute('r', Math.max(0.3, spacing * 0.07));
		                circle.setAttribute('fill', colorWithHash);
		                circle.setAttribute('fill-opacity', strokeOpacity);
		                pattern.appendChild(circle);
		            } else if (type === 'diagonal') {
		                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                line.setAttribute('x1', '0');
		                line.setAttribute('y1', '0');
		                line.setAttribute('x2', spacing);
		                line.setAttribute('y2', spacing);
		                line.setAttribute('stroke', colorWithHash);
		                line.setAttribute('stroke-width', strokeWidth);
		                line.setAttribute('stroke-opacity', strokeOpacity);
		                if (angle != null && angle !== 45) {
		                    const centerX = spacing / 2;
		                    const centerY = spacing / 2;
		                    pattern.setAttribute('patternTransform', `rotate(${angle} ${centerX} ${centerY})`);
		                }
		                pattern.appendChild(line);
		            } else if (type === 'cross') {
		                // Ligne horizontale
		                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                hLine.setAttribute('x1', '0');
		                hLine.setAttribute('y1', spacing / 2);
		                hLine.setAttribute('x2', spacing);
		                hLine.setAttribute('y2', spacing / 2);
		                hLine.setAttribute('stroke', colorWithHash);
		                hLine.setAttribute('stroke-width', strokeWidth);
		                hLine.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(hLine);
		                // Ligne verticale
		                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                vLine.setAttribute('x1', spacing / 2);
		                vLine.setAttribute('y1', '0');
		                vLine.setAttribute('x2', spacing / 2);
		                vLine.setAttribute('y2', spacing);
		                vLine.setAttribute('stroke', colorWithHash);
		                vLine.setAttribute('stroke-width', strokeWidth);
		                vLine.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(vLine);
		            } else if (type === 'x') {
		                // Diagonale principal (TL to BR)
		                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                line1.setAttribute('x1', '0');
		                line1.setAttribute('y1', '0');
		                line1.setAttribute('x2', spacing);
		                line1.setAttribute('y2', spacing);
		                line1.setAttribute('stroke', colorWithHash);
		                line1.setAttribute('stroke-width', strokeWidth);
		                line1.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(line1);
		                // Diagonale secondaire (TR to BL)
		                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                line2.setAttribute('x1', spacing);
		                line2.setAttribute('y1', '0');
		                line2.setAttribute('x2', '0');
		                line2.setAttribute('y2', spacing);
		                line2.setAttribute('stroke', colorWithHash);
		                line2.setAttribute('stroke-width', strokeWidth);
		                line2.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(line2);
		            } else if (type === 'horizontal') {
		                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                line.setAttribute('x1', '0');
		                line.setAttribute('y1', spacing / 2);
		                line.setAttribute('x2', spacing);
		                line.setAttribute('y2', spacing / 2);
		                line.setAttribute('stroke', colorWithHash);
		                line.setAttribute('stroke-width', strokeWidth);
		                line.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(line);
		            } else if (type === 'vertical') {
		                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
		                line.setAttribute('x1', spacing / 2);
		                line.setAttribute('y1', '0');
		                line.setAttribute('x2', spacing / 2);
		                line.setAttribute('y2', spacing);
		                line.setAttribute('stroke', colorWithHash);
		                line.setAttribute('stroke-width', strokeWidth);
		                line.setAttribute('stroke-opacity', strokeOpacity);
		                pattern.appendChild(line);
		            }

		            // Ajouter au defs du SVG
		            let defs = mapSvg.querySelector('defs');
		            if (!defs) {
		                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
		                mapSvg.insertBefore(defs, mapSvg.firstChild);
		            }
		            defs.appendChild(pattern);
		        }

		        // Fonction pour appliquer le pattern √† un √©l√©ment path
		        const applyToPath = (path) => {
		            if (path && path.setAttribute) {
		                const fillUrl = `url(#${patternId})`;
		                const currentFill = path.getAttribute('fill');

		                // N'appliquer que si diff√©rent (√©vite boucle infinie)
		                if (currentFill !== fillUrl) {
		                    path.setAttribute('fill', fillUrl);
		                }

		                // S'assurer que l'opacit√© de remplissage est visible pour les patterns
		                if (hatchConfig && hatchConfig.renderMode === 'pattern_only') {
		                    const curFillOpacity = path.getAttribute('fill-opacity');
		                    if (curFillOpacity == null || Number(curFillOpacity) <= 0) {
		                        path.setAttribute('fill-opacity', '1');
		                    }
		                }

		                // Observer les changements pour r√©appliquer le pattern
		                if (!path._hatchObserver) {
		                    const observer = new MutationObserver((mutations) => {
		                        mutations.forEach((mutation) => {
		                            if (mutation.type === 'attributes' && mutation.attributeName === 'fill') {
		                                const newFill = path.getAttribute('fill');
		                                // Ne r√©appliquer que si vraiment diff√©rent
		                                if (newFill !== fillUrl && !newFill.includes(patternId)) {
		                                    path.setAttribute('fill', fillUrl);
		                                }
		                            }
		                        });
		                    });
		                    observer.observe(path, { attributes: true, attributeFilter: ['fill'] });
		                    path._hatchObserver = observer;
		                }
		            }
		        };

		        // Pour les layers individuels
		        if (layer._path) {
		            applyToPath(layer._path);
		        }

		        // Pour les groupes de layers
		        if (typeof layer.eachLayer === 'function') {
		            layer.eachLayer(sublayer => {
		                if (sublayer._path) {
		                    applyToPath(sublayer._path);
		                }
		            });
		        }
		    }

		    /**
		     * Normalise le format de style vers le format Leaflet
		     * @private
		     * @param {Object} style - Style source (format imbriqu√© ou plat)
		     * @param {string} layerId - ID de la couche (pour les patterns SVG)
		     * @returns {Object} - Style normalis√© au format Leaflet
		     */
		    function _normalizeStyleToLeaflet(style, layerId) {
		        if (!style || typeof style !== 'object') {
		            return {};
		        }

		        const normalized = {};

		        // Nouveau format imbriqu√© avec fill/stroke
		        if (style.fill || style.stroke) {
		            // Fill (remplissage)
		            if (style.fill) {
		                if (style.fill.color) normalized.fillColor = style.fill.color;
		                if (typeof style.fill.opacity === 'number') normalized.fillOpacity = style.fill.opacity;
		                if (style.fill.pattern) normalized.fillPattern = style.fill.pattern;
		            }

		            // Si hatch avec renderMode="pattern_only", forcer un fillColor et une fillOpacity visible
		            // (Leaflet a besoin d'un fillColor pour appliquer un pattern et l'opacit√© doit √™tre > 0)
		            if (style.hatch && style.hatch.enabled && style.hatch.renderMode === 'pattern_only') {
		                if (!normalized.fillColor) normalized.fillColor = '#ffffff';
		                // Override toute valeur de fill.opacity fournie par le style (souvent 0.0) pour rendre le pattern visible
		                normalized.fillOpacity = 1.0;
		            }

		            // Stroke (contour)
		            if (style.stroke) {
		                if (style.stroke.color) normalized.color = style.stroke.color;
		                if (typeof style.stroke.opacity === 'number') normalized.opacity = style.stroke.opacity;
		                if (typeof style.stroke.widthPx === 'number') normalized.weight = style.stroke.widthPx;
		                if (style.stroke.dashArray) normalized.dashArray = style.stroke.dashArray;
		                if (style.stroke.lineCap) normalized.lineCap = style.stroke.lineCap;
		                if (style.stroke.lineJoin) normalized.lineJoin = style.stroke.lineJoin;
		            }

		            // Casing (bordure/contour pour polylines)
		            if (style.casing && style.casing.enabled) {
		                normalized._casing = {
		                    enabled: true,
		                    color: style.casing.color || '#000000',
		                    opacity: typeof style.casing.opacity === 'number' ? style.casing.opacity : 1.0,
		                    weight: typeof style.casing.widthPx === 'number' ? style.casing.widthPx : 1.0,
		                    dashArray: style.casing.dashArray || null,
		                    lineCap: style.casing.lineCap || null,
		                    lineJoin: style.casing.lineJoin || null
		                };
		            }

		            // Propri√©t√©s communes
		            if (style.shape) normalized.shape = style.shape;
		            if (typeof style.sizePx === 'number') {
		                normalized.radius = style.sizePx;
		                normalized.sizePx = style.sizePx;
		            }

		            // Hatch (hachurage) - copie de la structure compl√®te
		            if (style.hatch) {
		                normalized.hatch = { ...style.hatch };
		                // Normaliser le stroke du hatch si pr√©sent
		                if (style.hatch.stroke) {
		                    const hatchStroke = {};
		                    if (style.hatch.stroke.color) hatchStroke.color = style.hatch.stroke.color;
		                    if (typeof style.hatch.stroke.opacity === 'number') hatchStroke.opacity = style.hatch.stroke.opacity;
		                    if (typeof style.hatch.stroke.widthPx === 'number') hatchStroke.widthPx = style.hatch.stroke.widthPx;
		                    normalized.hatch.stroke = hatchStroke;
		                }

		                // Cr√©er le pattern SVG et l'appliquer comme fillPattern
		                if (style.hatch.enabled && layerId) {
		                    const patternId = _createHatchPattern(layerId, style.hatch);
		                    if (patternId) {
		                        // Stocker l'ID du pattern pour application ult√©rieure
		                        normalized._hatchPatternId = patternId;

		                        // Si renderMode = "pattern_only", on utilise le pattern comme fill
		                        // IMPORTANT: on NE d√©finit PAS fillOpacity=0 car cela rendrait le pattern invisible!
		                        // Le pattern SVG s'affichera avec son propre rendu via l'attribut fill="url(#pattern-id)"
		                        if (style.hatch.renderMode === 'pattern_only') {
		                            // Rendre le pattern visible: fillOpacity doit √™tre > 0 et un fillColor doit exister
		                            normalized.fillColor = normalized.fillColor || '#ffffff';
		                            normalized.fillOpacity = 1.0;
		                        }
		                    }
		                }
		            }
		        }
		        // Ancien format plat (r√©trocompatibilit√©)
		        else {
		            // Copier toutes les propri√©t√©s directement
		            Object.assign(normalized, style);
		        }

		        return normalized;
		    }

		    /**
		     * Applique un nouveau style √† une couche existante.
		     * Utilis√© par le module Themes pour changer dynamiquement l'apparence.
		     *
		     * @param {string} layerId - ID de la couche
		     * @param {Object} styleConfig - Configuration du style { style, styleRules }
		     * @returns {boolean} - true si le style a √©t√© appliqu√© avec succ√®s
		     */
		    LayerManager.setLayerStyle = function (layerId, styleConfig) {
		        const state = getState();
		        const Log = getLog();
		        const layerData = state.layers.get(layerId);

		        if (!layerData) {
		            Log.warn("[GeoLeaf.GeoJSON] setLayerStyle: couche introuvable :", layerId);
		            return false;
		        }

		        const leafletLayer = layerData.layer;
		        if (!leafletLayer || typeof leafletLayer.setStyle !== 'function') {
		            Log.warn("[GeoLeaf.GeoJSON] setLayerStyle: couche sans m√©thode setStyle :", layerId);
		            return false;
		        }

		        // Pr√©parer le style par d√©faut (ne pas utiliser defaultStyle qui peut contenir les anciennes valeurs)
		        const baseStyle = {
		            color: '#3388ff',
		            weight: 3,
		            opacity: 0.65,
		            fillColor: '#3388ff',
		            fillOpacity: 0.2
		        };

		        // Normaliser le style (defaultStyle ou style) vers format Leaflet
		        const rawStyle = styleConfig.defaultStyle || styleConfig.style || {};
		        const normalizedStyle = _normalizeStyleToLeaflet(rawStyle, layerId);
		        const defaultStyle = Object.assign({}, baseStyle, normalizedStyle);

		        // Pr√©parer les styleRules
		        const styleRules = Array.isArray(styleConfig.styleRules) ? styleConfig.styleRules : [];

		        // Fonction de style dynamique
		        const styleFn = (feature) => {
		            // 1. Commencer avec le style par d√©faut
		            let finalStyle = Object.assign({}, defaultStyle);

		            // 2. Appliquer les styleRules (premi√®re r√®gle correspondante gagne)
		            if (styleRules.length > 0 && GeoLeaf._GeoJSONStyleResolver) {
		                const matchedStyle = GeoLeaf._GeoJSONStyleResolver.evaluateStyleRules(feature, styleRules);
		                if (matchedStyle) {
		                    // Normaliser le style de la r√®gle vers format Leaflet
		                    const normalizedRuleStyle = _normalizeStyleToLeaflet(matchedStyle, layerId);
		                    finalStyle = Object.assign({}, finalStyle, normalizedRuleStyle);
		                }
		            }

		            // 3. NE PAS appliquer properties.style ou properties.color pour permettre aux r√®gles de s'appliquer
		            // Comment√© car cela √©crase les r√®gles de style
		            // const featureStyle = feature && feature.properties && feature.properties.style
		            //     ? feature.properties.style
		            //     : null;
		            // if (featureStyle) {
		            //     finalStyle = Object.assign({}, finalStyle, featureStyle);
		            // }

		            return finalStyle;
		        };

		        // Appliquer le style √† toutes les features de la couche
		        try {
		            let styled = 0;
		            let markersRecreated = 0;
		            const layersToRecreate = [];

		            // Premi√®re passe : identifier et styler ou marquer pour recr√©ation
		            leafletLayer.eachLayer(function(layer) {
		                if (!layer.feature) {
		                    return;
		                }

		                const style = styleFn(layer.feature);

		                // Cas 1: Layers avec setStyle (Path, CircleMarker, Polyline, etc.)
		                if (layer.setStyle && typeof layer.setStyle === 'function') {
		                    layer.setStyle(style);
		                    styled++;

		                    // G√©rer le casing (bordure pour polylines)
		                    if (style._casing && style._casing.enabled && layer instanceof global.L.Polyline && !(layer instanceof global.L.Polygon)) {
		                        const casingConfig = style._casing;

		                        // Cr√©er ou mettre √† jour la polyline de casing (dessous, plus large)
		                        if (!layer._casingLayer) {
		                            // Cr√©er une nouvelle couche de casing
		                            const casingStyle = {
		                                color: casingConfig.color,
		                                opacity: casingConfig.opacity,
		                                weight: casingConfig.weight,
		                                dashArray: casingConfig.dashArray,
		                                lineCap: casingConfig.lineCap || 'butt',
		                                lineJoin: casingConfig.lineJoin || 'miter',
		                                fill: false
		                            };

		                            layer._casingLayer = global.L.polyline(layer.getLatLngs(), casingStyle);
		                            // Ajouter la couche de casing au m√™me parent (group ou map)
		                            if (leafletLayer && leafletLayer.addLayer) {
		                                leafletLayer.addLayer(layer._casingLayer);
		                            } else if (layer._map) {
		                                layer._map.addLayer(layer._casingLayer);
		                            }
		                            // Mettre la couche de casing derri√®re la couche principale
		                            if (layer._casingLayer.setZIndex) {
		                                layer._casingLayer.setZIndex((layer.options.zIndex || 0) - 1);
		                            }
		                        } else {
		                            // Mettre √† jour le style existant
		                            layer._casingLayer.setStyle({
		                                color: casingConfig.color,
		                                opacity: casingConfig.opacity,
		                                weight: casingConfig.weight,
		                                dashArray: casingConfig.dashArray,
		                                lineCap: casingConfig.lineCap || 'butt',
		                                lineJoin: casingConfig.lineJoin || 'miter'
		                            });
		                        }
		                    } else if (!style._casing || !style._casing.enabled) {
		                        // Supprimer la couche de casing si elle existe mais n'est plus n√©cessaire
		                        if (layer._casingLayer && leafletLayer && leafletLayer.removeLayer) {
		                            leafletLayer.removeLayer(layer._casingLayer);
		                            layer._casingLayer = null;
		                        }
		                    }

		                    // Appliquer le hachurage si pr√©sent dans ce style
		                    if (style._hatchPatternId && style.hatch) {
		                        const patternId = style._hatchPatternId;
		                        const hatchConfig = style.hatch;
		                        // Log supprim√© pour √©viter des milliers de logs (appel√© pour chaque feature)
		                        // ...log supprim√© pour √©viter du bruit inutile...

		                        // Appliquer imm√©diatement si le path existe
		                        if (layer._path) {
		                            setTimeout(() => {
		                                _applyHatchToLayer(layer, patternId, hatchConfig);
		                            }, 0);
		                        }

		                        // Ajouter aussi un listener pour quand le layer est ajout√©/re-ajout√©
		                        if (!layer._hatchPatternId || layer._hatchPatternId !== patternId) {
		                            layer._hatchPatternId = patternId;

		                            // Supprimer l'ancien listener s'il existe
		                            if (layer._hatchListener) {
		                                layer.off('add', layer._hatchListener);
		                            }

		                            // Cr√©er le nouveau listener
		                            layer._hatchListener = function() {
		                                if (this._path) {
		                                    _applyHatchToLayer(this, patternId, hatchConfig);
		                                }
		                            };

		                            layer.on('add', layer._hatchListener);
		                        }
		                    }
		                }
		                // Cas 2: Markers avec ic√¥nes - besoin de recr√©er avec nouvelle ic√¥ne
		                else if (global.L && layer instanceof global.L.Marker) {
		                    layersToRecreate.push({ layer, feature: layer.feature, style });
		                } else ;
		            });

		            // Seconde passe : recr√©er les markers avec les nouvelles couleurs
		            if (layersToRecreate.length > 0) {
		                const POIMarkers = global.GeoLeaf && global.GeoLeaf._POIMarkers;

		                layersToRecreate.forEach(({ layer, feature, style }) => {
		                    const latlng = layer.getLatLng();

		                    // Utiliser le syst√®me POI pour cr√©er une nouvelle ic√¥ne color√©e
		                    if (POIMarkers && typeof POIMarkers.buildMarkerIcon === 'function') {
		                        const poiData = {
		                            ...feature.properties,
		                            latlng: [latlng.lat, latlng.lng],
		                            attributes: feature.properties.attributes || {},
		                            _layerConfig: { style: style } // Passer le style pour resolveCategoryColors
		                        };

		                        let displayConfig = {};
		                        if (typeof POIMarkers.resolveCategoryDisplay === 'function') {
		                            displayConfig = POIMarkers.resolveCategoryDisplay(poiData);
		                        }

		                        // Override avec tous les param√®tres du style
		                        if (style.fillColor) {
		                            displayConfig.colorFill = style.fillColor;
		                        }
		                        if (style.color) {
		                            displayConfig.colorStroke = style.color;
		                        }
		                        if (typeof style.radius === 'number') {
		                            displayConfig.radius = style.radius;
		                        }
		                        if (typeof style.weight === 'number') {
		                            displayConfig.weight = style.weight;
		                        }
		                        if (typeof style.fillOpacity === 'number') {
		                            displayConfig.fillOpacity = style.fillOpacity;
		                        }
		                        if (typeof style.opacity === 'number') {
		                            displayConfig.opacity = style.opacity;
		                        }

		                        const newIcon = POIMarkers.buildMarkerIcon(displayConfig);
		                        layer.setIcon(newIcon);
		                        markersRecreated++;
		                    } else {
		                        // Fallback: remplacer par un CircleMarker
		                        const newMarker = global.L.circleMarker(latlng, style);
		                        newMarker.feature = feature;
		                        leafletLayer.removeLayer(layer);
		                        leafletLayer.addLayer(newMarker);
		                        markersRecreated++;
		                    }
		                });
		            }

		            Log.debug(`[GeoLeaf.GeoJSON] Style appliqu√©: ${styled + markersRecreated} features (${styled} setStyle, ${markersRecreated} markers)`);

		            // Appliquer le hachurage global uniquement si pas de styleRules avec hatch
		            const hasHatchInRules = styleRules.some(rule => rule.style?.hatch?.enabled);

		            if (defaultStyle._hatchPatternId && !hasHatchInRules) {
		                const patternId = defaultStyle._hatchPatternId;

		                // Appliquer imm√©diatement
		                _applyHatchToLayer(leafletLayer, patternId);

		                // Log r√©sum√© au lieu de logs individuels
		                Log.debug(`[GeoLeaf.GeoJSON] Hachures appliqu√©es: pattern=${patternId}, features=${styled}`);

		                // Supprimer les anciens listeners pour √©viter les doublons
		                if (layerData._hatchListeners) {
		                    leafletLayer.off('add', layerData._hatchListeners.onAdd);
		                    if (global.L && global.L.DomEvent) {
		                        leafletLayer.eachLayer(layer => {
		                            if (layer._path) {
		                                layer.off('add', layerData._hatchListeners.onLayerAdd);
		                            }
		                        });
		                    }
		                }

		                // Cr√©er les listeners pour r√©appliquer le hachurage apr√®s les redraws
		                const onAdd = () => {
		                    setTimeout(() => _applyHatchToLayer(leafletLayer, patternId), 0);
		                };

		                const onLayerAdd = function() {
		                    if (this._path) {
		                        this._path.setAttribute('fill', `url(#${patternId})`);
		                    }
		                };

		                // Ajouter les listeners
		                leafletLayer.on('add', onAdd);
		                leafletLayer.eachLayer(layer => {
		                    if (layer._path) {
		                        layer.on('add', onLayerAdd);
		                    }
		                });

		                // Stocker les listeners pour nettoyage futur
		                layerData._hatchListeners = { onAdd, onLayerAdd };
		                layerData._hatchPatternId = patternId;
		            }

		            // Mettre √† jour la config stock√©e pour que les futures √©valuations utilisent le nouveau style
		            layerData.config = Object.assign({}, layerData.config, {
		                style: styleConfig.defaultStyle || styleConfig.style,
		                styleRules: styleRules
		            });

		            // Stocker currentStyle pour les labels
		            layerData.currentStyle = styleConfig;

		            // Mettre √† jour l'√©tat du bouton des labels imm√©diatement
		            if (GeoLeaf._LabelButtonManager) {
		                GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		            }

		            // R√©√©valuer la visibilit√© apr√®s application du style (layerScale)
		            if (GeoLeaf._GeoJSONLayerManager && typeof GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom === "function") {
		                GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom();
		            }

		            Log.debug("[GeoLeaf.GeoJSON] Style appliqu√© avec succ√®s :", layerId);
		            return true;
		        } catch (err) {
		            Log.error("[GeoLeaf.GeoJSON] Erreur setLayerStyle :", layerId, err.message);
		            return false;
		        }
		    };

		})(window);
		return style;
	}

	requireStyle();

	var integration = {};

	/**
	 * GeoLeaf GeoJSON Layer Manager - Integration
	 * Layer Manager UI registration, legend loading, populate with all configs
	 *
	 * @module geojson/layer-manager/integration
	 */

	var hasRequiredIntegration;

	function requireIntegration () {
		if (hasRequiredIntegration) return integration;
		hasRequiredIntegration = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    const LayerManager = GeoLeaf._GeoJSONLayerManager = GeoLeaf._GeoJSONLayerManager || {};

		    /**
		     * Enregistre les couches dans le module LayerManager.
		     */
		    LayerManager.registerWithLayerManager = function () {
		        const state = getState();
		        const Log = getLog();
		        const LMgr = GeoLeaf.LayerManager;

		        Log.info(`[GeoLeaf.GeoJSON] registerWithLayerManager() appel√© avec ${state.layers.size} couche(s)`);

		        if (!LMgr || typeof LMgr._registerGeoJsonLayer !== "function") {
		            Log.warn("[GeoLeaf.GeoJSON] Module LayerManager non disponible, pas d'int√©gration gestionnaire de couches");
		            return;
		        }

		        // Grouper les layers par idSection
		        const sectionMap = new Map();

		        state.layers.forEach((layerData, id) => {
		            // Log pour debug - VOIR TOUTES LES COUCHES
		            // Utiliser layerManagerId d√©fini dans layer.json
		            const sectionId = layerData.config.layerManagerId || "geojson-default";

		            if (!sectionMap.has(sectionId)) {
		                sectionMap.set(sectionId, {
		                    id: sectionId,
		                    order: 99,
		                    items: []
		                });
		            }

		            const type = LayerManager.detectLayerType(layerData.layer);
		            let legendType = "fill";
		            if (type === "poi") legendType = "circle";
		            else if (type === "route") legendType = "line";
		            else if (type === "area") legendType = "fill";

		            let color = "#3388ff";
		            if (layerData.config.style) {
		                color = layerData.config.style.fillColor || layerData.config.style.color || color;
		            } else if (layerData.config.pointStyle) {
		                color = layerData.config.pointStyle.fillColor || color;
		            }

		            // D√©tecter si la couche a des labels (dans la config OU dans le style courant)
		            let hasLabels = false;
		            let labelsConfig = null;

		            // V√©rifier d'abord dans la config de la couche
		            if (layerData.config.labels && layerData.config.labels.enabled) {
		                hasLabels = true;
		                labelsConfig = layerData.config.labels;
		            }

		            // V√©rifier ensuite dans le style actuel (currentStyle)
		            if (!hasLabels && layerData.currentStyle && layerData.currentStyle.label && layerData.currentStyle.label.enabled) {
		                hasLabels = true;
		                // Cr√©er une config de labels minimale bas√©e sur le style
		                labelsConfig = { enabled: true };
		            }

		            // Log pour TOUTES les couches pour comprendre le probl√®me
		            if (Log) {
		                Log.info(`[GeoJSON LayerManager] üîç Pr√©paration item ${id}:`, {
		                    hasConfig: !!layerData.config,
		                    hasStyles: !!(layerData.config && layerData.config.styles),
		                    styles: layerData.config ? layerData.config.styles : 'NO CONFIG',
		                    configKeys: layerData.config ? Object.keys(layerData.config).sort() : []
		                });
		            }

		            sectionMap.get(sectionId).items.push({
		                id: id,
		                label: layerData.label,
		                type: legendType,
		                color: color,
		                visible: layerData.visible,
		                toggleable: true,
		                order: 0,
		                zIndex: layerData.config.zIndex || 0,
		                themes: layerData.config.themes || null,
		                labels: hasLabels ? labelsConfig : null,
		                styles: layerData.config.styles || null
		            });
		        });

		        // Ajouter chaque section au gestionnaire de couches
		        sectionMap.forEach((section) => {
		            // Trier les items par zIndex d√©croissant (zIndex √©lev√© = en haut = affich√© au-dessus)
		            section.items.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));

		            // Enregistrer chaque couche dans le LayerManager
		            section.items.forEach((item) => {
		                Log.debug(`[GeoLeaf.GeoJSON] Enregistrement couche "${item.id}" dans section "${section.id}"`);
		                LMgr._registerGeoJsonLayer(item.id, {
		                    layerManagerId: section.id,
		                    label: item.label,
		                    themes: item.themes,
		                    styles: item.styles,
		                    labels: item.labels
		                });
		            });

		            Log.debug("[GeoLeaf.GeoJSON] Section couche '" + section.id + "' cr√©√©e avec " + section.items.length + " couche(s)");
		        });
		    };

		    /**
		     * Charge la l√©gende d'une couche si disponible
		     * @param {string} layerId - ID de la couche
		     * @param {Object} layerData - Donn√©es de la couche
		     * @private
		     */
		    LayerManager._loadLayerLegend = function (layerId, layerData) {
		        const Log = getLog();

		        const config = layerData.config || {};

		        // Nouveau flux : g√©n√©rer la l√©gende depuis le style JSON
		        if (GeoLeaf.Legend && typeof GeoLeaf.Legend.loadLayerLegend === "function") {
		            // D√©terminer le style courant
		            const styleSelector = GeoLeaf._LayerManagerStyleSelector;
		            let styleId = null;

		            if (styleSelector && typeof styleSelector.getCurrentStyle === "function") {
		                styleId = styleSelector.getCurrentStyle(layerId) || null;
		            }

		            // Fallback depuis metadata √©ventuelle
		            if (!styleId && layerData.currentStyleMetadata && layerData.currentStyleMetadata.id) {
		                styleId = layerData.currentStyleMetadata.id;
		            }

		            // Fallback depuis la config de styles
		            if (!styleId && config.styles && Array.isArray(config.styles.available)) {
		                const available = config.styles.available;
		                // Essayer de trouver l'ID correspondant au fichier default
		                const defaultFile = config.styles.default;
		                const defaultByFile = defaultFile ? available.find(s => s.file === defaultFile) : null;
		                styleId = (defaultByFile && defaultByFile.id) || (available[0] && available[0].id) || "default";
		            }

		            if (!styleId) {
		                styleId = "default";
		            }

		            GeoLeaf.Legend.loadLayerLegend(layerId, styleId, config);
		            return;
		        }

		        // Legacy fallback: charger un fichier de l√©gende statique si d√©clar√©
		        if (!GeoLeaf.Legend || typeof GeoLeaf.Legend.addLayerLegend !== "function") {
		            return;
		        }

		        if (!config.legends || !Array.isArray(config.legends.available)) {
		            return;
		        }

		        let activeStyle = layerData.activeStyle;
		        if (!activeStyle && config.styles && Array.isArray(config.styles.available)) {
		            const defaultStyle = config.styles.available.find(s => s.id === "default");
		            activeStyle = defaultStyle ? defaultStyle.id : (config.styles.available[0] ? config.styles.available[0].id : "default");
		        }
		        if (!activeStyle) {
		            activeStyle = "default";
		        }

		        const legendEntry = config.legends.available.find(l => l.id === activeStyle);
		        if (!legendEntry || !legendEntry.file) {
		            Log.warn(`[GeoLeaf.GeoJSON] Pas de l√©gende trouv√©e pour le style ${activeStyle} de la couche ${layerId}`);
		            return;
		        }

		        const profileId = config._profileId;
		        const layerDir = config._layerDirectory;
		        const legendDir = config.legends.directory || "legends";

		        if (!profileId || !layerDir) {
		            Log.warn("[GeoLeaf.GeoJSON] M√©tadonn√©es manquantes (profileId ou layerDirectory) pour charger la l√©gende");
		            return;
		        }

		        const Config = GeoLeaf.Config;
		        const dataCfg = Config && Config.get ? Config.get('data') : null;
		        const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";

		        const legendPath = `${profilesBasePath}/${profileId}/${layerDir}/${legendDir}/${legendEntry.file}`;

		        fetch(legendPath)
		            .then(response => {
		                if (!response.ok) {
		                    throw new Error(`HTTP ${response.status}`);
		                }
		                return response.json();
		            })
		            .then(legendData => {
		                GeoLeaf.Legend.addLayerLegend(layerId, activeStyle, legendData);
		                Log.debug(`[GeoLeaf.GeoJSON] L√©gende charg√©e pour ${layerId} (${activeStyle})`);
		            })
		            .catch(error => {
		                Log.warn(`[GeoLeaf.GeoJSON] Erreur chargement l√©gende pour ${layerId}:`, error.message);
		            });
		    };

		    /**
		     * Peuple le LayerManager avec TOUTES les configurations de couches disponibles.
		     * Contrairement √† registerWithLayerManager() qui ne montre que les couches charg√©es (th√®me actif),
		     * cette fonction affiche TOUTES les couches et met √† jour l'√©tat coch√© selon le th√®me actif.
		     *
		     * @param {Object} activeThemeConfig - Configuration du th√®me actif (contient liste des layers visibles)
		     * @returns {void}
		     */
		    LayerManager.populateLayerManagerWithAllConfigs = function(activeThemeConfig) {
		            // ...logs nettoy√©s...
		        const Log = getLog();
		        const LMgr = GeoLeaf.LayerManager;

		        if (!LMgr || typeof LMgr._registerGeoJsonLayer !== "function") {
		            Log.warn("[GeoLeaf.GeoJSON] populateLayerManagerWithAllConfigs: Module LayerManager non disponible");
		            return;
		        }

		        if (!GeoLeaf._allLayerConfigs || !Array.isArray(GeoLeaf._allLayerConfigs)) {
		            Log.warn("[GeoLeaf.GeoJSON] populateLayerManagerWithAllConfigs: GeoLeaf._allLayerConfigs non disponible");
		            return;
		        }

		        Log.info(`[GeoLeaf.GeoJSON] Peuplement LayerManager avec ${GeoLeaf._allLayerConfigs.length} configs de couches...`);
		        // ...log debug supprim√©...

		        // Obtenir la liste des couches actives du th√®me
		        // Les layers peuvent √™tre des objets {id, visible, style} ou des strings simples
		        let activeThemeLayers = [];
		        if (activeThemeConfig && Array.isArray(activeThemeConfig.layers)) {
		            activeThemeLayers = activeThemeConfig.layers.map(l => l.id || l);
		        }
		        Log.debug(`[GeoLeaf.GeoJSON] Couches actives du th√®me: ${activeThemeLayers.join(', ')}`);

		        // Grouper les configs par sectionId (layerManagerId)
		        const sectionMap = new Map();

		        GeoLeaf._allLayerConfigs.forEach(config => {
		            const sectionId = config.layerManagerId || "geojson-default";

		            if (!sectionMap.has(sectionId)) {
		                sectionMap.set(sectionId, {
		                    id: sectionId,
		                    items: []
		                });
		            }

		            // D√©terminer si la couche est active dans le th√®me courant
		            const isActive = activeThemeLayers.includes(config.id);

		            // Log pour debug - VOIR CE QUI EST DANS config POUR TOUTES LES COUCHES
		            // ...logs supprim√©s ([GeoJSON LayerManager] config debug)...

		            sectionMap.get(sectionId).items.push({
		                id: config.id,
		                label: config.label,
		                layerManagerId: sectionId,
		                themes: config.themes || null,
		                isActive: isActive,
		                zIndex: config.zIndex || 0,
		                styles: config.styles || null,
		                labels: config.labels || null
		            });
		        });

		        // Enregistrer chaque couche avec le LayerManager
		        sectionMap.forEach((section) => {
		            // Trier par zIndex d√©croissant
		            section.items.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));

		            section.items.forEach((item) => {
		                Log.debug(`[GeoLeaf.GeoJSON] Enregistrement couche "${item.id}" dans section "${section.id}" (actif: ${item.isActive})`);
		                LMgr._registerGeoJsonLayer(item.id, {
		                    layerManagerId: section.id,
		                    label: item.label,
		                    themes: item.themes,
		                    checked: item.isActive,
		                    styles: item.styles,
		                    labels: item.labels
		                });
		            });

		            Log.debug(`[GeoLeaf.GeoJSON] Section "${section.id}" peupl√©e avec ${section.items.length} couche(s)`);
		        });

		        Log.info(`[GeoLeaf.GeoJSON] LayerManager peupl√© avec succ√®s`);

		        // Mettre √† jour l'UI du LayerManager si n√©cessaire
		        if (LMgr._updateUI && typeof LMgr._updateUI === "function") {
		            Log.debug("[GeoLeaf.GeoJSON] Appel LayerManager._updateUI()");
		            LMgr._updateUI();
		        }
		    };

		})(window);
		return integration;
	}

	requireIntegration();

	var popupTooltip = {};

	/**
	 * GeoLeaf GeoJSON Module - Popup & Tooltip
	 * Gestion des popups et tooltips unifi√©s
	 *
	 * @module geojson/popup-tooltip
	 */

	var hasRequiredPopupTooltip;

	function requirePopupTooltip () {
		if (hasRequiredPopupTooltip) return popupTooltip;
		hasRequiredPopupTooltip = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONPopupTooltip = GeoLeaf._GeoJSONPopupTooltip || {};

		    /**
		     * Convertit une feature GeoJSON en format POI pour le side panel.
		     * Utilise _Normalizer si disponible, sinon cr√©e un POI par d√©faut.
		     * Enrichissement centralis√© pour tous les POIs.
		     *
		     * @param {Object} feature - Feature GeoJSON
		     * @param {Object} def - D√©finition de la couche
		     * @returns {Object} - Objet POI format√©
		     */
		    GeoLeaf._GeoJSONPopupTooltip.convertFeatureToPOI = function (feature, def) {
		        let poi;

		        // Utiliser le Normalizer centralis√© si disponible
		        const Normalizer = GeoLeaf._Normalizer;
		        if (Normalizer && typeof Normalizer.normalizeFromGeoJSON === 'function') {
		            poi = Normalizer.normalizeFromGeoJSON(feature, def);
		        } else {
		            // Fallback: logique locale
		            const props = feature.properties || {};

		            poi = {
		                id: props.id || ("geojson-feature-" + Math.random().toString(36).substr(2, 9)),
		                // R√©solution case-insensitive du titre (28 janvier 2026)
		                title: props.NAME || props.Name || props.name ||
		                       props.TITLE || props.Title || props.title ||
		                       props.LABEL || props.Label || props.label || "Sans titre",
		                description: props.description || props.desc || "",
		                // Conserver properties pour compatibilit√© avec les configs qui utilisent "properties.field"
		                properties: { ...props },
		                attributes: {
		                    source: "geojson",
		                    layerId: def.id,
		                    layerLabel: def.label,
		                    ...props
		                }
		            };

		            // Ajouter les coordonn√©es dans tous les formats support√©s
		            if (feature.geometry && feature.geometry.coordinates) {
		                // Format latlng array [lat, lng] pour compatibilit√© POI
		                poi.latlng = [
		                    feature.geometry.coordinates[1], // lat
		                    feature.geometry.coordinates[0]  // lng
		                ];
		                // Format geometry pour compatibilit√© GeoJSON
		                poi.geometry = feature.geometry;
		                // Format location pour compatibilit√© legacy
		                poi.location = {
		                    lat: feature.geometry.coordinates[1],
		                    lng: feature.geometry.coordinates[0]
		                };
		            }
		        }

		        // Enrichissement centralis√© pour tous les POIs
		        if (poi) {
		            poi.attributes = poi.attributes || {};
		            poi.attributes.source = "geojson";
		            poi.attributes.layerId = def.id;
		            poi.attributes.layerLabel = def.label;

		            // Attacher la configuration de la couche
		            poi._layerConfig = def;

		            // Utiliser getSidepanelConfig pour la normalisation correcte
		            const Loader = GeoLeaf._GeoJSONLoader;
		            const sidepanelLayout = Loader && Loader.getSidepanelConfig ? Loader.getSidepanelConfig(def) : null;
		            if (sidepanelLayout) {
		                poi._sidepanelConfig = {
		                    detailLayout: sidepanelLayout
		                };
		            }
		        }

		        return poi;
		    };

		    /**
		     * Attache un popup unifi√© compatible avec le syst√®me POI.
		     *
		     * @param {Object} feature - Feature GeoJSON
		     * @param {L.Layer} layer - Couche Leaflet
		     * @param {Object} def - D√©finition de la couche
		     */
		    GeoLeaf._GeoJSONPopupTooltip.bindUnifiedPopup = function (feature, layer, def) {
		        const Log = getLog();

		        if (!feature.properties) return;

		        // Si interactiveShape est false, ne rien attacher (la couche est non-cliquable)
		        if (def.interactiveShape === false) {
		            return;
		        }

		        // V√©rifier le param√®tre showPopup de la couche (d√©faut: true)
		        const showPopup = typeof def.showPopup === 'boolean' ? def.showPopup : true;

		        // Si showPopup est false, mode DIRECT: toggle du panneau lat√©ral au clic (sans popup)
		        if (!showPopup) {
		            layer.on("click", (e) => {
		                if (e && e.originalEvent) e.originalEvent.stopPropagation();

		                // Masquer le tooltip si pr√©sent
		                if (layer.getTooltip && layer.getTooltip()) {
		                    try {
		                        if (typeof layer.closeTooltip === 'function') layer.closeTooltip();
		                        else layer.unbindTooltip();
		                    } catch (err) { /* ignore */ }
		                }

		                if (GeoLeaf.POI && typeof GeoLeaf.POI.showPoiDetails === "function") {
		                    const poiData = GeoLeaf._GeoJSONPopupTooltip.convertFeatureToPOI(feature, def);
		                    const shared = GeoLeaf._POIShared && GeoLeaf._POIShared.state;
		                    const current = shared ? shared.currentPoiInPanel : null;

		                    // Toggle: si le m√™me POI est ouvert, fermer le panneau, sinon l'ouvrir
		                    if (current && poiData && current.id && poiData.id && current.id === poiData.id) {
		                        if (GeoLeaf.POI && typeof GeoLeaf.POI.hideSidePanel === 'function') {
		                            GeoLeaf.POI.hideSidePanel();
		                        }
		                    } else {
		                        GeoLeaf.POI.showPoiDetails(poiData);
		                    }
		                }
		            });
		            return;
		        }

		        // Si un popup existe d√©j√† (cr√©√© par POI Markers), le conserver
		        if (layer.getPopup()) {
		            return;
		        }

		        // Convertir la feature en POI normalis√©
		        const poiData = GeoLeaf._GeoJSONPopupTooltip.convertFeatureToPOI(feature, def);

		        // Utiliser ContentBuilder si disponible
		        const ContentBuilder = GeoLeaf._ContentBuilder;
		        // Utiliser le helper pour r√©cup√©rer la config popup (28 janvier 2026)
		        const Loader = GeoLeaf._GeoJSONLoader;

		        let popupConfig = null;
		        try {
		            popupConfig = Loader && Loader.getPopupConfig ? Loader.getPopupConfig(def) : null;
		        } catch (e) {
		            // ...log supprim√© ([DEBUG] bindUnifiedPopup - ERREUR getPopupConfig)...
		        }

		        // ...logs supprim√©s ([POPUP] bindUnifiedPopup)...
		        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === 'function') {
		            const markersModule = GeoLeaf._POIMarkers;
		            const resolveCategoryDisplay = markersModule && typeof markersModule.resolveCategoryDisplay === 'function'
		                ? markersModule.resolveCategoryDisplay
		                : null;

		            const popupContent = ContentBuilder.buildPopupHTML(poiData, popupConfig, {
		                resolveCategoryDisplay: resolveCategoryDisplay
		            });

		            if (popupContent) {
		                layer.bindPopup(popupContent);
		            }
		        } else {
		            // Fallback: utiliser POIPopup module
		            const popupModule = GeoLeaf._POIPopup;
		            if (popupModule && typeof popupModule.buildQuickPopupContent === 'function') {
		                const markersModule = GeoLeaf._POIMarkers;
		                const resolveCategoryDisplay = markersModule && typeof markersModule.resolveCategoryDisplay === 'function'
		                    ? markersModule.resolveCategoryDisplay
		                    : null;

		                const popupContent = popupModule.buildQuickPopupContent(poiData, resolveCategoryDisplay);
		                if (popupContent) {
		                    layer.bindPopup(popupContent);
		                }
		            } else {
		                // Fallback minimal sans modules
		                const Security = GeoLeaf.Security || {
		                    escapeHtml: (str) => {
		                        if (!str) return "";
		                        const div = document.createElement("div");
		                        div.textContent = String(str);
		                        return div.innerHTML;
		                    }
		                };

		                const props = feature.properties;
		                const name = props.name || props.label || props.title || "Sans titre";
		                const description = props.description || props.desc || "";

		                let popupHtml = '<div class="gl-geojson-popup">';
		                popupHtml += '<h3 class="gl-popup-title">' + Security.escapeHtml(name) + '</h3>';

		                if (description) {
		                    popupHtml += '<p class="gl-popup-description">' + Security.escapeHtml(description) + '</p>';
		                }

		                if (GeoLeaf.POI && typeof GeoLeaf.POI.showPoiDetails === "function") {
		                    popupHtml += '<a href="#" class="gl-poi-popup__link" data-layer-id="' + def.id + '" data-feature-id="' + (props.id || '') + '">Voir d√©tails ‚Üí</a>';
		                }

		                popupHtml += '</div>';
		                layer.bindPopup(popupHtml);
		            }
		        }

		        // Flag pour tracker l'√©tat du popup
		        layer._geoleafPopupActive = false;

		        // Fermer le tooltip quand le popup s'ouvre
		        layer.on('popupopen', () => {
		            layer._geoleafPopupActive = true;

		            // Fermer le tooltip si pr√©sent
		            if (layer.getTooltip && layer.getTooltip()) {
		                try {
		                    if (typeof layer.closeTooltip === 'function') {
		                        layer.closeTooltip();
		                    }
		                } catch (err) {
		                    Log.warn('[GeoJSON] Erreur fermeture tooltip:', err);
		                }
		            }

		            // D√©l√©gation d'√©v√©nement pour le lien "Voir d√©tails"
		            const popup = layer.getPopup();
		            if (!popup) return;

		            const popupEl = popup.getElement();
		            if (!popupEl) return;

		            const link = popupEl.querySelector('.gl-poi-popup__link');
		            if (link) {
		                link.addEventListener('click', (e) => {
		                    e.preventDefault();
		                    if (GeoLeaf.POI && typeof GeoLeaf.POI.showPoiDetails === "function") {
		                        const poiData = GeoLeaf._GeoJSONPopupTooltip.convertFeatureToPOI(feature, def);
		                        GeoLeaf.POI.showPoiDetails(poiData);
		                    }
		                });
		            }
		        });

		        // R√©activer le tooltip quand le popup se ferme
		        layer.on('popupclose', () => {
		            layer._geoleafPopupActive = false;

		            // R√©ouvrir le tooltip s'il est permanent (mode "always")
		            if (layer.getTooltip() && layer.getTooltip().options.permanent) {
		                setTimeout(() => {
		                    if (layer.openTooltip && !layer._geoleafPopupActive) {
		                        layer.openTooltip();
		                    }
		                }, 50);
		            }
		        });
		    };

		    /**
		     * Attache un tooltip unifi√© √† une couche selon sa configuration.
		     *
		     * @param {Object} feature - Feature GeoJSON
		     * @param {L.Layer} layer - Couche Leaflet
		     * @param {Object} def - D√©finition de la couche
		     */
		    GeoLeaf._GeoJSONPopupTooltip.bindUnifiedTooltip = function (feature, layer, def) {
		        const state = getState();

		        if (!feature.properties || !layer) return;

		        // R√©cup√©rer les param√®tres de tooltip de la couche
		        const tooltipMode = def.tooltipMode || "hover"; // "always", "never", "hover"
		        const tooltipMinZoom = typeof def.tooltipMinZoom === "number" ? def.tooltipMinZoom : 0;

		        // Si mode "never", ne rien faire
		        if (tooltipMode === "never") {
		            return;
		        }

		        // Construire le texte du tooltip par d√©faut
		        const props = feature.properties;
		        const tooltipText = props.name || props.label || props.title || props.id || "Sans titre";

		        // Utiliser le helper pour r√©cup√©rer la config tooltip (28 janvier 2026)
		        const Loader = GeoLeaf._GeoJSONLoader;
		        const tooltipConfig = Loader && Loader.getTooltipConfig ? Loader.getTooltipConfig(def) : null;

		        // Convertir la feature en POI pour avoir access aux champs via attributes.*
		        const featureAsPoi = GeoLeaf._GeoJSONPopupTooltip.convertFeatureToPOI(feature, def);

		        // Fonction pour construire le contenu du tooltip
		        const buildTooltipContent = () => {
		            // Utiliser ContentBuilder si disponible
		            const ContentBuilder = GeoLeaf._ContentBuilder;
		            if (ContentBuilder && typeof ContentBuilder.buildTooltipHTML === 'function') {
		                const content = ContentBuilder.buildTooltipHTML(featureAsPoi, tooltipConfig);
		                return content || tooltipText;
		            }

		            // Fallback: utiliser POIPopup module
		            const POIPopup = GeoLeaf._POIPopup;
		            if (POIPopup && typeof POIPopup.buildTooltipContent === 'function') {
		                const content = POIPopup.buildTooltipContent(featureAsPoi);
		                return content || tooltipText;
		            }

		            // Fallback minimal
		            return tooltipText;
		        };

		        // Fonction pour g√©rer l'affichage du tooltip selon le zoom
		        const updateTooltipVisibility = () => {
		            if (!state.map) return;

		            // Ne pas afficher le tooltip si un popup est actif sur cette couche
		            if (layer._geoleafPopupActive) return;

		            const currentZoom = state.map.getZoom();
		            const shouldShow = currentZoom >= tooltipMinZoom;

		            const content = buildTooltipContent();

		            if (shouldShow) {
		                if (!layer.getTooltip()) {
		                    const opts = {
		                        direction: 'top',
		                        offset: [0, -10],
		                        opacity: 0.9,
		                        className: 'gl-geojson-tooltip',
		                        permanent: tooltipMode === 'always'
		                    };
		                    layer.bindTooltip(content, opts);
		                    if (tooltipMode === 'always' && layer.openTooltip) {
		                        layer.openTooltip();
		                    }
		                } else {
		                    // update existing tooltip content
		                    const tooltip = layer.getTooltip();
		                    if (tooltip && tooltip.setContent) tooltip.setContent(content);
		                }
		            } else {
		                if (layer.getTooltip()) {
		                    try {
		                        if (typeof layer.closeTooltip === 'function') {
		                            layer.closeTooltip();
		                        } else {
		                            layer.unbindTooltip();
		                        }
		                    } catch (err) {
		                        /* ignore */
		                    }
		                }
		            }
		        };

		        // Stocker la r√©f√©rence pour le nettoyage
		        layer._geoleafTooltipUpdate = updateTooltipVisibility;

		        // Bloquer l'ouverture du tooltip pendant que le popup est actif
		        layer.on('tooltipopen', (e) => {
		            if (layer._geoleafPopupActive) {
		                layer.closeTooltip();
		            }
		        });

		        // Attendre que la couche soit ajout√©e √† la map avant d'initialiser
		        layer.on('add', () => {
		            // Initialiser le tooltip
		            updateTooltipVisibility();

		            // Ajouter le listener sur le zoom
		            if (state.map) {
		                state.map.on('zoomend', updateTooltipVisibility);
		            }
		        });

		        // Nettoyer le listener quand la couche est retir√©e
		        layer.on('remove', () => {
		            if (state.map && layer._geoleafTooltipUpdate) {
		                state.map.off('zoomend', layer._geoleafTooltipUpdate);
		            }
		        });
		    };

		})(window);
		return popupTooltip;
	}

	requirePopupTooltip();

	var clustering = {};

	/**
	 * GeoLeaf GeoJSON Module - Clustering
	 * Gestion des strat√©gies de clustering (unified, by-source, etc.)
	 *
	 * @module geojson/clustering
	 */

	var hasRequiredClustering;

	function requireClustering () {
		if (hasRequiredClustering) return clustering;
		hasRequiredClustering = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONClustering = GeoLeaf._GeoJSONClustering || {};

		    /**
		     * R√©cup√®re la configuration POI globale.
		     *
		     * @returns {Object}
		     */
		    GeoLeaf._GeoJSONClustering.getPoiConfig = function () {
		        const Config = GeoLeaf.Config;
		        if (Config && typeof Config.get === "function") {
		            return Config.get("poiConfig") || {};
		        }
		        return {};
		    };

		    /**
		     * R√©cup√®re le cluster partag√© du module POI s'il existe.
		     *
		     * @returns {L.MarkerClusterGroup|null}
		     */
		    GeoLeaf._GeoJSONClustering.getSharedPOICluster = function () {
		        const Log = getLog();

		        try {
		            const POI = GeoLeaf.POI;
		            if (!POI || typeof POI.getLayer !== "function") {
		                Log.info("[GeoLeaf.GeoJSON] ‚ùå Module POI non disponible ou getLayer() manquant");
		                return null;
		            }

		            const poiLayer = POI.getLayer();

		            if (!poiLayer) {
		                Log.info("[GeoLeaf.GeoJSON] ‚ùå POI.getLayer() retourne null/undefined");
		                return null;
		            }

		            Log.info("[GeoLeaf.GeoJSON] üîç POI.getLayer() retourn√©:", {
		                hasAddLayer: typeof poiLayer.addLayer === "function",
		                hasRemoveLayer: typeof poiLayer.removeLayer === "function",
		                hasFeatureGroup: poiLayer._featureGroup !== undefined,
		                hasGroup: poiLayer._group !== undefined,
		                hasClusterGroup: poiLayer._markerCluster !== undefined,
		                isMarkerClusterGroup: poiLayer.constructor && poiLayer.constructor.name === 'MarkerClusterGroup',
		                constructor: poiLayer.constructor ? poiLayer.constructor.name : 'unknown'
		            });

		            // V√©rifier si c'est un markerClusterGroup ou LayerGroup valide
		            // Accepter tout layer avec addLayer/removeLayer (plus permissif)
		            if (poiLayer &&
		                typeof poiLayer.addLayer === "function" &&
		                typeof poiLayer.removeLayer === "function") {
		                Log.info("[GeoLeaf.GeoJSON] ‚úÖ Cluster/Layer POI r√©cup√©r√© avec succ√®s");
		                return poiLayer;
		            }

		            Log.warn("[GeoLeaf.GeoJSON] ‚ùå POI.getLayer() ne retourne pas un layer valide (checks failed)");
		        } catch (e) {
		            Log.error("[GeoLeaf.GeoJSON] ‚ùå Impossible de r√©cup√©rer le cluster POI :", e);
		        }
		        return null;
		    };

		    /**
		     * D√©termine la strat√©gie de clustering pour une couche.
		     *
		     * @param {Object} def - D√©finition de la couche
		     * @param {Object} geojsonData - Donn√©es GeoJSON
		     * @returns {Object} - { shouldCluster: boolean, useSharedCluster: boolean }
		     */
		    GeoLeaf._GeoJSONClustering.getClusteringStrategy = function (def, geojsonData) {
		        const Log = getLog();
		        const poiConfig = GeoLeaf._GeoJSONClustering.getPoiConfig();

		        // Normaliser def.clustering: peut √™tre boolean ou object
		        const clusteringConfig = typeof def.clustering === 'object' ? def.clustering : { enabled: def.clustering };
		        const isClusteringEnabled = clusteringConfig.enabled === true;
		        const isClusteringDisabled = clusteringConfig.enabled === false;

		        // Override explicite dans la couche: clustering.enabled: false (priorit√© absolue)
		        if (isClusteringDisabled) {
		            return { shouldCluster: false, useSharedCluster: false };
		        }

		        // Si clustering d√©sactiv√© globalement ET pas d'override dans la couche
		        if (!poiConfig.clustering && !isClusteringEnabled) {
		            return { shouldCluster: false, useSharedCluster: false };
		        }

		        // V√©rifier si la couche contient des Points
		        const hasPoints = geojsonData.features && geojsonData.features.some(f =>
		            f.geometry && f.geometry.type && f.geometry.type.includes("Point")
		        );

		        if (!hasPoints) {
		            return { shouldCluster: false, useSharedCluster: false };
		        }

		        // Override explicite dans la couche: clustering.enabled: true
		        if (isClusteringEnabled) {
		            // Si la couche a des param√®tres de clustering sp√©cifiques, cr√©er un cluster ind√©pendant
		            const clusterRadius = clusteringConfig.maxClusterRadius || (typeof def.clusterRadius === "number" ? def.clusterRadius : null);
		            const disableAtZoom = clusteringConfig.disableClusteringAtZoom || (typeof def.disableClusteringAtZoom === "number" ? def.disableClusteringAtZoom : null);

		            const hasCustomClusterParams =
		                (clusterRadius !== null && clusterRadius !== (poiConfig.clusterRadius || 80)) ||
		                (disableAtZoom !== null && disableAtZoom !== (poiConfig.disableClusteringAtZoom || 18));

		            if (hasCustomClusterParams) {
		                return {
		                    shouldCluster: true,
		                    useSharedCluster: false  // Cluster ind√©pendant avec param√®tres personnalis√©s
		                };
		            }

		            // Sinon, respecter la strat√©gie globale
		            const strategy = poiConfig.clusterStrategy || "unified";
		            return {
		                shouldCluster: true,
		                useSharedCluster: strategy === "unified"
		            };
		        }

		        // Lire la strat√©gie configur√©e
		        const strategy = poiConfig.clusterStrategy || "unified";

		        switch (strategy) {
		            case "unified":
		                // Un seul cluster partag√© pour tous
		                return { shouldCluster: true, useSharedCluster: true };

		            case "by-layer":
		                // Cluster ind√©pendant par couche: respecte clustering.enabled: true/false en config
		                // Par d√©faut, pas de cluster SAUF si clustering.enabled === true
		                return {
		                    shouldCluster: isClusteringEnabled,
		                    useSharedCluster: false  // Chaque couche a son propre cluster
		                };

		            case "by-source":
		                // Cluster s√©par√© par source
		                const sourceConfig = poiConfig.clusterStrategies?.["by-source"]?.sources || {};
		                const shouldClusterGeoJSON = sourceConfig.geojson !== false;
		                return {
		                    shouldCluster: shouldClusterGeoJSON,
		                    useSharedCluster: false
		                };

		            case "json-only":
		                // Cluster uniquement pour JSON, pas GeoJSON
		                const jsonOnlyConfig = poiConfig.clusterStrategies?.["json-only"] || {};
		                return {
		                    shouldCluster: jsonOnlyConfig.geojsonClustering === true,
		                    useSharedCluster: false
		                };

		            default:
		                // Par d√©faut : comportement unifi√© (r√©trocompatibilit√©)
		                Log.warn("[GeoLeaf.GeoJSON] Strat√©gie de clustering inconnue: " + strategy + ". Utilisation de 'unified'.");
		                return { shouldCluster: true, useSharedCluster: true };
		        }
		    };

		    /**
		     * Cr√©e un cluster ind√©pendant avec les options sp√©cifi√©es.
		     *
		     * @param {Object} options - Options de clustering
		     * @returns {L.MarkerClusterGroup|null}
		     */
		    GeoLeaf._GeoJSONClustering.createIndependentCluster = function (options = {}) {
		        if (!global.L || !global.L.markerClusterGroup) {
		            return null;
		        }

		        return global.L.markerClusterGroup({
		            maxClusterRadius: options.clusterRadius || 80,
		            disableClusteringAtZoom: options.disableClusteringAtZoom || 18,
		            animate: options.animate !== undefined ? options.animate : false,
		            spiderfyOnMaxZoom: options.spiderfyOnMaxZoom !== undefined ? options.spiderfyOnMaxZoom : false,
		            showCoverageOnHover: options.showCoverageOnHover !== undefined ? options.showCoverageOnHover : false,
		            zoomToBoundsOnClick: options.zoomToBoundsOnClick !== undefined ? options.zoomToBoundsOnClick : true
		        });
		    };

		})(window);
		return clustering;
	}

	requireClustering();

	var layerConfigManager = {};

	/**
	 * GeoLeaf GeoJSON Module - Layer Configuration Manager
	 * Gestion de la configuration et des options des couches
	 *
	 * @module geojson/layer-config-manager
	 */

	var hasRequiredLayerConfigManager;

	function requireLayerConfigManager () {
		if (hasRequiredLayerConfigManager) return layerConfigManager;
		hasRequiredLayerConfigManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONLayerConfig = GeoLeaf._GeoJSONLayerConfig || {};

		    /**
		     * R√©sout le chemin absolu d'un fichier de donn√©es
		     *
		     * @param {string} dataFile - Nom du fichier de donn√©es
		     * @param {Object} profile - Profil actif
		     * @param {string} [layerDirectory] - Dossier de la couche
		     * @returns {string} Chemin absolu r√©solu
		     */
		    GeoLeaf._GeoJSONLayerConfig.resolveDataFilePath = function (dataFile, profile, layerDirectory) {
		        const Config = GeoLeaf.Config;
		        const dataCfg = Config && Config.get ? Config.get('data') : null;
		        const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
		        const profileId = (dataCfg && dataCfg.activeProfile) || profile.id;

		        // Si dataFile commence par ../, on r√©sout relativement au dossier du profil
		        if (dataFile.startsWith('../')) {
		            // dataFile = "../raw/file.json" -> "profiles/tourism/raw/file.json"
		            const relativePath = dataFile.replace('../', '');
		            return `${profilesBasePath}/${profileId}/${relativePath}`;
		        }

		        // Si dataFile commence par /, c'est un chemin absolu
		        if (dataFile.startsWith('/')) {
		            return dataFile;
		        }

		        // Sinon, relatif au dossier de la couche (layers/tourism_poi_all/data/file.json)
		        if (layerDirectory) {
		            return `${profilesBasePath}/${profileId}/${layerDirectory}/${dataFile}`;
		        }

		        // Fallback: relatif au dossier du profil
		        return `${profilesBasePath}/${profileId}/${dataFile}`;
		    };

		    /**
		     * Inf√®re le type de g√©om√©trie d'une couche
		     *
		     * @param {Object} def - D√©finition de la couche
		     * @param {Object} geojsonData - Donn√©es GeoJSON
		     * @returns {string} Type de g√©om√©trie ('point', 'line', 'polygon', 'unknown')
		     */
		    GeoLeaf._GeoJSONLayerConfig.inferGeometryType = function (def, geojsonData) {
		        if (def && typeof def.geometryType === "string") return def.geometryType;
		        const features = geojsonData && Array.isArray(geojsonData.features)
		            ? geojsonData.features
		            : [];
		        const first = features.find(f => f && f.geometry && f.geometry.type);
		        if (!first) return "unknown";
		        const geometryType = first.geometry.type.toLowerCase();
		        if (geometryType.includes("point")) return "point";
		        if (geometryType.includes("line")) return "line";
		        if (geometryType.includes("polygon")) return "polygon";
		        return "unknown";
		    };

		    /**
		     * Construit les options Leaflet pour une couche sp√©cifique
		     * Configure pointToLayer, onEachFeature, styles, popups, tooltips et panes
		     *
		     * @param {Object} def - D√©finition de la couche depuis profile.json
		     * @param {string} def.id - ID unique de la couche
		     * @param {number} [def.zIndex] - Index z pour le positionnement
		     * @param {Object} [def.style] - Style par d√©faut de la couche
		     * @param {Array} [def.styleRules] - R√®gles de style conditionnelles
		     * @param {boolean} [def.interactiveShape=false] - Rendre les formes interactives
		     * @param {boolean} [def.showIconsOnMap=false] - Afficher ic√¥nes SVG pour les points
		     * @param {Object} baseOptions - Options de base du module GeoJSON
		     * @returns {Object} Options Leaflet configur√©es (pointToLayer, onEachFeature, style, etc.)
		     * @example
		     * const options = GeoLeaf._GeoJSONLayerConfig.buildLayerOptions(
		     *   { id: 'poi_tourism', zIndex: 100, showIconsOnMap: true },
		     *   { defaultPointStyle: { radius: 8 } }
		     * );
		     */
		    GeoLeaf._GeoJSONLayerConfig.buildLayerOptions = function (def, baseOptions) {
		        const state = getState();
		        const mergedOptions = Object.assign({}, state.options, baseOptions);

		        // Style des polygones / lignes
		        if (def.style && typeof def.style === "object") {
		            mergedOptions.defaultStyle = Object.assign(
		                {},
		                mergedOptions.defaultStyle,
		                def.style
		            );
		        }

		        // R√®gles de style dynamiques (styleRules)
		        if (Array.isArray(def.styleRules) && def.styleRules.length > 0) {
		            mergedOptions.styleRules = def.styleRules;
		        }

		        // D√©terminer le param√®tre interactiveShape pour cette couche
		        mergedOptions.interactiveShape = typeof def.interactiveShape === "boolean"
		            ? def.interactiveShape
		            : (GeoLeaf.Config && GeoLeaf.Config.get ? GeoLeaf.Config.get('ui.interactiveShapes', false) : false);

		        // V√©rifier si on doit afficher les ic√¥nes SVG sur la carte
		        const showIconsOnMap = typeof def.showIconsOnMap === 'boolean' ? def.showIconsOnMap : false;

		        // D√©terminer le pane √† utiliser pour cette couche
		        const PaneHelpers = GeoLeaf._GeoJSONShared.PaneHelpers;
		        const paneName = PaneHelpers.getPaneName(def.zIndex);

		        // Style des points
		        if (showIconsOnMap) {
		            // Mode IC√îNE : utiliser les ic√¥nes SVG du profil
		            mergedOptions.pointToLayer = function (feature, latlng) {
		                // Convertir la feature en POI pour obtenir les infos de cat√©gorie
		                const PopupTooltip = GeoLeaf._GeoJSONPopupTooltip;
		                const poiData = PopupTooltip ? PopupTooltip.convertFeatureToPOI(feature, def) : null;

		                if (poiData) {
		                    // Convertir le format ancien 'fields' au nouveau 'detailPopup'
		                    const popupConfig = def.popup || {};
		                    const convertedPopup = {
		                        enabled: popupConfig.enabled,
		                        // Format ancien: { fields: [...] } ‚Üí Format nouveau: { detailPopup: [...] }
		                        detailPopup: popupConfig.detailPopup || popupConfig.fields || [],
		                        // Aussi supporter l'ancien format de tooltip
		                        detailTooltip: popupConfig.detailTooltip || (popupConfig.tooltip && popupConfig.tooltip.fields) || []
		                    };

		                    // Passer toute la configuration de la couche au POI
		                    poiData._layerConfig = {
		                        style: mergedOptions.defaultStyle || {},
		                        popup: convertedPopup,
		                        tooltip: def.tooltip || {},
		                        sidepanelConfig: def.sidepanelConfig || {}
		                    };
		                }

		                // Utiliser le syst√®me de markers POI pour cr√©er l'ic√¥ne
		                const markers = GeoLeaf._POIMarkers;
		                if (markers && typeof markers.createMarker === 'function' && poiData) {
		                    const attachEvents = mergedOptions.interactiveShape !== false;
		                    const marker = markers.createMarker(poiData, { attachEvents, pane: paneName });
		                    // S'assurer que le pane est d√©fini sur le marker
		                    if (marker && marker.options) {
		                        marker.options.pane = paneName;
		                    }
		                    return marker;
		                }

		                // Fallback sur circleMarker avec pane
		                const pointStyle = Object.assign(
		                    {},
		                    mergedOptions.defaultPointStyle,
		                    def.pointStyle,
		                    { interactive: mergedOptions.interactiveShape, pane: paneName }
		                );
		                return global.L.circleMarker(latlng, pointStyle);
		            };
		        } else if (def.pointStyle && typeof def.pointStyle === "object") {
		            // Mode CIRCLE : utiliser circleMarker classique avec pane
		            const pointStyle = Object.assign(
		                {},
		                mergedOptions.defaultPointStyle,
		                def.pointStyle,
		                { interactive: mergedOptions.interactiveShape, pane: paneName }
		            );
		            mergedOptions.pointToLayer = function (feature, latlng) {
		                return global.L.circleMarker(latlng, pointStyle);
		            };
		        }

		        // Callback onEachFeature : int√©gration popups + side panel + tooltips
		        const originalOnEachFeature = typeof def.onEachFeature === "function" ? def.onEachFeature : null;

		        mergedOptions.onEachFeature = function (feature, layer) {
		            // Popup unifi√©
		            const PopupTooltip = GeoLeaf._GeoJSONPopupTooltip;
		            if (PopupTooltip) {
		                PopupTooltip.bindUnifiedPopup(feature, layer, def);
		                PopupTooltip.bindUnifiedTooltip(feature, layer, def);
		            }

		            // Callback custom si fourni
		            if (originalOnEachFeature) {
		                originalOnEachFeature(feature, layer);
		            }
		        };

		        // Ajouter le pane aux defaultPointStyle pour que le style-resolver l'utilise dans son fallback
		        if (mergedOptions.defaultPointStyle) {
		            mergedOptions.defaultPointStyle = Object.assign({}, mergedOptions.defaultPointStyle, { pane: paneName });
		        } else {
		            mergedOptions.defaultPointStyle = { pane: paneName };
		        }

		        // Utiliser le StyleResolver pour construire les options Leaflet finales
		        if (GeoLeaf._GeoJSONStyleResolver && GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions) {
		            return GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions(mergedOptions);
		        }

		        return mergedOptions;
		    };

		    /**
		     * Charge la l√©gende d'une couche depuis son fichier legends/*.json
		     * R√©sout automatiquement le chemin selon le style actif et la config du profil
		     *
		     * @param {Object} profile - Profil contenant la configuration
		     * @param {string} profile.id - ID du profil (ex: 'tourism')
		     * @param {string} [profile.basePath] - Chemin de base du profil
		     * @param {Object} layerDef - D√©finition de la couche depuis profile.json
		     * @param {string} layerDef.id - ID de la couche
		     * @param {string} [layerDef.style='default'] - Style actif de la couche
		     * @param {Object} [layerDef.legends] - Configuration des l√©gendes
		     * @param {string} [layerDef.legends.directory='legends'] - Dossier des l√©gendes
		     * @param {string} [layerDef.legends.default] - Fichier l√©gende par d√©faut
		     * @returns {void} Charge et affiche la l√©gende via GeoLeaf.Legend.loadLegend()
		     * @example
		     * GeoLeaf._GeoJSONLayerConfig.loadLayerLegend(
		     *   { id: 'tourism', basePath: '../profiles/tourism' },
		     *   { id: 'poi_all', style: 'par_categorie', legends: { directory: 'legends' } }
		     * );
		     */
		    GeoLeaf._GeoJSONLayerConfig.loadLayerLegend = function (profile, layerDef) {
		        const Log = getLog();

		        if (!layerDef) {
		            if (Log) Log.debug("[GeoLeaf.GeoJSON] Pas de d√©finition de couche");
		            return;
		        }

		        // Pour v3.0, la config de la couche est d√©j√† dans layerDef (enrichie par profile.js)
		        const layerConfig = layerDef.legends ? layerDef : null;

		        if (!layerConfig || !layerConfig.legends) {
		            if (Log) Log.debug("[GeoLeaf.GeoJSON] Pas de config legends pour cette couche");
		            return;
		        }

		        const legendsConfig = layerConfig.legends;
		        const legendDirectory = legendsConfig.directory || "legends";

		        // D√©terminer le style actif de la couche
		        const activeStyle = layerDef.style || "default";

		        // Construire le nom de fichier de la l√©gende
		        let legendFile;
		        if (activeStyle === "default" && legendsConfig.default) {
		            legendFile = legendsConfig.default;
		        } else {
		            legendFile = `${activeStyle}.legend.json`;
		        }

		        // Construire le chemin de la l√©gende
		        const profileBasePath = profile.basePath || "./profiles/" + profile.id;
		        const layerDirectory = layerDef._layerDirectory || "layers/" + layerDef.id;
		        const legendPath = `${profileBasePath}/${layerDirectory}/${legendDirectory}/${legendFile}`;

		        if (Log) Log.debug(`[GeoLeaf.GeoJSON] Chargement l√©gende pour style "${activeStyle}": ${legendPath}`);

		        // Charger et afficher la l√©gende directement
		        if (GeoLeaf.Legend && typeof GeoLeaf.Legend.loadLegend === "function") {
		            GeoLeaf.Legend.loadLegend(legendPath)
		                .then(success => {
		                    if (success && Log) {
		                        Log.info(`[GeoLeaf.GeoJSON] L√©gende affich√©e pour ${layerDef.id} (style: ${activeStyle})`);
		                    }
		                })
		                .catch(error => {
		                    if (Log) Log.warn(`[GeoLeaf.GeoJSON] Erreur chargement l√©gende: ${error.message}`);
		                });
		        } else {
		            if (Log) Log.warn("[GeoLeaf.GeoJSON] Module Legend non disponible");
		        }
		    };

		    /**
		     * Charge le style par d√©faut d'une couche depuis son fichier styles/*.style.json
		     * Fonction asynchrone utilisant fetch() pour charger le JSON
		     *
		     * @async
		     * @param {string} layerId - ID de la couche (utilis√© pour le logging)
		     * @param {Object} layerDef - D√©finition de la couche
		     * @param {Object} layerDef.styles - Configuration des styles
		     * @param {string} layerDef.styles.default - Nom du fichier de style par d√©faut
		     * @param {string} [layerDef.styles.directory='styles'] - Dossier des styles
		     * @param {string} layerDef._profileId - ID du profil (m√©tadonn√©e interne)
		     * @param {string} layerDef._layerDirectory - Dossier de la couche (m√©tadonn√©e interne)
		     * @returns {Promise<Object>} Style charg√© (objet JSON pars√©)
		     * @throws {Error} "Pas de style par d√©faut d√©fini" si styles.default manquant
		     * @throws {Error} "M√©tadonn√©es manquantes" si _profileId ou _layerDirectory absent
		     * @throws {Error} "HTTP {status}" si le fetch √©choue
		     * @example
		     * try {
		     *   const style = await GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle(
		     *     'provincia_ar',
		     *     { styles: { default: 'd√©faut.json' }, _profileId: 'tourism', _layerDirectory: 'layers/provincia_ar' }
		     *   );
		     *   console.log('Style charg√©:', style);
		     * } catch (err) {
		     *   console.error('Erreur chargement style:', err);
		     * }
		     */
		    GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle = async function (layerId, layerDef) {
		        const Log = getLog();

		        if (!layerDef.styles || !layerDef.styles.default) {
		            throw new Error("Pas de style par d√©faut d√©fini");
		        }

		        const profileId = layerDef._profileId;
		        const layerDirectory = layerDef._layerDirectory;

		        if (!profileId || !layerDirectory) {
		            throw new Error("M√©tadonn√©es manquantes (profileId ou layerDirectory)");
		        }

		        const Config = global.GeoLeaf.Config;
		        const dataCfg = Config && Config.get ? Config.get('data') : null;
		        const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";

		        const styleDirectory = layerDef.styles.directory || "styles";
		        const styleFile = layerDef.styles.default;
		        const stylePath = `${profilesBasePath}/${profileId}/${layerDirectory}/${styleDirectory}/${styleFile}`;

		        Log.debug("[GeoLeaf.GeoJSON] Chargement style par d√©faut:", stylePath);

		        const response = await fetch(stylePath);
		        if (!response.ok) {
		            throw new Error(`HTTP ${response.status}`);
		        }

		        const styleData = await response.json();
		        Log.debug("[GeoLeaf.GeoJSON] Style charg√©:", styleData);
		        return styleData;
		    };

		})(window);
		return layerConfigManager;
	}

	requireLayerConfigManager();

	var featureValidator = {};

	/**
	 * GeoLeaf GeoJSON Module - Feature Validator
	 * Validation stricte des features GeoJSON selon sch√©ma centralis√©
	 *
	 * @module geojson/feature-validator
	 */

	var hasRequiredFeatureValidator;

	function requireFeatureValidator () {
		if (hasRequiredFeatureValidator) return featureValidator;
		hasRequiredFeatureValidator = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONFeatureValidator = GeoLeaf._GeoJSONFeatureValidator || {};

		    /**
		     * Valide une FeatureCollection enti√®re et retourne les features valides
		     *
		     * @param {Object} collection - FeatureCollection GeoJSON
		     * @returns {Object} { validFeatures: Array, errors: Array }
		     */
		    GeoLeaf._GeoJSONFeatureValidator.validateFeatureCollection = function (collection) {
		        const Log = getLog();
		        const errors = [];
		        const validFeatures = [];

		        if (!collection || typeof collection !== "object") {
		            Log.warn("[GeoLeaf.GeoJSON.Validator] Collection non valide : type invalide");
		            return { validFeatures: [], errors: [{ message: "Collection non valide" }] };
		        }

		        // Accepter les FeatureCollections ou les arrays de features
		        const features = collection.type === "FeatureCollection"
		            ? collection.features
		            : Array.isArray(collection)
		                ? collection
		                : [collection];

		        if (!Array.isArray(features)) {
		            Log.warn("[GeoLeaf.GeoJSON.Validator] Pas de features √† valider");
		            return { validFeatures: [], errors: [] };
		        }

		        features.forEach((feature, index) => {
		            const result = GeoLeaf._GeoJSONFeatureValidator.validateFeature(feature, index);
		            if (result.valid) {
		                validFeatures.push(feature);
		            } else {
		                errors.push(...result.errors);
		            }
		        });

		        return { validFeatures, errors };
		    };

		    /**
		     * Valide une single feature
		     *
		     * @param {Object} feature - Feature GeoJSON
		     * @param {number} [index] - Index dans la collection (pour logging)
		     * @returns {Object} { valid: Boolean, errors: Array }
		     */
		    GeoLeaf._GeoJSONFeatureValidator.validateFeature = function (feature, index) {
		        const Log = getLog();
		        const errors = [];
		        const featureId = feature?.properties?.id || feature?.id || index || "unknown";

		        // Type feature
		        if (!feature || feature.type !== "Feature") {
		            errors.push({
		                featureId,
		                field: "type",
		                message: "Feature doit avoir type='Feature'",
		                severity: "error"
		            });
		            Log.warn(`[GeoLeaf.GeoJSON.Validator] Feature ${featureId}: type invalide`);
		            return { valid: false, errors };
		        }

		        // G√©om√©trie
		        const geomResult = GeoLeaf._GeoJSONFeatureValidator.validateGeometry(
		            feature.geometry,
		            featureId
		        );
		        if (!geomResult.valid) {
		            errors.push(...geomResult.errors);
		        }

		        // Propri√©t√©s
		        const propsResult = GeoLeaf._GeoJSONFeatureValidator.validateProperties(
		            feature.properties,
		            featureId
		        );
		        if (!propsResult.valid) {
		            errors.push(...propsResult.errors);
		        }

		        if (errors.length > 0) {
		            Log.warn(
		                `[GeoLeaf.GeoJSON.Validator] Feature ${featureId} rejet√©e : ${errors.map(e => e.message).join("; ")}`
		            );
		            return { valid: false, errors };
		        }

		        return { valid: true, errors: [] };
		    };

		    /**
		     * Valide la g√©om√©trie d'une feature
		     *
		     * @param {Object} geometry - Geometry GeoJSON
		     * @param {string|number} featureId - Feature identifier (for logging)
		     * @returns {Object} { valid: Boolean, errors: Array }
		     */
		    GeoLeaf._GeoJSONFeatureValidator.validateGeometry = function (geometry, featureId) {
		        const errors = [];
		        const validTypes = ["Point", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];

		        if (!geometry || typeof geometry !== "object") {
		            errors.push({
		                featureId,
		                field: "geometry",
		                message: "geometry requis et doit √™tre un objet",
		                severity: "error"
		            });
		            return { valid: false, errors };
		        }

		        if (!geometry.type) {
		            errors.push({
		                featureId,
		                field: "geometry.type",
		                message: "geometry.type requis",
		                severity: "error"
		            });
		            return { valid: false, errors };
		        }

		        if (!validTypes.includes(geometry.type)) {
		            errors.push({
		                featureId,
		                field: "geometry.type",
		                message: `Type de g√©om√©trie invalide '${geometry.type}'. Doit √™tre : ${validTypes.join(", ")}`,
		                severity: "error"
		            });
		            return { valid: false, errors };
		        }

		        if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length === 0) {
		            errors.push({
		                featureId,
		                field: "geometry.coordinates",
		                message: "geometry.coordinates doit √™tre un array non-vide",
		                severity: "error"
		            });
		            return { valid: false, errors };
		        }

		        return { valid: errors.length === 0, errors };
		    };

		    /**
		     * Valide les propri√©t√©s d'une feature
		     *
		     * @param {Object} properties - Feature properties
		     * @param {string|number} featureId - Feature identifier (for logging)
		     * @returns {Object} { valid: Boolean, errors: Array }
		     */
		    GeoLeaf._GeoJSONFeatureValidator.validateProperties = function (properties, featureId) {
		        const errors = [];

		        if (!properties || typeof properties !== "object") {
		            errors.push({
		                featureId,
		                field: "properties",
		                message: "properties requis et doit √™tre un objet",
		                severity: "error"
		            });
		            return { valid: false, errors };
		        }

		        // Au moins un nom (name, title, ou autre identifier)
		        const hasName = properties.name || properties.title || properties.label;
		        if (!hasName) {
		            errors.push({
		                featureId,
		                field: "properties.name",
		                message: "properties doit contenir au moins name, title ou label",
		                severity: "error"
		            });
		        }

		        // Validation des types num√©riques
		        if (typeof properties.distance_km !== "undefined" && typeof properties.distance_km !== "number") {
		            errors.push({
		                featureId,
		                field: "properties.distance_km",
		                message: "distance_km doit √™tre un nombre",
		                severity: "warning"
		            });
		        }

		        if (typeof properties.distance_km === "number" && properties.distance_km < 0) {
		            errors.push({
		                featureId,
		                field: "properties.distance_km",
		                message: "distance_km doit √™tre >= 0",
		                severity: "warning"
		            });
		        }

		        if (typeof properties.duration_min !== "undefined" && typeof properties.duration_min !== "number") {
		            errors.push({
		                featureId,
		                field: "properties.duration_min",
		                message: "duration_min doit √™tre un nombre",
		                severity: "warning"
		            });
		        }

		        if (typeof properties.duration_min === "number" && properties.duration_min < 0) {
		            errors.push({
		                featureId,
		                field: "properties.duration_min",
		                message: "duration_min doit √™tre >= 0",
		                severity: "warning"
		            });
		        }

		        if (typeof properties.rating !== "undefined") {
		            if (typeof properties.rating !== "number") {
		                errors.push({
		                    featureId,
		                    field: "properties.rating",
		                    message: "rating doit √™tre un nombre",
		                    severity: "warning"
		                });
		            } else if (properties.rating < 0 || properties.rating > 5) {
		                errors.push({
		                    featureId,
		                    field: "properties.rating",
		                    message: "rating doit √™tre entre 0 et 5",
		                    severity: "warning"
		                });
		            }
		        }

		        // Validation des couleurs hex
		        if (typeof properties.color !== "undefined" && typeof properties.color === "string") {
		            if (!/^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(properties.color)) {
		                errors.push({
		                    featureId,
		                    field: "properties.color",
		                    message: `color invalide '${properties.color}'. Format: #RGB ou #RRGGBB`,
		                    severity: "warning"
		                });
		            }
		        }

		        // Validation des opacity
		        if (typeof properties.opacity !== "undefined") {
		            if (typeof properties.opacity !== "number") {
		                errors.push({
		                    featureId,
		                    field: "properties.opacity",
		                    message: "opacity doit √™tre un nombre",
		                    severity: "warning"
		                });
		            } else if (properties.opacity < 0 || properties.opacity > 1) {
		                errors.push({
		                    featureId,
		                    field: "properties.opacity",
		                    message: "opacity doit √™tre entre 0 et 1",
		                    severity: "warning"
		                });
		            }
		        }

		        // Validation des weight
		        if (typeof properties.weight !== "undefined") {
		            if (typeof properties.weight !== "number") {
		                errors.push({
		                    featureId,
		                    field: "properties.weight",
		                    message: "weight doit √™tre un nombre",
		                    severity: "warning"
		                });
		            } else if (properties.weight < 0) {
		                errors.push({
		                    featureId,
		                    field: "properties.weight",
		                    message: "weight doit √™tre >= 0",
		                    severity: "warning"
		                });
		            }
		        }

		        // Validation des URLs
		        const urlFields = ["link", "photo", "url"];
		        urlFields.forEach(field => {
		            if (typeof properties[field] !== "undefined" && typeof properties[field] === "string") {
		                if (!GeoLeaf._GeoJSONFeatureValidator.isValidUrl(properties[field])) {
		                    errors.push({
		                        featureId,
		                        field: `properties.${field}`,
		                        message: `${field} n'est pas une URL valide`,
		                        severity: "warning"
		                    });
		                }
		            }
		        });

		        // Validation email
		        if (typeof properties.email !== "undefined" && typeof properties.email === "string") {
		            if (!GeoLeaf._GeoJSONFeatureValidator.isValidEmail(properties.email)) {
		                errors.push({
		                    featureId,
		                    field: "properties.email",
		                    message: "email invalide",
		                    severity: "warning"
		                });
		            }
		        }

		        // Validation tags (doit √™tre array de strings)
		        if (typeof properties.tags !== "undefined") {
		            if (!Array.isArray(properties.tags)) {
		                errors.push({
		                    featureId,
		                    field: "properties.tags",
		                    message: "tags doit √™tre un array",
		                    severity: "warning"
		                });
		            } else {
		                properties.tags.forEach((tag, idx) => {
		                    if (typeof tag !== "string") {
		                        errors.push({
		                            featureId,
		                            field: `properties.tags[${idx}]`,
		                            message: "tag doit √™tre une string",
		                            severity: "warning"
		                        });
		                    }
		                });
		            }
		        }

		        // V√©rifier que properties ne contient pas d'objets imbriqu√©s (√† plat obligatoirement)
		        Object.entries(properties).forEach(([key, value]) => {
		            if (value !== null && typeof value === "object" && !Array.isArray(value)) {
		                errors.push({
		                    featureId,
		                    field: `properties.${key}`,
		                    message: `Propri√©t√© imbriqu√©e d√©tect√©e. Les propri√©t√©s doivent √™tre plates (strings, nombres, arrays). Objet trouv√©: ${JSON.stringify(value)}`,
		                    severity: "error"
		                });
		            }
		        });

		        // Les erreurs "error" invalident la feature, pas les "warning"
		        const hasErrors = errors.some(e => e.severity === "error");
		        return { valid: !hasErrors, errors };
		    };

		    /**
		     * Valide qu'une string est une URL valide
		     *
		     * @param {string} url - URL √† valider
		     * @returns {Boolean}
		     */
		    GeoLeaf._GeoJSONFeatureValidator.isValidUrl = function (url) {
		        if (typeof url !== "string") return false;
		        try {
		            new URL(url);
		            return true;
		        } catch {
		            // Accepter aussi les URLs relatives
		            return /^(https?:\/\/|\/|\.\.?\/)/.test(url);
		        }
		    };

		    /**
		     * Valide qu'une string est un email valide
		     *
		     * @param {string} email - Email √† valider
		     * @returns {Boolean}
		     */
		    GeoLeaf._GeoJSONFeatureValidator.isValidEmail = function (email) {
		        if (typeof email !== "string") return false;
		        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return featureValidator;
	}

	requireFeatureValidator();

	var configHelpers = {};

	/**
	 * GeoLeaf GeoJSON Loader - Config Helpers
	 * Accesseurs de configuration normalis√©e + d√©l√©gu√©s d√©pr√©ci√©s
	 *
	 * @module geojson/loader/config-helpers
	 */

	var hasRequiredConfigHelpers;

	function requireConfigHelpers () {
		if (hasRequiredConfigHelpers) return configHelpers;
		hasRequiredConfigHelpers = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._GeoJSONLoader = GeoLeaf._GeoJSONLoader || {};

		    /**
		     * R√©cup√®re la configuration des champs popup d'une couche.
		     *
		     * @param {Object} def - D√©finition de la couche (normalis√©e ou originale)
		     * @returns {Array|null} - Array de configurations de champs ou null
		     */
		    GeoLeaf._GeoJSONLoader.getPopupConfig = function(def) {
		        if (!def) return null;

		        // Structure normalis√©e (apr√®s passage dans loadProfile)
		        if (def.popupFields && Array.isArray(def.popupFields)) {
		            return def.popupFields;
		        }

		        // Structure originale (depuis config JSON)
		        if (def.popup && def.popup.fields && Array.isArray(def.popup.fields)) {
		            return def.popup.fields;
		        }

		        return null;
		    };

		    /**
		     * R√©cup√®re la configuration des champs tooltip d'une couche.
		     *
		     * @param {Object} def - D√©finition de la couche (normalis√©e ou originale)
		     * @returns {Array|null} - Array de configurations de champs ou null
		     */
		    GeoLeaf._GeoJSONLoader.getTooltipConfig = function(def) {
		        if (!def) return null;

		        // Structure normalis√©e (apr√®s passage dans loadProfile)
		        if (def.tooltipFields && Array.isArray(def.tooltipFields)) {
		            return def.tooltipFields;
		        }

		        // Structure originale (depuis config JSON)
		        if (def.tooltip && def.tooltip.fields && Array.isArray(def.tooltip.fields)) {
		            return def.tooltip.fields;
		        }

		        return null;
		    };

		    /**
		     * R√©cup√®re la configuration des champs sidepanel d'une couche.
		     *
		     * @param {Object} def - D√©finition de la couche (normalis√©e ou originale)
		     * @returns {Array|null} - Array de configurations de champs ou null
		     */
		    GeoLeaf._GeoJSONLoader.getSidepanelConfig = function(def) {
		        if (!def) return null;

		        // Structure normalis√©e (apr√®s passage dans loadProfile)
		        if (def.sidepanelFields && Array.isArray(def.sidepanelFields)) {
		            return def.sidepanelFields;
		        }

		        // Structure originale (depuis config JSON)
		        if (def.sidepanel && def.sidepanel.detailLayout && Array.isArray(def.sidepanel.detailLayout)) {
		            return def.sidepanel.detailLayout;
		        }

		        return null;
		    };

		    // ‚îÄ‚îÄ‚îÄ D√©l√©gu√©s d√©pr√©ci√©s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		    /**
		     * @deprecated Utiliser GeoLeaf._GeoJSONLayerConfig.resolveDataFilePath()
		     */
		    GeoLeaf._GeoJSONLoader._resolveDataFilePath = function (dataFile, profile, layerDirectory) {
		        return GeoLeaf._GeoJSONLayerConfig.resolveDataFilePath(dataFile, profile, layerDirectory);
		    };

		    /**
		     * @deprecated Utiliser GeoLeaf._GeoJSONLayerConfig.inferGeometryType()
		     */
		    GeoLeaf._GeoJSONLoader._inferGeometryType = function (def, geojsonData) {
		        return GeoLeaf._GeoJSONLayerConfig.inferGeometryType(def, geojsonData);
		    };

		    /**
		     * @deprecated Utiliser GeoLeaf._GeoJSONLayerConfig.buildLayerOptions()
		     */
		    GeoLeaf._GeoJSONLoader._buildLayerOptions = function (def, baseOptions) {
		        return GeoLeaf._GeoJSONLayerConfig.buildLayerOptions(def, baseOptions);
		    };

		    /**
		     * @deprecated Utiliser GeoLeaf._GeoJSONLayerConfig.loadLayerLegend()
		     */
		    GeoLeaf._GeoJSONLoader._loadLayerLegend = function (profile, layerDef) {
		        return GeoLeaf._GeoJSONLayerConfig.loadLayerLegend(profile, layerDef);
		    };

		    /**
		     * @deprecated Utiliser GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle()
		     */
		    GeoLeaf._GeoJSONLoader._loadDefaultStyle = function (layerId, layerDef) {
		        return GeoLeaf._GeoJSONLayerConfig.loadDefaultStyle(layerId, layerDef);
		    };

		})(window);
		return configHelpers;
	}

	requireConfigHelpers();

	var data = {};

	/**
	 * GeoLeaf GeoJSON Loader - Data
	 * Chargement direct de donn√©es GeoJSON (URL ou objet JS)
	 *
	 * @module geojson/loader/data
	 */

	var hasRequiredData;

	function requireData () {
		if (hasRequiredData) return data;
		hasRequiredData = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONLoader = GeoLeaf._GeoJSONLoader || {};

		    /**
		     * Charge un fichier GeoJSON via une URL.
		     *
		     * @param {string} url - URL du fichier GeoJSON.
		     * @param {Object} [options] - Options additionnelles, fusionn√©es avec celles du module.
		     * @returns {Promise<L.GeoJSON|null>}
		     */
		    GeoLeaf._GeoJSONLoader.loadUrl = async function (url, options = {}) {
		        const state = getState();
		        const Log = getLog();

		        if (!url) {
		            Log.warn("[GeoLeaf.GeoJSON] URL GeoJSON manquante.");
		            return state.geoJsonLayer;
		        }

		        if (!state.map) {
		            Log.error("[GeoLeaf.GeoJSON] Module non initialis√©. Appelle GeoLeaf.GeoJSON.init() avant loadUrl().");
		            return null;
		        }

		        const mergedOptions = GeoLeaf.Utils && GeoLeaf.Utils.mergeOptions
		            ? GeoLeaf.Utils.mergeOptions(state.options, options)
		            : Object.assign({}, state.options, options);

		        try {
		            // Sprint 3.3: Use unified FetchHelper for GeoJSON loading
		            const FetchHelper = GeoLeaf.Utils?.FetchHelper;

		            let data;
		            if (FetchHelper) {
		                data = await FetchHelper.get(url, {
		                    timeout: 20000, // GeoJSON files can be large
		                    retries: 2
		                });
		            } else {
		                // Fallback to raw fetch
		                const response = await fetch(url);
		                if (!response.ok) {
		                    throw new Error("HTTP " + response.status + " pour " + url);
		                }
		                data = await response.json();
		            }

		            GeoLeaf._GeoJSONLoader.addData(data, mergedOptions);
		            return state.geoJsonLayer;
		        } catch (err) {
		            Log.error("[GeoLeaf.GeoJSON] Erreur lors du chargement GeoJSON :", err);
		            return state.geoJsonLayer;
		        }
		    };

		    /**
		     * Ajoute des donn√©es GeoJSON pass√©es directement en objet JS.
		     * Valide les features selon le sch√©ma strict avant ajout.
		     *
		     * @param {Object} geojsonData - Objet GeoJSON valide.
		     * @param {Object} [options] - Options additionnelles, fusionn√©es avec celles du module.
		     */
		    GeoLeaf._GeoJSONLoader.addData = function (geojsonData, options = {}) {
		        const state = getState();
		        const Log = getLog();

		        if (!geojsonData) {
		            Log.warn("[GeoLeaf.GeoJSON] Aucune donn√©e GeoJSON fournie √† addData().");
		            return;
		        }

		        if (!state.map || !state.geoJsonLayer) {
		            Log.error("[GeoLeaf.GeoJSON] Module non initialis√©. Appelle GeoLeaf.GeoJSON.init() avant addData().");
		            return;
		        }

		        const mergedOptions = GeoLeaf.Utils && GeoLeaf.Utils.mergeOptions
		            ? GeoLeaf.Utils.mergeOptions(state.options, options)
		            : Object.assign({}, state.options, options);

		        // Met √† jour les options de la couche si besoin
		        if (GeoLeaf._GeoJSONStyleResolver && GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions) {
		            state.geoJsonLayer.options = GeoLeaf._GeoJSONStyleResolver.buildLeafletOptions(mergedOptions);
		        }

		        // Validation stricte des features GeoJSON
		        let dataToAdd = geojsonData;
		        if (GeoLeaf._GeoJSONFeatureValidator && typeof GeoLeaf._GeoJSONFeatureValidator.validateFeatureCollection === "function") {
		            const validationResult = GeoLeaf._GeoJSONFeatureValidator.validateFeatureCollection(geojsonData);

		            if (validationResult.errors.length > 0) {
		                Log.warn(
		                    `[GeoLeaf.GeoJSON] Validation: ${validationResult.errors.length} feature(s) rejet√©e(s), ${validationResult.validFeatures.length} accept√©e(s)`
		                );
		            }

		            // Ajouter uniquement les features valides
		            if (validationResult.validFeatures.length > 0) {
		                if (geojsonData.type === "FeatureCollection") {
		                    dataToAdd = {
		                        type: "FeatureCollection",
		                        features: validationResult.validFeatures
		                    };
		                } else {
		                    dataToAdd = validationResult.validFeatures.length === 1
		                        ? validationResult.validFeatures[0]
		                        : { type: "FeatureCollection", features: validationResult.validFeatures };
		                }
		            } else {
		                Log.warn("[GeoLeaf.GeoJSON] Aucune feature valide √† ajouter apr√®s validation");
		                return;
		            }
		        }

		        // Ajoute les donn√©es valid√©es
		        state.geoJsonLayer.addData(dataToAdd);

		        // Adapter la vue sur les donn√©es si demand√©
		        if (mergedOptions.fitBoundsOnLoad && state.layerGroup) {
		            const bounds = state.layerGroup.getBounds();
		            if (bounds.isValid()) {
		                const fitOptions = {};
		                if (typeof mergedOptions.maxZoomOnFit === "number") {
		                    fitOptions.maxZoom = mergedOptions.maxZoomOnFit;
		                }
		                state.map.fitBounds(bounds, fitOptions);
		            }
		        }

		        // √âv√©nement custom pour l'√©cosyst√®me GeoLeaf
		        try {
		            state.map.fire("geoleaf:geojson:loaded", {
		                data: geojsonData,
		                layer: state.geoJsonLayer
		            });
		        } catch (e) {
		            // On ne bloque jamais si fire √©choue
		        }
		    };

		})(window);
		return data;
	}

	requireData();

	var singleLayer = {};

	/**
	 * GeoLeaf GeoJSON Loader - Single Layer
	 * Pipeline complet de chargement d'une couche individuelle
	 *
	 * @module geojson/loader/single-layer
	 */

	var hasRequiredSingleLayer;

	function requireSingleLayer () {
		if (hasRequiredSingleLayer) return singleLayer;
		hasRequiredSingleLayer = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONLoader = GeoLeaf._GeoJSONLoader || {};

		    /**
		     * Charge une couche GeoJSON individuelle.
		     *
		     * @param {string} layerId - ID unique de la couche
		     * @param {string} layerLabel - Libell√© de la couche
		     * @param {Object} def - D√©finition de la couche depuis le profil
		     * @param {Object} baseOptions - Options de base
		     * @returns {Promise<Object>} - M√©tadonn√©es de la couche charg√©e
		     * @private
		     */
		    GeoLeaf._GeoJSONLoader._loadSingleLayer = function (layerId, layerLabel, def, baseOptions) {
		        const state = getState();
		        const Log = getLog();

		        const fromCache = !!def._cachedData;
		        const dataPromise = fromCache
		            ? Promise.resolve(def._cachedData)
		            : fetch(def.url).then((response) => {
		                if (!response.ok) {
		                    throw new Error("HTTP " + response.status + " pour " + def.url);
		                }

		                if (def.type === "gpx" || def.url.endsWith(".gpx")) {
		                    return response.text();
		                }

		                return response.json();
		            });

		        return dataPromise
		            .then((rawData) => {
		                if (fromCache) {
		                    delete def._cachedData;
		                }

		                const DataConverter = GeoLeaf._DataConverter;
		                let geojsonData;

		                if (def.type === "gpx" || def.url.endsWith(".gpx")) {
		                    if (typeof rawData === "string") {
		                        geojsonData = DataConverter && typeof DataConverter.convertGpxToGeoJSON === "function"
		                            ? DataConverter.convertGpxToGeoJSON(rawData)
		                            : { type: "FeatureCollection", features: [] };
		                    } else {
		                        Log.warn("[GeoLeaf.GeoJSON._loadSingleLayer] GPX n'est pas un string", layerId);
		                        geojsonData = { type: "FeatureCollection", features: [] };
		                    }
		                } else {
		                    geojsonData = DataConverter ? DataConverter.autoConvert(rawData) : rawData;
		                }

		                Log.debug("[GeoLeaf.GeoJSON._loadSingleLayer] Donn√©es converties", {
		                    layerId: layerId,
		                    type: def.type,
		                    features: geojsonData.features ? geojsonData.features.length : 0,
		                    source: fromCache ? "cache" : "network"
		                });

		                const PaneHelpers = GeoLeaf._GeoJSONShared.PaneHelpers;
		                const PaneConfig = GeoLeaf._GeoJSONShared.PANE_CONFIG;

		                const layerOptions = GeoLeaf._GeoJSONLoader._buildLayerOptions(def, baseOptions);
		                layerOptions.pane = PaneHelpers.getPaneName(def.zIndex);
		                const leafletLayer = global.L.geoJSON(geojsonData, layerOptions);

		                // D√©terminer la strat√©gie de clustering
		                const ClusteringModule = GeoLeaf._GeoJSONClustering;
		                const clusterStrategy = ClusteringModule
		                    ? ClusteringModule.getClusteringStrategy(def, geojsonData)
		                    : { shouldCluster: false, useSharedCluster: false };

		                let clusterGroup = null;
		                let useSharedCluster = false;

		                if (clusterStrategy.shouldCluster) {
		                    if (clusterStrategy.useSharedCluster) {
		                        // Utiliser le cluster POI partag√©
		                        Log.info("[GeoLeaf.GeoJSON] üîÑ Tentative r√©cup√©ration cluster POI partag√© pour:", layerId);
		                        let poiCluster = ClusteringModule ? ClusteringModule.getSharedPOICluster() : null;

		                        if (poiCluster) {
		                            clusterGroup = poiCluster;
		                            clusterGroup.addLayer(leafletLayer);
		                            useSharedCluster = true;
		                            Log.info("[GeoLeaf.GeoJSON] ‚úÖ Couche ajout√©e au cluster POI partag√© (strat√©gie: unified) :", layerId);
		                        } else {
		                            // Le cluster POI n'est pas encore cr√©√©, attendre un peu et r√©essayer
		                            Log.debug("[GeoLeaf.GeoJSON] Cluster POI non disponible imm√©diatement, tentative apr√®s d√©lai :", layerId);

		                            // Stocker temporairement sans cluster
		                            const tempLayerData = {
		                                id: layerId,
		                                label: layerLabel,
		                                layer: leafletLayer,
		                                visible: true,
		                                config: def,
		                                clusterGroup: null,
		                                useSharedCluster: false,
		                                pendingSharedCluster: true
		                            };

		                            state.layers.set(layerId, tempLayerData);

		                            // R√©essayer apr√®s un court d√©lai
		                            setTimeout(() => {
		                                poiCluster = ClusteringModule ? ClusteringModule.getSharedPOICluster() : null;

		                                if (poiCluster) {
		                                    poiCluster.addLayer(leafletLayer);
		                                    tempLayerData.clusterGroup = poiCluster;
		                                    tempLayerData.useSharedCluster = true;
		                                    tempLayerData.pendingSharedCluster = false;
		                                    Log.debug("[GeoLeaf.GeoJSON] Couche ajout√©e au cluster POI partag√© (apr√®s d√©lai) :", layerId);
		                                } else {
		                                    Log.warn("[GeoLeaf.GeoJSON] Cluster POI toujours non disponible, cr√©ation cluster ind√©pendant :", layerId);
		                                    if (global.L.markerClusterGroup) {
		                                        const independentCluster = global.L.markerClusterGroup({
		                                            maxClusterRadius: def.clusterRadius || 80,
		                                            disableClusteringAtZoom: def.disableClusteringAtZoom || 18,
		                                            animate: false,
		                                            showCoverageOnHover: false
		                                        });

		                                        // Forcer le pane sur tous les markers du cluster
		                                        independentCluster.on('layeradd', function(e) {
		                                            PaneHelpers.applyPaneToLayer(e.layer, def.zIndex || 0);
		                                        });

		                                        independentCluster.addLayer(leafletLayer);
		                                        tempLayerData.clusterGroup = independentCluster;
		                                        tempLayerData.useSharedCluster = false;
		                                        tempLayerData.pendingSharedCluster = false;

		                                        if (tempLayerData.visible) {
		                                            state.map.addLayer(independentCluster);
		                                        }
		                                    }
		                                }
		                            }, 500);

		                            return {
		                                id: layerId,
		                                label: layerLabel,
		                                featureCount: leafletLayer.getLayers().length
		                            };
		                        }
		                    } else {
		                        // Cr√©er un cluster ind√©pendant (by-source)
		                        if (global.L.markerClusterGroup) {
		                            clusterGroup = global.L.markerClusterGroup({
		                                maxClusterRadius: def.clusterRadius || 80,
		                                disableClusteringAtZoom: def.disableClusteringAtZoom || 18,
		                                animate: false,
		                                spiderfyOnMaxZoom: false,
		                                showCoverageOnHover: false,
		                                zoomToBoundsOnClick: true
		                            });

		                            // Forcer le pane sur tous les markers du cluster
		                            PaneHelpers.getPaneName(def.zIndex);
		                            clusterGroup.on('layeradd', function(e) {
		                                PaneHelpers.applyPaneToLayer(e.layer, def.zIndex || 0);
		                            });

		                            clusterGroup.addLayer(leafletLayer);
		                            Log.debug("[GeoLeaf.GeoJSON] Couche avec cluster ind√©pendant (strat√©gie: by-source) :", layerId);
		                        }
		                    }
		                } else {
		                    Log.debug("[GeoLeaf.GeoJSON] Couche sans clustering :", layerId);
		                }

		                // Stocker la couche
		                const inferredGeometry = GeoLeaf._GeoJSONLoader._inferGeometryType(def, geojsonData);

		                // Calculer le zIndex si non d√©fini
		                let zIndex = def.zIndex;
		                if (typeof zIndex !== 'number') {
		                    // Calculer automatiquement bas√© sur l'ordre d'apparition
		                    const allLayerIds = Array.from(state.layers.keys());
		                    zIndex = Math.max(PaneConfig.MIN_LAYER_ZINDEX, PaneConfig.MAX_LAYER_ZINDEX - allLayerIds.length);
		                    Log.debug(`[GeoLeaf.GeoJSON] zIndex auto-assign√© pour ${layerId}: ${zIndex}`);
		                } else {
		                    // Validation et clamping 0-99
		                    const validatedZIndex = PaneHelpers.validateZIndex(zIndex);
		                    if (validatedZIndex !== def.zIndex) {
		                        Log.warn(`[GeoLeaf.GeoJSON] zIndex ${def.zIndex} clamped to ${validatedZIndex} pour ${layerId}`);
		                    }
		                    zIndex = validatedZIndex;
		                }
		                def.zIndex = zIndex;

		                const Config = GeoLeaf.Config;
		                const dataCfg = Config && Config.get ? Config.get('data') : null;
		                const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
		                const layerBasePath = `${profilesBasePath}/${def._profileId}/${def._layerDirectory}`;

		                const layerData = {
		                    id: layerId,
		                    label: layerLabel,
		                    layer: leafletLayer,
		                    visible: true,
		                    config: def,
		                    clusterGroup: clusterGroup,
		                    legendsConfig: def.legends,
		                    basePath: layerBasePath,
		                    useSharedCluster: useSharedCluster,
		                    geojson: geojsonData,
		                    features: Array.isArray(geojsonData.features) ? geojsonData.features : [],
		                    geometryType: def.geometryType || inferredGeometry
		                };

		                // Initialiser les m√©tadonn√©es de visibilit√© AVANT d'ajouter √† la map
		                layerData._visibility = {
		                    current: false,
		                    logicalState: false,
		                    source: 'system',
		                    userOverride: false,
		                    themeOverride: false,
		                    themeDesired: null,
		                    zoomConstrained: false
		                };

		                state.layers.set(layerId, layerData);

		                // Mettre en cache pour l'UI (filtre, recherche)
		                state.featureCache.set(layerId, {
		                    features: layerData.features,
		                    geometryType: layerData.geometryType
		                });

		                // Mettre en cache les donn√©es GeoJSON pour les chargements suivants
		                if (GeoLeaf.ThemeCache && typeof GeoLeaf.ThemeCache.store === 'function') {
		                    const profileId = def._profileId || (GeoLeaf.Config && GeoLeaf.Config.getActiveProfileId ? GeoLeaf.Config.getActiveProfileId() : null);
		                    GeoLeaf.ThemeCache.store(layerId, profileId, geojsonData, { contentLength: def.contentLength });
		                }

		                // Appliquer imm√©diatement les seuils de zoom pour cette couche
		                if (GeoLeaf._GeoJSONLayerManager) {
		                    GeoLeaf._GeoJSONLayerManager.updateLayerVisibilityByZoom();
		                }

		                // NE PAS ajouter automatiquement √† la carte au chargement
		                // Les th√®mes contr√¥leront la visibilit√© des couches
		                layerData.visible = false;

		                // FitBounds UNIQUEMENT si pas de syst√®me de th√®mes
		                const shouldFitBounds = def.fitBoundsOnLoad && !GeoLeaf.ThemeSelector;
		                if (shouldFitBounds && leafletLayer.getBounds().isValid()) {
		                    const fitOptions = {};
		                    if (typeof def.maxZoomOnFit === "number") {
		                        fitOptions.maxZoom = def.maxZoomOnFit;
		                    }
		                    state.map.fitBounds(leafletLayer.getBounds(), fitOptions);
		                }

		                // Charger le style par d√©faut si styles.default est d√©fini
		                if (def.styles && def.styles.default) {
		                    GeoLeaf._GeoJSONLoader._loadDefaultStyle(layerId, def)
		                        .then((styleData) => {
		                            if (styleData && GeoLeaf._GeoJSONLayerManager) {
		                                Log.debug("[GeoLeaf.GeoJSON] Application du style par d√©faut pour:", layerId);

		                                // Stocker currentStyle dans layerData pour les labels
		                                const layerDataForStyle = state.layers.get(layerId);
		                                if (layerDataForStyle) {
		                                    layerDataForStyle.currentStyle = styleData;
		                                    Log.debug("[GeoLeaf.GeoJSON] currentStyle stock√© pour:", layerId);
		                                }

		                                GeoLeaf._GeoJSONLayerManager.setLayerStyle(layerId, styleData);

		                                // Initialiser les labels selon le style
		                                if (GeoLeaf.Labels && typeof GeoLeaf.Labels.initializeLayerLabels === 'function') {
		                                    GeoLeaf.Labels.initializeLayerLabels(layerId);
		                                }

		                                // Synchroniser le bouton de label maintenant que currentStyle est d√©fini
		                                if (GeoLeaf._LabelButtonManager) {
		                                    GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		                                }
		                            }
		                        })
		                        .catch((err) => {
		                            Log.warn("[GeoLeaf.GeoJSON] Erreur chargement style par d√©faut:", layerId, err.message);
		                        });
		                } else {
		                    // Pas de style par d√©faut: initialiser les labels depuis la config legacy si pr√©sents
		                    if (def.labels && def.labels.enabled && GeoLeaf.Labels && typeof GeoLeaf.Labels.initializeLayerLabels === 'function') {
		                        GeoLeaf.Labels.initializeLayerLabels(layerId);
		                    }

		                    // Synchroniser le bouton de label
		                    if (GeoLeaf._LabelButtonManager) {
		                        GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		                    }
		                }
		                Log.debug("[GeoLeaf.GeoJSON] Couche charg√©e avec succ√®s :", layerId, "(" + leafletLayer.getLayers().length + " features)");

		                return {
		                    id: layerId,
		                    label: layerLabel,
		                    featureCount: leafletLayer.getLayers().length
		                };
		            });
		    };

		})(window);
		return singleLayer;
	}

	requireSingleLayer();

	var profile = {};

	/**
	 * GeoLeaf GeoJSON Loader - Profile
	 * Orchestration du chargement par profil, batch loading, LayerManager population
	 *
	 * @module geojson/loader/profile
	 */

	var hasRequiredProfile;

	function requireProfile () {
		if (hasRequiredProfile) return profile;
		hasRequiredProfile = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    // D√©pendances lazy
		    const getState = () => GeoLeaf._GeoJSONShared.state;
		    const getLog = () => (GeoLeaf.Log || console);

		    GeoLeaf._GeoJSONLoader = GeoLeaf._GeoJSONLoader || {};

		    /**
		     * Charge automatiquement les couches GeoJSON d√©clar√©es dans le profil actif.
		     *
		     * @param {Object} [options] - Options suppl√©mentaires globales appliqu√©es √† toutes les couches.
		     * @returns {Promise<Array<Object>>} - Tableau des couches effectivement charg√©es avec m√©tadonn√©es.
		     */
		    GeoLeaf._GeoJSONLoader.loadFromActiveProfile = function (options = {}) {
		        const state = getState();
		        const Log = getLog();
		        const Config = GeoLeaf.Config;



		        if (!Config || typeof Config.getActiveProfile !== "function") {

		            Log.warn(
		                "[GeoLeaf.GeoJSON] Module Config ou Config.getActiveProfile() non disponible ; chargement GeoJSON par profil impossible."
		            );
		            return Promise.resolve([]);
		        }

		        const profile = Config.getActiveProfile();


		        if (!profile || typeof profile !== "object") {

		            Log.warn("[GeoLeaf.GeoJSON] Aucun profil actif ou profil invalide ; aucun GeoJSON charg√©.");
		            return Promise.resolve([]);
		        }

		        let layersDef = [];

		        // Format 1 : profil.geojsonLayers = [...]
		        if (Array.isArray(profile.geojsonLayers)) {
		            layersDef = profile.geojsonLayers;
		        }
		        // Format 2 : profil.geojson.layers = [...]
		        else if (profile.geojson && Array.isArray(profile.geojson.layers)) {
		            layersDef = profile.geojson.layers;
		        }
		        // Format 3 : profil.layers = [...] (nouveau mod√®le Full Layer)
		        else if (Array.isArray(profile.layers)) {
		            layersDef = profile.layers;
		        }
		        // Format 4 : v3.0 avec Config.getActiveProfileLayersConfig() (nouvelles couches modulaires)
		        else if (Config.Profile && typeof Config.Profile.getActiveProfileLayersConfig === "function") {
		            const layersConfig = Config.Profile.getActiveProfileLayersConfig();
		            if (Array.isArray(layersConfig)) {
		                layersDef = layersConfig;
		                Log.info("[GeoLeaf.GeoJSON] Utilisation du syst√®me v3.0 - " + layersConfig.length + " couches d√©tect√©es");
		            }
		        }

		        if (!layersDef.length) {
		            Log.info(
		                "[GeoLeaf.GeoJSON] Aucun bloc geojsonLayers / geojson.layers / layers d√©fini dans le profil actif ; rien √† charger."
		            );
		            return Promise.resolve([]);
		        }

		        // Limite de s√©curit√© : max 50 couches (augment√©e pour profils riches)
		        if (layersDef.length > 50) {
		            Log.warn(
		                "[GeoLeaf.GeoJSON] Beaucoup de couches GeoJSON d√©tect√©es (" + layersDef.length + "). Cela peut affecter les performances."
		            );
		        } else if (layersDef.length > 20) {
		            Log.info(
		                "[GeoLeaf.GeoJSON] " + layersDef.length + " couches GeoJSON d√©tect√©es. Profil riche d√©tect√©."
		            );
		        }

		        const baseOptions = options || {};
		        const batchSize = 3;
		        const batchDelay = 200;
		        const self = this;

		        const tasks = layersDef.map((def, index) => async () => {
		            if (!def || typeof def !== "object") {
		                Log.warn("[GeoLeaf.GeoJSON] Descripteur GeoJSON de profil invalide, ignor√© :", { index, def });
		                return null;
		            }

		            if (typeof def.active === "boolean" && def.active === false) {
		                Log.debug("[GeoLeaf.GeoJSON] Couche d√©sactiv√©e (active: false), ignor√©e :", def.id || "(sans ID)");
		                return null;
		            }

		            const layerDirectory = def._layerDirectory || null;
		            const layerUrl = def.url || (def.dataFile ? self._resolveDataFilePath(def.dataFile, profile, layerDirectory) : null);

		            if (!layerUrl) {
		                Log.warn("[GeoLeaf.GeoJSON] Descripteur GeoJSON sans URL ou dataFile, ignor√© :", {
		                    index,
		                    id: def.id,
		                    label: def.label
		                });
		                return null;
		            }

		            const normalizedDef = { ...def, url: layerUrl };
		            normalizedDef._profileId = profile.id;
		            normalizedDef._layerDirectory = layerDirectory;

		            // Normalisation unifi√©e des configurations
		            if (def.popup && typeof def.popup === 'object') {
		                normalizedDef.showPopup = def.popup.enabled !== false;
		                if (def.popup.fields && Array.isArray(def.popup.fields)) {
		                    normalizedDef.popupFields = def.popup.fields;
		                }
		                normalizedDef.popup = def.popup;
		            }

		            if (def.tooltip && typeof def.tooltip === 'object') {
		                normalizedDef.showTooltip = def.tooltip.enabled !== false;
		                if (def.tooltip.fields && Array.isArray(def.tooltip.fields)) {
		                    normalizedDef.tooltipFields = def.tooltip.fields;
		                }
		                if (def.tooltip.mode) {
		                    normalizedDef.tooltipMode = def.tooltip.mode;
		                }
		                normalizedDef.tooltip = def.tooltip;
		            }

		            if (def.sidepanel && typeof def.sidepanel === 'object') {
		                if (def.sidepanel.detailLayout && Array.isArray(def.sidepanel.detailLayout)) {
		                    normalizedDef.sidepanelFields = def.sidepanel.detailLayout;
		                }
		                normalizedDef.sidepanel = def.sidepanel;
		            }

		            if (def.clustering && typeof def.clustering === 'object') {
		                normalizedDef.clustering = def.clustering.enabled !== false;
		                if (typeof def.clustering.maxClusterRadius === 'number') {
		                    normalizedDef.maxClusterRadius = def.clustering.maxClusterRadius;
		                    normalizedDef.clusterRadius = def.clustering.maxClusterRadius;
		                }
		                if (typeof def.clustering.disableClusteringAtZoom === 'number') {
		                    normalizedDef.disableClusteringAtZoom = def.clustering.disableClusteringAtZoom;
		                }
		            }

		            if (def.search && typeof def.search === 'object') {
		                normalizedDef.search = def.search;
		            }

		            if (def.table && typeof def.table === 'object') {
		                normalizedDef.table = def.table;
		            }

		            const layerId = def.id || ("geojson-layer-" + (state.layerIdCounter++));
		            const layerLabel = def.label || layerId;

		            Log.debug("[GeoLeaf.GeoJSON] Chargement couche GeoJSON :", {
		                profileId: profile.id || "(inconnu)",
		                layerId: layerId,
		                url: layerUrl
		            });

		            try {
		                return await GeoLeaf._GeoJSONLoader._loadSingleLayer(layerId, layerLabel, normalizedDef, baseOptions);
		            } catch (err) {
		                Log.error("[GeoLeaf.GeoJSON] √âchec chargement couche :", {
		                    layerId: layerId,
		                    url: layerUrl,
		                    error: err
		                });
		                return null;
		            }
		        });

		        return this._loadLayersByBatch(tasks, batchSize, batchDelay).then((layers) => {
		            const loadedLayers = layers.filter(Boolean);

		            Log.info("[GeoLeaf.GeoJSON] " + loadedLayers.length + " couche(s) GeoJSON charg√©e(s)");
		            Log.info(`[GeoLeaf.GeoJSON] Avant v√©rif LayerManager - loadedLayers: ${loadedLayers.length}, _GeoJSONLayerManager existe: ${!!GeoLeaf._GeoJSONLayerManager}`);

		            // Int√©gration avec LayerManager si disponible
		            if (loadedLayers.length > 0 && GeoLeaf._GeoJSONLayerManager) {
		                GeoLeaf._GeoJSONLayerManager.registerWithLayerManager();
		            }

		            // Fit bounds sur l'ensemble des couches si demand√©
		            if (baseOptions.fitBoundsOnLoad !== false && state.map && state.layerGroup) {
		                const bounds = state.layerGroup.getBounds();
		                if (bounds.isValid()) {
		                    const fitOptions = {};
		                    if (typeof baseOptions.maxZoomOnFit === "number") {
		                        fitOptions.maxZoom = baseOptions.maxZoomOnFit;
		                    }
		                    state.map.fitBounds(bounds, fitOptions);
		                    Log.debug("[GeoLeaf.GeoJSON] Carte ajust√©e sur l'emprise des couches GeoJSON");

		                    // √âmettre un √©v√©nement apr√®s le fitBounds
		                    const onMoveEnd = function() {
		                        state.map.off('moveend', onMoveEnd);
		                        try {
		                            const event = new CustomEvent('geoleaf:fitbounds:complete', { detail: { bounds: bounds } });
		                            document.dispatchEvent(event);
		                        } catch (e) {
		                            // fallback si CustomEvent n'est pas dispo
		                        }
		                    };
		                    state.map.on('moveend', onMoveEnd);
		                }
		            }

		            // √âv√©nement global
		            try {
		                state.map.fire("geoleaf:geojson:layers-loaded", {
		                    count: loadedLayers.length,
		                    layers: loadedLayers.map(l => ({ id: l.id, label: l.label }))
		                });
		            } catch (e) {
		                // Silencieux
		            }

		            return loadedLayers;
		        });
		    };

		    /**
		     * Ex√©cute un tableau de t√¢ches async par lots.
		     *
		     * @param {Array<Function>} tasks - Fonctions async √† ex√©cuter
		     * @param {number} [batchSize=3] - Taille des lots
		     * @param {number} [delayMs=200] - D√©lai entre les lots (non utilis√© actuellement)
		     * @returns {Promise<Array>}
		     * @private
		     */
		    GeoLeaf._GeoJSONLoader._loadLayersByBatch = async function (tasks, batchSize = 3, delayMs = 200) {
		        const results = [];

		        for (let i = 0; i < tasks.length; i += batchSize) {
		            const batch = tasks.slice(i, i + batchSize);
		            const batchStart = Date.now();
		            const batchResults = await Promise.all(batch.map(fn => fn()));
		            results.push(...batchResults);

		            const batchDuration = Date.now() - batchStart;
		            const Log = getLog();
		            Log.info(`[GeoLeaf.GeoJSON] Lot ${Math.floor(i / batchSize) + 1}/${Math.ceil(tasks.length / batchSize)} charg√© en ${batchDuration} ms`);
		        }

		        return results;
		    };

		    /**
		     * Pr√©pare les configurations de TOUTES les couches pour le LayerManager.
		     * Utilise les configs d√©j√† charg√©es par ProfileV3Loader et y ajoute les layerManagerId.
		     *
		     * @param {Object} profile - Profil actif enrichi par ProfileV3Loader
		     * @returns {Promise<Array>} - Promise r√©solvant en array des infos de couches
		     */
		    GeoLeaf._GeoJSONLoader.loadAllLayersConfigsForLayerManager = async function(profile) {
		        const Log = getLog();

		        if (!profile || !profile.layers || !Array.isArray(profile.layers)) {
		            Log.warn("[GeoLeaf.GeoJSON] loadAllLayersConfigsForLayerManager: Pas de couches dans le profil");
		            return [];
		        }

		        Log.info(`[GeoLeaf.GeoJSON] Pr√©paration de ${profile.layers.length} configurations de couches pour LayerManager...`);

		        // Les configs sont d√©j√† charg√©es par ProfileV3Loader, il suffit d'enrichir avec layerManagerId
		        const allConfigs = profile.layers.map(layer => {
		            let styles = null;
		            let labels = null;
		            if (layer.config && layer.config.styles) {
		                styles = layer.config.styles;
		            } else if (layer.styles) {
		                styles = layer.styles;
		            }
		            if (layer.config && layer.config.labels) {
		                labels = layer.config.labels;
		            } else if (layer.labels) {
		                labels = layer.labels;
		            }
		            return {
		                id: layer.id,
		                label: layer.label,
		                layerManagerId: layer.layerManagerId || "geojson-default",
		                configFile: layer.configFile,
		                zIndex: (layer.config && layer.config.zIndex) || 0,
		                themes: (layer.config && layer.config.themes) || null,
		                styles: styles,
		                labels: labels
		            };
		        });

		        Log.info(`[GeoLeaf.GeoJSON] ${allConfigs.length} configurations pr√™tes pour LayerManager`);

		        // Stocker les configs pour utilisation par LayerManager
		        GeoLeaf._allLayerConfigs = allConfigs;

		        return allConfigs;
		    };

		})(window);
		return profile;
	}

	requireProfile();

	var core$1 = {};

	/**
	 * GeoLeaf GeoJSON Module - Aggregator
	 * Module principal qui d√©l√®gue aux sous-modules sp√©cialis√©s
	 *
	 * Architecture Phase 3.5:
	 * - geojson/shared.js        : √âtat partag√©, constantes, STYLE_OPERATORS
	 * - geojson/style-resolver.js: √âvaluation styleRules, buildLeafletOptions
	 * - geojson/layer-manager.js : Gestion couches (show/hide/toggle/remove)
	 * - geojson/loader.js        : Chargement (loadUrl, loadFromActiveProfile)
	 * - geojson/popup-tooltip.js : Popups et tooltips unifi√©s
	 * - geojson/clustering.js    : Strat√©gies de clustering
	 *
	 * @module geoleaf.geojson
	 */

	var hasRequiredCore$1;

	function requireCore$1 () {
		if (hasRequiredCore$1) return core$1;
		hasRequiredCore$1 = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    // ========================================
		    //   GETTERS LAZY POUR SOUS-MODULES
		    // ========================================

		    const getShared = () => GeoLeaf._GeoJSONShared;
		    const getState = () => GeoLeaf._GeoJSONShared && GeoLeaf._GeoJSONShared.state;
		    const getStyleResolver = () => GeoLeaf._GeoJSONStyleResolver;
		    const getLayerManager = () => GeoLeaf._GeoJSONLayerManager;
		    const getLoader = () => GeoLeaf._GeoJSONLoader;
		    const getPopupTooltip = () => GeoLeaf._GeoJSONPopupTooltip;
		    const getClustering = () => GeoLeaf._GeoJSONClustering;

		    // ========================================
		    //   MODULE GEOJSON (AGR√âGATEUR)
		    // ========================================

		    const GeoJSONModule = {
		        /**
		         * Getters pour acc√®s direct √† l'√©tat (compatibilit√©)
		         */
		        get _map() { return getState() ? getState().map : null; },
		        get _layerGroup() { return getState() ? getState().layerGroup : null; },
		        get _geoJsonLayer() { return getState() ? getState().geoJsonLayer : null; },
		        get _layers() { return getState() ? getState().layers : new Map(); },
		        get _featureCache() { return getState() ? getState().featureCache : new Map(); },
		        get _options() { return getState() ? getState().options : {}; },

		        /**
		         * Valide les options pass√©es √† init()
		         * @param {Object} options
		         * @private
		         */
		        _validateOptions(options) {
		            if (options.map && typeof options.map.addLayer !== 'function') {
		                Log.warn("[GeoLeaf.GeoJSON] options.map ne semble pas √™tre une carte Leaflet valide.");
		            }

		            if (options.defaultStyle && typeof options.defaultStyle !== 'object') {
		                Log.warn("[GeoLeaf.GeoJSON] options.defaultStyle doit √™tre un objet.");
		                delete options.defaultStyle;
		            }

		            if (options.onEachFeature && typeof options.onEachFeature !== 'function') {
		                Log.warn("[GeoLeaf.GeoJSON] options.onEachFeature doit √™tre une fonction.");
		                delete options.onEachFeature;
		            }

		            if (options.pointToLayer && typeof options.pointToLayer !== 'function') {
		                Log.warn("[GeoLeaf.GeoJSON] options.pointToLayer doit √™tre une fonction.");
		                delete options.pointToLayer;
		            }

		            if (options.maxZoomOnFit !== undefined &&
		                (typeof options.maxZoomOnFit !== 'number' || options.maxZoomOnFit < 1 || options.maxZoomOnFit > 20)) {
		                Log.warn("[GeoLeaf.GeoJSON] options.maxZoomOnFit doit √™tre un nombre entre 1 et 20.");
		                options.maxZoomOnFit = GeoLeaf.CONSTANTS ? GeoLeaf.CONSTANTS.GEOJSON_MAX_ZOOM_ON_FIT : 18;
		            }

		            return options;
		        },

		        /**
		         * Initialise le module GeoJSON.
		         *
		         * @param {Object} options
		         * @param {L.Map} [options.map] - Carte Leaflet. Si absent, tentative via GeoLeaf.Core.getMap().
		         * @param {Object} [options.defaultStyle]
		         * @param {Object} [options.defaultPointStyle]
		         * @param {Function} [options.onEachFeature]
		         * @param {Function} [options.pointToLayer]
		         * @param {boolean} [options.fitBoundsOnLoad]
		         * @param {number} [options.maxZoomOnFit]
		         * @returns {L.GeoJSON|null} - La couche GeoJSON ou null si √©chec.
		         */
		        init(options = {}) {
		            const state = getState();
		            if (!state) {
		                Log.error("[GeoLeaf.GeoJSON] Module shared.js non charg√©.");
		                return null;
		            }

		            // Validation
		            options = this._validateOptions(options);

		            if (typeof global.L === "undefined" || !global.L || typeof global.L.geoJSON !== "function") {
		                Log.error("[GeoLeaf.GeoJSON] Leaflet (L) est requis mais introuvable.");
		                return null;
		            }

		            // Utiliser l'helper partag√©
		            const map = GeoLeaf.Utils ? GeoLeaf.Utils.ensureMap(options.map) : (options.map || null);

		            if (!map) {
		                Log.error(
		                    "[GeoLeaf.GeoJSON] Aucune carte Leaflet disponible. Passe une instance de carte dans init({ map })."
		                );
		                return null;
		            }

		            state.map = map;

		            // Fusionner les options
		            state.options = GeoLeaf.Utils && GeoLeaf.Utils.mergeOptions
		                ? GeoLeaf.Utils.mergeOptions(state.options, options)
		                : Object.assign({}, state.options, options);

		            // Cr√©er les panes pour contr√¥ler le z-index des couches
		            const PaneConfig = getShared().PANE_CONFIG;
		            const PaneHelpers = getShared().PaneHelpers;

		            // Basemap: z-index 200 (toujours en dessous)
		            const basemapPane = state.map.createPane(PaneConfig.BASEMAP_NAME);
		            basemapPane.style.zIndex = PaneConfig.BASEMAP_ZINDEX;

		            // Couches GeoJSON/WMS: z-index 400-499 (0-99 dans config)
		            for (let i = PaneConfig.MIN_LAYER_ZINDEX; i <= PaneConfig.MAX_LAYER_ZINDEX; i++) {
		                const pane = state.map.createPane(PaneHelpers.getPaneName(i));
		                pane.style.zIndex = PaneConfig.LAYER_BASE_ZINDEX + i;
		            }

		            Log.info(`[GeoLeaf.GeoJSON] Panes cr√©√©s : ${PaneConfig.BASEMAP_NAME} (z:${PaneConfig.BASEMAP_ZINDEX}), ${PaneConfig.LAYER_PREFIX}0 √† ${PaneConfig.LAYER_PREFIX}${PaneConfig.MAX_LAYER_ZINDEX} (z:${PaneConfig.LAYER_BASE_ZINDEX}-${PaneConfig.LAYER_BASE_ZINDEX + PaneConfig.MAX_LAYER_ZINDEX})`);

		            // Cr√©er un groupe pour encapsuler TOUTES les couches GeoJSON
		            state.layerGroup = global.L.featureGroup().addTo(state.map);

		            // Initialiser la Map des couches
		            state.layers = new Map();

		            // Ajouter un √©couteur pour g√©rer les seuils de zoom
		            const LayerManager = getLayerManager();
		            if (LayerManager) {
		                state.map.on('zoomend', () => {
		                    LayerManager.updateLayerVisibilityByZoom();
		                });
		            }

		            // LEGACY: Cr√©er la couche GeoJSON vide (pour compatibilit√©)
		            const StyleResolver = getStyleResolver();
		            const leafletOptions = StyleResolver
		                ? StyleResolver.buildLeafletOptions(state.options)
		                : {};

		            state.geoJsonLayer = global.L.geoJSON(null, leafletOptions);
		            state.geoJsonLayer.addTo(state.layerGroup);

		            Log.info("[GeoLeaf.GeoJSON] Module initialis√© en mode multi-couches");

		            return state.geoJsonLayer;
		        },

		        /**
		         * Retourne la couche GeoJSON principale (LEGACY).
		         * @returns {L.GeoJSON|null}
		         */
		        getLayer() {
		            const state = getState();
		            return state ? state.geoJsonLayer : null;
		        },

		        // ========================================
		        //   D√âL√âGATION VERS LAYER MANAGER
		        // ========================================

		        getLayerById(layerId) {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.getLayerById(layerId) : null;
		        },

		        getLayerData(layerId) {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.getLayerData(layerId) : null;
		        },

		        getAllLayers() {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.getAllLayers() : [];
		        },

		        showLayer(layerId) {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.showLayer(layerId);
		        },

		        hideLayer(layerId) {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.hideLayer(layerId);
		        },

		        toggleLayer(layerId) {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.toggleLayer(layerId);
		        },

		        removeLayer(layerId) {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.removeLayer(layerId);
		        },

		        updateLayerZIndex(layerId, newZIndex) {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.updateLayerZIndex(layerId, newZIndex) : false;
		        },

		        setLayerStyle(layerId, styleConfig) {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.setLayerStyle(layerId, styleConfig) : false;
		        },

		        // ========================================
		        //   D√âL√âGATION VERS LOADER
		        // ========================================

		        loadUrl(url, options = {}) {
		            const Loader = getLoader();
		            return Loader ? Loader.loadUrl(url, options) : Promise.resolve(null);
		        },

		        addData(geojsonData, options = {}) {
		            const Loader = getLoader();
		            if (Loader) Loader.addData(geojsonData, options);
		        },

		        loadFromActiveProfile(options = {}) {
		            const Loader = getLoader();
		            return Loader ? Loader.loadFromActiveProfile(options) : Promise.resolve([]);
		        },

		        // ========================================
		        //   FILTRAGE DES FEATURES
		        // ========================================

		        /**
		         * Filtre les features de toutes les couches GeoJSON.
		         * Montre uniquement les features qui passent le pr√©dicat.
		         *
		         * @param {Function} filterFn - Fonction (feature, layerId) => boolean
		         * @param {Object} [options] - Options suppl√©mentaires
		         * @returns {Object} - { filtered: number, total: number, visible: number }
		         */
		        filterFeatures(filterFn, options = {}) {
		            const state = getState();
		            if (typeof filterFn !== 'function') {
		                Log.warn("[GeoLeaf.GeoJSON] filterFeatures: filterFn doit √™tre une fonction");
		                return { filtered: 0, total: 0, visible: 0 };
		            }

		            const stats = { filtered: 0, total: 0, visible: 0 };

		            // D√©terminer les couches √† filtrer
		            let layerIds = [];
		            if (options.layerIds) {
		                layerIds = Array.isArray(options.layerIds) ? options.layerIds : [options.layerIds];
		            } else {
		                layerIds = Array.from(state.layers.keys());
		            }

		            // Filtrer par type de g√©om√©trie si sp√©cifi√© (avec aliases)
		            if (options.geometryType) {
		                const geoType = options.geometryType.toLowerCase();
		                const typeAliases = {
		                    'poi': 'point',
		                    'route': 'line',
		                    'linestring': 'line',
		                    'area': 'polygon'
		                };
		                const normalizedType = typeAliases[geoType] || geoType;

		                layerIds = layerIds.filter(id => {
		                    const data = state.layers.get(id);
		                    if (!data) return false;
		                    const layerGeoType = (data.geometryType || '').toLowerCase();
		                    const normalizedLayerType = typeAliases[layerGeoType] || layerGeoType;
		                    return normalizedLayerType === normalizedType;
		                });
		            }

		            layerIds.forEach(layerId => {
		                const layerData = state.layers.get(layerId);
		                if (!layerData || !layerData.layer) return;

		                // Si search.enabled === false, la couche n'est pas concern√©e par le filtrage
		                const bypassFilter = layerData.config?.search?.enabled === false;

		                // Initialiser le Set des layers filtr√©es si pas encore fait
		                if (!layerData._filteredOutLayers) {
		                    layerData._filteredOutLayers = new Set();
		                }

		                const toShow = [];
		                const toHide = [];

		                // It√©rer sur chaque feature
		                layerData.layer.eachLayer(leafletLayer => {
		                    if (!leafletLayer.feature) return;

		                    stats.total++;

		                    const shouldShow = bypassFilter || filterFn(leafletLayer.feature, layerId);

		                    if (shouldShow) {
		                        toShow.push(leafletLayer);
		                        stats.visible++;
		                    } else {
		                        toHide.push(leafletLayer);
		                        stats.filtered++;
		                    }
		                });

		                // Appliquer les changements de visibilit√©
		                const clusterGroup = layerData.clusterGroup;

		                toHide.forEach(leafletLayer => {
		                    leafletLayer._geoleafFiltered = true;

		                    if (clusterGroup) {
		                        if (!layerData._filteredOutLayers.has(leafletLayer)) {
		                            clusterGroup.removeLayer(leafletLayer);
		                            layerData._filteredOutLayers.add(leafletLayer);
		                        }
		                    } else {
		                        if (leafletLayer.getElement) {
		                            const layerElement = leafletLayer.getElement();
		                            if (layerElement) layerElement.style.display = 'none';
		                        } else if (leafletLayer.setStyle) {
		                            if (leafletLayer.options._originalOpacity === undefined) {
		                                leafletLayer.options._originalOpacity = leafletLayer.options.opacity;
		                                leafletLayer.options._originalFillOpacity = leafletLayer.options.fillOpacity;
		                            }
		                            leafletLayer.setStyle({ opacity: 0, fillOpacity: 0 });
		                        }
		                    }
		                });

		                toShow.forEach(leafletLayer => {
		                    leafletLayer._geoleafFiltered = false;

		                    if (clusterGroup) {
		                        if (layerData._filteredOutLayers.has(leafletLayer)) {
		                            clusterGroup.addLayer(leafletLayer);
		                            layerData._filteredOutLayers.delete(leafletLayer);
		                        }
		                    } else {
		                        if (leafletLayer.getElement) {
		                            const layerElement = leafletLayer.getElement();
		                            if (layerElement) layerElement.style.display = '';
		                        } else if (leafletLayer.setStyle) {
		                            leafletLayer.setStyle({
		                                opacity: leafletLayer.options._originalOpacity !== undefined
		                                    ? leafletLayer.options._originalOpacity : 1,
		                                fillOpacity: leafletLayer.options._originalFillOpacity !== undefined
		                                    ? leafletLayer.options._originalFillOpacity : 0.4
		                            });
		                        }
		                    }
		                });
		            });

		            Log.debug(`[GeoLeaf.GeoJSON] filterFeatures: ${stats.visible}/${stats.total} features visibles`);
		            return stats;
		        },

		        /**
		         * R√©initialise le filtre sur les features (montre tout).
		         *
		         * @param {Object} [options] - M√™mes options que filterFeatures
		         */
		        clearFeatureFilter(options = {}) {
		            return this.filterFeatures(() => true, options);
		        },

		        /**
		         * Retourne toutes les features charg√©es.
		         * @param {Object} [options]
		         * @returns {Array<Object>} features GeoJSON enrichies de { _layerId }
		         */
		        getFeatures(options = {}) {
		            const state = getState();
		            if (!state) return [];

		            const geometrySet = Array.isArray(options.geometryTypes)
		                ? new Set(options.geometryTypes.map(t => t.toLowerCase()))
		                : null;
		            const layerSet = Array.isArray(options.layerIds) ? new Set(options.layerIds) : null;

		            const result = [];
		            state.featureCache.forEach((entry, layerId) => {
		                if (layerSet && !layerSet.has(layerId)) return;
		                const geoType = (entry.geometryType || "").toLowerCase();
		                if (geometrySet && !geometrySet.has(geoType)) return;

		                (entry.features || []).forEach((f) => {
		                    if (f && typeof f === "object") {
		                        const clone = Object.assign({}, f, { _layerId: layerId });
		                        result.push(clone);
		                    }
		                });
		            });
		            return result;
		        },

		        /**
		         * Supprime toutes les entit√©s GeoJSON de la couche legacy.
		         */
		        clear() {
		            const state = getState();
		            if (state && state.geoJsonLayer) {
		                state.geoJsonLayer.clearLayers();
		            }
		        },

		        // ========================================
		        //   M√âTHODES INTERNES EXPOS√âES
		        // ========================================

		        _updateLayerVisibilityByZoom() {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.updateLayerVisibilityByZoom();
		        },

		        _registerWithLayerManager() {
		            const LayerManager = getLayerManager();
		            if (LayerManager) LayerManager.registerWithLayerManager();
		        },

		        _convertFeatureToPOI(feature, def) {
		            const PopupTooltip = getPopupTooltip();
		            return PopupTooltip ? PopupTooltip.convertFeatureToPOI(feature, def) : null;
		        },

		        _getClusteringStrategy(def, geojsonData) {
		            const Clustering = getClustering();
		            return Clustering
		                ? Clustering.getClusteringStrategy(def, geojsonData)
		                : { shouldCluster: false, useSharedCluster: false };
		        },

		        _getSharedPOICluster() {
		            const Clustering = getClustering();
		            return Clustering ? Clustering.getSharedPOICluster() : null;
		        },

		        _getPoiConfig() {
		            const Clustering = getClustering();
		            return Clustering ? Clustering.getPoiConfig() : {};
		        },

		        _detectLayerType(layer) {
		            const LayerManager = getLayerManager();
		            return LayerManager ? LayerManager.detectLayerType(layer) : "mixed";
		        },

		        _buildLeafletOptions(options) {
		            const StyleResolver = getStyleResolver();
		            return StyleResolver ? StyleResolver.buildLeafletOptions(options) : {};
		        }
		    };

		    // Exposer _StyleRules pour compatibilit√© avec le module Themes
		    // (d√©j√† fait dans style-resolver.js, mais on s'assure que c'est accessible)
		    if (!GeoLeaf._StyleRules && getStyleResolver()) {
		        GeoLeaf._StyleRules = {
		            evaluate: getStyleResolver().evaluateStyleRules,
		            operators: getShared() ? getShared().STYLE_OPERATORS : {},
		            getNestedValue: getStyleResolver().getNestedValue
		        };
		    }

		    // Expose le module dans l'espace de nom GeoLeaf
		    GeoLeaf.GeoJSON = GeoJSONModule;

		})(window);
		return core$1;
	}

	requireCore$1();

	var geoleaf_geojson = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_geojson;

	function requireGeoleaf_geojson () {
		if (hasRequiredGeoleaf_geojson) return geoleaf_geojson;
		hasRequiredGeoleaf_geojson = 1;
		/**
		 * GeoLeaf GeoJSON Module - Aggregator (Legacy Entry Point)
		 *
		 * Ce fichier est conserv√© pour la r√©trocompatibilit√©.
		 * Le code a √©t√© scind√© en sous-modules dans geojson/:
		 * - shared.js        : √âtat partag√©, constantes
		 * - style-resolver.js: √âvaluation styleRules
		 * - layer-manager.js : Gestion couches
		 * - loader.js        : Chargement donn√©es
		 * - popup-tooltip.js : Popups et tooltips
		 * - clustering.js    : Strat√©gies de clustering
		 * - core.js          : Module principal (agr√©gateur)
		 *
		 * @module geoleaf.geojson
		 * @deprecated Charger les sous-modules via demo/index.html
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    // V√©rifier si les sous-modules sont charg√©s
		    if (GeoLeaf._GeoJSONShared && GeoLeaf.GeoJSON) {
		        Log.debug("[GeoLeaf.GeoJSON] Sous-modules d√©j√† charg√©s, agr√©gateur legacy ignor√©.");
		        return;
		    }

		    // Si les sous-modules ne sont pas charg√©s, afficher un avertissement
		    Log.warn("[GeoLeaf.GeoJSON] Les sous-modules geojson/*.js ne sont pas charg√©s. " +
		             "Veuillez mettre √† jour demo/index.html pour charger les nouveaux modules.");

		    // Cr√©er un module stub qui affiche des erreurs utiles
		    if (!GeoLeaf.GeoJSON) {
		        GeoLeaf.GeoJSON = {
		            init() {
		                Log.error("[GeoLeaf.GeoJSON] Module non initialis√©. " +
		                          "Chargez les sous-modules geojson/*.js avant d'appeler init().");
		                return null;
		            },
		            loadUrl() {
		                Log.error("[GeoLeaf.GeoJSON] Module non initialis√©.");
		                return Promise.resolve(null);
		            },
		            loadFromActiveProfile() {
		                Log.error("[GeoLeaf.GeoJSON] Module non initialis√©.");
		                return Promise.resolve([]);
		            },
		            addData() {
		                Log.error("[GeoLeaf.GeoJSON] Module non initialis√©.");
		            },
		            getLayer() { return null; },
		            getAllLayers() { return []; },
		            getFeatures() { return []; },
		            filterFeatures() { return { filtered: 0, total: 0, visible: 0 }; },
		            clear() {}
		        };
		    }

		})(window);
		return geoleaf_geojson;
	}

	requireGeoleaf_geojson();

	var styleResolver = {};

	/**
	 * GeoLeaf Route Style Resolver Module
	 * R√©solution des styles d'itin√©raires (couleurs, endpoints)
	 */

	var hasRequiredStyleResolver;

	function requireStyleResolver () {
		if (hasRequiredStyleResolver) return styleResolver;
		hasRequiredStyleResolver = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._RouteStyleResolver = GeoLeaf._RouteStyleResolver || {};

		    const Log = GeoLeaf.Log || console;

		    /**
		     * D√©termine la couleur d'un itin√©raire selon la priorit√© :
		     *  1. colorRoute de la sous-cat√©gorie (si d√©finie)
		     *  2. colorRoute de la cat√©gorie (si d√©finie)
		     *  3. couleur par d√©faut de routeConfig.default.color
		     *
		     * @param {Object} route - L'itin√©raire
		     * @param {Object} profile - Le profil actif
		     * @param {Object} routeConfigDefault - La config par d√©faut (defaultSettings.routeConfig.default)
		     * @returns {string|null} La couleur √† utiliser ou null
		     */
		    GeoLeaf._RouteStyleResolver.getRouteColor = function (route, profile, routeConfigDefault) {
		        if (!route || !route.attributes) {
		            return routeConfigDefault?.color || null;
		        }

		        const attrs = route.attributes;
		        const categoryId = attrs.categoryId;
		        const subCategoryId = attrs.subCategoryId;

		        // R√©cup√©rer la taxonomie du profil
		        const taxonomy = profile?.taxonomy?.categories || {};

		        // 1. V√©rifier colorRoute de la sous-cat√©gorie
		        if (categoryId && subCategoryId) {
		            const category = taxonomy[categoryId];
		            if (category && category.subcategories) {
		                const subCategory = category.subcategories[subCategoryId];
		                if (subCategory && subCategory.colorRoute) {
		                    return subCategory.colorRoute;
		                }
		            }
		        }

		        // 2. V√©rifier colorRoute de la cat√©gorie
		        if (categoryId) {
		            const category = taxonomy[categoryId];
		            if (category && category.colorRoute) {
		                return category.colorRoute;
		            }
		        }

		        // 3. Couleur par d√©faut
		        return routeConfigDefault?.color || null;
		    };

		    /**
		     * Calcule le style final d'un itin√©raire en combinant :
		     *  - le style par d√©faut du module,
		     *  - la config par d√©faut du profil (defaultSettings.routeConfig.default),
		     *  - la couleur bas√©e sur la taxonomie (colorRoute),
		     *  - les surcharges au niveau de l'itin√©raire (properties.*).
		     *
		     * @param {Object} route - L'itin√©raire
		     * @param {Object} activeProfile - Le profil actif
		     * @param {Object} routeConfigDefault - Config par d√©faut du profil
		     * @param {Object} defaultStyle - Style par d√©faut du module
		     * @returns {Object} Style final r√©solu
		     */
		    GeoLeaf._RouteStyleResolver.resolveRouteStyle = function (route, activeProfile, routeConfigDefault, defaultStyle) {
		        const finalStyle = Object.assign({}, defaultStyle || {});

		        // 1) Appliquer le style par d√©faut du profil (routeConfig.default)
		        if (routeConfigDefault && typeof routeConfigDefault === "object") {
		            Object.assign(finalStyle, routeConfigDefault);
		        }

		        // 2) Couleur bas√©e sur la taxonomie (subcategory > category > default)
		        const taxonomyColor = GeoLeaf._RouteStyleResolver.getRouteColor(route, activeProfile, routeConfigDefault);
		        if (taxonomyColor) {
		            finalStyle.color = taxonomyColor;
		        }

		        // 3) Surcharges au niveau de la route (properties.*)
		        if (route.properties && typeof route.properties === "object") {
		            const p = route.properties;

		            if (typeof p.color === "string" && p.color.trim() !== "") {
		                finalStyle.color = p.color.trim();
		            }
		            if (typeof p.weight === "number") {
		                finalStyle.weight = p.weight;
		            }
		            if (typeof p.opacity === "number") {
		                finalStyle.opacity = p.opacity;
		            }
		            if (typeof p.dashArray === "string" && p.dashArray.trim() !== "") {
		                finalStyle.dashArray = p.dashArray.trim();
		            }
		        }

		        return finalStyle;
		    };

		    /**
		     * Calcule la configuration d'affichage des points d√©part / arriv√©e
		     * en combinant :
		     *  - les options par d√©faut du module (_options),
		     *  - les endpoints d√©finis dans le profil actif (defaultSettings.routeConfig.endpoints),
		     *  - les surcharges √©ventuelles au niveau de l'itin√©raire
		     *    (properties.showStart, properties.showEnd, startStyle, endStyle).
		     *
		     * @param {Object} route - L'itin√©raire
		     * @param {Object} profileEndpoints - Config endpoints du profil
		     * @param {Object} moduleOptions - Options du module Route
		     * @returns {Object} Configuration des endpoints {showStart, showEnd, startStyle, endStyle}
		     */
		    GeoLeaf._RouteStyleResolver.resolveEndpointConfig = function (route, profileEndpoints, moduleOptions) {
		        const opt = moduleOptions || {};

		        const baseStartStyle =
		            opt.startWaypointStyle || opt.waypointStyle || {
		                radius: 6,
		                color: "#ffffff",
		                fillColor: "#2b7cff",
		                fillOpacity: 1,
		                weight: 2
		            };

		        const baseEndStyle =
		            opt.endWaypointStyle || opt.waypointStyle || {
		                radius: 6,
		                color: "#ffffff",
		                fillColor: "#ff7b32",
		                fillOpacity: 1,
		                weight: 2
		            };

		        const cfg = {
		            showStart: typeof opt.showStart === "boolean" ? opt.showStart : true,
		            showEnd: typeof opt.showEnd === "boolean" ? opt.showEnd : true,
		            startStyle: Object.assign({}, baseStartStyle),
		            endStyle: Object.assign({}, baseEndStyle)
		        };

		        // 1) Profil actif (defaultSettings.routeConfig.endpoints)
		        if (profileEndpoints && typeof profileEndpoints === "object") {
		            if (typeof profileEndpoints.showStart === "boolean") {
		                cfg.showStart = profileEndpoints.showStart;
		            }
		            if (typeof profileEndpoints.showEnd === "boolean") {
		                cfg.showEnd = profileEndpoints.showEnd;
		            }
		            if (
		                profileEndpoints.start &&
		                typeof profileEndpoints.start === "object"
		            ) {
		                Object.assign(cfg.startStyle, profileEndpoints.start);
		            }
		            if (profileEndpoints.end && typeof profileEndpoints.end === "object") {
		                Object.assign(cfg.endStyle, profileEndpoints.end);
		            }
		        }

		        // 2) Surcharges au niveau de l'itin√©raire
		        if (route && route.properties && typeof route.properties === "object") {
		            const p = route.properties;

		            if (typeof p.showStart === "boolean") {
		                cfg.showStart = p.showStart;
		            }
		            if (typeof p.showEnd === "boolean") {
		                cfg.showEnd = p.showEnd;
		            }
		            if (p.startStyle && typeof p.startStyle === "object") {
		                Object.assign(cfg.startStyle, p.startStyle);
		            }
		            if (p.endStyle && typeof p.endStyle === "object") {
		                Object.assign(cfg.endStyle, p.endStyle);
		            }
		        }

		        return cfg;
		    };

		    Log.info("[GeoLeaf._RouteStyleResolver] Module Style Resolver charg√©");

		})(window);
		return styleResolver;
	}

	requireStyleResolver();

	var popupBuilder = {};

	/**
	 * GeoLeaf Route Popup Builder Module
	 * Construction des popups/tooltips et panneau lat√©ral pour les itin√©raires.
	 * D√©l√®gue le rendu au module _ContentBuilder centralis√©.
	 *
	 * @module route/popup-builder
	 * @version 2.0.0
	 */

	var hasRequiredPopupBuilder;

	function requirePopupBuilder () {
		if (hasRequiredPopupBuilder) return popupBuilder;
		hasRequiredPopupBuilder = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._RoutePopupBuilder = GeoLeaf._RoutePopupBuilder || {};

		    const Log = GeoLeaf.Log || console;

		    // ========================================
		    //   UTILITAIRES
		    // ========================================

		    /**
		     * R√©cup√®re le ContentBuilder
		     * @returns {Object|null}
		     */
		    function getContentBuilder() {
		        return GeoLeaf._ContentBuilder || null;
		    }

		    /**
		     * R√©cup√®re le Normalizer
		     * @returns {Object|null}
		     */
		    function getNormalizer() {
		        return GeoLeaf._Normalizer || null;
		    }

		    /**
		     * √âchappe le HTML
		     * @param {string} str - Cha√Æne √† √©chapper
		     * @returns {string}
		     */
		    function escapeHtml(str) {
		        if (GeoLeaf.Security && typeof GeoLeaf.Security.escapeHtml === 'function') {
		            return GeoLeaf.Security.escapeHtml(str);
		        }
		        if (str == null) return '';
		        const div = document.createElement('div');
		        div.textContent = String(str);
		        return div.innerHTML;
		    }

		    /**
		     * Convertit une route en POI normalis√©
		     * @param {Object} route - Donn√©es de la route
		     * @returns {Object} POI normalis√©
		     */
		    function convertRouteToPOI(route) {
		        const Normalizer = getNormalizer();
		        if (Normalizer && typeof Normalizer.normalizeFromRoute === 'function') {
		            return Normalizer.normalizeFromRoute(route);
		        }

		        // Fallback: conversion manuelle
		        const attrs = route.attributes || {};
		        return {
		            id: route.id,
		            sourceType: 'route',
		            geometryType: 'LineString',
		            title: route.label || route.name || 'Itin√©raire',
		            description: attrs.description || route.description || '',
		            lat: null,
		            lng: null,
		            categoryId: attrs.categoryId || null,
		            subCategoryId: attrs.subCategoryId || null,
		            attributes: {
		                ...attrs,
		                label: route.label || route.name,
		                photo: attrs.photo,
		                distance_km: attrs.distance_km,
		                duration_min: attrs.duration_min,
		                difficulty: attrs.difficulty,
		                tags: attrs.tags
		            },
		            rawData: route
		        };
		    }

		    // ========================================
		    //   CONFIGURATION
		    // ========================================

		    /**
		     * R√©cup√®re la configuration de popup pour les routes
		     * @returns {Array|null}
		     */
		    function getRoutePopupConfig() {
		        const Config = GeoLeaf.Config;
		        if (Config && typeof Config.getActiveProfile === 'function') {
		            const profile = Config.getActiveProfile();
		            if (profile?.panels?.route?.popup?.detailPopup) {
		                return profile.panels.route.popup.detailPopup;
		            }
		        }
		        return null;
		    }

		    /**
		     * R√©cup√®re la configuration du layout pour le side panel des routes
		     * @returns {Array|null}
		     */
		    function getRouteLayoutConfig() {
		        const Config = GeoLeaf.Config;
		        if (Config && typeof Config.getActiveProfile === 'function') {
		            const profile = Config.getActiveProfile();
		            if (profile?.panels?.route?.layout) {
		                return profile.panels.route.layout;
		            }
		        }
		        return null;
		    }

		    // ========================================
		    //   TOOLTIP
		    // ========================================

		    /**
		     * Ajoute un tooltip √† une polyline d'itin√©raire
		     * @param {L.Polyline} polyline - Polyline Leaflet
		     * @param {Object} route - Donn√©es de l'itin√©raire
		     */
		    GeoLeaf._RoutePopupBuilder.addRouteTooltip = function (polyline, route) {
		        const label = route.label || route.name || 'Itin√©raire';

		        polyline.bindTooltip(escapeHtml(label), {
		            sticky: true,
		            className: 'gl-route-tooltip'
		        });
		    };

		    // ========================================
		    //   POPUP
		    // ========================================

		    /**
		     * Ajoute un popup √† une polyline d'itin√©raire
		     * @param {L.Polyline} polyline - Polyline Leaflet
		     * @param {Object} route - Donn√©es de l'itin√©raire
		     * @param {Object} routeModule - R√©f√©rence au module GeoLeaf.Route
		     */
		    GeoLeaf._RoutePopupBuilder.addRoutePopup = function (polyline, route, routeModule) {
		        const popupContent = GeoLeaf._RoutePopupBuilder.buildRoutePopupContent(route);
		        polyline.bindPopup(popupContent, { maxWidth: 300 });

		        // Attacher le handler pour le bouton "Voir plus"
		        polyline.on('popupopen', () => {
		            Log.info && Log.info('[Route Popup] Popup opened for route:', route.id);
		            setTimeout(() => {
		                const selector = '.gl-poi-popup__link[data-route-id="' + route.id + '"]';
		                const linkEl = document.querySelector(selector);
		                if (linkEl) {
		                    linkEl.addEventListener('click', (e) => {
		                        e.preventDefault();
		                        GeoLeaf._RoutePopupBuilder.openRouteSidePanel(route);
		                    });
		                }
		            }, 50);
		        });
		    };

		    /**
		     * Construit le contenu HTML d'un popup pour une route
		     * @param {Object} route - Donn√©es de l'itin√©raire
		     * @returns {string} Contenu HTML
		     */
		    GeoLeaf._RoutePopupBuilder.buildRoutePopupContent = function (route) {
		        const ContentBuilder = getContentBuilder();
		        const config = getRoutePopupConfig();
		        const routeAsPoi = convertRouteToPOI(route);

		        // Utiliser ContentBuilder si disponible et configur√©
		        if (ContentBuilder && typeof ContentBuilder.buildPopupHTML === 'function' && config) {
		            return ContentBuilder.buildPopupHTML(routeAsPoi, config, {
		                resolveCategoryDisplay: null
		            });
		        }

		        // Fallback: construction manuelle du popup
		        return buildFallbackRoutePopup(route);
		    };

		    /**
		     * Construit un popup de route par d√©faut (fallback)
		     * @param {Object} route - Donn√©es de l'itin√©raire
		     * @returns {string} HTML du popup
		     */
		    function buildFallbackRoutePopup(route) {
		        const attrs = route.attributes || {};
		        const label = escapeHtml(route.label || route.name || 'Itin√©raire');
		        const description = escapeHtml(attrs.description || route.description || '');
		        const photo = attrs.photo || route.photo || null;
		        const routeId = escapeHtml(String(route.id || ''));

		        // R√©solution des ic√¥nes depuis la taxonomie
		        const categoryId = attrs.categoryId || null;
		        const subCategoryId = attrs.subCategoryId || null;

		        const activeProfile = (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === 'function')
		            ? (GeoLeaf.Config.getActiveProfile() || {})
		            : {};

		        const categories = activeProfile?.taxonomy?.categories || {};
		        const catData = categoryId ? categories[categoryId] : null;
		        const subCatData = (catData && subCategoryId) ? catData.subcategories?.[subCategoryId] : null;

		        const iconId = subCatData?.icon || catData?.icon || activeProfile?.icons?.defaultIcon || 'activity-generic';
		        const colorFill = subCatData?.colorFill || catData?.colorFill || '#666666';
		        const colorStroke = subCatData?.colorStroke || catData?.colorStroke || '#222222';

		        // Construction de l'ic√¥ne
		        let iconHtml = '';
		        {
		            const iconPrefix = activeProfile?.icons?.symbolPrefix || 'gl-poi-cat-';
		            const iconIdNormalized = String(iconId).trim().toLowerCase().replace(/\s+/g, '-');
		            const symbolId = iconPrefix + iconIdNormalized;

		            iconHtml = '<svg class="gl-poi-popup__icon" aria-hidden="true" focusable="false" viewBox="0 0 24 24">' +
		                '<circle cx="12" cy="12" r="10" fill="' + colorFill + '" stroke="' + colorStroke + '" stroke-width="1.5"/>' +
		                '<svg x="4" y="4" width="16" height="16"><use href="#' + symbolId + '" style="color: #ffffff"/></svg>' +
		                '</svg>';
		        }

		        // M√©tadonn√©es (distance, dur√©e, difficult√©)
		        let metaText = '';
		        const metaItems = [];
		        if (attrs.distance_km) {
		            metaItems.push('üìè ' + attrs.distance_km + ' km');
		        }
		        if (attrs.duration_min) {
		            metaItems.push('‚è±Ô∏è ' + attrs.duration_min + ' min');
		        }
		        if (attrs.difficulty) {
		            const diffLabels = { easy: 'Facile', medium: 'Moyen', hard: 'Difficile' };
		            metaItems.push('‚ö° ' + (diffLabels[attrs.difficulty] || attrs.difficulty));
		        }
		        if (metaItems.length > 0) {
		            metaText = '<p class="gl-poi-popup__meta-text">' + metaItems.join(' ‚Ä¢ ') + '</p>';
		        }

		        // Tags
		        const tagBadges = [];
		        if (Array.isArray(attrs.tags)) {
		            attrs.tags.forEach(tag => {
		                if (tag && typeof tag === 'string') {
		                    tagBadges.push('<span class="gl-poi-badge gl-poi-badge--tag">' + escapeHtml(tag) + '</span>');
		                }
		            });
		        }

		        // Construction du popup
		        return '<div class="gl-poi-popup">' +
		            (photo ? '<div class="gl-poi-popup__photo"><img src="' + photo + '" alt="' + label + '" /></div>' : '') +
		            '<div class="gl-poi-popup__body">' +
		                '<div class="gl-poi-popup__title-wrapper">' +
		                    '<h3 class="gl-poi-popup__title">' + iconHtml + '<span class="gl-poi-popup__title-text">' + label + '</span></h3>' +
		                '</div>' +
		                (description ? '<p class="gl-poi-popup__desc">' + description + '</p>' : '') +
		                metaText +
		                (tagBadges.length ? '<div class="gl-poi-popup__badges">' + tagBadges.join('') + '</div>' : '') +
		                '<a class="gl-poi-popup__link" href="#" data-route-id="' + routeId + '">Voir plus >>></a>' +
		            '</div>' +
		        '</div>';
		    }

		    // ========================================
		    //   SIDE PANEL
		    // ========================================

		    /**
		     * Ouvre le panneau lat√©ral avec les d√©tails d'un itin√©raire
		     * @param {Object} route - Donn√©es de l'itin√©raire
		     */
		    GeoLeaf._RoutePopupBuilder.openRouteSidePanel = function (route) {
		        // V√©rifier que le module POI est disponible
		        if (!GeoLeaf.POI || typeof GeoLeaf.POI.openSidePanelWithLayout !== 'function') {
		            Log.warn && Log.warn('[Route Popup] Cannot open side panel: POI.openSidePanelWithLayout not available');
		            return;
		        }

		        const attrs = route.attributes || {};
		        const layout = getRouteLayoutConfig();

		        // Construire les m√©tadonn√©es
		        const metadata = [];
		        if (attrs.distance_km) {
		            metadata.push('üìè Distance : ' + attrs.distance_km + ' km');
		        }
		        if (attrs.duration_min) {
		            metadata.push('‚è±Ô∏è Dur√©e : ' + attrs.duration_min + ' minutes');
		        }
		        if (attrs.difficulty) {
		            const diffLabels = { easy: 'Facile', medium: 'Moyen', hard: 'Difficile' };
		            metadata.push('‚ö° Difficult√© : ' + (diffLabels[attrs.difficulty] || attrs.difficulty));
		        }

		        // Transformer la route en structure POI pour le rendu
		        const routeAsPoi = {
		            id: route.id,
		            label: route.label || route.name,
		            title: route.label || route.name,
		            name: route.label || route.name,
		            description: attrs.description || route.description,
		            attributes: {
		                ...attrs,
		                metadata: metadata.length > 0 ? metadata : null,
		                photo: attrs.photo,
		                mainImage: attrs.photo,
		                description: attrs.description,
		                shortDescription: attrs.description,
		                description_long: attrs.description_long,
		                longDescription: attrs.description_long,
		                categoryId: attrs.categoryId,
		                subCategoryId: attrs.subCategoryId,
		                difficulty: attrs.difficulty,
		                distance_km: attrs.distance_km,
		                duration_min: attrs.duration_min,
		                tags: attrs.tags,
		                link: attrs.link
		            }
		        };

		        // Ouvrir le panneau lat√©ral
		        GeoLeaf.POI.openSidePanelWithLayout(routeAsPoi, layout);
		    };

		    Log.info && Log.info("[GeoLeaf._RoutePopupBuilder] Module Popup Builder charg√© (v2.0.0)");

		})(typeof window !== 'undefined' ? window : commonjsGlobal);
		return popupBuilder;
	}

	requirePopupBuilder();

	var loaders = {};

	/**
	 * GeoLeaf Route Loaders Module
	 * Chargement d'itin√©raires depuis diff√©rentes sources (GPX, GeoJSON, Config)
	 */

	var hasRequiredLoaders;

	function requireLoaders () {
		if (hasRequiredLoaders) return loaders;
		hasRequiredLoaders = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._RouteLoaders = GeoLeaf._RouteLoaders || {};

		    const Log = GeoLeaf.Log || console;

		    /**
		     * Charger un fichier GPX depuis une URL
		     * @param {string} url - URL du fichier GPX
		     * @param {Function} applyRouteCallback - Callback pour appliquer les coordonn√©es
		     * @returns {Promise}
		     */
		    GeoLeaf._RouteLoaders.loadGPX = async function (url, applyRouteCallback) {
		        if (!url) {
		            Log.warn("[GeoLeaf.Route] URL GPX manquante.");
		            return;
		        }

		        try {
		            const res = await fetch(url);
		            const xmlText = await res.text();
		            const gpx = new DOMParser().parseFromString(xmlText, "application/xml");

		            const coords = Array.from(gpx.getElementsByTagName("trkpt")).map(
		                (pt) => [
		                    parseFloat(pt.getAttribute("lat") || "0"),
		                    parseFloat(pt.getAttribute("lon") || "0")
		                ]
		            );

		            if (typeof applyRouteCallback === "function") {
		                applyRouteCallback(coords);
		            }
		        } catch (err) {
		            Log.error("[GeoLeaf.Route] Erreur GPX :", err);
		        }
		    };

		    /**
		     * Charger un itin√©raire GeoJSON (LineString)
		     * @param {Object} geojson - Objet GeoJSON
		     * @param {Function} applyRouteCallback - Callback pour appliquer les coordonn√©es
		     */
		    GeoLeaf._RouteLoaders.loadGeoJSON = function (geojson, applyRouteCallback) {
		        if (!geojson || !geojson.type) {
		            Log.error("[GeoLeaf.Route] GeoJSON invalide.");
		            return;
		        }

		        let coords = [];

		        if (geojson.type === "Feature" && geojson.geometry.type === "LineString") {
		            coords = geojson.geometry.coordinates.map((c) => [c[1], c[0]]);
		        } else if (geojson.type === "LineString") {
		            coords = geojson.coordinates.map((c) => [c[1], c[0]]);
		        } else {
		            Log.warn("[GeoLeaf.Route] Format GeoJSON non g√©r√©.");
		        }

		        if (typeof applyRouteCallback === "function") {
		            applyRouteCallback(coords);
		        }
		    };

		    /**
		     * Extraire un tableau de [lat, lng] √† partir d'un item de cfg.routes.
		     * @param {Object} route - Route data
		     * @returns {number[][]} Coordinates array
		     */
		    GeoLeaf._RouteLoaders.extractCoordsFromRouteItem = function (route) {
		        // Cas 1 : tableau direct de [lat, lng]
		        if (Array.isArray(route.geometry) && route.geometry.length > 0) {
		            if (
		                Array.isArray(route.geometry[0]) &&
		                typeof route.geometry[0][0] === "number" &&
		                typeof route.geometry[0][1] === "number"
		            ) {
		                return route.geometry.map((pair) => [pair[0], pair[1]]);
		            }

		            // Cas 2 : GeoJSON-like dans un tableau
		            if (
		                route.geometry[0] &&
		                typeof route.geometry[0] === "object" &&
		                route.geometry[0].type === "LineString" &&
		                Array.isArray(route.geometry[0].coordinates)
		            ) {
		                return route.geometry[0].coordinates.map((c) => [c[1], c[0]]);
		            }
		        }

		        // Cas 3 : objet GeoJSON LineString
		        if (
		            route.geometry &&
		            typeof route.geometry === "object" &&
		            route.geometry.type === "LineString" &&
		            Array.isArray(route.geometry.coordinates) &&
		            route.geometry.coordinates.length > 0
		        ) {
		            return route.geometry.coordinates.map((c) => [c[1], c[0]]);
		        }

		        // Cas 4 : objet GeoJSON MultiLineString - fusionner tous les segments
		        if (
		            route.geometry &&
		            typeof route.geometry === "object" &&
		            route.geometry.type === "MultiLineString" &&
		            Array.isArray(route.geometry.coordinates) &&
		            route.geometry.coordinates.length > 0
		        ) {
		            // Prendre le premier segment (lin√©aire le plus long) ou fusionner tous
		            const allCoords = route.geometry.coordinates.reduce((acc, segment) => {
		                if (Array.isArray(segment) && segment.length > 0) {
		                    return acc.concat(segment.map((c) => [c[1], c[0]]));
		                }
		                return acc;
		            }, []);

		            if (allCoords.length > 0) {
		                return allCoords;
		            }
		        }

		        // Aucune g√©om√©trie valide trouv√©e - DEBUG au lieu de WARN
		        // car il peut y avoir des features sans coordonn√©es valides
		        return [];
		    };

		    Log.info("[GeoLeaf._RouteLoaders] Module Loaders charg√©");

		})(window);
		return loaders;
	}

	requireLoaders();

	var layerManager = {};

	/**
	 * GeoLeaf Route Layer Manager Module
	 * Gestion des layers Leaflet pour les itin√©raires
	 */

	var hasRequiredLayerManager;

	function requireLayerManager () {
		if (hasRequiredLayerManager) return layerManager;
		hasRequiredLayerManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    GeoLeaf._RouteLayerManager = GeoLeaf._RouteLayerManager || {};

		    const Log = GeoLeaf.Log || console;

		    /**
		     * Appliquer un itin√©raire complet (remplacement)
		     * @param {Object} context - Context object with map, layerGroup, routeLayer, options
		     * @param {number[][]} coords - Coordinates array
		     * @param {Function} clearCallback - Callback to clear existing routes
		     * @param {Function} fireEventsCallback - Callback to fire route loaded events
		     */
		    GeoLeaf._RouteLayerManager.applyRoute = function (context, coords, clearCallback, fireEventsCallback) {
		        if (!Array.isArray(coords)) {
		            coords = [];
		        }

		        if (typeof clearCallback === "function") {
		            clearCallback();
		        }

		        if (!context.routeLayer && context.layerGroup && context.map) {
		            // Applique le param√®tre interactiveShapes de la config
		            const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		            const lineStyle = Object.assign({}, context.options.lineStyle, { interactive: interactiveShapes });
		            context.routeLayer = global.L.polyline([], lineStyle).addTo(
		                context.layerGroup
		            );
		        }

		        if (context.routeLayer) {
		            context.routeLayer.setLatLngs(coords);
		        }

		        if (context.options.fitBoundsOnLoad && coords.length > 1 && context.map) {
		            const bounds = context.routeLayer.getBounds();
		            const fitOpt = {};
		            if (context.options.maxZoomOnFit) {
		                fitOpt.maxZoom = context.options.maxZoomOnFit;
		            }
		            context.map.fitBounds(bounds, fitOpt);
		        }

		        if (typeof fireEventsCallback === "function") {
		            fireEventsCallback(coords);
		        }
		    };

		    /**
		     * Ajouter un waypoint manuel
		     * @param {L.LayerGroup} layerGroup - Layer group
		     * @param {number[]} latlng - Coordinates [lat, lng]
		     * @param {Object} waypointStyle - Waypoint style
		     */
		    GeoLeaf._RouteLayerManager.addWaypoint = function (layerGroup, latlng, waypointStyle) {
		        if (!layerGroup) return;
		        const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		        const style = Object.assign({}, waypointStyle, { interactive: interactiveShapes });
		        global.L.circleMarker(latlng, style).addTo(layerGroup);
		    };

		    /**
		     * Ajouter un segment manuel
		     * @param {L.Polyline} routeLayer - Route polyline
		     * @param {number[][]} coords - Coordinates to add
		     */
		    GeoLeaf._RouteLayerManager.addSegment = function (routeLayer, coords) {
		        if (!routeLayer) return;
		        const current = routeLayer.getLatLngs();
		        routeLayer.setLatLngs([...current, ...coords]);
		    };

		    /**
		     * √âmet les √©v√©nements "geoleaf:route:loaded" (Leaflet + DOM)
		     * @param {L.Map} map - Leaflet map
		     * @param {L.Polyline} routeLayer - Route polyline
		     * @param {number[][]} coords - Coordinates
		     */
		    GeoLeaf._RouteLayerManager.fireRouteLoadedEvents = function (map, routeLayer, coords) {
		        // √âv√©nement Leaflet sur la carte
		        try {
		            if (map && typeof map.fire === "function") {
		                map.fire("geoleaf:route:loaded", {
		                    coords,
		                    layer: routeLayer,
		                    source: "geoleaf.route"
		                });
		            }
		        } catch (e) {
		            Log.warn(
		                "[GeoLeaf.Route] Impossible d'√©mettre l'√©v√©nement Leaflet geoleaf:route:loaded.",
		                e
		            );
		        }

		        // CustomEvent DOM
		        if (typeof document !== "undefined" && typeof document.dispatchEvent === "function") {
		            const detail = {
		                coords: Array.isArray(coords) ? coords.slice() : [],
		                map: map,
		                layer: routeLayer,
		                source: "geoleaf.route"
		            };

		            try {
		                if (typeof CustomEvent === "function") {
		                    const event = new CustomEvent("geoleaf:route:loaded", { detail });
		                    document.dispatchEvent(event);
		                } else {
		                    const legacyEvent = document.createEvent("CustomEvent");
		                    legacyEvent.initCustomEvent(
		                        "geoleaf:route:loaded",
		                        true,
		                        true,
		                        detail
		                    );
		                    document.dispatchEvent(legacyEvent);
		                }
		            } catch (err) {
		                Log.warn(
		                    "[GeoLeaf.Route] Impossible d'√©mettre le CustomEvent geoleaf:route:loaded.",
		                    err
		                );
		            }
		        }
		    };

		    Log.info("[GeoLeaf._RouteLayerManager] Module Layer Manager charg√©");

		})(window);
		return layerManager;
	}

	requireLayerManager();

	var geoleaf_route = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_route;

	function requireGeoleaf_route () {
		if (hasRequiredGeoleaf_route) return geoleaf_route;
		hasRequiredGeoleaf_route = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√© (d√©fini par geoleaf.log.js / logger-shim)
		     */
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Module GeoLeaf.Route
		     * - Charge et affiche des itin√©raires (GPX, GeoJSON, profils GeoLeaf)
		     * - G√®re une couche d√©di√©e (polyline + points √©ventuels)
		     * - Offre une API de visibilit√© pour la L√©gende (getLayer)
		     * - Prend en compte les styles et les points d√©part/arriv√©e d√©finis
		     *   dans le profil actif (profile.json).
		     */
		    const RouteModule = {
		        _map: null,
		        _layerGroup: null,
		        _routeLayer: null,

		        _initialized: false,
		        _visible: true,

		        /**
		         * Options par d√©faut
		         */
		        _options: {
		            lineStyle: {
		                color: "#1E88E5",
		                weight: 4,
		                opacity: 0.9,
		                interactive: false
		            },
		            waypointStyle: {
		                radius: 5,
		                color: "#0D47A1",
		                fillColor: "#42A5F5",
		                fillOpacity: 0.9,
		                weight: 2
		            },
		            // Affichage des points de d√©part / arriv√©e
		            showStart: true,
		            showEnd: true,
		            startWaypointStyle: null, // si null => waypointStyle
		            endWaypointStyle: null,   // si null => waypointStyle

		            fitBoundsOnLoad: true,
		            maxZoomOnFit: 14
		        },

		        /**
		         * Valide les options pass√©es √† init()
		         * @param {Object} options
		         * @private
		         */
		        _validateOptions(options) {
		            if (options.map && typeof options.map.addLayer !== "function") {
		                Log.warn("[GeoLeaf.Route] options.map ne semble pas √™tre une carte Leaflet valide.");
		            }

		            if (options.lineStyle && typeof options.lineStyle !== "object") {
		                Log.warn("[GeoLeaf.Route] options.lineStyle doit √™tre un objet.");
		                delete options.lineStyle;
		            }

		            if (options.waypointStyle && typeof options.waypointStyle !== "object") {
		                Log.warn("[GeoLeaf.Route] options.waypointStyle doit √™tre un objet.");
		                delete options.waypointStyle;
		            }

		            if (
		                options.maxZoomOnFit !== undefined &&
		                (typeof options.maxZoomOnFit !== "number" ||
		                    options.maxZoomOnFit < 1 ||
		                    options.maxZoomOnFit > 20)
		            ) {
		                Log.warn("[GeoLeaf.Route] options.maxZoomOnFit doit √™tre entre 1 et 20.");
		                options.maxZoomOnFit = 14;
		            }

		            return options;
		        },

		        /**
		         * Retourne le layerGroup contenant les itin√©raires
		         * (utilis√© par la L√©gende pour afficher/masquer la couche)
		         * @returns {L.LayerGroup|null}
		         */
		        getLayer() {
		            return this._layerGroup || null;
		        },

		        /**
		         * Initialisation du module Route
		         * @param {Object} options
		         * @param {L.Map} [options.map] - Carte Leaflet
		         * @returns {L.LayerGroup|null}
		         */
		        init(options = {}) {
		            options = this._validateOptions(options);

		            if (typeof global.L === "undefined") {
		                Log.error("[GeoLeaf.Route] Leaflet introuvable.");
		                return null;
		            }

		            // Utilise un helper commun si disponible
		            let map = options.map || null;
		            if (!map && GeoLeaf.Core && typeof GeoLeaf.Core.getMap === "function") {
		                map = GeoLeaf.Core.getMap();
		            }
		            if (GeoLeaf.Utils && typeof GeoLeaf.Utils.ensureMap === "function") {
		                map = GeoLeaf.Utils.ensureMap(map);
		            }

		            if (!map) {
		                Log.error("[GeoLeaf.Route] Aucune carte disponible pour init().");
		                return null;
		            }

		            this._map = map;

		            // Fusion des options
		            if (GeoLeaf.Utils && typeof GeoLeaf.Utils.mergeOptions === "function") {
		                this._options = GeoLeaf.Utils.mergeOptions(this._options, options);
		            } else {
		                this._options = Object.assign({}, this._options, options);
		            }

		            // Applique le param√®tre interactiveShapes de la config
		            const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		            if (this._options.lineStyle) {
		                this._options.lineStyle.interactive = interactiveShapes;
		            }

		            this._layerGroup = global.L.layerGroup().addTo(this._map);
		            this._routeLayer = global.L.polyline([], this._options.lineStyle).addTo(
		                this._layerGroup
		            );

		            this._initialized = true;
		            this._visible = true;

		            return this._layerGroup;
		        },

		        /**
		         * Indique si le module est initialis√©.
		         * @returns {boolean}
		         */
		        isInitialized() {
		            return this._initialized === true && !!this._map && !!this._layerGroup;
		        },

		        /**
		         * Indique si la couche d'itin√©raires est actuellement visible.
		         * @returns {boolean}
		         */
		        isVisible() {
		            return this._visible === true;
		        },

		        /**
		         * Affiche la couche d'itin√©raires.
		         */
		        show() {
		            if (!this._map || !this._layerGroup) return;
		            if (!this._map.hasLayer(this._layerGroup)) {
		                this._layerGroup.addTo(this._map);
		            }
		            this._visible = true;
		        },

		        /**
		         * Masque la couche d'itin√©raires.
		         */
		        hide() {
		            if (!this._map || !this._layerGroup) return;
		            if (this._map.hasLayer(this._layerGroup)) {
		                this._map.removeLayer(this._layerGroup);
		            }
		            this._visible = false;
		        },

		        /**
		         * Bascule la visibilit√© (utile √©ventuellement en dehors de la L√©gende).
		         */
		        toggleVisibility() {
		            if (!this.isInitialized()) {
		                Log.warn("[GeoLeaf.Route] toggleVisibility() appel√© sans init().");
		                return;
		            }
		            if (this.isVisible()) {
		                this.hide();
		            } else {
		                this.show();
		            }
		        },

		        /**
		         * Vider tous les itin√©raires de la couche
		         */
		        clear() {
		            if (this._layerGroup) {
		                this._layerGroup.clearLayers();
		            }
		            if (this._map && this._layerGroup) {
		                this._routeLayer = global.L.polyline([], this._options.lineStyle).addTo(
		                    this._layerGroup
		                );
		            } else {
		                this._routeLayer = null;
		            }
		        },

		        /**
		         * Charger un fichier GPX (via fetch)
		         * @param {string} url
		         * @returns {Promise<void>}
		         */
		        loadGPX(url) {
		            if (!url) {
		                Log.warn("[GeoLeaf.Route] URL GPX manquante.");
		                return Promise.resolve();
		            }

		            // Sprint 3.3: Use unified FetchHelper with timeout for GPX loading
		            const FetchHelper = GeoLeaf.Utils?.FetchHelper;

		            if (FetchHelper) {
		                return FetchHelper.fetch(url, {
		                    timeout: 15000, // GPX files can be larger, allow more time
		                    retries: 2,
		                    parseResponse: false // We need raw text
		                })
		                .then((response) => response.text())
		                .then((xmlText) =>
		                    new DOMParser().parseFromString(xmlText, "application/xml")
		                )
		                .then((gpx) => {
		                    const coords = Array.from(gpx.getElementsByTagName("trkpt")).map(
		                        (pt) => [
		                            parseFloat(pt.getAttribute("lat") || "0"),
		                            parseFloat(pt.getAttribute("lon") || "0")
		                        ]
		                    );
		                    this._applyRoute(coords);
		                })
		                .catch((err) => Log.error("[GeoLeaf.Route] Erreur GPX :", err));
		            }

		            // Fallback to raw fetch
		            return fetch(url)
		                .then((res) => res.text())
		                .then((xmlText) =>
		                    new DOMParser().parseFromString(xmlText, "application/xml")
		                )
		                .then((gpx) => {
		                    const coords = Array.from(gpx.getElementsByTagName("trkpt")).map(
		                        (pt) => [
		                            parseFloat(pt.getAttribute("lat") || "0"),
		                            parseFloat(pt.getAttribute("lon") || "0")
		                        ]
		                    );
		                    this._applyRoute(coords);
		                })
		                .catch((err) => Log.error("[GeoLeaf.Route] Erreur GPX :", err));
		        },

		        /**
		         * Charger un itin√©raire GeoJSON (LineString)
		         * @param {Object} geojson
		         */
		        loadGeoJSON(geojson) {
		            if (!GeoLeaf._RouteLoaders || typeof GeoLeaf._RouteLoaders.loadGeoJSON !== "function") {
		                Log.error("[GeoLeaf.Route.loadGeoJSON] GeoLeaf._RouteLoaders.loadGeoJSON() non disponible.");
		                return;
		            }
		            GeoLeaf._RouteLoaders.loadGeoJSON(geojson, this._applyRoute.bind(this));
		        },

		        /**
		         * Charge un tableau d‚Äôitin√©raires d√©j√† normalis√©s depuis cfg.routes
		         * (profil GeoLeaf) et les dessine sur la carte.
		         *
		         * Format attendu pour chaque item :
		         * {
		         *   id: "route-id",
		         *   label: "Nom",
		         *   type: "walking" | "trekking" | ... (optionnel)
		         *   geometry: [ [lat, lng], ... ]  // OU GeoJSON LineString
		         *   properties: {
		         *     type?: "walking" | "trekking" | ...,
		         *     color?: "#hex",
		         *     weight?: number,
		         *     opacity?: number,
		         *     dashArray?: string,
		         *     showStart?: boolean,
		         *     showEnd?: boolean,
		         *     startStyle?: {...},
		         *     endStyle?: {...},
		         *     ...
		         *   }
		         * }
		         *
		         * Les styles et endpoints par d√©faut peuvent √™tre d√©finis
		         * dans le profil actif (profile.json) :
		         *
		         * "defaultSettings": {
		         *   "routeConfig": {
		         *     "default": { "color": "#ff6600", "weight": 4, "opacity": 0.9 },
		         *     "endpoints": {
		         *       "showStart": true,
		         *       "showEnd": true,
		         *       "start": { "radius": 6, "color": "#ffffff", "fillColor": "#2b7cff" },
		         *       "end":   { "radius": 6, "color": "#ffffff", "fillColor": "#ff7b32" }
		         *     }
		         *   }
		         * }
		         *
		         * La couleur des routes est d√©termin√©e par priorit√© :
		         * 1. colorRoute de la sous-cat√©gorie (taxonomy.categories[cat].subcategories[subcat].colorRoute)
		         * 2. colorRoute de la cat√©gorie (taxonomy.categories[cat].colorRoute)
		         * 3. defaultSettings.routeConfig.default.color
		         *
		         * @param {Array} routes
		         */
		        loadFromConfig(routes) {
		            if (!this.isInitialized()) {
		                Log.warn(
		                    "[GeoLeaf.Route] loadFromConfig() appel√© alors que le module n'est pas initialis√©."
		                );
		                return;
		            }

		            if (!Array.isArray(routes) || routes.length === 0) {
		                this.clear();
		                Log.info("[GeoLeaf.Route] Aucun itin√©raire dans cfg.routes ; couche vid√©e.");
		                return;
		            }

		            this.clear();

		            const allCoords = [];
		            const defaultStyle = this._options.lineStyle || {};

		            // R√©cup√©rer config + endpoints d√©finis dans le profil actif
		            let activeProfile = null;
		            let routeConfigDefault = null;
		            let profileEndpoints = null;

		            try {
		                if (
		                    GeoLeaf.Config &&
		                    typeof GeoLeaf.Config.getActiveProfile === "function"
		                ) {
		                    activeProfile = GeoLeaf.Config.getActiveProfile();
		                    if (activeProfile && activeProfile.defaultSettings && activeProfile.defaultSettings.routeConfig) {
		                        if (
		                            activeProfile.defaultSettings.routeConfig.default &&
		                            typeof activeProfile.defaultSettings.routeConfig.default === "object" &&
		                            !Array.isArray(activeProfile.defaultSettings.routeConfig.default)
		                        ) {
		                            routeConfigDefault = activeProfile.defaultSettings.routeConfig.default;
		                        }
		                        if (
		                            activeProfile.defaultSettings.routeConfig.endpoints &&
		                            typeof activeProfile.defaultSettings.routeConfig.endpoints === "object" &&
		                            !Array.isArray(activeProfile.defaultSettings.routeConfig.endpoints)
		                        ) {
		                            profileEndpoints = activeProfile.defaultSettings.routeConfig.endpoints;
		                        }
		                    }
		                }
		            } catch (e) {
		                Log.warn(
		                    "[GeoLeaf.Route] Impossible de lire la config/endpoints depuis le profil actif.",
		                    e
		                );
		            }

		            routes.forEach((route) => {
		                if (!route || typeof route !== "object") {
		                    return;
		                }

		                const coords = this._extractCoordsFromRouteItem(route);
		                if (!coords || coords.length === 0) {
		                    return;
		                }

		                // Style de la polyline
		                const routeStyle = this._resolveRouteStyle(
		                    route,
		                    activeProfile,
		                    routeConfigDefault,
		                    defaultStyle
		                );

		                // Applique le param√®tre interactiveShapes
		                const interactiveShapes = GeoLeaf.Config.get('ui.interactiveShapes', false);
		                routeStyle.interactive = interactiveShapes;

		                const polyline = global.L.polyline(coords, routeStyle).addTo(
		                    this._layerGroup
		                );

		                // Attach route data to polyline for popup/tooltip access
		                polyline._geoleafRouteData = route;

		                // Add tooltip with route label
		                this._addRouteTooltip(polyline, route);

		                // Add popup with route details
		                this._addRoutePopup(polyline, route);

		                // Premi√®re polyline = "routeLayer" principal
		                if (!this._routeLayer) {
		                    this._routeLayer = polyline;
		                }

		                allCoords.push(...coords);

		                // Points de d√©part / arriv√©e
		                const endpointCfg = this._resolveEndpointConfig(
		                    route,
		                    profileEndpoints,
		                    this._options
		                );

		                if (coords.length > 0) {
		                    const startLatLng = coords[0];
		                    const endLatLng = coords[coords.length - 1];

		                    if (endpointCfg.showStart) {
		                        const startStyle = Object.assign({}, endpointCfg.startStyle, { interactive: interactiveShapes });
		                        global.L.circleMarker(startLatLng, startStyle).addTo(
		                            this._layerGroup
		                        );
		                    }

		                    if (
		                        endpointCfg.showEnd &&
		                        endLatLng &&
		                        (endLatLng[0] !== startLatLng[0] ||
		                            endLatLng[1] !== startLatLng[1])
		                    ) {
		                        const endStyle = Object.assign({}, endpointCfg.endStyle, { interactive: interactiveShapes });
		                        global.L.circleMarker(endLatLng, endStyle).addTo(
		                            this._layerGroup
		                        );
		                    }
		                }
		            });

		            if (allCoords.length === 0) {
		                Log.warn(
		                    "[GeoLeaf.Route] loadFromConfig() n'a trouv√© aucun itin√©raire valide dans cfg.routes."
		                );
		                return;
		            }

		            // Ajuster l'emprise globale si option activ√©e
		            if (this._options.fitBoundsOnLoad) {
		                try {
		                    const bounds = this._layerGroup.getBounds();
		                    const fitOpt = {};
		                    if (this._options.maxZoomOnFit) {
		                        fitOpt.maxZoom = this._options.maxZoomOnFit;
		                    }
		                    this._map.fitBounds(bounds, fitOpt);
		                } catch (e) {
		                    Log.warn(
		                        "[GeoLeaf.Route] Erreur lors du fitBounds sur les itin√©raires :",
		                        e
		                    );
		                }
		            }

		            // √âv√©nements "route loaded" (Leaflet + DOM)
		            this._fireRouteLoadedEvents(allCoords);
		        },

		        /**
		         * Filtrer la visibilit√© des routes d√©j√† charg√©es sans les recharger.
		         * Pr√©serve les styles originaux des routes.
		         * @param {Array<Object>} filteredRoutes - Liste des routes √† afficher (apr√®s filtrage)
		         * @public
		         */
		        filterVisibility: function (filteredRoutes) {
		            if (!this._initialized) {
		                Log.warn("[GeoLeaf.Route] Module non initialis√© - filterVisibility ignor√©.");
		                return;
		            }

		            if (!Array.isArray(filteredRoutes)) {
		                Log.warn("[GeoLeaf.Route] filterVisibility : filteredRoutes doit √™tre un tableau.");
		                return;
		            }

		            // Cr√©er un Set des IDs des routes √† afficher pour une recherche rapide
		            const visibleRouteIds = new Set(filteredRoutes.map(r => r.id));

		            // Parcourir toutes les couches actuellement affich√©es
		            this._layerGroup.eachLayer(function (layer) {
		                // V√©rifier si cette couche a un ID de route
		                const routeId = layer.options && layer.options.routeId;

		                if (routeId !== undefined) {
		                    // Afficher ou masquer selon si l'ID est dans la liste filtr√©e
		                    if (visibleRouteIds.has(routeId)) {
		                        if (!this._map.hasLayer(layer)) {
		                            this._map.addLayer(layer);
		                        }
		                    } else {
		                        if (this._map.hasLayer(layer)) {
		                            this._map.removeLayer(layer);
		                        }
		                    }
		                }
		            }.bind(this));

		            Log.info("[GeoLeaf.Route] Visibilit√© filtr√©e : " + filteredRoutes.length + " routes visibles.");
		        },

		        /**
		         * Extraire un tableau de [lat, lng] √† partir d'un item de cfg.routes.
		         * @param {Object} route
		         * @returns {number[][]}
		         * @private
		         */
		        _extractCoordsFromRouteItem(route) {
		            if (!GeoLeaf._RouteLoaders || typeof GeoLeaf._RouteLoaders.extractCoordsFromRouteItem !== "function") {
		                Log.error("[GeoLeaf.Route._extractCoordsFromRouteItem] GeoLeaf._RouteLoaders.extractCoordsFromRouteItem() non disponible.");
		                return [];
		            }
		            return GeoLeaf._RouteLoaders.extractCoordsFromRouteItem(route);
		        },

		        /**
		         * D√©termine la couleur d'un itin√©raire selon la priorit√© :
		         *  1. colorRoute de la sous-cat√©gorie (si d√©finie)
		         *  2. colorRoute de la cat√©gorie (si d√©finie)
		         *  3. couleur par d√©faut de routeConfig.default.color
		         *
		         * @param {Object} route - L'itin√©raire
		         * @param {Object} profile - Le profil actif
		         * @param {Object} routeConfigDefault - La config par d√©faut (defaultSettings.routeConfig.default)
		         * @returns {string|null} La couleur √† utiliser ou null
		         * @private
		         */
		        _getRouteColor(route, profile, routeConfigDefault) {
		            if (!GeoLeaf._RouteStyleResolver || typeof GeoLeaf._RouteStyleResolver.getRouteColor !== "function") {
		                Log.error("[GeoLeaf.Route._getRouteColor] GeoLeaf._RouteStyleResolver.getRouteColor() non disponible.");
		                return routeConfigDefault?.color || null;
		            }
		            return GeoLeaf._RouteStyleResolver.getRouteColor(route, profile, routeConfigDefault);
		        },

		        /**
		         * Calcule le style final d'un itin√©raire en combinant :
		         *  - le style par d√©faut du module,
		         *  - la config par d√©faut du profil (defaultSettings.routeConfig.default),
		         *  - la couleur bas√©e sur la taxonomie (colorRoute),
		         *  - les surcharges au niveau de l'itin√©raire (properties.*).
		         *
		         * @private
		         */
		        _resolveRouteStyle(route, activeProfile, routeConfigDefault, defaultStyle) {
		            if (!GeoLeaf._RouteStyleResolver || typeof GeoLeaf._RouteStyleResolver.resolveRouteStyle !== "function") {
		                Log.error("[GeoLeaf.Route._resolveRouteStyle] GeoLeaf._RouteStyleResolver.resolveRouteStyle() non disponible.");
		                return Object.assign({}, defaultStyle || {});
		            }
		            return GeoLeaf._RouteStyleResolver.resolveRouteStyle(route, activeProfile, routeConfigDefault, defaultStyle);
		        },

		        /**
		         * Calcule la configuration d'affichage des points d√©part / arriv√©e
		         * en combinant :
		         *  - les options par d√©faut du module (_options),
		         *  - les endpoints d√©finis dans le profil actif (defaultSettings.routeConfig.endpoints),
		         *  - les surcharges √©ventuelles au niveau de l'itin√©raire
		         *    (properties.showStart, properties.showEnd, startStyle, endStyle).
		         *
		         * @private
		         */
		        _resolveEndpointConfig(route, profileEndpoints, moduleOptions) {
		            if (!GeoLeaf._RouteStyleResolver || typeof GeoLeaf._RouteStyleResolver.resolveEndpointConfig !== "function") {
		                Log.error("[GeoLeaf.Route._resolveEndpointConfig] GeoLeaf._RouteStyleResolver.resolveEndpointConfig() non disponible.");
		                return {
		                    showStart: true,
		                    showEnd: true,
		                    startStyle: { radius: 6, color: "#ffffff", fillColor: "#2b7cff", fillOpacity: 1, weight: 2 },
		                    endStyle: { radius: 6, color: "#ffffff", fillColor: "#ff7b32", fillOpacity: 1, weight: 2 }
		                };
		            }
		            return GeoLeaf._RouteStyleResolver.resolveEndpointConfig(route, profileEndpoints, moduleOptions);
		        },

		        /**
		         * Ajouter un waypoint manuel
		         * @param {number[]} latlng
		         */
		        addWaypoint(latlng) {
		            if (!GeoLeaf._RouteLayerManager || typeof GeoLeaf._RouteLayerManager.addWaypoint !== "function") {
		                Log.error("[GeoLeaf.Route.addWaypoint] GeoLeaf._RouteLayerManager.addWaypoint() non disponible.");
		                return;
		            }
		            GeoLeaf._RouteLayerManager.addWaypoint(this._layerGroup, latlng, this._options.waypointStyle);
		        },

		        /**
		         * Ajouter un segment manuel
		         * @param {number[][]} coords
		         */
		        addSegment(coords) {
		            if (!this._routeLayer) return;
		            const current = this._routeLayer.getLatLngs();
		            this._routeLayer.setLatLngs([...current, ...coords]);
		        },

		        /**
		         * Appliquer un itin√©raire complet (remplacement)
		         * @param {number[][]} coords
		         * @private
		         */
		        _applyRoute(coords) {
		            if (!GeoLeaf._RouteLayerManager || typeof GeoLeaf._RouteLayerManager.applyRoute !== "function") {
		                Log.error("[GeoLeaf.Route._applyRoute] GeoLeaf._RouteLayerManager.applyRoute() non disponible.");
		                return;
		            }
		            const context = {
		                map: this._map,
		                layerGroup: this._layerGroup,
		                routeLayer: this._routeLayer,
		                options: this._options
		            };
		            GeoLeaf._RouteLayerManager.applyRoute(context, coords, this.clear.bind(this), this._fireRouteLoadedEvents.bind(this));
		            this._routeLayer = context.routeLayer;
		        },

		        /**
		         * Add tooltip to route polyline
		         * @param {L.Polyline} polyline
		         * @param {Object} route
		         * @private
		         */
		        _addRouteTooltip(polyline, route) {
		            if (!GeoLeaf._RoutePopupBuilder || typeof GeoLeaf._RoutePopupBuilder.addRouteTooltip !== "function") {
		                Log.error("[GeoLeaf.Route._addRouteTooltip] GeoLeaf._RoutePopupBuilder.addRouteTooltip() non disponible.");
		                return;
		            }
		            GeoLeaf._RoutePopupBuilder.addRouteTooltip(polyline, route);
		        },

		        /**
		         * Add popup to route polyline with "Voir plus" button
		         * @param {L.Polyline} polyline
		         * @param {Object} route
		         * @private
		         */
		        _addRoutePopup(polyline, route) {
		            if (!GeoLeaf._RoutePopupBuilder || typeof GeoLeaf._RoutePopupBuilder.addRoutePopup !== "function") {
		                Log.error("[GeoLeaf.Route._addRoutePopup] GeoLeaf._RoutePopupBuilder.addRoutePopup() non disponible.");
		                return;
		            }
		            GeoLeaf._RoutePopupBuilder.addRoutePopup(polyline, route, this);
		        },

		        /**
		         * Build popup content for route (same structure as POI popup)
		         * @param {Object} route
		         * @returns {string} HTML content
		         * @private
		         */
		        _buildRoutePopupContent(route) {
		            if (!GeoLeaf._RoutePopupBuilder || typeof GeoLeaf._RoutePopupBuilder.buildRoutePopupContent !== "function") {
		                Log.error("[GeoLeaf.Route._buildRoutePopupContent] GeoLeaf._RoutePopupBuilder.buildRoutePopupContent() non disponible.");
		                return "<div>Route popup non disponible</div>";
		            }
		            return GeoLeaf._RoutePopupBuilder.buildRoutePopupContent(route);
		        },        /**
		         * Open side panel with route details
		         * @param {Object} route
		         * @private
		         */
		        _openRouteSidePanel(route) {
		            if (!GeoLeaf._RoutePopupBuilder || typeof GeoLeaf._RoutePopupBuilder.openRouteSidePanel !== "function") {
		                Log.error("[GeoLeaf.Route._openRouteSidePanel] GeoLeaf._RoutePopupBuilder.openRouteSidePanel() non disponible.");
		                return;
		            }
		            GeoLeaf._RoutePopupBuilder.openRouteSidePanel(route);
		        },

		        /**
		         * √âmet les √©v√©nements "geoleaf:route:loaded" (Leaflet + DOM)
		         * @param {number[][]} coords
		         * @private
		         */
		        _fireRouteLoadedEvents(coords) {
		            // √âv√©nement Leaflet sur la carte
		            try {
		                if (this._map && typeof this._map.fire === "function") {
		                    this._map.fire("geoleaf:route:loaded", {
		                        coords,
		                        layer: this._routeLayer,
		                        source: "geoleaf.route"
		                    });
		                }
		            } catch (e) {
		                Log.warn(
		                    "[GeoLeaf.Route] Impossible d'√©mettre l'√©v√©nement Leaflet geoleaf:route:loaded.",
		                    e
		                );
		            }

		            // CustomEvent DOM
		            if (typeof document !== "undefined" && typeof document.dispatchEvent === "function") {
		                const detail = {
		                    coords: Array.isArray(coords) ? coords.slice() : [],
		                    map: this._map,
		                    layer: this._routeLayer,
		                    source: "geoleaf.route"
		                };

		                try {
		                    if (typeof CustomEvent === "function") {
		                        const event = new CustomEvent("geoleaf:route:loaded", { detail });
		                        document.dispatchEvent(event);
		                    } else {
		                        const legacyEvent = document.createEvent("CustomEvent");
		                        legacyEvent.initCustomEvent(
		                            "geoleaf:route:loaded",
		                            true,
		                            true,
		                            detail
		                        );
		                        document.dispatchEvent(legacyEvent);
		                    }
		                } catch (err) {
		                    Log.warn(
		                        "[GeoLeaf.Route] Impossible d'√©mettre le CustomEvent geoleaf:route:loaded.",
		                        err
		                    );
		                }
		            }
		        }
		    };

		    GeoLeaf.Route = RouteModule;
		})(window);
		return geoleaf_route;
	}

	requireGeoleaf_route();

	var shared = {};

	/**
	 * Module partag√© pour LayerManager
	 * √âtat et utilitaires communs entre les sous-modules
	 *
	 * D√âPENDANCES:
	 * - GeoLeaf.Log (optionnel)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LayerManagerShared
	 */

	var hasRequiredShared;

	function requireShared () {
		if (hasRequiredShared) return shared;
		hasRequiredShared = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    /**
		     * √âtat partag√© pour LayerManager (priv√© interne)
		     * @private
		     */
		    const _LayerManagerShared = {
		        /**
		         * R√©f√©rence √† la carte Leaflet
		         * @type {L.Map|null}
		         */
		        map: null,

		        /**
		         * R√©f√©rence au contr√¥le Leaflet
		         * @type {L.Control|null}
		         */
		        control: null,

		        /**
		         * Options internes du module
		         * @type {Object}
		         */
		        options: {
		            position: "bottomright",
		            title: "L√©gende",
		            collapsible: true,
		            collapsed: false,
		            sections: []
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LayerManagerShared = _LayerManagerShared;

		})(window);
		return shared;
	}

	requireShared();

	var renderer$1 = {};

	/**
	 * Module Renderer pour LayerManager
	 * Logique de rendu des sections et items de la l√©gende
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.DomUtil, L.DomEvent)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf._LayerManagerBasemapSelector (pour section basemap)
	 * - GeoLeaf._LayerManagerThemeSelector (pour th√®mes)
	 * - GeoLeaf.Themes (pour getAvailableThemes)
	 * - GeoLeaf.GeoJSON (pour setTheme)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LayerManagerRenderer
	 */

	var hasRequiredRenderer$1;

	function requireRenderer$1 () {
		if (hasRequiredRenderer$1) return renderer$1;
		hasRequiredRenderer$1 = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Renderer pour LayerManager
		     * @namespace _LayerManagerRenderer
		     * @private
		     */
		    const _LayerManagerRenderer = {
		        /**
		         * Rend les sections de la l√©gende
		         * @param {HTMLElement} bodyEl - √âl√©ment body de la l√©gende
		         * @param {Array} sections - Liste des sections √† rendre
		         */
		        renderSections(bodyEl, sections) {
		            if (!bodyEl) {
		                return;
		            }

		            // Clear content sans innerHTML
		            if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.clearElement === 'function') {
		                GeoLeaf._UIComponents.clearElement(bodyEl);
		            } else {
		                while (bodyEl.firstChild) {
		                    bodyEl.removeChild(bodyEl.firstChild);
		                }
		            }

		            if (!Array.isArray(sections) || sections.length === 0) {
		                if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.createEmptyMessage === 'function') {
		                    GeoLeaf._UIComponents.createEmptyMessage(bodyEl, "Aucune couche √† afficher.", "gl-layer-manager__empty");
		                } else {
		                    const emptyEl = global.L.DomUtil.create("div", "gl-layer-manager__empty", bodyEl);
		                    emptyEl.textContent = "Aucune couche √† afficher.";
		                }
		                return;
		            }

		            // Filtrer les sections legacy "poi" et "route" (obsol√®tes)
		            const filteredSections = sections.filter(s => s.id !== "poi" && s.id !== "route");

		            filteredSections.forEach((section) => {
		                const isCollapsible = typeof section.collapsedByDefault === 'boolean';
		                const isCollapsed = section.collapsedByDefault === true;

		                const sectionEl = global.L.DomUtil.create(
		                    "div",
		                    isCollapsible ? "gl-layer-manager__section gl-layer-manager__section--accordion" : "gl-layer-manager__section",
		                    bodyEl
		                );

		                if (isCollapsed) {
		                    sectionEl.classList.add("gl-layer-manager__section--collapsed");
		                }

		                if (section.label) {
		                    if (isCollapsible) {
		                        // En-t√™te cliquable pour accord√©on
		                        const accordionHeader = global.L.DomUtil.create(
		                            "div",
		                            "gl-layer-manager__accordion-header",
		                            sectionEl
		                        );

		                        const sectionTitle = global.L.DomUtil.create(
		                            "div",
		                            "gl-layer-manager__section-title",
		                            accordionHeader
		                        );
		                        sectionTitle.textContent = section.label;

		                        const accordionArrow = global.L.DomUtil.create(
		                            "span",
		                            "gl-layer-manager__accordion-arrow",
		                            accordionHeader
		                        );
		                        accordionArrow.textContent = "‚ñ∂";

		                        // Gestionnaire de clic pour l'accord√©on
		                        global.L.DomEvent.on(accordionHeader, "click", function(ev) {
		                            global.L.DomEvent.stopPropagation(ev);
		                            global.L.DomEvent.preventDefault(ev);

		                            const wasCollapsed = sectionEl.classList.contains("gl-layer-manager__section--collapsed");
		                            sectionEl.classList.toggle("gl-layer-manager__section--collapsed");

		                            // Mettre √† jour la fl√®che avec animation
		                            accordionArrow.textContent = wasCollapsed ? "‚ñº" : "‚ñ∂";

		                            // Mettre √† jour l'√©tat dans la section
		                            section._isExpanded = wasCollapsed;

		                            if (Log) Log.debug("[LayerManager] Accord√©on", section.id, wasCollapsed ? "ouvert" : "ferm√©");
		                        });
		                    } else {
		                        // Titre simple pour section non-accord√©on
		                        const sectionTitle = global.L.DomUtil.create(
		                            "div",
		                            "gl-layer-manager__section-title",
		                            sectionEl
		                        );
		                        sectionTitle.textContent = section.label;
		                    }
		                }

		                // Si pas d'items, garder la section visible avec son titre seulement
		                if (!Array.isArray(section.items) || section.items.length === 0) {
		                    return;
		                }

		                // Cr√©er le corps de la section (accord√©on ou simple)
		                const sectionBody = isCollapsible ?
		                    global.L.DomUtil.create("div", "gl-layer-manager__accordion-body", sectionEl) :
		                    sectionEl;

		                // Section basemap : d√©l√©guer au BasemapSelector
		                if (section.id === "basemap") {
		                    if (GeoLeaf._LayerManagerBasemapSelector) {
		                        GeoLeaf._LayerManagerBasemapSelector.render(section, sectionBody);
		                    }
		                } else {
		                    // Autres sections : rendre les items
		                    this._renderItems(section, sectionBody);
		                }
		            });

		            // Synchroniser imm√©diatement les boutons de labels apr√®s re-render
		            if (GeoLeaf._LabelButtonManager && GeoLeaf._GeoJSONLayerManager) {
		                const allLayers = GeoLeaf._GeoJSONLayerManager._layers || new Map();
		                allLayers.forEach((layerData, layerId) => {
		                    if (layerData.currentStyle) {
		                        GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		                    }
		                });
		            }
		        },

		        /**
		         * Synchronise l'√©tat des toggles existants sans re-g√©n√©rer le DOM
		         * Utilis√© apr√®s l'application d'un th√®me pour mettre √† jour les toggles
		         * @public
		         */
		        syncToggles() {
		            // Trouver tous les items de couche dans le DOM
		            const layerItems = document.querySelectorAll('[data-layer-id]');

		            if (Log) Log.debug(`[LayerManager Renderer] Synchronisation de ${layerItems.length} toggles`);

		            layerItems.forEach(itemEl => {
		                const layerId = itemEl.getAttribute('data-layer-id');
		                if (!layerId) return;

		                // R√©cup√©rer les infos de visibilit√© pour le log
		                const layerData = global.GeoLeaf?.GeoJSON?.getLayerById(layerId);
		                const isVisible = this._checkLayerVisibility(layerId);

		                if (Log) Log.debug(`[LayerManager Renderer] Couche ${layerId}:`, {
		                    isVisible,
		                    hasLayerData: !!layerData,
		                    hasVisibility: !!(layerData && layerData._visibility),
		                    currentValue: layerData?._visibility?.current,
		                    onMap: layerData?.layer ? global.GeoLeaf._GeoJSONShared?.state?.map?.hasLayer(layerData.layer) : false
		                });

		                // Mettre √† jour la classe gl-layer--hidden
		                if (isVisible) {
		                    itemEl.classList.remove('gl-layer--hidden');
		                } else {
		                    itemEl.classList.add('gl-layer--hidden');
		                }

		                // Trouver et mettre √† jour le toggle button
		                const toggleBtn = itemEl.querySelector('.gl-layer-manager__item-toggle');
		                if (toggleBtn) {
		                    toggleBtn.setAttribute('aria-pressed', isVisible ? 'true' : 'false');

		                    // Harmoniser avec createToggleButton: suffixe "--on"
		                    const onClass = 'gl-layer-manager__item-toggle--on';
		                    if (isVisible) {
		                        toggleBtn.classList.add(onClass);
		                    } else {
		                        toggleBtn.classList.remove(onClass);
		                    }
		                }
		            });

		            if (Log) Log.debug("[LayerManager Renderer] √âtats des toggles synchronis√©s");
		        },

		        /**
		         * Rend les items d'une section
		         * @private
		         */
		        _renderItems(section, sectionEl) {
		            const listEl = global.L.DomUtil.create(
		                "div",
		                "gl-layer-manager__items",
		                sectionEl
		            );

		            section.items.forEach((item) => {
		                const itemEl = global.L.DomUtil.create(
		                    "div",
		                    "gl-layer-manager__item",
		                    listEl
		                );

		                // Ajouter l'attribut data-layer-id pour faciliter la recherche DOM
		                if (item.id) {
		                    itemEl.setAttribute("data-layer-id", item.id);

		                    // Ajouter la classe gl-layer--hidden si la couche n'est pas visible au chargement
		                    const isVisible = this._checkLayerVisibility(item.id);
		                    if (!isVisible) {
		                        itemEl.classList.add("gl-layer--hidden");
		                    }
		                }

		                // Conteneur de la ligne principale (toujours cr√©√© pour le layout en colonne)
		                const mainRow = global.L.DomUtil.create("div", "gl-layer-manager__item-row", itemEl);

		                // Libell√©
		                const labelEl = global.L.DomUtil.create(
		                    "span",
		                    "gl-layer-manager__label",
		                    mainRow
		                );
		                labelEl.textContent = item.label || "";

		                // Toggle d'affichage pour les couches toggleable
		                if (item.toggleable && item.id) {
		                    this._renderToggleControls(item, mainRow, itemEl);
		                } else if (item.id) {
		                    // M√™me pour les couches non-toggleable, cr√©er le bouton label
		                    const controlsContainer = global.L.DomUtil.create(
		                        "div",
		                        "gl-layer-manager__item-controls",
		                        mainRow
		                    );

		                    // Cr√©er le bouton de label
		                    if (global.GeoLeaf && global.GeoLeaf._LabelButtonManager) {
		                        global.GeoLeaf._LabelButtonManager.createButton(item.id, controlsContainer);
		                        global.GeoLeaf._LabelButtonManager.syncImmediate(item.id);
		                    }
		                } else {
		                    // Valeur/info compl√©mentaire pour items sans ID
		                    if (typeof item.value !== "undefined") {
		                        const valueEl = global.L.DomUtil.create(
		                            "span",
		                            "gl-layer-manager__value",
		                            itemEl
		                        );
		                        valueEl.textContent = String(item.value);
		                    }
		                }
		            });
		        },

		        /**
		         * Rend les contr√¥les toggle pour un item
		         * @private
		         */
		        _renderToggleControls(item, mainRow, itemEl) {
		            // Conteneur des contr√¥les (toggle + fl√®che th√®me)
		            const controlsContainer = global.L.DomUtil.create(
		                "div",
		                "gl-layer-manager__item-controls",
		                mainRow
		            );

		            // Cr√©er le bouton de label via le gestionnaire centralis√©
		            if (global.GeoLeaf && global.GeoLeaf._LabelButtonManager) {
		                global.GeoLeaf._LabelButtonManager.createButton(item.id, controlsContainer);
		                global.GeoLeaf._LabelButtonManager.syncImmediate(item.id);
		            }

		            // V√©rifier l'√©tat initial
		            const isActive = this._checkLayerVisibility(item.id);

		            const toggleBtn = GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.createToggleButton === 'function'
		                ? GeoLeaf._UIComponents.createToggleButton(controlsContainer, {
		                    isActive: isActive,
		                    className: "gl-layer-manager__item-toggle",
		                    title: "Afficher / masquer la couche"
		                })
		                : this._createToggleFallback(controlsContainer, isActive);

		            // Attacher le gestionnaire de toggle
		            this._attachToggleHandler(toggleBtn, item.id);

		            // S√©lecteur de styles si disponible
		            if (item.styles && GeoLeaf._LayerManagerStyleSelector) {
		                const styleElement = GeoLeaf._LayerManagerStyleSelector.renderDOM(item);
		                if (styleElement) {
		                    itemEl.appendChild(styleElement);
		                    GeoLeaf._LayerManagerStyleSelector.bindEvents(styleElement, item);
		                }
		            }
		        },

		        /**
		         * V√©rifie si une couche est visible
		         * @private
		         */
		        _checkLayerVisibility(layerId) {
		            try {
		                if (layerId && global.GeoLeaf && global.GeoLeaf.GeoJSON && typeof global.GeoLeaf.GeoJSON.getLayerById === "function") {
		                    const layerData = global.GeoLeaf.GeoJSON.getLayerById(layerId);

		                    // IMPORTANT: Utiliser logicalState (√©tat du bouton ON/OFF) au lieu de current (√©tat physique sur carte)
		                    // Le bouton doit refl√©ter l'intention de l'utilisateur/th√®me, pas les contraintes de zoom
		                    const logicalState = layerData && layerData._visibility && typeof layerData._visibility.logicalState === 'boolean'
		                        ? layerData._visibility.logicalState
		                        : (layerData && layerData.visible === true);

		                    const result = logicalState;

		                    if (Log) {
		                        Log.debug(`[LayerManager Renderer] _checkLayerVisibility(${layerId}): logicalState=${logicalState}`);
		                    }

		                    return result;
		                }
		            } catch (e) {
		                if (Log) Log.error("[LayerManager Renderer] Erreur dans _checkLayerVisibility:", e);
		            }
		            return false;
		        },

		        /**
		         * Attache le gestionnaire de toggle pour une couche
		         * @private
		         */
		        _attachToggleHandler(toggleBtn, itemId) {
		            // GUARD: V√©rifier si un gestionnaire est d√©j√† attach√©
		            if (toggleBtn._toggleHandlerAttached) {
		                return;
		            }

		            // Marquer comme attach√© AVANT de cr√©er le gestionnaire
		            toggleBtn._toggleHandlerAttached = true;

		            const self = this;

		            const onToggle = function (ev) {
		                // EMP√äCHER LES MULTIPLES CLICS EN PREMIER
		                if (toggleBtn._isToggling) {
		                    if (Log) Log.warn("[LayerManager] ‚è∏Ô∏è Toggle D√âJ√Ä en cours, BLOQU√â:", itemId);
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.stopPropagation(ev);
		                        global.L.DomEvent.preventDefault(ev);
		                    }
		                    return; // SORTIR IMM√âDIATEMENT
		                }

		                // Marquer comme en cours IMM√âDIATEMENT
		                toggleBtn._isToggling = true;

		                // Arr√™ter la propagation
		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                    global.L.DomEvent.preventDefault(ev);
		                }

		                // R√©initialiser apr√®s 100ms (juste pour emp√™cher les double-clics rapides)
		                setTimeout(() => {
		                    toggleBtn._isToggling = false;
		                }, 100);

		                try {
		                    if (itemId && global.GeoLeaf && global.GeoLeaf.GeoJSON) {
		                        const layerData = global.GeoLeaf.GeoJSON.getLayerById(itemId);

		                        // Si la couche n'est pas encore charg√©e, la charger √† la demande
		                        if (!layerData) {
		                            if (Log) Log.info("[LayerManager] ‚è≥ Couche non charg√©e, chargement √† la demande:", itemId);

		                            // Indicateur visuel de chargement
		                            toggleBtn.classList.add("gl-layer-manager__item-toggle--loading");
		                            toggleBtn.disabled = true;

		                            const ThemeApplier = global.GeoLeaf._ThemeApplier;
		                            if (ThemeApplier && typeof ThemeApplier._loadLayerFromProfile === "function") {
		                                ThemeApplier._loadLayerFromProfile(itemId).then(function (loadedLayer) {
		                                    // Retirer l'indicateur de chargement
		                                    toggleBtn.classList.remove("gl-layer-manager__item-toggle--loading");
		                                    toggleBtn.disabled = false;

		                                    if (loadedLayer) {
		                                        if (Log) Log.info("[LayerManager] ‚úÖ Couche charg√©e avec succ√®s:", itemId);

		                                        // Afficher la couche via le gestionnaire standard
		                                        global.GeoLeaf.GeoJSON.showLayer(itemId);

		                                        // Mettre √† jour l'UI du toggle
		                                        toggleBtn.setAttribute("aria-pressed", "true");
		                                        toggleBtn.classList.add("gl-layer-manager__item-toggle--on");

		                                        const layerItem = document.querySelector('[data-layer-id="' + itemId + '"]');
		                                        if (layerItem) {
		                                            layerItem.classList.remove("gl-layer--hidden");
		                                        }

		                                        // R√©activer le bouton label si applicable
		                                        let labelBtn = null;
		                                        if (layerItem) {
		                                            labelBtn = layerItem.querySelector('.gl-layer-manager__label-toggle');
		                                        }
		                                        if (!labelBtn && toggleBtn.parentElement) {
		                                            labelBtn = toggleBtn.parentElement.querySelector('.gl-layer-manager__label-toggle');
		                                        }
		                                        if (labelBtn) {
		                                            const ld = global.GeoLeaf?.GeoJSON?.getLayerById?.(itemId);
		                                            const labelEnabled = ld?.currentStyle?.label?.enabled === true;
		                                            if (labelEnabled) {
		                                                labelBtn.disabled = false;
		                                                labelBtn.classList.remove("gl-layer-manager__label-toggle--disabled");
		                                            }
		                                        }
		                                    } else {
		                                        if (Log) Log.warn("[LayerManager] ‚ùå √âchec du chargement de la couche:", itemId);
		                                    }
		                                }).catch(function (err) {
		                                    toggleBtn.classList.remove("gl-layer-manager__item-toggle--loading");
		                                    toggleBtn.disabled = false;
		                                    if (Log) Log.error("[LayerManager] Erreur lors du chargement de la couche:", itemId, err);
		                                });
		                            } else {
		                                toggleBtn.classList.remove("gl-layer-manager__item-toggle--loading");
		                                toggleBtn.disabled = false;
		                                if (Log) Log.warn("[LayerManager] ThemeApplier non disponible pour charger:", itemId);
		                            }
		                            return;
		                        }

		                        const isCurrentlyVisible = self._checkLayerVisibility(itemId);

		                        // Trouver le layerItem pour ajouter/retirer la classe CSS
		                        const layerItem = document.querySelector(`[data-layer-id="${itemId}"]`);

		                        if (isCurrentlyVisible) {
		                            // Masquer la couche
		                            global.GeoLeaf.GeoJSON.hideLayer(itemId);
		                            toggleBtn.setAttribute("aria-pressed", "false");
		                            toggleBtn.classList.remove("gl-layer-manager__item-toggle--on");

		                            // Ajouter la classe gl-layer--hidden
		                            if (layerItem) {
		                                layerItem.classList.add("gl-layer--hidden");
		                            }

		                            // D√©sactiver imm√©diatement le bouton label (couche cach√©e)
		                            // Chercher dans tout le layerItem, pas juste les enfants directs
		                            let labelBtn = null;
		                            if (layerItem) {
		                                labelBtn = layerItem.querySelector('.gl-layer-manager__label-toggle');
		                            }
		                            // Fallback: chercher via le sibling du toggle button (m√™me container)
		                            if (!labelBtn && toggleBtn.parentElement) {
		                                labelBtn = toggleBtn.parentElement.querySelector('.gl-layer-manager__label-toggle');
		                            }
		                            if (labelBtn) {
		                                labelBtn.disabled = true;
		                                labelBtn.classList.add("gl-layer-manager__label-toggle--disabled");
		                                labelBtn.classList.remove("gl-layer-manager__label-toggle--on");
		                                labelBtn.setAttribute("aria-pressed", "false");
		                            } else {
		                                if (Log) Log.warn("[LayerManager] Bouton label NON TROUV√â pour d√©sactivation:", itemId);
		                            }
		                        } else {
		                            // Afficher la couche
		                            global.GeoLeaf.GeoJSON.showLayer(itemId);
		                            toggleBtn.setAttribute("aria-pressed", "true");
		                            toggleBtn.classList.add("gl-layer-manager__item-toggle--on");

		                            // Retirer la classe gl-layer--hidden
		                            if (layerItem) {
		                                layerItem.classList.remove("gl-layer--hidden");
		                            }

		                            // R√©activer le bouton label
		                            let labelBtn = null;
		                            if (layerItem) {
		                                labelBtn = layerItem.querySelector('.gl-layer-manager__label-toggle');
		                            }
		                            if (!labelBtn && toggleBtn.parentElement) {
		                                labelBtn = toggleBtn.parentElement.querySelector('.gl-layer-manager__label-toggle');
		                            }
		                            if (labelBtn) {
		                                // V√©rifier si label.enabled dans le style avant de r√©activer
		                                const ld = global.GeoLeaf?.GeoJSON?.getLayerById?.(itemId);
		                                const labelEnabled = ld?.currentStyle?.label?.enabled === true;
		                                if (labelEnabled) {
		                                    labelBtn.disabled = false;
		                                    labelBtn.classList.remove("gl-layer-manager__label-toggle--disabled");
		                                }
		                            }
		                        }
		                    }
		                } catch (err) {
		                    if (Log) Log.warn("Erreur toggle l√©gende :", err);
		                }
		            };

		            // TEMPORAIREMENT: utiliser uniquement L.DomEvent pour d√©boguer
		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(toggleBtn, "click", onToggle);
		                global.L.DomEvent.disableClickPropagation(toggleBtn);
		            } else {
		                toggleBtn.addEventListener("click", onToggle);
		            }

		            // Ancienne version avec _UIComponents (d√©sactiv√© pour debug)
		            // if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.attachEventHandler === 'function') {
		            //     GeoLeaf._UIComponents.attachEventHandler(toggleBtn, "click", onToggle);
		            // } else if (global.L && global.L.DomEvent) {
		            //     global.L.DomEvent.on(toggleBtn, "click", onToggle);
		            // } else {
		            //     toggleBtn.addEventListener("click", onToggle);
		            // }
		        },

		        /**
		         * Fallback pour cr√©er un toggle button si _UIComponents non disponible
		         * @private
		         */
		        _createToggleFallback(container, isActive) {
		            const toggleBtn = global.L.DomUtil.create("button", "gl-layer-manager__item-toggle", container);
		            toggleBtn.type = "button";
		            toggleBtn.setAttribute("aria-pressed", isActive ? "true" : "false");
		            toggleBtn.title = "Afficher / masquer la couche";
		            if (isActive) {
		                toggleBtn.classList.add("gl-layer-manager__item-toggle--on");
		            }
		            return toggleBtn;
		        },

		        /**
		         * Cr√©e le bouton de labels pour une couche (appel√© lors de l'application d'un style)
		         * @param {string} layerId - ID de la couche
		         */
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LayerManagerRenderer = _LayerManagerRenderer;

		})(window);
		return renderer$1;
	}

	requireRenderer$1();

	var cacheSection = {};

	/**
	 * Module LayerManager - Cache Section
	 *
	 * Ajoute une section de gestion du cache offline dans le gestionnaire de couches.
	 * Permet de t√©l√©charger/effacer le cache du profil actif.
	 *
	 * @module GeoLeaf.LayerManager.CacheSection
	 * @version 3.0.0
	 */

	var hasRequiredCacheSection;

	function requireCacheSection () {
		if (hasRequiredCacheSection) return cacheSection;
		hasRequiredCacheSection = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Module de section cache pour la l√©gende
		     */
		    const CacheSection = {
		        /**
		         * G√©n√®re la section HTML du cache
		         *
		         * @returns {Object} Section configuration
		         */
		        generateSection() {
		            return {
		                id: "offline-cache",
		                label: "üì• Cache Hors Ligne",
		                order: 98,
		                collapsedByDefault: false,
		                customContent: this._generateContent(),
		                init: () => this._attachEventListeners()
		            };
		        },

		        /**
		         * G√©n√®re le contenu HTML
		         * @private
		         */
		        _generateContent() {
		            return `
                <div class="gl-cache-section">
                    <div class="gl-cache-status">
                        <div class="gl-cache-status__header">
                            <span class="gl-cache-status__icon">üíæ</span>
                            <span class="gl-cache-status__label">Statut</span>
                        </div>
                        <div class="gl-cache-status__info">
                            <div class="gl-cache-status__row">
                                <span class="gl-cache-status__key">Profil:</span>
                                <span class="gl-cache-status__value" id="gl-cache-profile">-</span>
                            </div>
                            <div class="gl-cache-status__row">
                                <span class="gl-cache-status__key">√âtat:</span>
                                <span class="gl-cache-status__value" id="gl-cache-state">Non t√©l√©charg√©</span>
                            </div>
                            <div class="gl-cache-status__row">
                                <span class="gl-cache-status__key">Taille:</span>
                                <span class="gl-cache-status__value" id="gl-cache-size">0 MB</span>
                            </div>
                            <div class="gl-cache-status__row">
                                <span class="gl-cache-status__key">Quota:</span>
                                <span class="gl-cache-status__value" id="gl-cache-quota">0 MB disponible</span>
                            </div>
                        </div>
                    </div>

                    <div class="gl-cache-actions">
                        <button
                            id="gl-cache-download"
                            class="gl-btn gl-btn--primary gl-cache-btn"
                            title="T√©l√©charger le profil pour usage offline">
                            <span class="gl-btn__icon">‚¨áÔ∏è</span>
                            <span class="gl-btn__text">T√©l√©charger profil</span>
                        </button>

                        <button
                            id="gl-cache-clear"
                            class="gl-btn gl-btn--secondary gl-cache-btn"
                            title="Effacer le cache du profil"
                            disabled>
                            <span class="gl-btn__icon">üóëÔ∏è</span>
                            <span class="gl-btn__text">Vider cache</span>
                        </button>
                    </div>

                    <div class="gl-cache-progress" id="gl-cache-progress" style="display: none;">
                        <div class="gl-cache-progress__bar">
                            <div class="gl-cache-progress__fill" id="gl-cache-progress-fill"></div>
                        </div>
                        <div class="gl-cache-progress__text" id="gl-cache-progress-text">
                            T√©l√©chargement en cours...
                        </div>
                    </div>
                </div>
            `;
		        },

		        /**
		         * Attache les event listeners
		         * @private
		         */
		        _attachEventListeners() {
		            const downloadBtn = document.getElementById("gl-cache-download");
		            const clearBtn = document.getElementById("gl-cache-clear");

		            if (downloadBtn) {
		                downloadBtn.addEventListener("click", () => this._handleDownload());
		            }

		            if (clearBtn) {
		                clearBtn.addEventListener("click", () => this._handleClear());
		            }

		            // Mettre √† jour le statut initial
		            this._updateStatus();

		            // √âcouter les √©v√©nements de cache
		            document.addEventListener("geoleaf:cache:completed", () => this._updateStatus());
		            document.addEventListener("geoleaf:cache:cleared", () => this._updateStatus());
		            document.addEventListener("geoleaf:profile:loaded", () => this._updateStatus());
		        },

		        /**
		         * Met √† jour l'affichage du statut
		         * @private
		         */
		        async _updateStatus() {
		            if (!GeoLeaf.Storage || !GeoLeaf.Storage.isAvailable()) {
		                return;
		            }

		            try {
		                const profileId = GeoLeaf.Config.get("data.activeProfile", "");
		                const status = await GeoLeaf.Storage.CacheManager.getCacheStatus(profileId);
		                const quota = await GeoLeaf.Storage.CacheManager.getStorageQuota();

		                // Mettre √† jour les √©l√©ments DOM
		                const profileEl = document.getElementById("gl-cache-profile");
		                const stateEl = document.getElementById("gl-cache-state");
		                const sizeEl = document.getElementById("gl-cache-size");
		                const quotaEl = document.getElementById("gl-cache-quota");
		                const clearBtn = document.getElementById("gl-cache-clear");

		                if (profileEl) profileEl.textContent = profileId || "-";

		                if (status && status.resourcesCount > 0) {
		                    if (stateEl) {
		                        stateEl.textContent = "‚úÖ T√©l√©charg√©";
		                        stateEl.style.color = "#22c55e";
		                    }
		                    if (sizeEl) {
		                        sizeEl.textContent = `${(status.totalSize / 1024 / 1024).toFixed(2)} MB`;
		                    }
		                    if (clearBtn) clearBtn.disabled = false;
		                } else {
		                    if (stateEl) {
		                        stateEl.textContent = "‚ùå Non t√©l√©charg√©";
		                        stateEl.style.color = "#ef4444";
		                    }
		                    if (sizeEl) sizeEl.textContent = "0 MB";
		                    if (clearBtn) clearBtn.disabled = true;
		                }

		                if (quotaEl) {
		                    quotaEl.textContent = `${(quota.available / 1024 / 1024).toFixed(2)} MB disponible`;
		                }

		            } catch (error) {
		                Log.error(`[CacheSection] Failed to update status: ${error.message}`);
		            }
		        },

		        /**
		         * G√®re le t√©l√©chargement du profil
		         * @private
		         */
		        async _handleDownload() {
		            if (!GeoLeaf.Storage || !GeoLeaf.Storage.isAvailable()) {
		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.error(
		                        "Stockage offline non disponible",
		                        5000
		                    );
		                }
		                return;
		            }

		            const profileId = GeoLeaf.Config.get("data.activeProfile", "");
		            if (!profileId) {
		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.error(
		                        "Aucun profil actif",
		                        3000
		                    );
		                }
		                return;
		            }

		            const downloadBtn = document.getElementById("gl-cache-download");
		            const progressEl = document.getElementById("gl-cache-progress");
		            const progressText = document.getElementById("gl-cache-progress-text");

		            try {
		                // D√©sactiver le bouton
		                if (downloadBtn) {
		                    downloadBtn.disabled = true;
		                    downloadBtn.querySelector(".gl-btn__text").textContent = "T√©l√©chargement...";
		                }

		                // Afficher la barre de progression
		                if (progressEl) progressEl.style.display = "block";
		                if (progressText) progressText.textContent = "Pr√©paration...";

		                Log.info(`[CacheSection] Starting download for profile: ${profileId}`);

		                // T√©l√©charger le profil
		                const result = await GeoLeaf.Storage.downloadProfileForOffline(profileId);

		                if (progressText) {
		                    progressText.textContent = `‚úÖ ${result.resourcesCount} ressources t√©l√©charg√©es`;
		                }

		                // Notification de succ√®s
		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.success(
		                        `Profil t√©l√©charg√© : ${(result.totalSize / 1024 / 1024).toFixed(2)} MB`,
		                        4000
		                    );
		                }

		                // Masquer la progression apr√®s 2s
		                setTimeout(() => {
		                    if (progressEl) progressEl.style.display = "none";
		                }, 2000);

		                await this._updateStatus();

		            } catch (error) {
		                Log.error(`[CacheSection] Download failed: ${error.message}`);

		                if (progressText) progressText.textContent = `‚ùå Erreur: ${error.message}`;

		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.error(
		                        `Erreur t√©l√©chargement: ${error.message}`,
		                        5000
		                    );
		                }

		                setTimeout(() => {
		                    if (progressEl) progressEl.style.display = "none";
		                }, 3000);

		            } finally {
		                // R√©activer le bouton
		                if (downloadBtn) {
		                    downloadBtn.disabled = false;
		                    downloadBtn.querySelector(".gl-btn__text").textContent = "T√©l√©charger profil";
		                }
		            }
		        },

		        /**
		         * G√®re l'effacement du cache
		         * @private
		         */
		        async _handleClear() {
		            if (!GeoLeaf.Storage || !GeoLeaf.Storage.isAvailable()) {
		                return;
		            }

		            const profileId = GeoLeaf.Config.get("data.activeProfile", "");
		            if (!profileId) {
		                return;
		            }

		            // Confirmation
		            if (!confirm(`Voulez-vous vraiment effacer le cache du profil "${profileId}" ?`)) {
		                return;
		            }

		            const clearBtn = document.getElementById("gl-cache-clear");

		            try {
		                if (clearBtn) {
		                    clearBtn.disabled = true;
		                    clearBtn.querySelector(".gl-btn__text").textContent = "Effacement...";
		                }

		                Log.info(`[CacheSection] Clearing cache for profile: ${profileId}`);

		                const deleted = await GeoLeaf.Storage.CacheManager.clearCache(profileId);

		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.success(
		                        `Cache effac√© : ${deleted} ressources supprim√©es`,
		                        3000
		                    );
		                }

		                await this._updateStatus();

		            } catch (error) {
		                Log.error(`[CacheSection] Clear failed: ${error.message}`);

		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications) {
		                    GeoLeaf.UI.Notifications.error(
		                        `Erreur effacement: ${error.message}`,
		                        5000
		                    );
		                }
		            } finally {
		                if (clearBtn) {
		                    clearBtn.querySelector(".gl-btn__text").textContent = "Vider cache";
		                }
		            }
		        }
		    };

		    // Exposer le module
		    GeoLeaf._LayerManagerCacheSection = CacheSection;

		})(window);
		return cacheSection;
	}

	requireCacheSection();

	var basemapSelector = {};

	/**
	 * Module Basemap Selector pour LayerManager
	 * Gestion du s√©lecteur de fonds de carte
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.DomUtil, L.DomEvent)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf.Baselayers (optionnel, pour getActiveId et setBaseLayer)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LayerManagerBasemapSelector
	 */

	var hasRequiredBasemapSelector;

	function requireBasemapSelector () {
		if (hasRequiredBasemapSelector) return basemapSelector;
		hasRequiredBasemapSelector = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Basemap Selector
		     * @namespace _LayerManagerBasemapSelector
		     * @private
		     */
		    const _LayerManagerBasemapSelector = {
		        /**
		         * Rend le s√©lecteur de basemap
		         * @param {Object} section - Section basemap avec items
		         * @param {HTMLElement} sectionEl - √âl√©ment DOM de la section
		         */
		        render(section, sectionEl) {
		            // Validation des param√®tres
		            if (!section || !sectionEl) {
		                return;
		            }

		            const container = global.L.DomUtil.create(
		                "div",
		                "gl-layer-manager__items gl-layer-manager__basemap-select",
		                sectionEl
		            );

		            const select = global.L.DomUtil.create("select", "gl-layer-manager__basemap-select__select", container);

		            // Remplir les options
		            if (Array.isArray(section.items)) {
		                section.items.forEach(function (item) {
		                    if (!item || !item.id) return;
		                    const opt = document.createElement("option");
		                    opt.value = item.id;
		                    opt.textContent = item.label || item.id;
		                    select.appendChild(opt);
		                });
		            }

		            // Valeur initiale -> ID actif des basemaps
		            try {
		                const activeId = global.GeoLeaf && global.GeoLeaf.Baselayers && typeof global.GeoLeaf.Baselayers.getActiveId === "function"
		                    ? global.GeoLeaf.Baselayers.getActiveId()
		                    : null;
		                if (activeId) {
		                    select.value = activeId;
		                }
		            } catch (e) {
		                // ignore
		            }

		            // Changement par l'utilisateur
		            this._attachChangeHandler(select);

		            // √âcouter les changements externes
		            this._attachExternalListener(select);
		        },

		        /**
		         * Attache le gestionnaire de changement au select
		         * @private
		         */
		        _attachChangeHandler(select) {
		            const handler = function (ev) {
		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                }
		                try {
		                    const val = select.value;
		                    if (global.GeoLeaf && global.GeoLeaf.Baselayers && typeof global.GeoLeaf.Baselayers.setBaseLayer === "function") {
		                        global.GeoLeaf.Baselayers.setBaseLayer(val);
		                    }
		                } catch (err) {
		                    if (Log) Log.warn("Erreur lors du changement de basemap depuis la l√©gende:", err);
		                }
		            };

		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(select, "change", handler);
		            } else {
		                select.addEventListener("change", handler);
		            }
		        },

		        /**
		         * √âcoute les √©v√©nements de changement de basemap externe
		         * @private
		         */
		        _attachExternalListener(select) {
		            if (typeof document !== "undefined") {
		                document.addEventListener("geoleaf:basemap-changed", function (e) {
		                    try {
		                        if (e && e.detail && e.detail.id) {
		                            select.value = e.detail.id;
		                        }
		                    } catch (err) {
		                        // ignore
		                    }
		                });
		            }
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LayerManagerBasemapSelector = _LayerManagerBasemapSelector;

		})(window);
		return basemapSelector;
	}

	requireBasemapSelector();

	var styleSelector = {};

	/**
	 * @module _LayerManagerStyleSelector
	 * @description S√©lecteur de styles pour le gestionnaire de couches.
	 * Permet de changer dynamiquement le style appliqu√© √† une couche.
	 * Utilise le nouveau style-loader pour charger et valider les styles.
	 * @version 3.1.0
	 */

	var hasRequiredStyleSelector;

	function requireStyleSelector () {
		if (hasRequiredStyleSelector) return styleSelector;
		hasRequiredStyleSelector = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * √âtat interne du s√©lecteur de styles
		     * @private
		     */
		    const state = {
		        currentStyles: new Map() // layerId -> styleId
		    };

		    /**
		     * Module s√©lecteur de styles pour le gestionnaire de couches
		     * @namespace
		     */
		    GeoLeaf._LayerManagerStyleSelector = {
		        /**
		         * R√©cup√®re le style actuel d'une couche
		         * @param {string} layerId - Identifiant de la couche
		         * @returns {string|null} Identifiant du style actuel
		         */
		        getCurrentStyle: function (layerId) {
		            return state.currentStyles.get(layerId) || null;
		        },

		        /**
		         * D√©finit le style actuel d'une couche
		         * @param {string} layerId - Identifiant de la couche
		         * @param {string} styleId - Identifiant du style
		         */
		        setCurrentStyle: function (layerId, styleId) {
		            state.currentStyles.set(layerId, styleId);
		        },

		        /**
		         * G√©n√®re le HTML du s√©lecteur de styles
		         * @param {Object} item - Configuration de l'item de couche
		         * @param {string} item.id - Identifiant de la couche
		         * @param {Object} item.styles - Configuration des styles disponibles
		         * @param {Array} item.styles.available - Tableau des styles disponibles
		         * @param {string} item.styles.default - Style par d√©faut
		         * @returns {string} HTML du s√©lecteur
		         * @deprecated Utiliser renderDOM() √† la place
		         */
		        render: function (item) {
		            if (!item.styles || !Array.isArray(item.styles.available) || item.styles.available.length <= 1) {
		                return "";
		            }

		            const currentStyle = this.getCurrentStyle(item.id) || item.styles.default || item.styles.available[0].id;
		            const selectId = "style-selector-" + item.id;

		            let html = '<div class="gl-layer-manager__style-selector">';
		            html += '<select id="' + selectId + '" class="gl-layer-manager__style-select" data-layer-id="' + item.id + '">';

		            item.styles.available.forEach(function (style) {
		                const selected = style.id === currentStyle ? ' selected' : '';
		                html += '<option value="' + style.id + '"' + selected + '>' + style.label + '</option>';
		            });

		            html += '</select>';
		            html += '</div>';

		            return html;
		        },

		        /**
		         * G√©n√®re l'√©l√©ment DOM du s√©lecteur de styles
		         * @param {Object} item - Configuration de l'item de couche
		         * @param {string} item.id - Identifiant de la couche
		         * @param {Object} item.styles - Configuration des styles disponibles
		         * @param {Array} item.styles.available - Tableau des styles disponibles
		         * @param {string} item.styles.default - Style par d√©faut
		         * @returns {HTMLElement|null} √âl√©ment DOM du s√©lecteur ou null
		         */
		        renderDOM: function (item) {

					// ...log supprim√© ([StyleSelector] renderDOM)...

		            if (!item.styles || !Array.isArray(item.styles.available) || item.styles.available.length <= 1) {
		                // ...log supprim√© ([StyleSelector] Pas de s√©lecteur n√©cessaire)...
		                return null;
		            }

		            const currentStyle = this.getCurrentStyle(item.id) || item.styles.default || item.styles.available[0].id;
		            const selectId = "style-selector-" + item.id;

		            // Cr√©er le conteneur
		            const container = document.createElement("div");
		            container.className = "gl-layer-manager__style-selector";

		            // Cr√©er le select
		            const select = document.createElement("select");
		            select.id = selectId;
		            select.className = "gl-layer-manager__style-select";
		            select.setAttribute("data-layer-id", item.id);

		            // Ajouter les options
		            item.styles.available.forEach(function (style) {
		                const option = document.createElement("option");
		                option.value = style.id;
		                option.textContent = style.label;
		                if (style.id === currentStyle) {
		                    option.selected = true;
		                }
		                select.appendChild(option);
		            });

		            container.appendChild(select);
		            return container;
		        },

		        /**
		         * Initialise les √©v√©nements du s√©lecteur de styles
		         * @param {HTMLElement} container - Conteneur des contr√¥les
		         * @param {Object} item - Configuration de l'item de couche
		         */
		        bindEvents: function (container, item) {
		            if (!item.styles || !Array.isArray(item.styles.available) || item.styles.available.length <= 1) {
		                return;
		            }

		            const selectId = "style-selector-" + item.id;
		            const select = container.querySelector("#" + selectId);

		            if (!select) {
		                return;
		            }

		            const self = this;

		            select.addEventListener("change", function () {
		                const styleId = this.value;
		                const layerId = this.getAttribute("data-layer-id");

		                // Enregistrer le style actuel
		                self.setCurrentStyle(layerId, styleId);

		                // Appliquer le style √† la couche
		                self.applyStyle(layerId, styleId);
		            });
		        },

		        /**
		         * Applique un style √† une couche
		         * Utilise le style-loader pour charger, valider et appliquer le style
		         * @param {string} layerId - Identifiant de la couche
		         * @param {string} styleId - Identifiant du style
		         */
		        applyStyle: async function (layerId, styleId) {

					if (!global.GeoLeaf._GeoJSONLayerManager) {
						// ...log supprim√© ([StyleSelector] Module GeoJSON non disponible)...
						return;
					}

					// R√©cup√©rer les donn√©es de la couche
					const layerManager = global.GeoLeaf._GeoJSONLayerManager;
					const layerData = layerManager.getLayerData(layerId);

					if (!layerData) {
						// ...log supprim√© ([StyleSelector] Couche non trouv√©e)...
						return;
					}

					if (!layerData.config.styles || !Array.isArray(layerData.config.styles.available)) {
						// ...log supprim√© ([StyleSelector] Aucun style disponible pour la couche)...
						return;
					}

					// Trouver la configuration du style
					const styleConfig = layerData.config.styles.available.find(function (s) {
						return s.id === styleId;
					});

					if (!styleConfig) {
						// ...log supprim√© ([StyleSelector] Style non trouv√©)...
						return;
					}

					// ...log supprim√© ([StyleSelector] Application du style)...

		            try {
		                // V√©rifier que le style-loader est disponible
		                const StyleLoader = global.GeoLeaf._StyleLoader;
		                if (!StyleLoader) {
		                    // ...log supprim√© ([StyleSelector] GeoLeaf._StyleLoader non disponible)...
		                    // Fallback vers ancien syst√®me si n√©cessaire
		                    this._applyStyleLegacy(layerId, styleId, layerData, styleConfig);
		                    return;
		                }

		                // R√©cup√©rer les m√©tadonn√©es n√©cessaires
		                const profileId = layerData.config._profileId;
		                const layerDirectory = layerData.config._layerDirectory;

		                if (!profileId || !layerDirectory) {
		                    // ...log supprim√© ([StyleSelector] M√©tadonn√©es manquantes)...
		                    return;
		                }

		                // Charger et valider le style avec le style-loader
		                // ...log supprim√© ([StyleSelector] Chargement du style via style-loader)...

		                const result = await StyleLoader.loadAndValidateStyle(
		                    profileId,
		                    layerId,
		                    styleId,
		                    styleConfig.file,
		                    layerDirectory
		                );

		                // ...log supprim√© ([StyleSelector] Style charg√© et valid√©)...

		                // Stocker le style actuel dans layerData pour que les labels puissent y acc√©der
		                layerData.currentStyle = result.styleData;
		                layerData.currentStyleMetadata = result.metadata;

		                // Appliquer le style via le GeoJSONLayerManager
		                if (typeof layerManager.setLayerStyle === "function") {
		                    layerManager.setLayerStyle(layerId, result.styleData);
		                    // ...log supprim√© ([StyleSelector] Style appliqu√© avec succ√®s)...
		                }

		                // R√©initialiser les labels selon le nouveau style et visibleByDefault
		                if (global.GeoLeaf.Labels && typeof global.GeoLeaf.Labels.initializeLayerLabels === 'function') {
		                    global.GeoLeaf.Labels.initializeLayerLabels(layerId);
		                }

		                // Mettre √† jour l'√©tat du bouton des labels selon le nouveau style
		                // Utiliser syncImmediate car currentStyle vient d'√™tre mis √† jour
		                if (global.GeoLeaf._LabelButtonManager) {
		                    // ...log supprim√© ([StyleSelector] Synchronisation du bouton label)...
		                    global.GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		                }

		                // Charger la l√©gende correspondante
		                if (global.GeoLeaf.Legend && typeof global.GeoLeaf.Legend.loadLayerLegend === "function") {
		                    global.GeoLeaf.Legend.loadLayerLegend(layerData.config.id, styleId, layerData.config);
		                }

		            } catch (error) {
		                // ...log supprim√© ([StyleSelector] Erreur lors du chargement/application du style)...
		                // ...log supprim√© ([StyleSelector] Stack trace)...
		            }
		        },

		        /**
		         * M√©thode legacy de chargement de style (fallback)
		         * @private
		         * @deprecated Utiliser applyStyle() avec style-loader √† la place
		         */
		        _applyStyleLegacy: function (layerId, styleId, layerData, styleConfig) {
		            const layerManager = global.GeoLeaf._GeoJSONLayerManager;

		            // ...log supprim√© ([StyleSelector] Utilisation de la m√©thode legacy)...

		            const profileId = layerData.config._profileId;
		            const layerDirectory = layerData.config._layerDirectory;

		            if (!profileId || !layerDirectory) {
		                // ...log supprim√© ([StyleSelector] M√©tadonn√©es manquantes)...
		                return;
		            }

		            const Config = global.GeoLeaf.Config;
		            const dataCfg = Config && Config.get ? Config.get('data') : null;
		            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";

		            const styleDirectory = layerData.config.styles.directory || "styles";
		            const stylePath = profilesBasePath + "/" + profileId + "/" + layerDirectory + "/" + styleDirectory + "/" + styleConfig.file;

		            // ...log supprim√© ([StyleSelector] Chargement du fichier de style (legacy))...

		            fetch(stylePath)
		                .then(function (response) {
		                    if (!response.ok) {
		                        throw new Error("Erreur HTTP " + response.status);
		                    }
		                    return response.json();
		                })
		                .then(function (styleData) {
		                    if (typeof layerManager.setLayerStyle === "function") {
		                        layerManager.setLayerStyle(layerId, styleData);
		                        // ...log supprim√© ([StyleSelector] Style appliqu√© avec succ√®s (legacy))...
		                    }

		                    if (global.GeoLeaf.Legend && typeof global.GeoLeaf.Legend.loadLayerLegend === "function") {
		                        global.GeoLeaf.Legend.loadLayerLegend(layerData.config.id, styleId, layerData.config);
		                    }
		                })
		                .catch(function (error) {
		                    // ...log supprim√© ([StyleSelector] Erreur lors du chargement du style (legacy))...
		                });
		        }
		    };

		})(window);
		return styleSelector;
	}

	requireStyleSelector();

	var control = {};

	/**
	 * Module Control pour LayerManager
	 * D√©finition du contr√¥le Leaflet personnalis√©
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.Control, L.DomUtil, L.DomEvent, L.setOptions)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf._LayerManagerRenderer (pour renderSections)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LayerManagerControl
	 */

	var hasRequiredControl;

	function requireControl () {
		if (hasRequiredControl) return control;
		hasRequiredControl = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Cr√©e un contr√¥le Leaflet pour le gestionnaire de couches
		     * @param {Object} options - Options du contr√¥le
		     * @returns {L.Control} - Instance du contr√¥le Leaflet
		     */
		    function createLayerManagerControl(options) {
		        if (!global.L || !global.L.Control) {
		            if (Log) Log.error("[LayerManager] Leaflet L.Control non disponible");
		            return null;
		        }

		        const LayerManagerControl = global.L.Control.extend({
		            options: {
		                position: options.position || "bottomright"
		            },

		            initialize: function (controlOptions) {
		                global.L.setOptions(this, controlOptions || {});
		                this._glOptions = controlOptions._glOptions;
		            },

		            onAdd: function (mapInstance) {
		                this._map = mapInstance;
		                this._container = global.L.DomUtil.create("div", "gl-layer-manager");

		                // Emp√™cher les interactions carte
		                if (global.L.DomEvent) {
		                    global.L.DomEvent.disableClickPropagation(this._container);
		                    global.L.DomEvent.disableScrollPropagation(this._container);
		                }

		                this._buildStructure();
		                return this._container;
		            },

		            onRemove: function () {
		                this._map = null;
		                this._container = null;
		            },

		            /**
		             * Construit la structure DOM de la l√©gende
		             * @private
		             */
		            _buildStructure: function () {
		                const opts = this._glOptions;

		                // Conteneur principal (flex container)
		                const mainWrapper = global.L.DomUtil.create("div", "gl-layer-manager__main-wrapper", this._container);

		                // Wrapper du header (reste fixe)
		                const headerWrapper = global.L.DomUtil.create("div", "gl-layer-manager__header-wrapper", mainWrapper);

		                // En-t√™te : titre + bouton collapse
		                const header = global.L.DomUtil.create("div", "gl-layer-manager__header", headerWrapper);

		                const titleEl = global.L.DomUtil.create(
		                    "div",
		                    "gl-layer-manager__title",
		                    header
		                );
		                titleEl.textContent = opts.title || "L√©gende";

		                let toggleEl = null;
		                if (opts.collapsible) {
		                    toggleEl = global.L.DomUtil.create(
		                        "button",
		                        "gl-layer-manager__toggle",
		                        header
		                    );
		                    toggleEl.type = "button";
		                    toggleEl.setAttribute("aria-label", "Basculer la l√©gende");
		                    toggleEl.textContent = "‚ü±";

		                    const self = this;
		                    global.L.DomEvent.on(toggleEl, "click", function (ev) {
		                        global.L.DomEvent.stopPropagation(ev);
		                        self._toggleCollapsed();
		                    });
		                }

		                // Wrapper du body avec scrollbar
		                const bodyWrapper = global.L.DomUtil.create("div", "gl-layer-manager__body-wrapper", mainWrapper);

		                // Corps de la l√©gende
		                this._bodyEl = global.L.DomUtil.create(
		                    "div",
		                    "gl-layer-manager__body",
		                    bodyWrapper
		                );

		                // Appliquer l'√©tat collapsed initial (depuis options ou collapsedByDefault)
		                const initialCollapsed = opts.collapsed || opts.collapsedByDefault || false;
		                if (initialCollapsed) {
		                    this._container.classList.add("gl-layer-manager--collapsed");
		                    opts.collapsed = true; // Synchroniser l'√©tat
		                }

		                // Rendu des sections via le renderer
		                this._renderSections(opts.sections || []);
		            },

		            /**
		             * Rend les sections (d√©l√®gue au renderer)
		             * @private
		             */
		            _renderSections: function (sections) {
		                if (GeoLeaf._LayerManagerRenderer) {
		                    GeoLeaf._LayerManagerRenderer.renderSections(this._bodyEl, sections);
		                } else {
		                    if (Log) Log.error("[LayerManager] _LayerManagerRenderer non disponible");
		                }
		            },

		            /**
		             * Mise √† jour des sections
		             * @param {Array} sections - Nouvelles sections
		             */
		            updateSections: function (sections) {
		                this._glOptions.sections = Array.isArray(sections) ? sections : [];
		                this._renderSections(this._glOptions.sections);
		            },

		            /**
		             * Rafra√Æchit l'affichage pour mettre √† jour l'√©tat des boutons toggle
		             * Utilis√© notamment apr√®s l'application d'un th√®me
		             * @public
		             */
		            refresh: function () {
		                // Synchroniser uniquement les toggles au lieu de re-g√©n√©rer tout le DOM
		                if (GeoLeaf._LayerManagerRenderer && typeof GeoLeaf._LayerManagerRenderer.syncToggles === 'function') {
		                    GeoLeaf._LayerManagerRenderer.syncToggles();
		                } else if (this._glOptions && this._glOptions.sections) {
		                    // Fallback: re-g√©n√©rer les sections si syncToggles n'est pas disponible
		                    this._renderSections(this._glOptions.sections);
		                }
		            },

		            /**
		             * Bascule l'√©tat collapsed
		             * @private
		             */
		            _toggleCollapsed: function () {
		                const isCollapsed = this._container.classList.toggle("gl-layer-manager--collapsed");
		                this._glOptions.collapsed = isCollapsed;
		            }
		        });

		        return new LayerManagerControl({
		            position: options.position,
		            _glOptions: options
		        });
		    }

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LayerManagerControl = {
		        create: createLayerManagerControl
		    };

		})(window);
		return control;
	}

	requireControl();

	var geoleaf_layerManager = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_layerManager;

	function requireGeoleaf_layerManager () {
		if (hasRequiredGeoleaf_layerManager) return geoleaf_layerManager;
		hasRequiredGeoleaf_layerManager = 1;
		(function (global) {

		    /**
		     * Namespace global GeoLeaf
		     */
		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Logger unifi√©
		     */
		    const Log = GeoLeaf.Log;

		    /**
		     * Module GeoLeaf.LayerManager (REFACTORIS√â v3.0)
		     *
		     * ARCHITECTURE MODULAIRE :
		     * - layer-manager/shared.js : √âtat partag√©
		     * - layer-manager/control.js : Contr√¥le Leaflet (L.Control)
		     * - layer-manager/renderer.js : Rendu des sections et items
		     * - layer-manager/basemap-selector.js : S√©lecteur de fonds de carte
		     * - layer-manager/theme-selector.js : S√©lecteur de th√®mes
		     * - geoleaf.layer-manager.js (ce fichier) : Agr√©gateur/fa√ßade publique
		     *
		     * D√âPENDANCES REQUISES (charg√©es avant ce module) :
		     * - layer-manager/shared.js ‚Üí GeoLeaf._LayerManagerShared
		     * - layer-manager/renderer.js ‚Üí GeoLeaf._LayerManagerRenderer
		     * - layer-manager/basemap-selector.js ‚Üí GeoLeaf._LayerManagerBasemapSelector
		     * - layer-manager/theme-selector.js ‚Üí GeoLeaf._LayerManagerThemeSelector
		     * - layer-manager/control.js ‚Üí GeoLeaf._LayerManagerControl
		     *
		     * R√¥le :
		     * - Cr√©er un contr√¥le Leaflet de gestionnaire de couches pour GeoLeaf
		     * - Afficher des sections structur√©es (basemaps, couches, cat√©gories)
		     * - G√©rer un mode repliable (collapsible)
		     * - Pr√©paration pour l'int√©gration avec le module Legend (Phase 6)
		     */
		    const LayerManagerModule = {
		        /**
		         * R√©f√©rence √† la carte Leaflet
		         * @type {L.Map|null}
		         * @private
		         */
		        _map: null,

		        /**
		         * R√©f√©rence au contr√¥le Leaflet de l√©gende
		         * @type {L.Control|null}
		         * @private
		         */
		        _control: null,

		        /**
		         * Timeout pour le debounce du refresh
		         * @type {number|null}
		         * @private
		         */
		        _refreshTimeout: null,

		        /**
		         * Options internes du module
		         * @type {Object}
		         * @private
		         */
		        _options: {
		            position: "bottomright",
		            title: "Gestionnaire de couches",
		            collapsible: true,
		            collapsed: false,
		            sections: []
		        },

		        /**
		         * Initialisation du module LayerManager
		         *
		         * @param {Object} options
		         * @param {L.Map} [options.map] - Carte Leaflet (si absent, tentative via GeoLeaf.Core.getMap())
		         * @param {string} [options.position]
		         * @param {string} [options.title]
		         * @param {boolean} [options.collapsible]
		         * @param {boolean} [options.collapsed]
		         * @param {Array} [options.sections]
		         * @returns {L.Control|null} - Le contr√¥le LayerManager ou null
		         */
		        init(options = {}) {
		            if (typeof global.L === "undefined" || !global.L || !global.L.Control) {
		                if (Log) Log.error("[GeoLeaf.LayerManager] Leaflet (L.Control) est requis mais introuvable.");
		                return null;
		            }

		            let map = options.map || null;

		            // Tentative de r√©cup√©ration via GeoLeaf.Core
		            if (!map && GeoLeaf.Core && typeof GeoLeaf.Core.getMap === "function") {
		                map = GeoLeaf.Core.getMap();
		            }

		            if (!map) {
		                if (Log) Log.error("[GeoLeaf.LayerManager] Aucune carte Leaflet disponible. Passe une instance dans init({ map }).");
		                return null;
		            }

		            this._map = map;
		            if (Log) Log.info("[GeoLeaf.LayerManager] init: map assigned");

		            this._options = this._mergeOptions(this._options, options);

		            // Charger les sections depuis layerManagerConfig si disponibles
		            this._loadConfigSections();

		            // Remplir automatiquement la section basemap
		            this._autoPopulateBasemap();

		            // Autoremplissage minimal si aucune section
		            this._autoPopulateSections();

		            // Cr√©er le contr√¥le Leaflet via le sous-module
		            if (!GeoLeaf._LayerManagerControl) {
		                if (Log) Log.error("[GeoLeaf.LayerManager] Module _LayerManagerControl non charg√©");
		                return null;
		            }

		            this._control = GeoLeaf._LayerManagerControl.create(this._options);

		            if (!this._control) {
		                if (Log) Log.error("[GeoLeaf.LayerManager] √âchec cr√©ation contr√¥le");
		                return null;
		            }

		            this._control.addTo(this._map);

		            if (Log) Log.info("[GeoLeaf.LayerManager] Contr√¥le cr√©√© et ajout√© √† la carte");
		            return this._control;
		        },

		        /**
		         * Charge les sections depuis la configuration
		         * @private
		         */
		        _loadConfigSections() {
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.get === "function") {
		                const layerManagerConfig = GeoLeaf.Config.get('layerManagerConfig');
		                if (GeoLeaf.Log) GeoLeaf.Log.debug("[LayerManager] Configuration charg√©e:", {
		                    title: layerManagerConfig?.title,
		                    collapsed: layerManagerConfig?.collapsedByDefault,
		                    sectionsCount: layerManagerConfig?.sections?.length || 0
		                });
		                if (layerManagerConfig) {
		                    if (layerManagerConfig.title) {
		                        this._options.title = layerManagerConfig.title;
		                    }

		                    // Param√®tre global collapsed/collapsedByDefault
		                    if (typeof layerManagerConfig.collapsedByDefault === 'boolean') {
		                        this._options.collapsed = layerManagerConfig.collapsedByDefault;
		                    }

		                    if (Array.isArray(layerManagerConfig.sections) && layerManagerConfig.sections.length > 0) {
		                        const configSections = layerManagerConfig.sections
		                            .slice()
		                            .sort((a, b) => (a.order || 0) - (b.order || 0))
		                            .map(s => ({
		                                id: s.id,
		                                label: s.label,
		                                order: s.order,
		                                collapsedByDefault: s.collapsedByDefault,
		                                items: []
		                            }));

		                        if (!Array.isArray(this._options.sections)) {
		                            this._options.sections = [];
		                        }

		                        configSections.forEach(configSection => {
		                            const existingSection = this._options.sections.find(s => s.id === configSection.id);
		                            if (!existingSection) {
		                                this._options.sections.push(configSection);
		                            } else if (configSection.label && !existingSection.label) {
		                                existingSection.label = configSection.label;
		                            }
		                        });

		                        this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));

		                        if (Log) Log.info("[GeoLeaf.LayerManager] Sections fusionn√©es avec layerManagerConfig");
		                    }
		                }
		            }
		        },

		        /**
		         * Remplit automatiquement la section basemap
		         * @private
		         */
		        _autoPopulateBasemap() {
		            if (!Array.isArray(this._options.sections)) return;

		            const basemapSection = this._options.sections.find(s => s.id === "basemap");
		            if (basemapSection && (!basemapSection.items || basemapSection.items.length === 0)) {
		                try {
		                    let basemapDefs = null;
		                    if (global.GeoLeaf && global.GeoLeaf.Baselayers && typeof global.GeoLeaf.Baselayers.getBaseLayers === "function") {
		                        basemapDefs = global.GeoLeaf.Baselayers.getBaseLayers() || {};
		                    } else if (GeoLeaf.Config && typeof GeoLeaf.Config.get === "function") {
		                        basemapDefs = GeoLeaf.Config.get('basemaps') || {};
		                    }

		                    if (basemapDefs && Object.keys(basemapDefs).length > 0) {
		                        basemapSection.items = Object.keys(basemapDefs).map(k => {
		                            const d = basemapDefs[k] || {};
		                            return { id: d.id || k, label: d.label || k };
		                        });
		                        if (Log) Log.info("[GeoLeaf.LayerManager] Section basemap remplie automatiquement");
		                    }
		                } catch (e) {
		                    if (Log) Log.warn("[GeoLeaf.LayerManager] Erreur lors du remplissage automatique des basemaps:", e);
		                }
		            }
		        },

		        /**
		         * Autoremplissage minimal des sections
		         * @private
		         */
		        _autoPopulateSections() {
		            if (Array.isArray(this._options.sections) && this._options.sections.length > 0) return;

		            const autoSections = [];
		            try {
		                if (global.GeoLeaf && global.GeoLeaf.Baselayers && typeof global.GeoLeaf.Baselayers.getBaseLayers === "function") {
		                    const defs = global.GeoLeaf.Baselayers.getBaseLayers() || {};
		                    const baseItems = Object.keys(defs).map(k => {
		                        const d = defs[k] || {};
		                        return { id: k, label: d.label || k };
		                    });
		                    if (baseItems.length) {
		                        autoSections.push({ id: "basemap", label: "Fond de carte", items: baseItems });
		                    }
		                }
		            } catch (e) {
		                // ignore
		            }

		            if (autoSections.length) {
		                this._options.sections = autoSections;
		                if (Log) Log.info("[GeoLeaf.LayerManager] auto-populated sections from Baselayers");
		            } else {
		                if (Log) Log.warn("[GeoLeaf.LayerManager] Aucune section fournie et autoremplissage impossible.");
		            }
		        },

		        /**
		         * Enregistre une couche GeoJSON dans la l√©gende
		         * @param {string} layerId - ID de la couche
		         * @param {Object} options - Options de la couche
		         */
		        _registerGeoJsonLayer(layerId, options = {}) {
		            // ...log supprim√© ([LayerManager] _registerGeoJsonLayer appel√© pour)...

		            if (!this._options.sections) {
		                this._options.sections = [];
		            }

		            // Utiliser layerManagerId ou legendSection (r√©trocompatibilit√©)
		            const sectionId = options.layerManagerId || options.legendSection || "geojson-default";
		            let section = this._options.sections.find(s => s.id === sectionId);

		            if (!section) {
		                section = {
		                    id: sectionId,
		                    label: options.legendSectionLabel || "Couches GeoJSON",
		                    order: 10,
		                    items: []
		                };
		                this._options.sections.push(section);
		                this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));
		            }

		            const existingItem = section.items.find(item => item.id === layerId);
		            if (!existingItem) {
		                section.items.push({
		                    id: layerId,
		                    label: options.label || layerId,
		                    toggleable: true,
		                    themes: options.themes || null,
		                    styles: options.styles || null,
		                    labels: options.labels || null
		                });

		                this._updateContent();
		                if (Log) Log.debug(`[LayerManager] Couche "${layerId}" enregistr√©e dans section "${sectionId}"`);
		            }
		        },

		        /**
		         * D√©senregistre une couche GeoJSON de la l√©gende
		         * @param {string} layerId - ID de la couche
		         */
		        _unregisterGeoJsonLayer(layerId) {
		            if (!Array.isArray(this._options.sections)) return;

		            this._options.sections.forEach(section => {
		                if (Array.isArray(section.items)) {
		                    section.items = section.items.filter(item => item.id !== layerId);
		                }
		            });

		            this._options.sections = this._options.sections.filter(
		                section => section.id === "basemap" || (Array.isArray(section.items) && section.items.length > 0)
		            );

		            this._updateContent();
		            if (Log) Log.debug(`[LayerManager] Couche "${layerId}" d√©senregistr√©e`);
		        },

		        /**
		         * Met √† jour les sections de la l√©gende
		         * @param {Array} sections - Nouvelles sections
		         */
		        updateSections(sections) {
		            if (!Array.isArray(sections)) {
		                if (Log) Log.warn("[GeoLeaf.LayerManager] updateSections: sections doit √™tre un tableau");
		                return;
		            }
		            this._options.sections = sections;
		            this._updateContent();
		        },

		        /**
		         * Ajoute ou met √† jour une section dans la l√©gende
		         * @param {Object} section - Section √† ajouter {id, label, order, items}
		         */
		        addSection(section) {
		            if (!section || !section.id) {
		                if (Log) Log.warn("[GeoLeaf.LayerManager] addSection: section invalide (id manquant)");
		                return;
		            }

		            if (!Array.isArray(this._options.sections)) {
		                this._options.sections = [];
		            }

		            // Chercher une section existante avec le m√™me id
		            const existingIndex = this._options.sections.findIndex(s => s.id === section.id);

		            if (existingIndex !== -1) {
		                // Fusionner avec la section existante
		                const existing = this._options.sections[existingIndex];

		                // Fusionner les items
		                if (Array.isArray(section.items)) {
		                    if (!Array.isArray(existing.items)) {
		                        existing.items = [];
		                    }

		                    section.items.forEach(newItem => {
		                        const existingItemIndex = existing.items.findIndex(i => i.id === newItem.id);
		                        if (existingItemIndex !== -1) {
		                            // Mettre √† jour l'item existant
		                            existing.items[existingItemIndex] = Object.assign({}, existing.items[existingItemIndex], newItem);
		                        } else {
		                            // Ajouter le nouvel item
		                            existing.items.push(newItem);
		                        }
		                    });

		                    // Trier les items par order
		                    existing.items.sort((a, b) => (a.order || 0) - (b.order || 0));
		                }

		                // Mettre √† jour les autres propri√©t√©s si fournies
		                if (section.label) existing.label = section.label;
		                if (section.order !== undefined) existing.order = section.order;
		                if (section.collapsedByDefault !== undefined) existing.collapsedByDefault = section.collapsedByDefault;
		            } else {
		                // Ajouter la nouvelle section
		                this._options.sections.push({
		                    id: section.id,
		                    label: section.label || section.id,
		                    order: section.order || 99,
		                    collapsedByDefault: section.collapsedByDefault || false,
		                    items: section.items || []
		                });

		                // Trier les sections par order
		                this._options.sections.sort((a, b) => (a.order || 0) - (b.order || 0));
		            }

		            this._updateContent();
		            if (Log) Log.debug(`[LayerManager] Section "${section.id}" ajout√©e/mise √† jour`);
		        },

		        /**
		         * Bascule l'√©tat repli√©/d√©pli√© de la l√©gende
		         */
		        toggleCollapse() {
		            this._options.collapsed = !this._options.collapsed;
		            if (!this._control) return;
		            if (this._options.collapsed) {
		                this._control._container.classList.add("gl-layer-manager--collapsed");
		            } else {
		                this._control._container.classList.remove("gl-layer-manager--collapsed");
		            }
		        },

		        /**
		         * Indique si la l√©gende est repli√©e
		         * @returns {boolean}
		         */
		        isCollapsed() {
		            return !!this._options.collapsed;
		        },

		        /**
		         * Force le re-rendu du contenu
		         * @private
		         */
		        _updateContent() {
		            if (!this._control || typeof this._control.updateSections !== "function") {
		                return;
		            }
		            this._control.updateSections(this._options.sections || []);
		        },

		        /**
		         * Rafra√Æchit l'affichage du LayerManager
		         * Utilis√© notamment apr√®s l'application d'un th√®me pour mettre √† jour l'√©tat des boutons toggle
		         * Version debounced pour grouper les appels multiples (ex: plusieurs couches changent de visibilit√© au zoom)
		         * @public
		         * @param {boolean} [immediate=false] - Si true, force le refresh imm√©diat sans debounce
		         */
		        refresh(immediate = false) {
		            if (!this._control || typeof this._control.refresh !== "function") {
		                if (Log) Log.warn("[LayerManager] refresh(): contr√¥le non disponible ou m√©thode refresh manquante");
		                return;
		            }

		            // Si refresh imm√©diat demand√©, annuler le debounce et ex√©cuter
		            if (immediate) {
		                if (this._refreshTimeout) {
		                    clearTimeout(this._refreshTimeout);
		                    this._refreshTimeout = null;
		                }
		                this._control.refresh();
		                if (Log) Log.debug("[LayerManager] Affichage rafra√Æchi (imm√©diat)");
		                return;
		            }

		            // Debounce: annuler le timeout pr√©c√©dent et programmer un nouveau refresh
		            if (this._refreshTimeout) {
		                clearTimeout(this._refreshTimeout);
		            }

		            this._refreshTimeout = setTimeout(() => {
		                this._refreshTimeout = null;
		                this._control.refresh();
		                if (Log) Log.debug("[LayerManager] Affichage rafra√Æchi (debounced)");
		            }, 250);
		        },

		        /**
		         * Fusion d'options (shallow + fusion l√©g√®re pour sous-objets)
		         * @param {Object} base
		         * @param {Object} override
		         * @returns {Object}
		         * @private
		         */
		        _mergeOptions(base, override) {
		            const result = Object.assign({}, base || {});
		            if (!override) return result;

		            Object.keys(override).forEach((key) => {
		                const value = override[key];

		                if (
		                    value &&
		                    typeof value === "object" &&
		                    !Array.isArray(value) &&
		                    base &&
		                    typeof base[key] === "object" &&
		                    !Array.isArray(base[key])
		                ) {
		                    result[key] = Object.assign({}, base[key], value);
		                } else {
		                    result[key] = value;
		                }
		            });

		            return result;
		        }
		    };

		    // Exposer le module dans l'espace de nom GeoLeaf
		    GeoLeaf.LayerManager = LayerManagerModule;
		})(window);
		return geoleaf_layerManager;
	}

	requireGeoleaf_layerManager();

	var legendGenerator = {};

	/**
	 * Module Legend Generator
	 * G√©n√®re automatiquement les l√©gendes depuis les fichiers de style
	 *
	 * D√âPENDANCES:
	 * - GeoLeaf.Log (optionnel)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LegendGenerator
	 */

	var hasRequiredLegendGenerator;

	function requireLegendGenerator () {
		if (hasRequiredLegendGenerator) return legendGenerator;
		hasRequiredLegendGenerator = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * R√©cup√®re l'ic√¥ne depuis taxonomy pour une r√®gle donn√©e
		     * @param {Object} rule - R√®gle de style avec condition when
		     * @param {Object} taxonomyData - Donn√©es de taxonomy
		     * @param {string} symbolPrefix - Pr√©fixe des symboles (ex: "tourism-poi-cat-")
		     * @returns {string|null} - ID de l'ic√¥ne sprite ou null
		     * @private
		     */
		    function getIconFromTaxonomy(rule, taxonomyData, symbolPrefix) {
		        if (!rule.when || !taxonomyData || !taxonomyData.categories) {
		            if (Log) Log.debug("[LegendGenerator] Donn√©es insuffisantes pour r√©cup√©rer ic√¥ne:", {
		                hasRule: !!rule.when,
		                hasTaxonomy: !!taxonomyData,
		                hasCategories: !!(taxonomyData && taxonomyData.categories)
		            });
		            return null;
		        }

		        const field = rule.when.field;
		        const value = rule.when.value;
		        const categories = taxonomyData.categories;

		        if (Log) Log.debug(`[LegendGenerator] Recherche ic√¥ne pour ${field}=${value}`);

		        // D√©terminer le type de recherche
		        const isSubCategory = field === "properties.subCategoryId" || field === "attributes.subCategoryId";
		        const isCategoryId = field === "properties.categoryId" || field === "attributes.categoryId";

		        // Recherche dans subCategoryId
		        if (isSubCategory) {
		            for (const categoryKey in categories) {
		                const subcategories = categories[categoryKey].subcategories;
		                if (subcategories && subcategories[value] && subcategories[value].icon) {
		                    const iconId = symbolPrefix + subcategories[value].icon;
		                    if (Log) Log.debug(`[LegendGenerator] Ic√¥ne trouv√©e (subcat): ${iconId}`);
		                    return iconId;
		                }
		            }
		        }

		        // Recherche dans categoryId
		        if (isCategoryId && categories[value] && categories[value].icon) {
		            const iconId = symbolPrefix + categories[value].icon;
		            if (Log) Log.debug(`[LegendGenerator] Ic√¥ne trouv√©e (cat): ${iconId}`);
		            return iconId;
		        }

		        if (Log) Log.warn(`[LegendGenerator] Aucune ic√¥ne trouv√©e pour ${field}=${value}`);
		        return null;
		    }

		    // Fonction utilitaire pour d√©terminer si les ic√¥nes doivent √™tre affich√©es
		    // Copie exactement la logique de markers.js resolveCategoryDisplay()
		    function shouldUseIcons() {
		        try {
		            // R√©cup√©rer l'√©tat partag√© (comme dans markers.js)
		            const shared = (GeoLeaf && GeoLeaf._POIShared) ? GeoLeaf._POIShared : null;
		            const poiConfig = shared ? shared.state.poiConfig : {};
		            const showIconsOnMap = (poiConfig.showIconsOnMap !== false);

		            if (showIconsOnMap) {
		                // V√©rifier la config d'ic√¥nes (comme dans markers.js)
		                const iconsConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getIconsConfig === "function")
		                    ? GeoLeaf.Config.getIconsConfig()
		                    : null;

		                if (iconsConfig && iconsConfig.showOnMap !== false) {
		                    return true;
		                }
		            }
		        } catch (e) {
		            // Ignorer les erreurs silencieusement
		        }

		        return false;
		    }

		    /**
		     * G√©n√®re les donn√©es de l√©gende depuis un fichier de style
		     * @param {Object} styleData - Donn√©es du style (JSON pars√©)
		     * @param {string} geometryType - Type de g√©om√©trie (point, line, polygon)
		     * @param {Object} taxonomyData - Donn√©es de taxonomy (pour les ic√¥nes POI)
		     * @returns {Object} - Donn√©es de l√©gende format√©es
		     */
		    function generateLegendFromStyle(styleData, geometryType, taxonomyData) {
		        if (!styleData) {
		            if (Log) Log.warn("[LegendGenerator] Style data manquant");
		            return null;
		        }

		        const legendData = {
		            version: "3.0",
		            id: styleData.id,
		            title: styleData.label || "Sans titre",
		            description: styleData.description || "",
		            sections: []
		        };

		        const items = [];
		        const symbolPrefix = taxonomyData?.icons?.symbolPrefix || "tourism-poi-cat-";

		        // Cas 1 : Style avec styleRules
		        if (Array.isArray(styleData.styleRules) && styleData.styleRules.length > 0) {
		            styleData.styleRules.forEach(rule => {
		                if (!rule.legend) {
		                    if (Log) Log.warn("[LegendGenerator] R√®gle sans propri√©t√© legend:", rule);
		                    return;
		                }

		                const item = generateLegendItem(
		                    rule.style,
		                    rule.legend,
		                    geometryType,
		                    styleData.style, // style de base
		                    rule,
		                    taxonomyData,
		                    symbolPrefix
		                );

		                if (item) {
		                    items.push(item);
		                }
		            });

		            // Trier par order
		            items.sort((a, b) => (a.order || 999) - (b.order || 999));

		        // Cas 2 : Style simple sans r√®gles ou avec styleRules vide
		        }

		        // Si pas d'items g√©n√©r√©s √† partir des styleRules (ou pas de styleRules)
		        // essayer d'utiliser la l√©gende au niveau racine
		        if (items.length === 0 && styleData.style && styleData.legend) {
		            const item = generateLegendItem(
		                styleData.style,
		                styleData.legend,
		                geometryType,
		                null,
		                null,
		                taxonomyData,
		                symbolPrefix
		            );

		            if (item) {
		                items.push(item);
		            }
		        }

		        // Cr√©er une section par d√©faut avec tous les items
		        if (items.length > 0) {
		            legendData.sections.push({
		                title: "",
		                items: items
		            });
		        }

		        return legendData;
		    }

		    /**
		     * G√©n√®re un item de l√©gende selon le type de g√©om√©trie
		     * @param {Object} style - Style de l'entit√©
		     * @param {Object} legend - Propri√©t√©s legend (label, order, description)
		     * @param {string} geometryType - Type de g√©om√©trie
		     * @param {Object} baseStyle - Style de base (pour h√©ritage)
		     * @param {Object} rule - R√®gle compl√®te (pour extraction ic√¥ne)
		     * @param {Object} taxonomyData - Donn√©es taxonomy
		     * @param {string} symbolPrefix - Pr√©fixe symboles
		     * @param {boolean} showIconsOnMap - Si true, g√©n√®re les ic√¥nes
		     * @returns {Object|null} - Item de l√©gende
		     * @private
		     */
		    function generateLegendItem(style, legend, geometryType, baseStyle, rule, taxonomyData, symbolPrefix) {
		        if (!style || !legend) {
		            return null;
		        }

		        // Fusionner avec le style de base si pr√©sent
		        const mergedStyle = baseStyle ? Object.assign({}, baseStyle, style) : style;

		        const item = {
		            label: legend.label || "Sans label",
		            order: legend.order || 999
		        };

		        if (legend.description) {
		            item.description = legend.description;
		        }

		        // G√©n√©ration du symbole selon le type de g√©om√©trie
		        switch (geometryType) {
		            case "point":
		                item.symbol = generatePointSymbol(mergedStyle, rule, taxonomyData, symbolPrefix);
		                break;

		            case "line":
		                item.symbol = generateLineSymbol(mergedStyle);
		                break;

		            case "polygon":
		                item.symbol = generatePolygonSymbol(mergedStyle);
		                break;

		            default:
		                if (Log) Log.warn("[LegendGenerator] Type de g√©om√©trie non reconnu:", geometryType);
		                item.symbol = generatePointSymbol(mergedStyle, rule, taxonomyData, symbolPrefix);
		        }

		        return item;
		    }

		    /**
		     * Ajoute les propri√©t√©s communes d'opacit√© √† un symbole
		     * @param {Object} symbol - Objet symbole
		     * @param {Object} style - Style source
		     * @param {Array<string>} opacityProps - Propri√©t√©s d'opacit√© √† copier
		     * @private
		     */
		    function applyOpacityProperties(symbol, style, opacityProps) {
		        opacityProps.forEach(prop => {
		            if (style[prop] !== undefined) {
		                symbol[prop] = style[prop];
		            }
		        });
		    }

		    /**
		     * R√©sout les ic√¥nes d'une r√®gle selon la configuration showIconsOnMap
		     * @param {Object} rule - R√®gle de style
		     * @returns {Object} - {useIcon: boolean, iconId: string|null}
		     * @private
		     */
		    function resolveRuleIcons(rule) {
		        // Utiliser la m√™me logique que markers.js
		        if (!shouldUseIcons()) {
		            return { useIcon: false, iconId: null };
		        }
		        // R√©cup√©rer la configuration des cat√©gories
		        const categoriesConfig = (GeoLeaf.Config && typeof GeoLeaf.Config.getCategories === "function")
		            ? GeoLeaf.Config.getCategories()
		            : {};

		        if (!categoriesConfig || Object.keys(categoriesConfig).length === 0) {
		            return { useIcon: false, iconId: null };
		        }

		        // Mappage de fclass vers categoryId/subCategoryId pour les ic√¥nes
		        // Permet de r√©soudre les ic√¥nes pour les r√®gles qui utilisent fclass au lieu de categoryId
		        const fclassMappings = {
		            // Cultures
		            'archaeological': { categoryId: 'CULTURES', subCategoryId: 'SITE ARCHEOLOGIQUE' },
		            'museum': { categoryId: 'CULTURES', subCategoryId: 'MUSEE' },
		            // H√©bergements
		            'camp_site': { categoryId: 'HEBERGEMENT', subCategoryId: 'CAMPING' },
		            'hotel': { categoryId: 'HEBERGEMENT', subCategoryId: 'HOTEL' }
		        };

		        // Extraire categoryId et subCategoryId depuis la r√®gle
		        let categoryId = null;
		        let subCategoryId = null;

		        // Format v3 : rule.when avec field/value
		        if (rule.when && rule.when.field && rule.when.value !== undefined) {
		            // NOUVEAU: Cas sp√©cial pour fclass (r√©soudre via mapping)
		            if (rule.when.field === 'properties.fclass' || rule.when.field === 'fclass') {
		                const mapping = fclassMappings[rule.when.value];
		                if (mapping) {
		                    categoryId = mapping.categoryId;
		                    subCategoryId = mapping.subCategoryId;
		                }
		            } else if (rule.when.field === 'properties.categoryId' || rule.when.field === 'categoryId') {
		                categoryId = rule.when.value;
		            } else if (rule.when.field === 'properties.subCategoryId' || rule.when.field === 'subCategoryId') {
		                subCategoryId = rule.when.value;
		            } else if (rule.when.field === 'properties.category' || rule.when.field === 'category') {
		                categoryId = rule.when.value;
		            } else if (rule.when.field === 'properties.subCategory' || rule.when.field === 'subCategory') {
		                subCategoryId = rule.when.value;
		            }
		        }
		        // Format legacy : rule.condition
		        else if (rule.condition) {
		            if (typeof rule.condition.categoryId !== 'undefined') {
		                categoryId = rule.condition.categoryId;
		            }
		            if (typeof rule.condition.subCategoryId !== 'undefined') {
		                subCategoryId = rule.condition.subCategoryId;
		            }
		            if (typeof rule.condition.category !== 'undefined') {
		                categoryId = rule.condition.category;
		            }
		            if (typeof rule.condition.subCategory !== 'undefined') {
		                subCategoryId = rule.condition.subCategory;
		            }
		        }

		        // Pour les subCategoryId, il faut deviner la categoryId depuis la taxonomie
		        if (subCategoryId && !categoryId) {
		            // Chercher dans quelle cat√©gorie se trouve cette sous-cat√©gorie
		            Object.keys(categoriesConfig).forEach(catKey => {
		                const cat = categoriesConfig[catKey];
		                if (cat.subcategories && cat.subcategories[subCategoryId]) {
		                    categoryId = catKey;
		                }
		            });
		        }

		        if (!categoryId && !subCategoryId) {
		            return { useIcon: false, iconId: null };
		        }

		        // R√©solution de l'ic√¥ne depuis la taxonomie
		        let iconId = null;
		        if (subCategoryId && categoriesConfig[categoryId]?.subcategories) {
		            const subCat = categoriesConfig[categoryId].subcategories[subCategoryId];
		            const cat = categoriesConfig[categoryId];

		            if (subCat) {
		                iconId = subCat.icon || subCat.iconId || cat.icon || cat.iconId || null;
		            } else {
		                iconId = cat.icon || cat.iconId || null;
		            }
		        } else if (categoriesConfig[categoryId]) {
		            const cat = categoriesConfig[categoryId];
		            iconId = cat.icon || cat.iconId || null;
		        }

		        return {
		            useIcon: iconId !== null,
		            iconId: iconId
		        };
		    }

		    /**
		     * G√©n√®re un symbole pour les points (POI)
		     * @param {Object} style - Style du point
		     * @param {Object} rule - R√®gle compl√®te (pour extraction ic√¥ne)
		     * @param {Object} taxonomyData - Donn√©es taxonomy
		     * @param {string} symbolPrefix - Pr√©fixe symboles
		     * @param {boolean} showIconsOnMap - Si true, g√©n√®re les ic√¥nes
		     * @returns {Object} - Configuration du symbole
		     * @private
		     */
		    function generatePointSymbol(style, rule, taxonomyData, symbolPrefix) {
		        const fill = style.fill || {};
		        const stroke = style.stroke || {};

		        const resolvedRadius = style.radius || style.size || (style.sizePx ? style.sizePx / 2 : undefined);

		        // Taille par d√©faut plus grande pour que les ic√¥nes soient visibles dans la l√©gende
		        // Utiliser 24px pour les ic√¥nes, 16px pour les cercles simples
		        const defaultRadius = 24;

		        const symbol = {
		            type: "circle",
		            radius: resolvedRadius || defaultRadius,
		            fillColor: style.fillColor || style.color || fill.color || "#3388ff",
		            fillOpacity: style.fillOpacity !== undefined ? style.fillOpacity : (fill.opacity !== undefined ? fill.opacity : 1),
		            color: style.color || stroke.color || "#ffffff",
		            weight: style.weight || stroke.widthPx || 2,
		            opacity: style.opacity !== undefined ? style.opacity : (stroke.opacity !== undefined ? stroke.opacity : 1)
		        };

		        // Priorit√© 1 : V√©rifier si l'ic√¥ne est directement dans le style (showIconsOnMap)
		        if (style.useIcon && style.iconId) {
		            symbol.icon = style.iconId;
		            symbol.iconColor = "#ffffff"; // Couleur par d√©faut pour ic√¥nes
		            if (Log) Log.debug(`[LegendGenerator] Ic√¥ne trouv√©e dans le style: ${style.iconId}`);
		        }
		        // Priorit√© 2 : R√©soudre l'ic√¥ne depuis la configuration showIconsOnMap
		        else if (rule && shouldUseIcons()) {
		            const iconResolution = resolveRuleIcons(rule);

		            if (iconResolution.useIcon && iconResolution.iconId) {
		                // Ajouter le pr√©fixe sprite si n√©cessaire
		                const fullIconId = iconResolution.iconId.startsWith('#') ?
		                    iconResolution.iconId :
		                    (symbolPrefix ? symbolPrefix + iconResolution.iconId : '#sprite-' + iconResolution.iconId);

		                symbol.icon = fullIconId;
		                symbol.iconColor = "#ffffff";
		                if (Log) Log.debug(`[LegendGenerator] Ic√¥ne r√©solue depuis la config: ${fullIconId}`);
		            }
		        }
		        // Priorit√© 3 : Tenter de r√©cup√©rer l'ic√¥ne depuis taxonomy (m√©thode legacy)
		        if (!symbol.icon && rule && taxonomyData && shouldUseIcons()) {
		            const icon = getIconFromTaxonomy(rule, taxonomyData, symbolPrefix);
		            if (icon) {
		                symbol.icon = icon;
		                symbol.iconColor = "#ffffff"; // Couleur par d√©faut pour ic√¥nes
		                if (Log) Log.debug("[LegendGenerator] Ic√¥ne taxonomy ajout√©e:", icon);
		            }
		        }

		        return symbol;
		    }

		    /**
		     * G√©n√®re un symbole pour les lignes
		     * @param {Object} style - Style de la ligne
		     * @returns {Object} - Configuration du symbole
		     * @private
		     */
		    function generateLineSymbol(style) {
		        const stroke = style.stroke || {};
		        const casing = style.casing || {};

		        // Strat√©gie : afficher le casing comme contour/bordure du stroke
		        // Si casing existe, utiliser la couleur du casing comme contour
		        // et le stroke comme couleur principale
		        const symbol = {
		            type: "line",
		            color: stroke.color || style.color || "#3388ff",
		            width: stroke.widthPx || style.weight || 3,
		            style: "solid" // Par d√©faut
		        };

		        // Si casing est activ√©, ajouter une bordure/outline fine
		        // Limiter l'√©paisseur pour la l√©gende (r√©duit d'un facteur)
		        if (casing.enabled && casing.color) {
		            symbol.outlineColor = casing.color;
		            // Utiliser une fraction de la largeur du casing pour la l√©gende
		            symbol.outlineWidth = Math.max(0.5, (casing.widthPx || 1) * 0.4);
		            symbol.outlineOpacity = casing.opacity || 1;
		        }

		        // Appliquer l'opacit√©
		        if (stroke.opacity !== undefined) {
		            symbol.opacity = stroke.opacity;
		        }

		        // Support pour dashArray - passer la valeur compl√®te
		        const dashArray = style.dashArray || stroke.dashArray;
		        if (dashArray) {
		            symbol.dashArray = dashArray;
		            // Garder le style pour la r√©trocompatibilit√©
		            if (dashArray === "5, 5" || dashArray === "10, 10") {
		                symbol.style = "dashed";
		            } else if (dashArray === "1, 3" || dashArray === "2, 4") {
		                symbol.style = "dotted";
		            }
		        }

		        return symbol;
		    }

		    /**
		     * G√©n√®re un symbole pour les polygones
		     * @param {Object} style - Style du polygone
		     * @returns {Object} - Configuration du symbole
		     * @private
		     */
		    function generatePolygonSymbol(style) {
		        const fill = style.fill || {};
		        const stroke = style.stroke || {};

		        const symbol = {
		            type: "polygon",
		            fillColor: style.fillColor || style.color || fill.color || "#3388ff",
		            color: style.color || stroke.color || "#333",
		            weight: style.weight || stroke.widthPx || 1
		        };

		        // Appliquer l'opacit√© du fill (pas du stroke qui √©crase)
		        applyOpacityProperties(symbol, style, ['fillOpacity']);
		        // Si pas de fillOpacity, prendre l'opacity directement du fill
		        if (fill.opacity !== undefined) {
		            symbol.opacity = fill.opacity;
		        }
		        // Puis v√©rifier style.opacity en dernier (peut √™tre au niveau racine)
		        if (style.opacity !== undefined) {
		            symbol.opacity = style.opacity;
		        }

		        // Support pour dashArray sur le contour
		        const dashArray = style.dashArray || stroke.dashArray;
		        if (dashArray) {
		            symbol.dashArray = dashArray;
		        }

		        // Support pour patterns de hachures
		        if (style.fillPattern) {
		            symbol.fillPattern = style.fillPattern;
		        }

		        // Support pour les hachures (format moderne)
		        if (style.hatch) {
		            symbol.hatch = style.hatch;
		        }

		        return symbol;
		    }

		    // Exposer le module
		    GeoLeaf._LegendGenerator = {
		        generateLegendFromStyle: generateLegendFromStyle,
		        generateLegendItem: generateLegendItem
		    };

		})(window);
		return legendGenerator;
	}

	requireLegendGenerator();

	var legendRenderer = {};

	/**
	 * Module Legend Renderer
	 * Rendu des symboles de l√©gende cartographique
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.DomUtil)
	 * - GeoLeaf.Log (optionnel)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LegendRenderer
	 */

	var hasRequiredLegendRenderer;

	function requireLegendRenderer () {
		if (hasRequiredLegendRenderer) return legendRenderer;
		hasRequiredLegendRenderer = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Rendu d'une section de l√©gende
		     * @param {HTMLElement} container - Conteneur parent
		     * @param {Object} section - Section de l√©gende
		     */
		    function renderSection(container, section) {
		        const sectionEl = global.L.DomUtil.create("div", "gl-legend__section", container);

		        // Titre de section
		        if (section.title) {
		            const titleEl = global.L.DomUtil.create("h3", "gl-legend__section-title", sectionEl);
		            titleEl.textContent = section.title;
		        }

		        // Items
		        const itemsContainer = global.L.DomUtil.create("div", "gl-legend__items", sectionEl);
		        if (Array.isArray(section.items)) {
		            section.items.forEach(item => renderItem(itemsContainer, item));
		        }

		        return sectionEl;
		    }

		    /**
		     * Rendu d'un item de l√©gende
		     * @param {HTMLElement} container - Conteneur parent
		     * @param {Object} item - Item de l√©gende
		     */
		    function renderItem(container, item) {
		        const itemEl = global.L.DomUtil.create("div", "gl-legend__item", container);

		        // Symbole
		        const symbolEl = global.L.DomUtil.create("div", "gl-legend__symbol", itemEl);
		        renderSymbol(symbolEl, item);

		        // Texte
		        const textContainer = global.L.DomUtil.create("div", "gl-legend__text", itemEl);

		        const labelEl = global.L.DomUtil.create("span", "gl-legend__label", textContainer);
		        labelEl.textContent = item.label || "";

		        if (item.description) {
		            const descEl = global.L.DomUtil.create("span", "gl-legend__description", textContainer);
		            descEl.textContent = item.description;
		        }

		        return itemEl;
		    }

		    /**
		     * Rendu d'un symbole selon son type
		     * @param {HTMLElement} container - Conteneur du symbole
		     * @param {Object} item - Configuration du symbole
		     */
		    function renderSymbol(container, item) {
		        // D√©l√©guer au module commun
		        if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.renderSymbol === 'function') {
		            GeoLeaf._UIComponents.renderSymbol(container, item);
		        } else {
		            // Fallback si module non charg√©
		            if (Log) Log.error("[LegendRenderer] Module _UIComponents non disponible");
		        }
		    }

		    /**
		     * Rendu du footer
		     * @param {HTMLElement} container - Conteneur parent
		     * @param {Object} footer - Configuration du footer
		     */
		    function renderFooter(container, footer) {
		        if (!footer || !footer.text) return;

		        const footerEl = global.L.DomUtil.create("div", "gl-legend__footer", container);
		        footerEl.textContent = footer.text;

		        if (footer.style === "italic") {
		            footerEl.style.fontStyle = "italic";
		        }
		    }

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LegendRenderer = {
		        renderSection: renderSection,
		        renderItem: renderItem,
		        renderSymbol: renderSymbol,
		        renderFooter: renderFooter,
		        renderAccordion: renderAccordion
		    };

		    /**
		     * Rendu d'un accord√©on pour une couche
		     * @param {HTMLElement} container - Conteneur parent
		     * @param {Object} accordionData - Configuration de l'accord√©on
		     * @param {string} accordionData.layerId - ID de la couche
		     * @param {string} accordionData.label - Titre de l'accord√©on
		     * @param {boolean} accordionData.collapsed - √âtat initial
		     * @param {boolean} accordionData.visible - Couche visible ou non (pour grisage)
		     * @param {Array} accordionData.sections - Sections de l√©gende
		     */
		    function renderAccordion(container, accordionData) {
		        // Utiliser le module commun pour cr√©er l'accord√©on
		        if (!GeoLeaf._UIComponents) {
		            if (Log) Log.error("[LegendRenderer] Module _UIComponents non disponible");
		            return;
		        }

		        const { bodyEl } = GeoLeaf._UIComponents.createAccordion(container, {
		            layerId: accordionData.layerId,
		            label: accordionData.label,
		            collapsed: accordionData.collapsed !== false,
		            visible: accordionData.visible,
		            onToggle: (layerId, expanded) => {
		                // Notifier le module Legend du changement
		                if (global.GeoLeaf && global.GeoLeaf.Legend && typeof global.GeoLeaf.Legend.toggleAccordion === "function") {
		                    global.GeoLeaf.Legend.toggleAccordion(layerId);
		                }
		            }
		        });

		        // Rendre les sections √† l'int√©rieur du body
		        if (Array.isArray(accordionData.sections)) {
		            accordionData.sections.forEach(section => {
		                renderSection(bodyEl, section);
		            });
		        }
		    }

		})(window);
		return legendRenderer;
	}

	requireLegendRenderer();

	var legendControl = {};

	/**
	 * Module Legend Control
	 * Contr√¥le Leaflet pour afficher une l√©gende cartographique
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.Control, L.DomUtil, L.DomEvent)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf._LegendRenderer
	 *
	 * EXPOSE:
	 * - GeoLeaf._LegendControl
	 */

	var hasRequiredLegendControl;

	function requireLegendControl () {
		if (hasRequiredLegendControl) return legendControl;
		hasRequiredLegendControl = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * S'assure que le sprite SVG des ic√¥nes est charg√© avec v√©rification robuste
		     * @private
		     * @param {Function} [callback] - Fonction √† appeler une fois le sprite charg√©
		     */
		    async function ensureSpriteLoaded(callback) {
		        if (GeoLeaf._POIMarkers && typeof GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync === "function") {
		            // √âviter les logs r√©p√©titifs - log seulement la premi√®re fois
		            if (!ensureSpriteLoaded._alreadyLogged) {
		                if (Log) Log.debug("[Legend] Chargement du sprite SVG pour les ic√¥nes...");
		                ensureSpriteLoaded._alreadyLogged = true;
		            }

		            // Attendre que le sprite soit charg√© de mani√®re asynchrone
		            await GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync();

		            // V√©rification avec retry pour s'assurer que le sprite est charg√©
		            let attempts = 0;
		            const maxAttempts = 20; // 2 secondes max
		            const checkInterval = 100;

		            function checkSprite() {
		                const spriteEl = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		                attempts++;

		                if (spriteEl) {
		                    // Log seulement la premi√®re d√©tection r√©ussie
		                    if (!ensureSpriteLoaded._spriteDetected) {
		                        if (Log) Log.info("[Legend] Sprite SVG d√©tect√© et pr√™t pour utilisation");
		                        ensureSpriteLoaded._spriteDetected = true;
		                    }
		                    if (typeof callback === 'function') {
		                        callback(true);
		                    }
		                } else if (attempts < maxAttempts) {
		                    setTimeout(checkSprite, checkInterval);
		                } else {
		                    if (Log) Log.warn("[Legend] Sprite SVG non trouv√© apr√®s", maxAttempts * checkInterval, "ms");
		                    if (typeof callback === 'function') {
		                        callback(false);
		                    }
		                }
		            }

		            checkSprite();
		        } else {
		            if (Log) Log.debug("[Legend] GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync non disponible");
		            if (typeof callback === 'function') {
		                callback(false);
		            }
		        }
		    }

		    /**
		     * Cr√©e un contr√¥le Leaflet pour la l√©gende cartographique
		     * @param {Object} options - Options du contr√¥le
		     * @returns {L.Control} - Instance du contr√¥le Leaflet
		     */
		    function createLegendControl(options) {
		        if (!global.L || !global.L.Control) {
		            if (Log) Log.error("[Legend] Leaflet L.Control non disponible");
		            return null;
		        }

		        const LegendControl = global.L.Control.extend({
		            options: {
		                position: options.position || "bottomleft"
		            },

		            initialize: function (controlOptions) {
		                global.L.setOptions(this, controlOptions || {});
		                this._glOptions = controlOptions._glOptions;
		            },

		            onAdd: function (mapInstance) {
		                this._map = mapInstance;
		                this._container = global.L.DomUtil.create("div", "gl-map-legend");

		                // Emp√™cher les interactions carte
		                if (global.L.DomEvent) {
		                    global.L.DomEvent.disableClickPropagation(this._container);
		                    global.L.DomEvent.disableScrollPropagation(this._container);
		                }

		                this._buildStructure();
		                return this._container;
		            },

		            onRemove: function () {
		                this._map = null;
		                this._container = null;
		            },

		            /**
		             * Construit la structure DOM de la l√©gende
		             * @private
		             */
		            _buildStructure: function () {
		                const opts = this._glOptions;

		                // Wrapper principal
		                const wrapper = global.L.DomUtil.create("div", "gl-map-legend__wrapper", this._container);

		                // En-t√™te : titre + bouton collapse
		                if (opts.title) {
		                    const header = global.L.DomUtil.create("div", "gl-map-legend__header", wrapper);

		                    const titleEl = global.L.DomUtil.create("h2", "gl-map-legend__title", header);
		                    titleEl.textContent = opts.title;

		                    if (opts.collapsible) {
		                        const toggleEl = global.L.DomUtil.create("button", "gl-map-legend__toggle", header);
		                        toggleEl.type = "button";
		                        toggleEl.setAttribute("aria-label", "Basculer la l√©gende");
		                        toggleEl.textContent = "‚ü±";

		                        const self = this;
		                        global.L.DomEvent.on(toggleEl, "click", function (ev) {
		                            global.L.DomEvent.stopPropagation(ev);
		                            self._toggleCollapsed();
		                        });
		                    }
		                }

		                // Corps de la l√©gende
		                this._bodyEl = global.L.DomUtil.create("div", "gl-map-legend__body", wrapper);

		                // Appliquer l'√©tat collapsed initial
		                if (opts.collapsed) {
		                    this._container.classList.add("gl-map-legend--collapsed");
		                }

		                // Rendu des sections via le renderer
		                this._renderContent();
		            },

		            /**
		             * Rend le contenu de la l√©gende
		             * @private
		             */
		            _renderContent: function () {
		                if (!this._bodyEl) return;

		                // Vider le contenu existant
		                if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.clearElement === 'function') {
		                    GeoLeaf._UIComponents.clearElement(this._bodyEl);
		                } else {
		                    GeoLeaf.DOMSecurity.clearElementFast(this._bodyEl);
		                }

		                const opts = this._glOptions;
		                const renderer = GeoLeaf._LegendRenderer;

		                if (!renderer) {
		                    if (Log) Log.error("[Legend] _LegendRenderer non disponible");
		                    return;
		                }

		                // S'assurer que le sprite SVG est charg√© pour les ic√¥nes
		                ensureSpriteLoaded();

		                // Rendu des sections (ancien mode pour compatibilit√©)
		                if (Array.isArray(opts.sections)) {
		                    opts.sections.forEach(section => {
		                        renderer.renderSection(this._bodyEl, section);
		                    });
		                }

		                // Rendu du footer
		                if (opts.footer) {
		                    renderer.renderFooter(this._bodyEl, opts.footer);
		                }
		            },

		            /**
		             * Mise √† jour du contenu multi-couches avec accord√©ons
		             * @param {Array} legendsArray - Tableau d'accord√©ons √† afficher
		             */
		            updateMultiLayerContent: function (legendsArray) {
		                if (!this._bodyEl) return;

		                // Vider le contenu existant
		                if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.clearElement === 'function') {
		                    GeoLeaf._UIComponents.clearElement(this._bodyEl);
		                } else {
		                    GeoLeaf.DOMSecurity.clearElementFast(this._bodyEl);
		                }

		                const renderer = GeoLeaf._LegendRenderer;

		                if (!renderer || typeof renderer.renderAccordion !== "function") {
		                    if (Log) Log.error("[Legend] Renderer.renderAccordion non disponible");
		                    return;
		                }

		                // S'assurer que le sprite SVG est charg√© avant le rendu
		                const self = this;
		                ensureSpriteLoaded(function(spriteLoaded) {
		                    if (Log) Log.debug("[Legend] Sprite charg√©:", spriteLoaded, "- Rendu des accord√©ons");

		                    // Rendre chaque accord√©on (m√™me si le sprite n'est pas charg√© pour √©viter une interface vide)
		                    if (Array.isArray(legendsArray)) {
		                        legendsArray.forEach(accordionData => {
		                            renderer.renderAccordion(self._bodyEl, accordionData);
		                        });
		                    }

		                    // Si le sprite n'√©tait pas charg√©, r√©essayer dans 1 seconde
		                    if (!spriteLoaded) {
		                        setTimeout(function() {
		                            const spriteEl = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		                            if (spriteEl && Log) {
		                                Log.info("[Legend] Sprite charg√© tardivement - Re-rendu des accord√©ons");
		                                self.updateMultiLayerContent(legendsArray);
		                            }
		                        }, 1000);
		                    }
		                });
		            },

		            /**
		             * Mise √† jour du contenu de la l√©gende (ancien mode)
		             * @param {Object} legendData - Nouvelles donn√©es de l√©gende
		             */
		            updateContent: function (legendData) {
		                if (legendData.title) this._glOptions.title = legendData.title;
		                if (legendData.sections) this._glOptions.sections = legendData.sections;
		                if (legendData.footer) this._glOptions.footer = legendData.footer;

		                this._renderContent();
		            },

		            /**
		             * Bascule l'√©tat collapsed
		             * @private
		             */
		            _toggleCollapsed: function () {
		                const isCollapsed = this._container.classList.toggle("gl-map-legend--collapsed");
		                this._glOptions.collapsed = isCollapsed;
		            },

		            /**
		             * Montre la l√©gende
		             * @public
		             */
		            show: function () {
		                if (this._container) {
		                    this._container.style.display = "block";
		                }
		            },

		            /**
		             * Cache la l√©gende
		             * @public
		             */
		            hide: function () {
		                if (this._container) {
		                    this._container.style.display = "none";
		                }
		            }
		        });

		        return new LegendControl({
		            position: options.position,
		            _glOptions: options
		        });
		    }

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LegendControl = {
		        create: createLegendControl
		    };

		})(window);
		return legendControl;
	}

	requireLegendControl();

	var geoleaf_legend = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_legend;

	function requireGeoleaf_legend () {
		if (hasRequiredGeoleaf_legend) return geoleaf_legend;
		hasRequiredGeoleaf_legend = 1;
		/**
		 * Module principal GeoLeaf.Legend
		 * Gestionnaire de l√©gende cartographique multi-couches avec accord√©ons
		 * G√©n√®re automatiquement les l√©gendes depuis les styles
		 *
		 * D√âPENDANCES:
		 * - Leaflet (map instance)
		 * - GeoLeaf.Log (optionnel)
		 * - GeoLeaf._LegendControl
		 * - GeoLeaf._LegendRenderer
		 * - GeoLeaf._LegendGenerator (nouveau)
		 * - GeoLeaf.Config (pour chargement configuration)
		 *
		 * EXPOSE:
		 * - GeoLeaf.Legend
		 */
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    let _map = null;
		    let _control = null;
		    let _options = {};
		    let _profileConfig = null;
		    let _taxonomyData = null;

		    // Timers and UI helpers
		    let _rebuildTimer = null;
		    const REBUILD_DEBOUNCE_MS = 150;
		    let _loadingOverlayEl = null;
		    let _loadingOverlayTimer = null;
		    const LOADING_OVERLAY_TIMEOUT_MS = 12000;

		    // Map<layerId, {label, styleId, legendData, visible, order, geometryType}>
		    const _allLayers = new Map();

		    function _normalizeGeometryType(rawGeometry) {
		        const value = (rawGeometry).toLowerCase();
		        if (value === "polyline" || value === "line") return "line";
		        if (value === "polygon") return "polygon";
		        return "point";
		    }

		    function _scheduleRebuild() {
		        if (_rebuildTimer) {
		            clearTimeout(_rebuildTimer);
		        }
		        _rebuildTimer = setTimeout(() => {
		            _rebuildTimer = null;
		            LegendModule._rebuildDisplay();
		        }, REBUILD_DEBOUNCE_MS);
		    }

		    function _ensureSpinnerStyles() {
		        if (document.getElementById("gl-legend-spinner-style")) return;
		        const styleEl = document.createElement("style");
		        styleEl.id = "gl-legend-spinner-style";
		        styleEl.textContent = "@keyframes gl-legend-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }";
		        document.head.appendChild(styleEl);
		    }

		    function _clearOverlayTimeout() {
		        if (_loadingOverlayTimer) {
		            clearTimeout(_loadingOverlayTimer);
		            _loadingOverlayTimer = null;
		        }
		    }

		    function _showLoadingOverlay() {
		        if (!_control || !_control._container) return;

		        _ensureSpinnerStyles();
		        _clearOverlayTimeout();

		        const container = _control._container;
		        if (!container.style.position) {
		            container.style.position = "relative";
		        }

		        if (!_loadingOverlayEl) {
		            const overlay = document.createElement("div");
		            overlay.className = "gl-map-legend__loading-overlay";
		            overlay.style.position = "absolute";
		            overlay.style.inset = "0";
		            overlay.style.background = "rgba(255,255,255,0.6)";
		            overlay.style.display = "flex";
		            overlay.style.alignItems = "center";
		            overlay.style.justifyContent = "center";
		            overlay.style.pointerEvents = "auto";
		            overlay.style.zIndex = "2";
		            overlay.setAttribute("aria-hidden", "false");

		            const spinner = document.createElement("div");
		            spinner.className = "gl-map-legend__spinner";
		            spinner.style.width = "34px";
		            spinner.style.height = "34px";
		            spinner.style.border = "3px solid rgba(0,0,0,0.12)";
		            spinner.style.borderTop = "3px solid rgba(0,0,0,0.55)";
		            spinner.style.borderRadius = "50%";
		            spinner.style.animation = "gl-legend-spin 1s linear infinite";

		            overlay.appendChild(spinner);
		            _loadingOverlayEl = overlay;
		        }

		        if (!_loadingOverlayEl.parentElement) {
		            container.appendChild(_loadingOverlayEl);
		        }

		        container.setAttribute("aria-busy", "true");
		        container.setAttribute("aria-live", "polite");

		        _loadingOverlayTimer = setTimeout(() => {
		            _loadingOverlayTimer = null;
		            _hideLoadingOverlay();
		        }, LOADING_OVERLAY_TIMEOUT_MS);
		    }

		    function _hideLoadingOverlay() {
		        _clearOverlayTimeout();
		        if (_loadingOverlayEl && _loadingOverlayEl.parentElement) {
		            _loadingOverlayEl.parentElement.removeChild(_loadingOverlayEl);
		        }
		        if (_control && _control._container) {
		            _control._container.removeAttribute("aria-busy");
		            _control._container.removeAttribute("aria-live");
		        }
		    }

		    const LegendModule = {
		        /**
		         * Initialise le module Legend
		         * @param {L.Map} mapInstance - Instance de la carte Leaflet
		         * @param {Object} options - Options du module
		         * @param {string} [options.position="bottomleft"] - Position du contr√¥le
		         * @param {boolean} [options.collapsible=true] - L√©gende repliable
		         * @param {boolean} [options.collapsed=false] - √âtat repli√© initial
		         */
		        init: function (mapInstance, options) {
		            if (!mapInstance) {
		                if (Log) Log.error("[Legend] Carte Leaflet requise pour initialiser Legend");
		                return false;
		            }

		            _map = mapInstance;

		            // Charger la configuration depuis le profil
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.get === "function") {
		                const legendConfig = GeoLeaf.Config.get("legendConfig");

		                _options = Object.assign({
		                    position: (legendConfig && legendConfig.position) || "bottomleft",
		                    collapsible: true,
		                    collapsed: (legendConfig && legendConfig.collapsedByDefault) || false,
		                    title: (legendConfig && legendConfig.title) || "L√©gende"
		                }, options || {});

		                // R√©cup√©rer le profil actif complet
		                if (typeof GeoLeaf.Config.getActiveProfile === "function") {
		                    _profileConfig = GeoLeaf.Config.getActiveProfile();
		                } else {
		                    // Fallback : essayer de r√©cup√©rer depuis getAll
		                    const allConfig = GeoLeaf.Config.getAll();
		                    _profileConfig = {
		                        id: allConfig.id || GeoLeaf.Config.get('id'),
		                        layers: allConfig.layers || GeoLeaf.Config.get('layers') || []
		                    };
		                }
		            } else {
		                _options = Object.assign({
		                    position: "bottomleft",
		                    collapsible: true,
		                    collapsed: false,
		                    title: "L√©gende"
		                }, options || {});
		            }

		            // Charger la taxonomy pour les ic√¥nes
		            this._loadTaxonomy();

		            // Initialiser toutes les couches du profil
		            this._initializeAllLayers();

		            if (Log) Log.info("[Legend] Module Legend initialis√© avec g√©n√©ration automatique depuis styles");
		            return true;
		        },

		        /**
		         * Charge la taxonomy pour la correspondance cat√©gories ‚Üí ic√¥nes
		         * @private
		         */
		        _loadTaxonomy: function () {
		            if (!_profileConfig) return;

		            const Config = GeoLeaf.Config;
		            const dataCfg = Config && Config.get ? Config.get('data') : null;
		            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
		            const profileId = _profileConfig.id;

		            if (!profileId) {
		                if (Log) Log.warn("[Legend] Impossible de charger taxonomy sans profileId");
		                return;
		            }

		            const taxonomyPath = `${profilesBasePath}/${profileId}/taxonomy.json`;

		            fetch(taxonomyPath)
		                .then(response => {
		                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
		                    return response.json();
		                })
		                .then(data => {
		                    _taxonomyData = data;
		                    if (Log) Log.debug("[Legend] Taxonomy charg√©e");
		                })
		                .catch(err => {
		                    if (Log) Log.warn(`[Legend] Erreur chargement taxonomy: ${err.message}`);
		                });
		        },

		        /**
		         * Initialise toutes les couches d√©finies dans le profil
		         * @private
		         */
		        _initializeAllLayers: function () {
		            if (!_profileConfig || !Array.isArray(_profileConfig.layers)) {
		                if (Log) Log.warn("[Legend] Aucune couche d√©finie dans le profil");
		                return;
		            }

		            _profileConfig.layers.forEach((layerDef, index) => {
		                _allLayers.set(layerDef.id, {
		                    label: layerDef.id, // Sera mis √† jour lors du chargement du config
		                    styleId: null,
		                    legendData: null,
		                    visible: false,
		                    order: index + 1,
		                    geometryType: null,
		                    configFile: layerDef.configFile
		                });
		            });

		            if (Log) Log.debug(`[Legend] ${_allLayers.size} couche(s) initialis√©e(s)`);
		        },

		        /**
		         * Charge et g√©n√®re la l√©gende pour une couche
		         * @param {string} layerId - ID de la couche
		         * @param {string} styleId - ID du style √† appliquer
		         * @param {Object} layerConfig - Configuration de la couche
		         */
		        loadLayerLegend: function (layerId, styleId, layerConfig) {
		            if (!_map) {
		                if (Log) Log.warn("[Legend] Module non initialis√©");
		                return;
		            }

		            const layerInfo = _allLayers.get(layerId);
		            if (!layerInfo) {
		                if (Log) Log.warn(`[Legend] Couche ${layerId} non trouv√©e dans le profil`);
		                return;
		            }

		            // S'assurer que le sprite SVG est disponible d√®s le d√©but
		            if (GeoLeaf._POIMarkers && typeof GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync === "function") {
		                GeoLeaf._POIMarkers.ensureProfileSpriteInjectedSync();
		                if (Log) Log.debug(`[Legend] Sprite SVG demand√© pour couche ${layerId}`);
		            }

		            // Mettre √† jour les informations de la couche
		            layerInfo.label = layerConfig.label || layerId;
		            layerInfo.geometryType = _normalizeGeometryType(layerConfig.geometryType || layerConfig.geometry || layerInfo.geometryType || "point");
		            layerInfo.styleId = styleId;

		            // Charger le fichier de style
		            const Config = GeoLeaf.Config;
		            const dataCfg = Config && Config.get ? Config.get('data') : null;
		            const profilesBasePath = (dataCfg && dataCfg.profilesBasePath) || "profiles";
		            const profileId = layerConfig._profileId || _profileConfig.id;
		            const layerDir = layerConfig._layerDirectory;

		            if (!layerConfig.styles || !layerConfig.styles.directory) {
		                if (Log) Log.warn(`[Legend] Configuration styles manquante pour ${layerId}`);
		                return;
		            }

		            const stylesDir = layerConfig.styles.directory;
		            const styleFile = layerConfig.styles.available?.find(s => s.id === styleId)?.file
		                            || layerConfig.styles.default;

		            const stylePath = `${profilesBasePath}/${profileId}/${layerDir}/${stylesDir}/${styleFile}`;

		            if (Log) Log.debug(`[Legend] Chargement style: ${stylePath}`);

		            fetch(stylePath)
		                .then(response => {
		                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
		                    return response.json();
		                })
		                .then(styleData => {
		                    // G√©n√©rer la l√©gende depuis le style
		                    if (!GeoLeaf._LegendGenerator) {
		                        if (Log) Log.error("[Legend] LegendGenerator non disponible");
		                        return;
		                    }

		                    // Temporairement stocker la config de couche pour le g√©n√©rateur (comme dans markers.js)
		                    const originalPOIShared = GeoLeaf._POIShared;
		                    if (layerConfig.showIconsOnMap !== undefined) {
		                        // Cr√©er un √©tat temporaire pour cette couche
		                        GeoLeaf._POIShared = {
		                            state: {
		                                poiConfig: {
		                                    showIconsOnMap: layerConfig.showIconsOnMap
		                                }
		                            }
		                        };
		                    }

		                    const legendData = GeoLeaf._LegendGenerator.generateLegendFromStyle(
		                        styleData,
		                        layerInfo.geometryType,
		                        _taxonomyData
		                    );

		                    // Restaurer l'√©tat POI original
		                    if (layerConfig.showIconsOnMap !== undefined) {
		                        GeoLeaf._POIShared = originalPOIShared;
		                    }

		                    if (legendData) {
		                        layerInfo.legendData = legendData;
		                        _allLayers.set(layerId, layerInfo);
		                        if (Log) Log.debug(`[Legend] L√©gende g√©n√©r√©e pour ${layerId}`);

		                        // Reconstruire l'affichage
		                        _scheduleRebuild();
		                    }
		                })
		                .catch(err => {
		                    if (Log) Log.warn(`[Legend] Erreur chargement style: ${err.message}`);
		                });
		        },

		        /**
		         * Met √† jour la visibilit√© d'une couche dans la l√©gende
		         * @param {string} layerId - ID de la couche
		         * @param {boolean} visible - Visible ou non
		         */
		        setLayerVisibility: function (layerId, visible) {
		            const layerInfo = _allLayers.get(layerId);
		            if (layerInfo) {
		                layerInfo.visible = visible;
		                _allLayers.set(layerId, layerInfo);
		                _scheduleRebuild();
		                if (Log) Log.debug(`[Legend] Visibilit√© de ${layerId}: ${visible}`);
		            }
		        },

		        /**
		         * Reconstruit l'affichage de toutes les l√©gendes
		         * @private
		         */
		        _rebuildDisplay: function () {
		            if (!_map) return;

		            // Si aucune couche, supprimer le contr√¥le
		            if (_allLayers.size === 0) {
		                if (_control && _map) {
		                    _map.removeControl(_control);
		                    _control = null;
		                }
		                return;
		            }

		            // Cr√©er le contr√¥le si n√©cessaire
		            if (!_control) {
		                _control = GeoLeaf._LegendControl.create(_options);
		                if (_control) {
		                    _map.addControl(_control);
		                }
		            }

		            // Pr√©parer les donn√©es pour le rendu (afficher toutes les couches)
		            if (_control && typeof _control.updateMultiLayerContent === "function") {
		                const visibilityManager = GeoLeaf._LayerVisibilityManager;
		                const legendsArray = [];

		                _allLayers.forEach((data, layerId) => {
		                    if (!data.legendData) return;

		                    const visState = visibilityManager && typeof visibilityManager.getVisibilityState === "function"
		                        ? visibilityManager.getVisibilityState(layerId)
		                        : null;

		                    const isVisible = visState ? visState.current : data.visible;
		                    if (!isVisible) return;

		                    legendsArray.push({
		                        layerId: layerId,
		                        label: data.label,
		                        collapsed: true,
		                        order: data.order,
		                        visible: true,
		                        sections: data.legendData.sections || []
		                    });
		                });

		                // Trier par ordre
		                legendsArray.sort((a, b) => a.order - b.order);

		                _control.updateMultiLayerContent(legendsArray);

		                // Si nous avons des ic√¥nes mais pas de sprite, programmer un retry
		                const hasIcons = legendsArray.some(legend =>
		                    legend.sections.some(section =>
		                        section.items && section.items.some(item => item.icon)
		                    )
		                );

		                if (hasIcons) {
		                    const sprite = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		                    if (!sprite) {
		                        if (Log) Log.info("[Legend] Ic√¥nes d√©tect√©es mais sprite manquant - programmation retry");
		                        // Programmer un nouveau rendu dans 2 secondes
		                        setTimeout(() => {
		                            const spriteCheck = document.querySelector('svg[data-geoleaf-sprite="profile"]');
		                            if (spriteCheck && Log) {
		                                Log.info("[Legend] Sprite disponible - nouveau rendu de la l√©gende");
		                                this._rebuildDisplay();
		                            }
		                        }, 2000);
		                    }
		                }
		            }
		        },

		        /**
		         * Bascule l'√©tat d'un accord√©on
		         * @param {string} layerId - ID de la couche
		         */
		        toggleAccordion: function (layerId) {
		            // G√©r√© visuellement par le renderer
		        },

		        /**
		         * R√©cup√®re toutes les couches
		         * @returns {Map}
		         */
		        getAllLayers: function () {
		            return _allLayers;
		        },

		        // ===== Anciennes m√©thodes pour compatibilit√© =====

		        /**
		         * @deprecated Utiliser loadLayerLegend √† la place
		         */
		        addLayerLegend: function (layerId, styleId, legendData) {
		            if (Log) Log.warn("[Legend] addLayerLegend() est d√©pr√©ci√© avec donn√©es JSON, utiliser loadLayerLegend avec style");
		            // Ajouter quand m√™me pour compatibilit√©
		            const layerInfo = _allLayers.get(layerId);
		            if (layerInfo) {
		                layerInfo.legendData = legendData;
		                layerInfo.styleId = styleId;
		                _allLayers.set(layerId, layerInfo);
		                this._rebuildDisplay();
		            }
		        },

		        /**
		         * @deprecated Utiliser setLayerVisibility √† la place
		         */
		        removeLayerLegend: function (layerId) {
		            if (Log) Log.warn("[Legend] removeLayerLegend() est d√©pr√©ci√©, utiliser setLayerVisibility(id, false)");
		            this.setLayerVisibility(layerId, false);
		        },

		        /**
		         * @deprecated Utiliser loadLayerLegend √† la place
		         */
		        updateLayerLegend: function (layerId, styleId, legendData) {
		            if (Log) Log.warn("[Legend] updateLayerLegend() avec JSON est d√©pr√©ci√©, utiliser loadLayerLegend");
		            this.addLayerLegend(layerId, styleId, legendData);
		        },

		        /**
		         * @deprecated
		         */
		        loadLegend: function (legendFilePath) {
		            if (Log) Log.warn("[Legend] loadLegend() est d√©pr√©ci√©");
		            return Promise.resolve(false);
		        },

		        /**
		         * @deprecated
		         */
		        showLegend: function (legendData) {
		            if (Log) Log.warn("[Legend] showLegend() est d√©pr√©ci√©");
		        },

		        /**
		         * Cache la l√©gende
		         */
		        hideLegend: function () {
		            if (_control) {
		                _control.hide();
		            }
		        },

		        /**
		         * Supprime toutes les l√©gendes
		         */
		        removeLegend: function () {
		            _allLayers.forEach((layerInfo, layerId) => {
		                layerInfo.legendData = null;
		                layerInfo.visible = false;
		            });

		            if (_control && _map) {
		                _map.removeControl(_control);
		                _control = null;
		                if (Log) Log.debug("[Legend] Toutes les l√©gendes supprim√©es");
		            }
		        },

		        /**
		         * V√©rifie si des l√©gendes sont affich√©es
		         * @returns {boolean}
		         */
		        isLegendVisible: function () {
		            return _control !== null && _allLayers.size > 0;
		        },

		        showLoadingOverlay: function () {
		            _showLoadingOverlay();
		        },

		        hideLoadingOverlay: function () {
		            _hideLoadingOverlay();
		        }
		    };

		    // Exposer le module public
		    GeoLeaf.Legend = LegendModule;

		})(window);
		return geoleaf_legend;
	}

	requireGeoleaf_legend();

	var labelRenderer = {};

	/**
	 * Module Label Renderer pour GeoLeaf
	 * Cr√©e et g√®re les tooltips permanents Leaflet pour les √©tiquettes
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.Tooltip, L.LatLng)
	 * - GeoLeaf.Log (optionnel)
	 *
	 * EXPOSE:
	 * - GeoLeaf._LabelRenderer
	 */

	var hasRequiredLabelRenderer;

	function requireLabelRenderer () {
		if (hasRequiredLabelRenderer) return labelRenderer;
		hasRequiredLabelRenderer = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Module Label Renderer
		     * @namespace _LabelRenderer
		     * @private
		     */
		    const _LabelRenderer = {
		        /**
		         * Cr√©e les tooltips permanents pour toutes les features d'une couche
		         * @param {string} layerId - ID de la couche
		         * @param {L.LayerGroup} leafletLayer - Couche Leaflet (LayerGroup ou FeatureGroup)
		         * @param {Object} labelConfig - Configuration des labels
		         * @param {Object} style - Style des labels (extrait de currentStyle.label)
		         * @param {Map} tooltipsMap - Map pour stocker les tooltips cr√©√©s
		         */
		        createTooltipsForLayer(layerId, leafletLayer, labelConfig, style, tooltipsMap) {
		            if (!leafletLayer || !labelConfig || !labelConfig.labelId) {
		                if (Log) Log.warn("[LabelRenderer] Param√®tres invalides pour createTooltipsForLayer", {
		                    layerId,
		                    hasLeafletLayer: !!leafletLayer,
		                    hasLabelConfig: !!labelConfig,
		                    labelId: labelConfig?.labelId,
		                    labelConfigKeys: labelConfig ? Object.keys(labelConfig) : null
		                });
		                return;
		            }

		            const labelField = labelConfig.labelId;

		            if (Log) Log.debug(`[LabelRenderer] Cr√©ation tooltips pour ${layerId}, champ: ${labelField}`);

		            // Parcourir toutes les features de la couche
		            let featureCount = 0;

		            leafletLayer.eachLayer((featureLayer) => {
		                featureCount++;
		                try {
		                    this._createTooltipForFeature(
		                        featureLayer,
		                        labelField,
		                        style,
		                        tooltipsMap
		                    );
		                } catch (err) {
		                    if (Log) Log.warn("[LabelRenderer] Erreur cr√©ation tooltip:", err);
		                }
		            });

		            if (Log) Log.debug(`[LabelRenderer] ${tooltipsMap.size} tooltips cr√©√©s pour ${layerId} (${featureCount} features parcourues)`);
		        },

		        /**
		         * Cr√©e un marker texte (label) pour une feature
		         * @private
		         * @param {L.Layer} featureLayer - Layer Leaflet de la feature
		         * @param {string} labelField - Nom du champ √† afficher
		         * @param {Object} style - Style du label
		         * @param {Map} tooltipsMap - Map pour stocker le marker
		         */
		        _createTooltipForFeature(featureLayer, labelField, style, tooltipsMap) {
		            // R√©cup√©rer les donn√©es GeoJSON de la feature
		            const feature = featureLayer.feature;
		            if (!feature || !feature.properties) {
		                if (Log) Log.debug("[LabelRenderer] Feature ou properties manquant");
		                return;
		            }

		            // Extraire la valeur du champ label
		            const labelValue = this._extractFieldValue(feature.properties, labelField);
		            if (!labelValue) {
		                return;
		            }

		            // R√©cup√©rer la position (centre de la g√©om√©trie)
		            let position = null;

		            if (typeof featureLayer.getLatLng === "function") {
		                // Pour les points
		                position = featureLayer.getLatLng();
		            } else if (typeof featureLayer.getBounds === "function") {
		                // Pour les polygones (Polygon, MultiPolygon) - centre du bounding box
		                // IMPORTANT: V√©rifier getBounds AVANT getLatLngs car les polygones ont les deux!
		                const bounds = featureLayer.getBounds();
		                if (bounds && typeof bounds.getCenter === "function") {
		                    position = bounds.getCenter();
		                    if (Log) Log.info("[LabelRenderer] Position polygone calcul√©e:", {
		                        labelValue,
		                        position: position,
		                        positionType: typeof position,
		                        hasLat: 'lat' in position,
		                        hasLng: 'lng' in position,
		                        latType: typeof position.lat,
		                        lngType: typeof position.lng,
		                        positionKeys: Object.keys(position)
		                    });
		                } else {
		                    if (Log) Log.warn("[LabelRenderer] getBounds ne retourne pas getCenter pour:", labelValue);
		                }
		            } else if (typeof featureLayer.getLatLngs === "function") {
		                // Pour les lignes - prendre le point du milieu de la ligne
		                const latlngs = featureLayer.getLatLngs();
		                if (latlngs && latlngs.length > 0) {
		                    // Si c'est un MultiLineString ou une ligne complexe
		                    const flatLatlngs = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
		                    if (flatLatlngs && flatLatlngs.length > 0) {
		                        const middleIndex = Math.floor(flatLatlngs.length / 2);
		                        position = flatLatlngs[middleIndex];
		                    }
		                }
		            }

		            // V√©rifier que position est valide
		            // Note: Leaflet LatLng peut avoir lat/lng comme propri√©t√©s OU comme m√©thodes
		            if (!position) {
		                if (Log) Log.debug("[LabelRenderer] Position null pour feature, skipping label. Label:", labelValue);
		                return;
		            }

		            const lat = typeof position.lat === 'function' ? position.lat() : position.lat;
		            const lng = typeof position.lng === 'function' ? position.lng() : position.lng;

		            if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
		                return;
		            }

		            // Cr√©er un divIcon avec le texte du label
		            const htmlContent = this._formatLabelContent(labelValue, style);

		            const labelIcon = global.L.divIcon({
		                html: htmlContent,
		                className: this._buildClassName(style),
		                iconSize: null, // Auto-size
		                iconAnchor: [0, 0] // Position relative au point
		            });

		            // Cr√©er un marker avec cet ic√¥ne texte
		            const labelMarker = global.L.marker([lat, lng], {
		                icon: labelIcon,
		                interactive: false, // Ne pas intercepter les clics
		                keyboard: false
		            });

		            // Ajouter au map
		            const map = GeoLeaf.Core && GeoLeaf.Core.getMap ? GeoLeaf.Core.getMap() : null;
		            if (map) {
		                labelMarker.addTo(map);

		                // Stocker dans la map
		                const featureId = feature.id || feature.properties.id || `feature_${Date.now()}_${Math.random()}`;
		                tooltipsMap.set(featureId, labelMarker);
		            } else {
		                if (Log) Log.warn("[LabelRenderer] Carte non disponible pour", labelValue);
		            }
		        },

		        /**
		         * Extrait la valeur d'un champ depuis les propri√©t√©s
		         * Supporte la notation point√©e (ex: "attributes.name")
		         * @private
		         */
		        _extractFieldValue(properties, fieldPath) {
		            if (!properties || !fieldPath) return null;

		            // Si pas de point, acc√®s direct
		            if (!fieldPath.includes(".")) {
		                return properties[fieldPath];
		            }

		            // Notation point√©e
		            const parts = fieldPath.split(".");
		            let value = properties;

		            for (const part of parts) {
		                if (value && typeof value === "object" && part in value) {
		                    value = value[part];
		                } else {
		                    return null;
		                }
		            }

		            return value;
		        },

		        /**
		         * Parse l'offset depuis le style
		         * @private
		         */
		        _parseOffset(offset) {
		            if (!offset) return [0, 0];

		            if (Array.isArray(offset) && offset.length === 2) {
		                return [
		                    typeof offset[0] === "number" ? offset[0] : 0,
		                    typeof offset[1] === "number" ? offset[1] : 0
		                ];
		            }

		            return [0, 0];
		        },

		        /**
		         * Construit le nom de classe CSS pour le tooltip
		         * @private
		         */
		        _buildClassName(style) {
		            const classes = ["gl-label"];

		            if (style) {
		                if (style.className) {
		                    classes.push(style.className);
		                }

		                // Ajouter des classes bas√©es sur les propri√©t√©s de style
		                if (style.variant) {
		                    classes.push(`gl-label--${style.variant}`);
		                }
		            }

		            return classes.join(" ");
		        },

		        /**
		         * Formate le contenu du label
		         * @private
		         */
		        _formatLabelContent(value, style) {
		            if (!value) return "";

		            let content = String(value);

		            // Appliquer un pr√©fixe/suffixe si d√©fini
		            if (style) {
		                if (style.prefix) {
		                    content = style.prefix + content;
		                }
		                if (style.suffix) {
		                    content = content + style.suffix;
		                }
		            }

		            // Cr√©er le HTML du label
		            const div = global.document.createElement("div");
		            div.className = "gl-label__content";
		            div.textContent = content;

		            // Appliquer les styles inline si d√©finis
		            if (style) {
		                this._applyInlineStyles(div, style);
		            }

		            // Retourner le HTML string, pas l'√©l√©ment DOM
		            return div.outerHTML;
		        },

		        /**
		         * Applique les styles inline au contenu du label
		         * @private
		         */
		        _applyInlineStyles(element, style) {
		            if (!element || !style) return;

		            // Appliquer les styles de police et couleur avec setProperty + important pour forcer la priorit√© sur le CSS
		            if (style.font) {
		                if (style.font.family) {
		                    // Ajouter un fallback pour assurer la lisibilit√© si la police demand√©e n'est pas disponible
		                    const fontFamily = `"${style.font.family}", -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif`;
		                    element.style.setProperty('font-family', fontFamily, 'important');
		                }
		                if (style.font.sizePt) {
		                    element.style.setProperty('font-size', `${style.font.sizePt}pt`, 'important');
		                }
		                if (style.font.bold) {
		                    element.style.setProperty('font-weight', 'bold', 'important');
		                } else if (style.font.weight) {
		                    // Pour am√©liorer la lisibilit√©, forcer un poids minimum de 500 si < 400
		                    const weight = style.font.weight < 400 ? 500 : style.font.weight;
		                    element.style.setProperty('font-weight', weight, 'important');
		                }
		                if (style.font.italic) {
		                    element.style.setProperty('font-style', 'italic', 'important');
		                }
		            }

		            // Appliquer la couleur du texte avec !important
		            if (style.color) {
		                element.style.setProperty('color', style.color, 'important');
		            }

		            // Appliquer l'opacit√© du texte
		            if (style.opacity !== undefined) {
		                element.style.setProperty('opacity', style.opacity, 'important');
		            }

		            // Appliquer le buffer (text-shadow pour contour) avec !important
		            if (style.buffer && style.buffer.enabled) {
		                const bufferColor = style.buffer.color || '#ffffff';
		                const bufferOpacity = style.buffer.opacity !== undefined ? style.buffer.opacity : 1;
		                const bufferSize = style.buffer.sizePx || 2;

		                // Convertir la couleur hex + opacit√© en rgba
		                const rgba = this._hexToRgba(bufferColor, bufferOpacity);

		                // Cr√©er un text-shadow multi-couches pour un contour plus net et visible
		                const shadowParts = [];

		                // Couche 1: Contour net avec de nombreux angles pour une couverture compl√®te
		                for (let angle = 0; angle < 360; angle += 30) {
		                    const rad = angle * Math.PI / 180;
		                    const x = Math.cos(rad) * bufferSize;
		                    const y = Math.sin(rad) * bufferSize;
		                    shadowParts.push(`${x.toFixed(2)}px ${y.toFixed(2)}px 0 ${rgba}`);
		                }

		                // Couche 2: Contour interm√©diaire pour plus de densit√© (meilleure couverture)
		                for (let angle = 15; angle < 360; angle += 30) {
		                    const rad = angle * Math.PI / 180;
		                    const x = Math.cos(rad) * bufferSize * 0.7;
		                    const y = Math.sin(rad) * bufferSize * 0.7;
		                    shadowParts.push(`${x.toFixed(2)}px ${y.toFixed(2)}px 0 ${rgba}`);
		                }

		                // Couche 3: Effet glow plus prononc√© pour renforcer le contraste
		                shadowParts.push(`0 0 ${bufferSize * 0.8}px ${rgba}`);
		                shadowParts.push(`0 0 ${bufferSize * 1.5}px ${rgba}`);

		                element.style.setProperty('text-shadow', shadowParts.join(', '), 'important');
		            }

		            // Appliquer textTransform
		            if (style.textTransform) {
		                element.style.setProperty('text-transform', style.textTransform, 'important');
		            }
		        },

		        /**
		         * Convertit une couleur hex en rgba
		         * @private
		         */
		        _hexToRgba(hex, opacity) {
		            if (!hex) return `rgba(0, 0, 0, ${opacity})`;

		            // Enlever le # si pr√©sent
		            hex = hex.replace('#', '');

		            // G√©rer les formats courts (#RGB) et longs (#RRGGBB)
		            if (hex.length === 3) {
		                hex = hex.split('').map(c => c + c).join('');
		            }

		            const r = parseInt(hex.substring(0, 2), 16);
		            const g = parseInt(hex.substring(2, 4), 16);
		            const b = parseInt(hex.substring(4, 6), 16);

		            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LabelRenderer = _LabelRenderer;

		})(window);
		return labelRenderer;
	}

	requireLabelRenderer();

	var labelButtonManager = {};

	/**
	 * Gestionnaire centralis√© pour le bouton de label dans le Layer Manager
	 *
	 * RESPONSABILIT√âS:
	 * - Cr√©er le bouton de label lors du premier render d'une couche
	 * - Synchroniser l'√©tat du bouton (activ√©/d√©sactiv√©, actif/inactif)
	 * - Source unique de v√©rit√© pour la logique de d√©cision
	 *
	 * LOGIQUE SIMPLIFI√âE:
	 * - Le bouton est TOUJOURS visible pour toutes les couches
	 * - Si couche visible ET label.enabled: true ‚Üí bouton cliquable
	 * - Sinon ‚Üí bouton d√©sactiv√© (gris√©)
	 * - √âtat actif/inactif selon si les labels sont actuellement affich√©s
	 */

	var hasRequiredLabelButtonManager;

	function requireLabelButtonManager () {
		if (hasRequiredLabelButtonManager) return labelButtonManager;
		hasRequiredLabelButtonManager = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Gestionnaire de boutons de label
		     */
		    const LabelButtonManager = {
		        /**
		         * Cr√©e le bouton de label pour une couche
		         * Appel√© uniquement lors du premier render du layer manager
		         * @param {string} layerId - ID de la couche
		         * @param {HTMLElement} controlsContainer - Conteneur des contr√¥les
		         * @returns {HTMLElement|null} Le bouton cr√©√© ou null si √©chec
		         */
		        createButton(layerId, controlsContainer) {
		            if (!layerId || !controlsContainer) {
		                if (Log) Log.warn("[LabelButtonManager] createButton: param√®tres manquants", {layerId, hasContainer: !!controlsContainer});
		                return null;
		            }

		            // V√©rifier si le bouton existe d√©j√†
		            const existingButton = controlsContainer.querySelector('.gl-layer-manager__label-toggle');
		            if (existingButton) {
		                if (Log) Log.debug("[LabelButtonManager] Bouton d√©j√† existant pour:", layerId);
		                return existingButton;
		            }

		            if (Log) Log.debug("[LabelButtonManager] Cr√©ation du bouton pour:", layerId);

		            // Cr√©er le bouton (toujours visible, sera activ√©/d√©sactiv√© selon label.enabled)
		            const labelToggle = global.L.DomUtil.create("button", "gl-layer-manager__label-toggle");
		            labelToggle.type = "button";
		            labelToggle.setAttribute("aria-label", "Afficher/masquer les √©tiquettes");
		            // D√©sactiv√© par d√©faut jusqu'√† la synchronisation
		            labelToggle.disabled = true;
		            labelToggle.classList.add("gl-layer-manager__label-toggle--disabled");

		            const iconSpan = document.createElement("span");
		            iconSpan.className = "gl-layer-manager__label-toggle-icon";
		            iconSpan.textContent = "üè∑Ô∏è";
		            labelToggle.appendChild(iconSpan);
		            labelToggle.title = "Afficher/masquer les √©tiquettes";

		            // Gestionnaire de clic
		            const onLabelToggle = function (ev) {
		                if (global.L && global.L.DomEvent) global.L.DomEvent.stopPropagation(ev);
		                ev.preventDefault();

		                if (labelToggle.disabled) return;

		                try {
		                    // V√©rifier que le style actuel autorise les labels
		                    const layerData = global.GeoLeaf?.GeoJSON?.getLayerById?.(layerId);
		                    const labelEnabled = layerData?.currentStyle?.label?.enabled === true;

		                    if (!labelEnabled) {
		                        if (Log) Log.warn("[LabelButtonManager] Impossible d'afficher les labels: le style actuel a label.enabled=false");
		                        return;
		                    }

		                    // Toggle les labels
		                    if (global.GeoLeaf?.Labels?.toggleLabels) {
		                        const newState = global.GeoLeaf.Labels.toggleLabels(layerId);

		                        // Mettre √† jour l'√©tat visuel du bouton IMM√âDIATEMENT
		                        if (newState) {
		                            labelToggle.classList.add("gl-layer-manager__label-toggle--on");
		                            labelToggle.setAttribute("aria-pressed", "true");
		                        } else {
		                            labelToggle.classList.remove("gl-layer-manager__label-toggle--on");
		                            labelToggle.setAttribute("aria-pressed", "false");
		                        }
		                    }
		                } catch (err) {
		                    if (Log) Log.warn("[LabelButtonManager] Erreur lors du toggle des labels:", err);
		                }
		            };

		            // Attacher le gestionnaire
		            if (GeoLeaf._UIComponents && typeof GeoLeaf._UIComponents.attachEventHandler === 'function') {
		                GeoLeaf._UIComponents.attachEventHandler(labelToggle, "click", onLabelToggle);
		            } else if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(labelToggle, "click", onLabelToggle);
		                global.L.DomEvent.disableClickPropagation(labelToggle);
		            } else {
		                labelToggle.addEventListener("click", onLabelToggle);
		            }

		            // Ins√©rer le bouton avant le toggle de visibilit√©
		            const visibilityToggle = controlsContainer.querySelector('.gl-layer-manager__item-toggle');
		            if (visibilityToggle) {
		                controlsContainer.insertBefore(labelToggle, visibilityToggle);
		            } else {
		                controlsContainer.appendChild(labelToggle);
		            }

		            if (Log) Log.debug("[LabelButtonManager] Bouton cr√©√© avec succ√®s:", layerId);

		            return labelToggle;
		        },

		        /**
		         * Synchronise l'√©tat du bouton de label
		         * UNIQUE POINT D'ENTR√âE pour mettre √† jour le bouton
		         * @param {string} layerId - ID de la couche
		         */
		        sync(layerId) {
		            if (!layerId) return;

		            // D√©bounce pour √©viter les mises √† jour trop fr√©quentes
		            if (this._syncTimeouts && this._syncTimeouts.has(layerId)) {
		                clearTimeout(this._syncTimeouts.get(layerId));
		            }

		            if (!this._syncTimeouts) {
		                this._syncTimeouts = new Map();
		            }

		            const timeout = setTimeout(() => {
		                this._syncTimeouts.delete(layerId);
		                this._doSync(layerId);
		            }, 300);

		            this._syncTimeouts.set(layerId, timeout);
		        },

		        /**
		         * Ex√©cute la synchronisation imm√©diate (m√©thode interne)
		         * @private
		         */
		        _doSync(layerId) {
		            if (!layerId) return;

		            // Trouver le bouton - chercher directement dans tout le document
		            // car le Layer Manager peut recr√©er des √©l√©ments
		            let button = document.querySelector(`[data-layer-id="${layerId}"] .gl-layer-manager__label-toggle`);

		            if (!button) {
		                // Fallback: chercher le layerItem et cr√©er le bouton si n√©cessaire
		                const layerItem = document.querySelector(`[data-layer-id="${layerId}"]`);
		                if (!layerItem) {
		                    if (Log) Log.debug("[LabelButtonManager] LayerItem non trouv√© (pas encore rendu):", layerId);
		                    return;
		                }

		                const controlsContainer = layerItem.querySelector('.gl-layer-manager__item-controls');
		                if (controlsContainer) {
		                    // V√©rifier si le bouton existe d√©j√† dans controls
		                    button = controlsContainer.querySelector('.gl-layer-manager__label-toggle');
		                    if (!button) {
		                        if (Log) Log.debug("[LabelButtonManager] Bouton manquant dans controls, cr√©ation √† la vol√©e pour:", layerId);
		                        button = this.createButton(layerId, controlsContainer);
		                    }
		                } else {
		                    if (Log) Log.debug("[LabelButtonManager] Bouton et controlsContainer non trouv√©s pour:", layerId);
		                    return;
		                }
		            }

		            if (!button) {
		                if (Log) Log.debug("[LabelButtonManager] Bouton non trouv√© apr√®s toutes tentatives:", layerId);
		                return;
		            }

		            // Collecter l'√©tat actuel
		            const state = this._getState(layerId);

		            // Appliquer la logique de d√©cision
		            this._applyState(button, state);
		        },

		        /**
		         * Collecte l'√©tat actuel de tous les composants
		         * @private
		         */
		        _getState(layerId) {
		            const layerData = global.GeoLeaf?.GeoJSON?.getLayerById?.(layerId);

		            const state = {
		                layerId: layerId,
		                layerExists: !!layerData,
		                layerVisible: layerData?._visibility?.current === true,
		                labelEnabled: layerData?.currentStyle?.label?.enabled === true,
		                areLabelsActive: global.GeoLeaf?.Labels?.areLabelsEnabled?.(layerId) || false
		            };

		            return state;
		        },

		        /**
		         * Applique l'√©tat au bouton selon la logique simplifi√©e
		         * R√àGLES:
		         * - Bouton TOUJOURS visible
		         * - Si label.enabled: true ET couche visible ‚Üí bouton activ√©
		         * - Sinon ‚Üí bouton d√©sactiv√© (gris√©)
		         * - √âtat actif/inactif selon si les labels sont affich√©s
		         * @private
		         */
		        _applyState(button, state) {
		            // Bouton cliquable uniquement si la couche est visible et que le style autorise les labels
		            const canUseLabels = state.labelEnabled && state.layerVisible;

		            if (canUseLabels) {
		                // Activer le bouton
		                button.disabled = false;
		                button.classList.remove("gl-layer-manager__label-toggle--disabled");

		                // Appliquer l'√©tat actif/inactif
		                const shouldAppearOn = state.areLabelsActive && state.layerVisible;

		                if (shouldAppearOn) {
		                    button.classList.add("gl-layer-manager__label-toggle--on");
		                    button.setAttribute("aria-pressed", "true");
		                } else {
		                    button.classList.remove("gl-layer-manager__label-toggle--on");
		                    button.setAttribute("aria-pressed", "false");
		                }
		            } else {
		                // D√©sactiver le bouton
		                button.disabled = true;
		                button.classList.add("gl-layer-manager__label-toggle--disabled");
		                button.classList.remove("gl-layer-manager__label-toggle--on");
		                button.setAttribute("aria-pressed", "false");
		            }
		        },

		        /**
		         * Synchronise imm√©diatement sans debouncing
		         * Utilis√© pour les cas o√π une r√©ponse imm√©diate est n√©cessaire
		         * @param {string} layerId - ID de la couche
		         */
		        syncImmediate(layerId) {
		            if (!layerId) return;

		            // Annuler tout debounce en cours
		            if (this._syncTimeouts && this._syncTimeouts.has(layerId)) {
		                clearTimeout(this._syncTimeouts.get(layerId));
		                this._syncTimeouts.delete(layerId);
		            }

		            // Ex√©cuter imm√©diatement
		            this._doSync(layerId);
		        }
		    };

		    // Exposer dans l'espace de noms interne
		    GeoLeaf._LabelButtonManager = LabelButtonManager;

		    if (Log) Log.debug("[LabelButtonManager] Module initialis√©");

		})(window);
		return labelButtonManager;
	}

	requireLabelButtonManager();

	var labels = {};

	/**
	 * Module Labels pour GeoLeaf
	 * Gestion des √©tiquettes flottantes sur les entit√©s
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.Tooltip, L.DomUtil)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf.GeoJSON (pour acc√©der aux layers)
	 * - labels/label-renderer.js (pour le rendu des tooltips)
	 * - loaders/style-loader.js (pour extraire les labels depuis les styles)
	 *
	 * EXPOSE:
	 * - GeoLeaf.Labels
	 *
	 * MIGRATION V3:
	 * - Les labels sont maintenant int√©gr√©s dans les fichiers style.json
	 * - Plus de fichiers styleLabel.json s√©par√©s
	 * - Les labels sont extraits depuis layerData.currentStyle.label
	 */

	var hasRequiredLabels;

	function requireLabels () {
		if (hasRequiredLabels) return labels;
		hasRequiredLabels = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;
		    const ScaleUtils = GeoLeaf.Utils && GeoLeaf.Utils.ScaleUtils;

		    /**
		     * √âtat interne du module Labels
		     * @private
		     */
		    const _state = {
		        // Map: layerId -> { enabled, config, tooltips }
		        layers: new Map(),
		        // Flag pour savoir si l'√©couteur de zoom est attach√©
		        zoomListenerAttached: false
		    };

		    /**
		     * Module Labels
		     * @namespace Labels
		     */
		    const Labels = {
		        /**
		         * Initialise le syst√®me de labels
		         * @param {Object} options - Options d'initialisation
		         */
		        init(options = {}) {
		            if (Log) Log.debug("[Labels] Initialisation du module Labels");

		            // √âcouter les √©v√©nements de chargement de couches
		            this._attachLayerEvents();

		            if (Log) Log.debug("[Labels] Module Labels initialis√©");
		        },

		        /**
		         * Initialise les labels pour une couche au chargement
		         * Charge les labels UNIQUEMENT si:
		         * - Le style contient label.enabled === true
		         * - label.visibleByDefault === true
		         * - La couche est visible
		         *
		         * POINT D'ENTR√âE UNIQUE pour l'initialisation au chargement
		         * @param {string} layerId - ID de la couche
		         */
		        initializeLayerLabels(layerId) {
		            if (!layerId) return;

		            const layerData = this._getLayerData(layerId);
		            if (!layerData) return;

		            // D'ABORD masquer les labels existants pour r√©initialiser lors du changement de style
		            this._hideLabelsForLayer(layerId);

		            // R√©initialiser l'√©tat interne des labels pour cette couche
		            _state.layers.delete(layerId);

		            // V√©rifier si le style a des labels activ√©s
		            if (layerData.currentStyle?.label?.enabled !== true) {
		                if (Log) Log.debug("[Labels.initialize] Style sans labels ou labels d√©sactiv√©s pour", layerId);
		                return;
		            }

		            // V√©rifier visibleByDefault
		            const visibleByDefault = layerData.currentStyle.label.visibleByDefault === true;

		            if (!visibleByDefault) {
		                if (Log) Log.debug("[Labels.initialize] Labels d√©sactiv√©s par d√©faut pour", layerId);
		                // Toujours initialiser la config, mais sans les afficher
		                return this.enableLabels(layerId, {}, false);
		            }

		            // Afficher les labels uniquement si couche visible ET visibleByDefault = true
		            const isLayerVisible = layerData._visibility?.current === true;
		            if (!isLayerVisible) {
		                if (Log) Log.debug("[Labels.initialize] Labels configur√©s mais couche invisible pour", layerId);
		                // Initialiser la config sans afficher
		                return this.enableLabels(layerId, {}, false);
		            }

		            if (Log) Log.debug("[Labels.initialize] Initialisation labels visibles pour", layerId);
		            return this.enableLabels(layerId, {}, true);
		        },

		        /**
		         * Active les labels pour une couche
		         * Les labels sont extraits depuis le style actuel de la couche (layerData.currentStyle.label)
		         * @param {string} layerId - ID de la couche
		         * @param {Object} labelConfig - Configuration des labels depuis layer.json (legacy, peut √™tre vide)
		         * @param {boolean} showImmediately - Si true, affiche les labels imm√©diatement (visibleByDefault)
		         * @returns {Promise<void>}
		         */
		        async enableLabels(layerId, labelConfig = {}, showImmediately = true) {
		            if (!layerId) {
		                if (Log) Log.warn("[Labels] enableLabels: layerId manquant");
		                return;
		            }

		            // V√âRIFICATION: D√©tecter les r√©f√©rences obsol√®tes √† styleFile
		            if (labelConfig && labelConfig.styleFile) {
		                const errorMessage =
		                    `‚ùå CONFIGURATION OBSOL√àTE D√âTECT√âE\n` +
		                    `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
		                    `La couche "${layerId}" utilise une r√©f√©rence obsol√®te √† un fichier\n` +
		                    `de labels s√©par√© via "labelConfig.styleFile".\n\n` +
		                    `GeoLeaf ne supporte plus les fichiers de labels s√©par√©s (styleLabel.json).\n` +
		                    `Les labels doivent √™tre int√©gr√©s dans les fichiers de style.\n\n` +
		                    `Valeur d√©tect√©e: ${labelConfig.styleFile}\n` +
		                    `Couche: ${layerId}\n\n` +
		                    `Action requise:\n` +
		                    `1. Supprimez la propri√©t√© "labels.styleFile" de la configuration\n` +
		                    `2. Les labels sont maintenant extraits depuis layerData.currentStyle.label\n` +
		                    `3. Consultez docs/STYLE_FORMAT_SPEC.md pour la syntaxe\n` +
		                    `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`;

		                console.error(errorMessage);
		                throw new Error(`Configuration obsol√®te: labels.styleFile d√©tect√© dans la couche ${layerId}`);
		            }

		            if (Log) Log.debug("[Labels] Pr√©paration labels pour", layerId, "showImmediately:", showImmediately);

		            try {
		                // R√©cup√©rer le style actuel de la couche pour extraire les labels int√©gr√©s
		                const layerData = this._getLayerData(layerId);
		                let labelStyleConfig = null;

		                if (layerData && layerData.currentStyle && layerData.currentStyle.label) {
		                    // Labels int√©gr√©s dans le style
		                    const integratedLabel = layerData.currentStyle.label;

		                    if (integratedLabel.enabled === true) {
		                        labelStyleConfig = integratedLabel;

		                        // IMPORTANT: Copier aussi labelScale depuis le style
		                        if (layerData.currentStyle.labelScale) {
		                            labelStyleConfig.labelScale = layerData.currentStyle.labelScale;
		                        }

		                        if (Log) {
		                            Log.debug("[Labels] Labels int√©gr√©s d√©tect√©s pour", layerId);
		                            Log.debug("[Labels] labelScale:", labelStyleConfig.labelScale);
		                        }
		                    } else {
		                        if (Log) Log.debug("[Labels] Labels int√©gr√©s d√©sactiv√©s (enabled=false) pour", layerId);
		                        return;
		                    }
		                } else {
		                    // Pas de labels int√©gr√©s dans le style - v√©rifier config legacy
		                    if (labelConfig && labelConfig.enabled && labelConfig.labelId) {
		                        // Utiliser la config legacy du fichier de config de la couche
		                        labelStyleConfig = {
		                            enabled: true,
		                            field: labelConfig.labelId,
		                            font: labelConfig.font || {
		                                family: "Arial",
		                                sizePt: 10,
		                                weight: 50,
		                                bold: false,
		                                italic: false
		                            },
		                            color: labelConfig.color || "#000000",
		                            opacity: labelConfig.opacity || 1.0,
		                            buffer: labelConfig.buffer || { enabled: false },
		                            background: labelConfig.background || { enabled: false },
		                            offset: labelConfig.offset || { distancePx: 0 }
		                        };
		                        if (Log) Log.debug("[Labels] Utilisation config legacy pour", layerId);
		                    } else {
		                        // Pas de labels du tout
		                        if (Log) Log.debug("[Labels] Aucun label configur√© pour", layerId);
		                        return;
		                    }
		                }

		                // Stocker la configuration (enabled d√©termine si on affiche)
		                // showImmediately est d√©termin√© par visibleByDefault du style en priorit√©
		                const effectiveShowImmediately = labelStyleConfig.visibleByDefault !== undefined
		                    ? labelStyleConfig.visibleByDefault
		                    : showImmediately;

		                _state.layers.set(layerId, {
		                    enabled: effectiveShowImmediately, // true si visibleByDefault, false sinon
		                    config: labelConfig, // Configuration legacy (minZoom, maxZoom, etc.)
		                    labelStyle: labelStyleConfig, // Configuration de style extraite du style
		                    tooltips: new Map() // Map: featureId -> L.Marker
		                });

		                // V√©rifier si la couche est visible avant de cr√©er les labels
		                let shouldShowLabels = effectiveShowImmediately;

		                // V√©rifier l'√©tat de visibilit√© de la couche dans GeoJSON
		                if (layerData) {
		                    // Utiliser _visibility.current pour v√©rifier l'√©tat r√©el
		                    const isLayerVisible = layerData._visibility && layerData._visibility.current === true;
		                    shouldShowLabels = effectiveShowImmediately && isLayerVisible;

		                    if (effectiveShowImmediately && !isLayerVisible) {
		                        if (Log) Log.debug("[Labels] Labels configur√©s pour affichage mais couche invisible:", layerId);
		                    }
		                }

		                // Cr√©er les markers seulement si la couche est visible ET showImmediately
		                if (shouldShowLabels) {
		                    await this._createLabelsForLayer(layerId);
		                }

		                // Attacher l'√©couteur de zoom si ce n'est pas d√©j√† fait
		                this._ensureZoomListener();

		                if (Log) Log.debug("[Labels] Config labels pr√©par√©e pour", layerId, "visible:", showImmediately);
		            } catch (err) {
		                if (Log) Log.error("[Labels] Erreur pr√©paration labels:", err);
		                console.error("[Labels] Stack trace:", err.stack);
		            }
		        },

		        /**
		         * D√©sactive les labels pour une couche
		         * @param {string} layerId - ID de la couche
		         */
		        disableLabels(layerId) {
		            if (!layerId) return;

		            const layerState = _state.layers.get(layerId);
		            if (!layerState) return;

		            if (Log) Log.debug("[Labels] D√©sactivation des labels pour", layerId);

		            // Supprimer tous les tooltips
		            if (layerState.tooltips) {
		                layerState.tooltips.forEach(tooltip => {
		                    try {
		                        if (tooltip && tooltip.remove) {
		                            tooltip.remove();
		                        }
		                    } catch (e) {
		                        // Ignore
		                    }
		                });
		                layerState.tooltips.clear();
		            }

		            // Marquer comme d√©sactiv√©
		            layerState.enabled = false;

		            if (Log) Log.debug("[Labels] Labels d√©sactiv√©s pour", layerId);
		        },

		        /**
		         * Cache temporairement les labels d'une couche sans changer l'√©tat enabled
		         * Utilis√© quand la couche est d√©sactiv√©e mais qu'on veut garder la config
		         * @param {string} layerId - ID de la couche
		         * @private
		         */
		        _hideLabelsForLayer(layerId) {
		            if (!layerId) return;

		            const layerState = _state.layers.get(layerId);
		            if (!layerState) return;

		            if (Log) Log.debug("[Labels] Masquage temporaire des labels pour", layerId);

		            // Supprimer tous les markers de la map
		            if (layerState.tooltips) {
		                layerState.tooltips.forEach(tooltip => {
		                    try {
		                        if (tooltip && tooltip.remove) {
		                            tooltip.remove();
		                        }
		                    } catch (e) {
		                        // Ignore
		                    }
		                });
		                layerState.tooltips.clear();
		            }

		            // NE PAS changer layerState.enabled - on garde la config
		            if (Log) Log.debug("[Labels] Labels masqu√©s (enabled reste:", layerState.enabled, ")");
		        },

		        /**
		         * Bascule l'affichage des labels pour une couche
		         * @param {string} layerId - ID de la couche
		         * @returns {boolean} Nouvel √©tat (true = activ√©)
		         */
		        toggleLabels(layerId) {
		            if (!layerId) return false;

		            const layerState = _state.layers.get(layerId);
		            if (!layerState) return false;

		            // V√âRIFICATION CRITIQUE: Le style actuel doit autoriser les labels
		            const layerData = this._getLayerData(layerId);
		            const currentLabelEnabled = layerData?.currentStyle?.label?.enabled === true;

		            if (!currentLabelEnabled) {
		                return false;
		            }

		            if (layerState.enabled) {
		                // D√©sactiver : masquer sans perdre la config
		                this._hideLabelsForLayer(layerId);
		                layerState.enabled = false;
		                return false;
		            } else {
		                // Activer : changer l'√©tat et rafra√Æchir (refreshLabels v√©rifiera la visibilit√©)
		                layerState.enabled = true;
		                this.refreshLabels(layerId);
		                return true;
		            }
		        },

		        /**
		         * V√©rifie si la config labels existe pour une couche
		         * @param {string} layerId - ID de la couche
		         * @returns {boolean}
		         */
		        hasLabelConfig(layerId) {
		            return _state.layers.has(layerId);
		        },

		        /**
		         * V√©rifie si les labels sont actifs pour une couche
		         * @param {string} layerId - ID de la couche
		         * @returns {boolean}
		         */
		        areLabelsEnabled(layerId) {
		            const layerState = _state.layers.get(layerId);
		            return layerState ? layerState.enabled : false;
		        },

		        /**
		         * Rafra√Æchit les labels d'une couche (apr√®s zoom, filtre, etc.)
		         * @param {string} layerId - ID de la couche
		         */
		        refreshLabels(layerId) {
		            if (!layerId) return;

		            const layerState = _state.layers.get(layerId);
		            if (!layerState || !layerState.enabled) return;

		            // V√©rifier si la couche est visible avant de cr√©er les labels
		            // Priorit√©: visibilit√© de couche prime sur les param√®tres d'√©chelle
		            const layerData = this._getLayerData(layerId);
		            if (!layerData || !layerData._visibility || !layerData._visibility.current) {
		                if (Log) Log.debug("[Labels] Couche invisible, skip refresh pour", layerId);
		                return;
		            }

		            if (Log) Log.debug("[Labels] Rafra√Æchissement des labels pour", layerId);

		            // Supprimer les anciens tooltips
		            if (layerState.tooltips) {
		                layerState.tooltips.forEach(tooltip => {
		                    try {
		                        if (tooltip && tooltip.remove) tooltip.remove();
		                    } catch (e) {
		                        // Ignore
		                    }
		                });
		                layerState.tooltips.clear();
		            }

		            // Recr√©er les tooltips
		            this._createLabelsForLayer(layerId);
		        },

		        /**
		         * Cr√©e les tooltips permanents pour toutes les features d'une couche
		         * @private
		         * @param {string} layerId - ID de la couche
		         * @returns {Promise<void>}
		         */
		        async _createLabelsForLayer(layerId) {
		            const layerState = _state.layers.get(layerId);
		            if (!layerState || !layerState.enabled) {
		                if (Log) Log.debug("[Labels] _createLabelsForLayer: layerState non trouv√© ou d√©sactiv√© pour", layerId);
		                return;
		            }

		            // PRIORIT√â: V√©rifier la visibilit√© de la couche AVANT les calculs d'√©chelle
		            const layerData = this._getLayerData(layerId);
		            if (!layerData || !layerData._visibility || !layerData._visibility.current) {
		                if (Log) Log.debug("[Labels] Couche invisible, abandon cr√©ation labels pour", layerId);
		                return;
		            }

		            if (!layerData.layer) {
		                if (Log) Log.warn("[Labels] Couche GeoJSON non trouv√©e:", layerId);
		                return;
		            }

		            const { config, labelStyle } = layerState;

		            if (Log) Log.debug("[Labels] Cr√©ation labels pour", layerId, "labelStyle:", labelStyle);

		            // V√©rifier l'√©chelle actuelle si labelScale est d√©fini
		            const map = GeoLeaf.Core && GeoLeaf.Core.getMap ? GeoLeaf.Core.getMap() : null;

		            if (map && labelStyle.labelScale) {
		                const { minScale, maxScale } = labelStyle.labelScale;

		                if (minScale !== null || maxScale !== null) {
		                    // Calculer l'√©chelle actuelle de la carte
		                    const currentScale = this._calculateMapScale(map);

		                    if (Log) Log.debug("[Labels] V√©rification √©chelle:", {
		                        currentScale,
		                        minScale,
		                        maxScale,
		                        visible: this._isScaleInRange(currentScale, minScale, maxScale)
		                    });

		                    if (!this._isScaleInRange(currentScale, minScale, maxScale)) {
		                        if (Log) Log.debug("[Labels] √âchelle hors limites pour", layerId, `(√©chelle: 1:${currentScale})`);
		                        return;
		                    }
		                }
		            } else if (map && config.minZoom !== undefined && config.maxZoom !== undefined) {
		                // Fallback sur minZoom/maxZoom legacy
		                const currentZoom = map.getZoom();
		                if (currentZoom < config.minZoom || currentZoom > config.maxZoom) {
		                    if (Log) Log.debug("[Labels] Zoom hors limites pour", layerId);
		                    return;
		                }
		            }

		            // Cr√©er les tooltips via le renderer
		            if (GeoLeaf._LabelRenderer) {
		                // Adapter le format nouveau (field) vers ancien (labelId) pour le renderer
		                const rendererConfig = {
		                    labelId: labelStyle.field || config.labelId,
		                    minZoom: config.minZoom,
		                    maxZoom: config.maxZoom
		                };

		                if (Log) Log.debug("[Labels] Appel renderer avec:", {
		                    layerId,
		                    labelId: rendererConfig.labelId,
		                    hasLayer: !!layerData.layer,
		                    hasStyle: !!labelStyle
		                });

		                GeoLeaf._LabelRenderer.createTooltipsForLayer(
		                    layerId,
		                    layerData.layer,
		                    rendererConfig,
		                    labelStyle, // Passe le style de label extrait du style actuel
		                    layerState.tooltips
		                );

		                if (Log) Log.debug("[Labels] Renderer termin√©, tooltips cr√©√©s:", layerState.tooltips.size);
		            } else {
		                if (Log) Log.error("[Labels] GeoLeaf._LabelRenderer non disponible!");
		            }
		        },

		        /**
		         * R√©cup√®re les donn√©es de la couche depuis GeoLeaf.GeoJSON
		         * @private
		         * @param {string} layerId - ID de la couche
		         * @returns {Object|null} Layer data ou null si non trouv√©
		         */
		        _getLayerData(layerId) {
		            if (!GeoLeaf.GeoJSON || typeof GeoLeaf.GeoJSON.getLayerById !== "function") {
		                if (Log) Log.warn("[Labels] GeoLeaf.GeoJSON non disponible");
		                return null;
		            }

		            return GeoLeaf.GeoJSON.getLayerById(layerId);
		        },

		        /**
		         * S'assure que l'√©couteur de zoom est attach√©
		         * @private
		         */
		        _ensureZoomListener() {
		            if (_state.zoomListenerAttached) return;

		            const map = GeoLeaf.Core && GeoLeaf.Core.getMap ? GeoLeaf.Core.getMap() : null;
		            if (map) {
		                map.on('zoomend', () => {
		                    const zoom = map.getZoom();
		                    if (Log) Log.debug("[Labels] Zoom chang√©:", zoom);
		                    this._handleZoomChange({ zoom: zoom });
		                });
		                _state.zoomListenerAttached = true;
		                if (Log) Log.debug("[Labels] √âcouteur zoom attach√© √† la carte");
		            } else {
		                if (Log) Log.warn("[Labels] Carte non disponible pour attacher l'√©couteur de zoom");
		            }
		        },

		        /**
		         * Attache les √©couteurs d'√©v√©nements pour les couches
		         * @private
		         */
		        _attachLayerEvents() {
		            // Les √©couteurs de zoom sont maintenant attach√©s dans _ensureZoomListener()

		            // √âcouter les √©v√©nements personnalis√©s (si disponibles)
		            if (typeof global.addEventListener === "function") {
		                // √âcouter les √©v√©nements de chargement de couches
		                global.addEventListener("geoleaf:layer-loaded", (evt) => {
		                    if (evt.detail && evt.detail.layerId) {
		                        this._handleLayerLoaded(evt.detail.layerId);
		                    }
		                });
		            }
		        },

		        /**
		         * G√®re le changement de zoom/√©chelle
		         * @private
		         */
		        _handleZoomChange(detail) {
		            if (!detail) return;

		            const map = GeoLeaf.Core && GeoLeaf.Core.getMap ? GeoLeaf.Core.getMap() : null;
		            if (!map) return;

		            // Calculer l'√©chelle actuelle
		            const currentScale = this._calculateMapScale(map);

		            // Parcourir toutes les couches avec labels
		            _state.layers.forEach((layerState, layerId) => {
		                if (!layerState.enabled) return;

		                // PRIORIT√â: V√©rifier visibilit√© couche AVANT calculs d'√©chelle (performance)
		                const layerData = this._getLayerData(layerId);
		                if (!layerData || !layerData._visibility || !layerData._visibility.current) {
		                    // Couche invisible - masquer labels imm√©diatement, ignorer √©chelle
		                    const isShowing = layerState.tooltips && layerState.tooltips.size > 0;
		                    if (isShowing) {
		                        layerState.tooltips.forEach(tooltip => {
		                            if (tooltip && tooltip.remove) tooltip.remove();
		                        });
		                        layerState.tooltips.clear();
		                    }
		                    return;
		                }

		                // Couche visible: v√©rifier les contraintes d'√©chelle
		                const { labelStyle, config } = layerState;
		                let shouldShow = true;

		                // V√©rifier avec labelScale si disponible
		                if (labelStyle && labelStyle.labelScale) {
		                    const { minScale, maxScale } = labelStyle.labelScale;
		                    shouldShow = this._isScaleInRange(currentScale, minScale, maxScale);
		                } else if (config.minZoom !== undefined && config.maxZoom !== undefined) {
		                    // Fallback sur minZoom/maxZoom legacy
		                    const zoom = detail.zoom !== undefined ? detail.zoom : map.getZoom();
		                    const minZoom = config.minZoom;
		                    const maxZoom = config.maxZoom;
		                    shouldShow = zoom >= minZoom && zoom <= maxZoom;
		                }

		                const isShowing = layerState.tooltips && layerState.tooltips.size > 0;

		                if (shouldShow && !isShowing) {
		                    // Afficher les labels
		                    this._createLabelsForLayer(layerId);
		                } else if (!shouldShow && isShowing) {
		                    // Masquer les labels
		                    layerState.tooltips.forEach(tooltip => {
		                        if (tooltip && tooltip.remove) tooltip.remove();
		                    });
		                    layerState.tooltips.clear();
		                }
		            });
		        },

		        /**
		         * G√®re le chargement d'une couche
		         * @private
		         */
		        async _handleLayerLoaded(layerId) {
		            const layerState = _state.layers.get(layerId);
		            if (layerState && layerState.enabled) {
		                await this._createLabelsForLayer(layerId);
		            }
		        },

		        /**
		         * R√©cup√®re l'ID du profil actif
		         * @private
		         */
		        _getProfileId() {
		            if (GeoLeaf.Config && typeof GeoLeaf.Config.get === "function") {
		                return GeoLeaf.Config.get("id") || "default";
		            }
		            return "default";
		        },

		        /**
		         * Calcule l'√©chelle actuelle de la carte (1:X format)
		         * @private
		         * @param {L.Map} map - Instance de la carte Leaflet
		         * @returns {number} √âchelle (ex: 5000000 pour 1:5M)
		         */
		        _calculateMapScale(map) {
		            if (ScaleUtils && typeof ScaleUtils.calculateMapScale === "function") {
		                return ScaleUtils.calculateMapScale(map, { logger: Log });
		            }

		            if (!map) return 0;

		            const center = map.getCenter();
		            const zoom = map.getZoom();

		            const METERS_PER_PIXEL_AT_ZOOM_0 = 156543.04;
		            const metersPerPixel = METERS_PER_PIXEL_AT_ZOOM_0 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);

		            const METERS_PER_INCH = 0.0254;
		            const DPI = 96;
		            const metersPerInch = metersPerPixel * DPI;

		            const scale = Math.round(metersPerInch / METERS_PER_INCH);

		            if (Log) {
		                Log.debug(`[Labels] Calcul √©chelle (fallback): zoom=${zoom}, lat=${center.lat.toFixed(2)}, √©chelle=1:${scale.toLocaleString()}`);
		            }

		            return scale;
		        },

		        /**
		         * V√©rifie si une √©chelle est dans la plage min/max
		         * @private
		         * @param {number} currentScale - √âchelle actuelle (ex: 5000000)
		         * @param {number|null} minScale - √âchelle minimale (plus grand nombre = plus d√©zoom√©)
		         * @param {number|null} maxScale - √âchelle maximale (plus petit nombre = plus zoom√©)
		         * @returns {boolean} True si l'√©chelle est dans la plage
		         *
		         * Logique:
		         * - minScale est l'√©chelle la plus "large" (ex: 15000000 = 1:15M, vue d'ensemble)
		         * - maxScale est l'√©chelle la plus "d√©taill√©e" (ex: 1000 = 1:1k, vue rapproch√©e)
		         * - Labels visibles si: maxScale <= currentScale <= minScale
		         */
		        _isScaleInRange(currentScale, minScale, maxScale) {
		            if (ScaleUtils && typeof ScaleUtils.isScaleInRange === "function") {
		                return ScaleUtils.isScaleInRange(currentScale, minScale, maxScale, Log);
		            }

		            if (typeof minScale === "number" && currentScale > minScale) {
		                if (Log) {
		                    Log.debug(`[Labels] Test √©chelle (fallback): ${currentScale} > minScale ${minScale} ‚Üí ‚úó CACH√â (trop d√©zoom√©)`);
		                }
		                return false;
		            }

		            if (typeof maxScale === "number" && currentScale < maxScale) {
		                if (Log) {
		                    Log.debug(`[Labels] Test √©chelle (fallback): ${currentScale} < maxScale ${maxScale} ‚Üí ‚úó CACH√â (trop zoom√©)`);
		                }
		                return false;
		            }

		            if (Log) {
		                Log.debug(`[Labels] Test √©chelle (fallback): ${currentScale} dans [${maxScale} - ${minScale}] ‚Üí ‚úì VISIBLE`);
		            }

		            return true;
		        },

		        /**
		         * Nettoie toutes les ressources du module
		         */
		        destroy() {
		            if (Log) Log.debug("[Labels] Destruction du module Labels");

		            _state.layers.forEach((layerState, layerId) => {
		                this.disableLabels(layerId);
		            });

		            _state.layers.clear();
		        }
		    };

		    // Exposer le module
		    GeoLeaf.Labels = Labels;

		})(window);
		return labels;
	}

	requireLabels();

	var themeLoader = {};

	/**
	 * Module Theme Loader
	 * Charge et met en cache le fichier themes.json
	 *
	 * D√âPENDANCES:
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf.Core.getActiveProfile()
	 *
	 * EXPOSE:
	 * - GeoLeaf._ThemeLoader
	 *
	 * @module _ThemeLoader
	 * @private
	 */

	var hasRequiredThemeLoader;

	function requireThemeLoader () {
		if (hasRequiredThemeLoader) return themeLoader;
		hasRequiredThemeLoader = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    /**
		     * Cache pour les configurations de th√®mes
		     * @type {Map<string, Object>}
		     */
		    const _cache = new Map();

		    /**
		     * Promises en cours de chargement
		     * @type {Map<string, Promise>}
		     */
		    const _loadingPromises = new Map();

		    /**
		     * Module Theme Loader
		     * @namespace _ThemeLoader
		     * @private
		     */
		    const _ThemeLoader = {
		        /**
		         * Charge le fichier themes.json pour un profil
		         * @param {string} profileId - ID du profil
		         * @returns {Promise<Object>} Configuration des th√®mes
		         */
		        loadThemesConfig(profileId) {
		            if (Log) Log.debug("[ThemeLoader] loadThemesConfig appel√© pour:", profileId);

		            // V√©rifier le cache
		            if (_cache.has(profileId)) {
		                if (Log) Log.debug("[ThemeLoader] Config en cache pour:", profileId);
		                return Promise.resolve(_cache.get(profileId));
		            }

		            // V√©rifier si d√©j√† en cours de chargement
		            if (_loadingPromises.has(profileId)) {
		                if (Log) Log.debug("[ThemeLoader] Chargement d√©j√† en cours pour:", profileId);
		                return _loadingPromises.get(profileId);
		            }

		            // Construire le chemin du fichier
		            // Utiliser un chemin relatif depuis la racine du projet
		            // Si on est dans /demo/, on remonte avec ../
		            const isInDemo = window.location.pathname.includes('/demo/');
		            const basePath = isInDemo ? '../' : '';
		            const themesPath = `${basePath}profiles/${profileId}/themes.json`;

		            // Sprint 3.3: Unified fetch using FetchHelper with timeout and retry
		            const FetchHelper = GeoLeaf.Utils?.FetchHelper;
		            let loadPromise;

		            if (FetchHelper) {
		                // Use enhanced FetchHelper with timeout and retry
		                loadPromise = FetchHelper.get(themesPath, {
		                    timeout: 8000,
		                    retries: 1,
		                    parseResponse: true
		                })
		                .then((data) => {
		                    if (Log) Log.debug("[ThemeLoader] Fichier charg√©:", themesPath);

		                    // Valider la structure
		                    const validated = this._validateConfig(data);

		                    // Mettre en cache
		                    _cache.set(profileId, validated);
		                    _loadingPromises.delete(profileId);

		                    return validated;
		                })
		                .catch((err) => {
		                    if (Log) Log.warn("[ThemeLoader] Erreur chargement themes.json:", err.message);
		                    _loadingPromises.delete(profileId);
		                    throw err;
		                });
		            } else {
		                // Fallback to raw fetch if FetchHelper not available
		                loadPromise = fetch(themesPath)
		                    .then((response) => {
		                        if (!response.ok) {
		                            throw new Error(`Erreur HTTP ${response.status} lors du chargement de ${themesPath}`);
		                        }
		                        return response.json();
		                    })
		                    .then((data) => {
		                        if (Log) Log.debug("[ThemeLoader] Fichier charg√©:", themesPath);

		                        // Valider la structure
		                        const validated = this._validateConfig(data);

		                        // Mettre en cache
		                        _cache.set(profileId, validated);
		                        _loadingPromises.delete(profileId);

		                        return validated;
		                    })
		                    .catch((err) => {
		                        if (Log) Log.warn("[ThemeLoader] Erreur chargement themes.json:", err.message);
		                        _loadingPromises.delete(profileId);
		                        throw err;
		                    });
		            }

		            // Stocker la promesse en cours
		            _loadingPromises.set(profileId, loadPromise);

		            return loadPromise;
		        },

		        /**
		         * Valide et normalise la configuration des th√®mes
		         * @param {Object} config - Configuration brute
		         * @returns {Object} Configuration valid√©e
		         * @private
		         */
		        _validateConfig(config) {
		            if (!config || typeof config !== 'object') {
		                throw new Error("Configuration de th√®mes invalide");
		            }

		            // Valeurs par d√©faut pour config
		            const validatedConfig = {
		                config: {
		                    primaryThemes: {
		                        enabled: true,
		                        position: "top-map",
		                        ...(config.config?.primaryThemes || {})
		                    },
		                    secondaryThemes: {
		                        enabled: true,
		                        placeholder: "S√©lectionner un th√®me...",
		                        showNavigationButtons: true,
		                        position: "top-layermanager",
		                        ...(config.config?.secondaryThemes || {})
		                    }
		                },
		                themes: [],
		                defaultTheme: config.defaultTheme || null
		            };

		            // Valider les th√®mes
		            if (!Array.isArray(config.themes)) {
		                if (Log) Log.warn("[ThemeLoader] Aucun th√®me d√©fini dans la configuration");
		                return validatedConfig;
		            }

		            // Normaliser chaque th√®me
		            validatedConfig.themes = config.themes.map((theme) => {
		                if (!theme.id) {
		                    if (Log) Log.warn("[ThemeLoader] Th√®me sans ID ignor√©");
		                    return null;
		                }

		                return {
		                    id: theme.id,
		                    label: theme.label || theme.id,
		                    type: theme.type || "secondary", // Par d√©faut: secondary
		                    description: theme.description || "",
		                    icon: theme.icon || "",
		                    layers: Array.isArray(theme.layers) ? theme.layers : []
		                };
		            }).filter(Boolean); // Supprimer les th√®mes invalides

		            // V√©rifier qu'il y a au moins un th√®me
		            if (validatedConfig.themes.length === 0) {
		                throw new Error("Aucun th√®me valide trouv√© dans la configuration");
		            }

		            // V√©rifier que le defaultTheme existe
		            if (validatedConfig.defaultTheme) {
		                const defaultExists = validatedConfig.themes.some(
		                    (t) => t.id === validatedConfig.defaultTheme
		                );
		                if (!defaultExists) {
		                    if (Log) Log.warn("[ThemeLoader] defaultTheme introuvable, utilisation du premier th√®me");
		                    validatedConfig.defaultTheme = validatedConfig.themes[0].id;
		                }
		            } else {
		                // Pas de defaultTheme d√©fini, utiliser le premier
		                validatedConfig.defaultTheme = validatedConfig.themes[0].id;
		            }

		            if (Log) Log.debug("[ThemeLoader] Configuration valid√©e:", validatedConfig.themes.length, "th√®mes");

		            return validatedConfig;
		        },

		        /**
		         * Vide le cache (pour tests ou rechargement)
		         * @param {string} [profileId] - ID du profil (optionnel, vide tout si non sp√©cifi√©)
		         */
		        clearCache(profileId) {
		            if (profileId) {
		                _cache.delete(profileId);
		                _loadingPromises.delete(profileId);
		                if (Log) Log.debug("[ThemeLoader] Cache vid√© pour:", profileId);
		            } else {
		                _cache.clear();
		                _loadingPromises.clear();
		                if (Log) Log.debug("[ThemeLoader] Cache complet vid√©");
		            }
		        }
		    };

		    // Exposer dans l'espace de noms
		    GeoLeaf._ThemeLoader = _ThemeLoader;

		})(window);
		return themeLoader;
	}

	requireThemeLoader();

	var core = {};

	/**
	 * GeoLeaf Theme Applier - Core
	 * Module state, init/cleanup, applyTheme orchestration, getCurrentThemeId
	 *
	 * @module themes/theme-applier/core
	 */

	var hasRequiredCore;

	function requireCore () {
		if (hasRequiredCore) return core;
		hasRequiredCore = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    /**
		     * Module Theme Applier
		     * @namespace _ThemeApplier
		     * @private
		     */
		    const _ThemeApplier = {
		        /** @type {string|null} Th√®me actuellement actif */
		        _currentThemeId: null,

		        /** @type {boolean} Flag pour savoir si c'est le premier chargement */
		        _isFirstLoad: true,

		        /**
		         * Initialise le ThemeApplier
		         * @private
		         */
		        _init() {
		            this._pendingLayerConfigs = new Map();
		            this._pendingCheckTimer = null;
		        },

		        /**
		         * Nettoie les ressources
		         * @private
		         */
		        _cleanup() {
		            if (this._pendingCheckTimer) {
		                clearTimeout(this._pendingCheckTimer);
		                this._pendingCheckTimer = null;
		            }
		            if (this._pendingLayerConfigs) {
		                this._pendingLayerConfigs.clear();
		            }
		        },

		        /**
		         * Applique un th√®me
		         * @param {Object} theme - Configuration du th√®me
		         * @param {Object} [options] - Options d'application
		         * @param {boolean} [options.fitBounds] - Force le fitBounds
		         * @returns {Promise<void>}
		         */
		        applyTheme(theme, options = {}) {
		            // Initialiser si n√©cessaire
		            if (!this._pendingLayerConfigs) {
		                this._init();
		            }

		            if (GeoLeaf.Legend && typeof GeoLeaf.Legend.showLoadingOverlay === "function") {
		                GeoLeaf.Legend.showLoadingOverlay();
		            }

		            if (!theme || !theme.id) {
		                return Promise.reject(new Error("Th√®me invalide"));
		            }

		            // V√©rifier les d√©pendances
		            if (!GeoLeaf.GeoJSON || !GeoLeaf.LayerManager) {
		                return Promise.reject(new Error("Modules GeoJSON ou LayerManager non disponibles"));
		            }

		            // Notifier le d√©but du chargement du th√®me
		            try {
		                document.dispatchEvent(new CustomEvent('geoleaf:theme:applying', {
		                    detail: {
		                        themeId: theme.id,
		                        themeName: theme.name || theme.label || theme.id
		                    }
		                }));
		            } catch (e) { /* silencieux */ }

		            // D√©sactiver toutes les couches d'abord
		            this._hideAllLayers();

		            // Appliquer les couches du th√®me avec chargement optimis√© par lots
		            const layerConfigs = theme.layers || [];

		            // R√©cup√©rer la configuration de performance depuis le profil
		            const profileConfig = GeoLeaf.Config?.Profile?.getActiveProfileConfig();
		            const perfConfig = profileConfig?.performance || {};
		            // fitBounds d√©sactiv√© : le positionnement se fait via map.bounds du profil
		            const enableFitBounds = false;

		            // S√©parer les couches visibles et invisibles
		            const visibleLayers = layerConfigs.filter(config => config.visible !== false);
		            layerConfigs.filter(config => config.visible === false);

		            // Charger d'abord les couches visibles par lots
		            const BATCH_SIZE = perfConfig.themeBatchSize || 3;

		            // Helper progression pour l'√©cran de chargement (97‚Üí99)
		            const updateProgress = (p) => {
		                try {
		                    if (typeof window !== 'undefined' && window._glLoadingScreen && typeof window._glLoadingScreen.updateProgress === 'function') {
		                        window._glLoadingScreen.updateProgress(p);
		                    }
		                } catch (e) { /* ignore */ }
		            };

		            const loadInBatches = async (layers) => {
		                for (let i = 0; i < layers.length; i += BATCH_SIZE) {
		                    const batch = layers.slice(i, i + BATCH_SIZE);
		                    await Promise.all(batch.map(layerConfig => this._applyLayerConfig(layerConfig)));

		                    if (i === 0) {
		                        updateProgress(98);
		                    }
		                }
		            };

		            const self = this;

		            return loadInBatches(visibleLayers)
		                .then(() => {
		                    updateProgress(98);
		                    return Promise.resolve();
		                })
		                .then(() => {
		                    updateProgress(99);
		                    self._currentThemeId = theme.id;

		                    // Rafra√Æchir le LayerManager
		                    if (GeoLeaf.LayerManager && GeoLeaf.LayerManager.refresh) {
		                        GeoLeaf.LayerManager.refresh();
		                    }

		                    // Synchroniser l'√©tat de visibilit√© dans la l√©gende
		                    self._syncLegendVisibility();

		                    // √âv√©nement de th√®me appliqu√©
		                    try {
		                        const themeNotificationEvent = new CustomEvent('geoleaf:theme:applied', {
		                            detail: {
		                                themeId: theme.id,
		                                themeName: theme.name || theme.label || theme.id,
		                                layerCount: visibleLayers.length,
		                                totalLayersInTheme: layerConfigs.length,
		                                timestamp: new Date().toISOString()
		                            }
		                        });
		                        document.dispatchEvent(themeNotificationEvent);
		                    } catch (e) {
		                        // Silencieux
		                    }

		                    // FitBounds selon la configuration
		                    const shouldFitBounds = options.fitBounds === true ||
		                                           (self._isFirstLoad && enableFitBounds);
		                    if (shouldFitBounds) {
		                        setTimeout(() => {
		                            self._fitBoundsOnAllLayers();
		                        }, 1000);
		                        self._isFirstLoad = false;
		                    }
		                })
		                .catch((err) => {
		                    throw err;
		                })
		                .finally(() => {
		                    if (GeoLeaf.Legend && typeof GeoLeaf.Legend.hideLoadingOverlay === "function") {
		                        GeoLeaf.Legend.hideLoadingOverlay();
		                    }
		                });
		        },

		        /**
		         * R√©cup√®re l'ID du th√®me actuellement actif
		         * @returns {string|null}
		         */
		        getCurrentThemeId() {
		            return this._currentThemeId;
		        }
		    };

		    // Exposer dans l'espace de noms
		    GeoLeaf._ThemeApplier = _ThemeApplier;

		})(window);
		return core;
	}

	requireCore();

	var visibility = {};

	/**
	 * GeoLeaf Theme Applier - Visibility
	 * Gestion de la visibilit√© des couches et application des styles
	 *
	 * @module themes/theme-applier/visibility
	 */

	var hasRequiredVisibility;

	function requireVisibility () {
		if (hasRequiredVisibility) return visibility;
		hasRequiredVisibility = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    const TA = GeoLeaf._ThemeApplier;

		    /**
		     * D√©sactive toutes les couches GeoJSON
		     * @private
		     */
		    TA._hideAllLayers = function () {
		        if (!GeoLeaf._GeoJSONShared?.state?.layers) {
		            return;
		        }

		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            return;
		        }

		        // R√©initialiser tous les overrides utilisateur pour laisser le th√®me prendre le contr√¥le
		        VisibilityManager.resetAllUserOverrides();

		        // Parcourir toutes les couches enregistr√©es
		        GeoLeaf._GeoJSONShared.state.layers.forEach((layerData, layerId) => {
		            VisibilityManager.setVisibility(
		                layerId,
		                false,
		                VisibilityManager.VisibilitySource.THEME
		            );
		        });
		    };

		    /**
		     * Applique la configuration d'une couche (visible/masqu√©e + style)
		     * @param {Object} layerConfig - Configuration { id, visible, style }
		     * @returns {Promise<void>}
		     * @private
		     */
		    TA._applyLayerConfig = function (layerConfig) {
		        if (!layerConfig?.id) {
		            return Promise.resolve();
		        }

		        const layerId = layerConfig.id;
		        const visible = layerConfig.visible !== false;
		        const styleId = layerConfig.style ? String(layerConfig.style).trim() : undefined;

		        // R√©cup√©rer la couche depuis le registre
		        let layerData = GeoLeaf._GeoJSONShared?.state?.layers?.get(layerId);

		        // Si la couche n'existe pas, essayer de la charger automatiquement
		        if (!layerData) {
		            return TA._loadLayerFromProfile(layerId).then((loadedLayer) => {
		                if (loadedLayer) {
		                    return TA._setLayerVisibilityAndStyle(layerId, visible, styleId);
		                } else {
		                    return TA._scheduleLayerConfig(layerId, visible, styleId);
		                }
		            });
		        }

		        // La couche existe d√©j√†, appliquer directement la visibilit√©
		        return TA._setLayerVisibilityAndStyle(layerId, visible, styleId);
		    };

		    /**
		     * D√©finit la visibilit√© et le style d'une couche
		     * @param {string} layerId - ID de la couche
		     * @param {boolean} visible - Visibilit√© souhait√©e
		     * @param {string} styleId - ID du style √† appliquer
		     * @returns {Promise<void>}
		     * @private
		     */
		    TA._setLayerVisibilityAndStyle = function (layerId, visible, styleId) {
		        const layerData = GeoLeaf._GeoJSONShared?.state?.layers?.get(layerId);
		        if (!layerData) {
		            return Promise.resolve();
		        }

		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            return Promise.resolve();
		        }

		        if (visible) {
		            // Utiliser le gestionnaire centralis√© avec source THEME
		            VisibilityManager.setVisibility(
		                layerId,
		                true,
		                VisibilityManager.VisibilitySource.THEME
		            );

		            // Appliquer le style si sp√©cifi√©
		            if (styleId && GeoLeaf._GeoJSONLayerManager?.setLayerStyle) {
		                const availableStyles = layerData.config?.styles?.available || [];
		                let effectiveStyleId = styleId;
		                let styleExists = availableStyles.some(s => s.id === styleId);

		                // Fallback: si 'default' n'existe pas, essayer 'd√©faut' (et vice-versa)
		                if (!styleExists) {
		                    const fallbackMap = {
		                        'default': 'd√©faut',
		                        'd√©faut': 'default'
		                    };
		                    const fallbackStyleId = fallbackMap[styleId];
		                    if (fallbackStyleId) {
		                        const fallbackExists = availableStyles.some(s => s.id === fallbackStyleId);
		                        if (fallbackExists) {
		                            effectiveStyleId = fallbackStyleId;
		                            styleExists = true;
		                        }
		                    }
		                }

		                if (styleExists) {
		                    const styleFile = availableStyles.find(s => s.id === effectiveStyleId)?.file;
		                    if (styleFile) {
		                        let profileId = 'default';
		                        if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === 'function') {
		                            const activeProfile = GeoLeaf.Config.getActiveProfile();
		                            profileId = activeProfile?.id || 'default';
		                        }

		                        const layerDirectory = layerData._layerDirectory || layerId;

		                        const StyleLoader = GeoLeaf._StyleLoader;
		                        if (!StyleLoader) {
		                            if (Log) Log.error(`[ThemeApplier] GeoLeaf._StyleLoader non disponible`);
		                            return Promise.resolve();
		                        }

		                        return StyleLoader.loadAndValidateStyle(
		                            profileId,
		                            layerId,
		                            effectiveStyleId,
		                            styleFile,
		                            `layers/${layerDirectory}`
		                        )
		                            .then(result => {
		                                const styleConfig = result.styleData;
		                                GeoLeaf._GeoJSONLayerManager.setLayerStyle(layerId, styleConfig);

		                                // Stocker currentStyle pour les labels
		                                const layerDataForStyle = GeoLeaf._GeoJSONShared?.state?.layers?.get(layerId);
		                                if (layerDataForStyle) {
		                                    layerDataForStyle.currentStyle = styleConfig;
		                                }

		                                // Initialiser les labels si configur√©s
		                                if (GeoLeaf.Labels && typeof GeoLeaf.Labels.initializeLayerLabels === 'function') {
		                                    GeoLeaf.Labels.initializeLayerLabels(layerId);
		                                }

		                                // Mettre √† jour l'√©tat du bouton des labels
		                                if (GeoLeaf._LabelButtonManager) {
		                                    GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		                                }

		                                // Synchroniser l'UI du Layer Manager
		                                if (GeoLeaf.LayerManager && typeof GeoLeaf.LayerManager.refresh === 'function') {
		                                    GeoLeaf.LayerManager.refresh();
		                                }

		                                // Mettre √† jour le style actuel dans le s√©lecteur
		                                if (GeoLeaf._LayerManagerStyleSelector) {
		                                    GeoLeaf._LayerManagerStyleSelector.setCurrentStyle(layerId, styleId);
		                                }

		                                // Rafra√Æchir le s√©lecteur dans l'UI
		                                TA._updateStyleSelector(layerId, styleId);

		                                // Charger la l√©gende correspondante
		                                TA._loadLegendForStyle(layerId, styleId);

		                                return result;
		                            })
		                            .catch(err => {
		                                // Silencieux ‚Äî erreur d√©j√† logu√©e par StyleLoader
		                            });
		                    }
		                }
		            }
		        } else {
		            // Masquer la couche avec source THEME
		            VisibilityManager.setVisibility(
		                layerId,
		                false,
		                VisibilityManager.VisibilitySource.THEME
		            );

		            // D√©sactiver les labels et mettre √† jour le bouton
		            if (GeoLeaf.Labels) {
		                GeoLeaf.Labels.disableLabels(layerId);
		            }
		            if (GeoLeaf._LabelButtonManager) {
		                GeoLeaf._LabelButtonManager.syncImmediate(layerId);
		            }
		        }

		        return Promise.resolve();
		    };

		})(window);
		return visibility;
	}

	requireVisibility();

	var deferred = {};

	/**
	 * GeoLeaf Theme Applier - Deferred
	 * Chargement diff√©r√© de couches, r√©solution de profil, gestion du cache
	 *
	 * @module themes/theme-applier/deferred
	 */

	var hasRequiredDeferred;

	function requireDeferred () {
		if (hasRequiredDeferred) return deferred;
		hasRequiredDeferred = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    const TA = GeoLeaf._ThemeApplier;

		    /**
		     * Programme l'application d'une configuration de couche pour plus tard
		     * @param {string} layerId - ID de la couche
		     * @param {boolean} visible - Visibilit√© souhait√©e
		     * @param {string} styleId - ID du style √† appliquer
		     * @returns {Promise<void>}
		     * @private
		     */
		    TA._scheduleLayerConfig = function (layerId, visible, styleId) {
		        if (!TA._pendingLayerConfigs) {
		            TA._pendingLayerConfigs = new Map();
		        }

		        TA._pendingLayerConfigs.set(layerId, { visible, styleId });

		        // Programmer une v√©rification p√©riodique
		        TA._schedulePendingCheck();

		        return Promise.resolve();
		    };

		    /**
		     * Planifie une v√©rification des couches en attente
		     * @private
		     */
		    TA._schedulePendingCheck = function () {
		        if (TA._pendingCheckTimer) {
		            return; // D√©j√† planifi√©
		        }

		        TA._pendingCheckTimer = setTimeout(() => {
		            TA._checkPendingLayerConfigs();
		            TA._pendingCheckTimer = null;
		        }, 1000);
		    };

		    /**
		     * V√©rifie et applique les configurations de couches en attente
		     * @private
		     */
		    TA._checkPendingLayerConfigs = function () {
		        if (!TA._pendingLayerConfigs || TA._pendingLayerConfigs.size === 0) {
		            return;
		        }

		        const appliedLayers = [];

		        for (const [layerId, config] of TA._pendingLayerConfigs) {
		            const layerData = GeoLeaf._GeoJSONShared?.state?.layers?.get(layerId);
		            if (layerData) {
		                TA._setLayerVisibilityAndStyle(layerId, config.visible, config.styleId);
		                appliedLayers.push(layerId);
		            }
		        }

		        // Supprimer les couches trait√©es
		        appliedLayers.forEach(layerId => {
		            TA._pendingLayerConfigs.delete(layerId);
		        });

		        // S'il reste des couches en attente, programmer une nouvelle v√©rification
		        if (TA._pendingLayerConfigs.size > 0) {
		            TA._schedulePendingCheck();
		        }
		    };

		    /**
		     * Charge une couche depuis le profil actif (avec tol√©rance aux erreurs)
		     * @param {string} layerId - ID de la couche √† charger
		     * @returns {Promise<Object|null>} - Couche charg√©e ou null si erreur
		     * @private
		     */
		    TA._loadLayerFromProfile = async function (layerId) {
		        const Config = GeoLeaf.Config;
		        if (!Config || typeof Config.getActiveProfile !== 'function') {
		            return null;
		        }

		        try {
		            const activeProfile = Config.getActiveProfile();

		            if (!activeProfile || typeof activeProfile !== 'object') {
		                return null;
		            }

		            const profileId = activeProfile.id || null;

		            // Get layers config from profile
		            let profileLayersConfig = [];
		            if (Array.isArray(activeProfile.geojsonLayers)) {
		                profileLayersConfig = activeProfile.geojsonLayers;
		            } else if (activeProfile.geojson && Array.isArray(activeProfile.geojson.layers)) {
		                profileLayersConfig = activeProfile.geojson.layers;
		            } else if (Array.isArray(activeProfile.layers)) {
		                profileLayersConfig = activeProfile.layers;
		            } else if (Array.isArray(activeProfile.Layers)) {
		                profileLayersConfig = activeProfile.Layers;
		            }

		            if (!Array.isArray(profileLayersConfig) || profileLayersConfig.length === 0) {
		                return null;
		            }

		            const layerConfig = profileLayersConfig.find(config => config.id === layerId);

		            if (!layerConfig) {
		                return null;
		            }

		            const dataUrl = TA._resolveDataFilePath(layerConfig);

		            if (!dataUrl) {
		                return null;
		            }

		            const layerLabel = layerConfig.label || layerId;
		            const baseOptions = {};

		            const loader = GeoLeaf._GeoJSONLoader?._loadSingleLayer;

		            if (!loader) {
		                return null;
		            }

		            // Tentative cache avant r√©seau
		            let cachedData = null;
		            if (GeoLeaf.ThemeCache?.get) {
		                cachedData = await GeoLeaf.ThemeCache.get(layerId, profileId);
		            }

		            // Transmettre TOUTE la configuration de la couche
		            const layerDef = {
		                ...layerConfig,
		                url: dataUrl,
		                type: layerConfig.geometryType || layerConfig.type || 'geojson',
		                _profileId: profileId,
		                _layerDirectory: layerConfig._layerDirectory
		            };

		            // Normaliser les champs popup/tooltip/sidepanel
		            const normalizedDef = { ...layerDef };

		            if (layerDef.popup && layerDef.popup.fields) {
		                normalizedDef.popupFields = layerDef.popup.fields;
		            }

		            if (layerDef.tooltip && layerDef.tooltip.fields) {
		                normalizedDef.tooltipFields = layerDef.tooltip.fields;
		            }

		            if (layerDef.sidepanel && layerDef.sidepanel.detailLayout) {
		                normalizedDef.sidepanelFields = layerDef.sidepanel.detailLayout;
		            }

		            if (cachedData) {
		                normalizedDef._cachedData = cachedData;
		            }

		            try {
		                const layer = await loader.call(GeoLeaf._GeoJSONLoader, layerId, layerLabel, normalizedDef, baseOptions);
		                // Rafra√Æchir le cache pour prolonger la dur√©e de vie
		                if (cachedData && GeoLeaf.ThemeCache?.store) {
		                    GeoLeaf.ThemeCache.store(layerId, profileId, cachedData);
		                }
		                return layer;
		            } catch (err) {
		                return null;
		            }
		        } catch (error) {
		            return null;
		        }
		    };

		    /**
		     * R√©sout le chemin du fichier de donn√©es d'une couche
		     * @param {Object} layerConfig - Configuration de la couche
		     * @returns {string|null} - URL compl√®te du fichier de donn√©es
		     * @private
		     */
		    TA._resolveDataFilePath = function (layerConfig) {
		        if (!layerConfig.dataFile || !layerConfig._layerDirectory) {
		            return null;
		        }

		        const Config = GeoLeaf.Config;
		        if (!Config || !Config.getActiveProfile) {
		            return null;
		        }

		        const activeProfile = Config.getActiveProfile();
		        if (!activeProfile) {
		            return null;
		        }

		        const profileId = activeProfile.id;
		        const profileBasePath = TA._getProfilesBasePath(activeProfile);

		        return `${profileBasePath}/${profileId}/${layerConfig._layerDirectory}/${layerConfig.dataFile}`;
		    };

		    /**
		     * R√©sout le chemin de base des profils
		     * @private
		     */
		    TA._getProfilesBasePath = function (activeProfile) {
		        const Config = GeoLeaf.Config;
		        const configured = Config?.get?.("data.profilesBasePath");

		        if (typeof configured === "string" && configured.trim().length > 0) {
		            return TA._normalizeBasePath(configured);
		        }

		        if (activeProfile && typeof activeProfile.profilesBasePath === "string") {
		            return TA._normalizeBasePath(activeProfile.profilesBasePath);
		        }

		        return "profiles";
		    };

		    /**
		     * Normalise un chemin (trim + supprime le / final)
		     * @private
		     */
		    TA._normalizeBasePath = function (path) {
		        const trimmed = path.trim();
		        return trimmed.endsWith("/") ? trimmed.slice(0, -1) : trimmed;
		    };

		})(window);
		return deferred;
	}

	requireDeferred();

	var uiSync = {};

	/**
	 * GeoLeaf Theme Applier - UI Sync
	 * Synchronisation de l'UI : s√©lecteur de style, l√©gende, fitBounds
	 *
	 * @module themes/theme-applier/ui-sync
	 */

	var hasRequiredUiSync;

	function requireUiSync () {
		if (hasRequiredUiSync) return uiSync;
		hasRequiredUiSync = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};

		    const TA = GeoLeaf._ThemeApplier;

		    /**
		     * Met √† jour le s√©lecteur de style dans l'UI
		     * @param {string} layerId - Identifiant de la couche
		     * @param {string} styleId - Identifiant du style
		     * @private
		     */
		    TA._updateStyleSelector = function (layerId, styleId) {
		        const selectId = "style-selector-" + layerId;
		        const select = document.getElementById(selectId);

		        if (select) {
		            select.value = styleId;
		        }
		    };

		    /**
		     * Charge la l√©gende correspondant au style appliqu√©
		     * @param {string} layerId - ID de la couche
		     * @param {string} styleId - ID du style
		     * @private
		     */
		    TA._loadLegendForStyle = function (layerId, styleId) {
		        if (!GeoLeaf.Legend || typeof GeoLeaf.Legend.loadLayerLegend !== "function") {
		            return;
		        }

		        // R√©cup√©rer les informations de la couche
		        const layersMap = GeoLeaf._GeoJSONShared?.state?.layers;
		        const layerInfo = layersMap instanceof Map ? layersMap.get(layerId) : layersMap?.[layerId];

		        if (!layerInfo || !layerInfo.config) {
		            return;
		        }

		        // Utiliser la nouvelle API qui g√©n√®re la l√©gende depuis le style
		        GeoLeaf.Legend.loadLayerLegend(layerId, styleId, layerInfo.config);
		    };

		    /**
		     * Zoom sur l'emprise de toutes les couches charg√©es
		     * @private
		     */
		    TA._fitBoundsOnAllLayers = function () {
		        const map = GeoLeaf.Core?.getMap();
		        if (!map) {
		            return;
		        }

		        // Mettre √† jour la progression (99%)
		        if (window._glLoadingScreen && typeof window._glLoadingScreen.updateProgress === 'function') {
		            window._glLoadingScreen.updateProgress(99);
		        }

		        // Cr√©er un groupe temporaire avec toutes les couches pour calculer les bounds
		        const tempGroup = global.L.featureGroup();
		        let layerCount = 0;

		        // Ajouter les couches GeoJSON
		        if (GeoLeaf._GeoJSONShared?.state?.layers) {
		            GeoLeaf._GeoJSONShared.state.layers.forEach((layerData, layerId) => {
		                if (layerData.layer) {
		                    try {
		                        tempGroup.addLayer(layerData.layer);
		                        layerCount++;
		                    } catch (e) {
		                        // Silencieux
		                    }
		                }
		            });
		        }

		        // Ajouter les POI s'ils existent
		        if (GeoLeaf._POIShared?.state?.markerLayer) {
		            try {
		                tempGroup.addLayer(GeoLeaf._POIShared.state.markerLayer);
		                layerCount++;
		            } catch (e) {
		                // Silencieux
		            }
		        }

		        // Ajouter les Routes s'elles existent
		        if (GeoLeaf.Route?.getLayerGroup) {
		            try {
		                const routeGroup = GeoLeaf.Route.getLayerGroup();
		                if (routeGroup) {
		                    tempGroup.addLayer(routeGroup);
		                    layerCount++;
		                }
		            } catch (e) {
		                // Silencieux
		            }
		        }

		        // Zoomer sur l'emprise
		        if (layerCount > 0) {
		            const bounds = tempGroup.getBounds();
		            if (bounds.isValid()) {
		                // Afficher la carte AVANT le fitBounds pour √©viter l'√©cran noir
		                const mapContainer = document.getElementById('geoleaf-map') ||
		                                   document.querySelector('.leaflet-container')?.parentElement;
		                if (mapContainer) {
		                    mapContainer.style.opacity = '1';
		                }

		                map.fitBounds(bounds, { maxZoom: 12, padding: [50, 50], animate: false });

		                // Attendre que les tuiles soient charg√©es avant de fermer le spinner
		                setTimeout(() => {
		                    try {
		                        const event = new CustomEvent('geoleaf:map:ready', { detail: { time: Date.now() } });
		                        document.dispatchEvent(event);
		                    } catch (e) {
		                        // fallback
		                    }
		                }, 800);
		            }
		        }
		    };

		    /**
		     * Synchronise l'√©tat de visibilit√© de toutes les couches dans la l√©gende
		     * @private
		     */
		    TA._syncLegendVisibility = function () {
		        if (!GeoLeaf.Legend || typeof GeoLeaf.Legend.setLayerVisibility !== "function") {
		            return;
		        }

		        if (!GeoLeaf._GeoJSONShared?.state?.layers) {
		            return;
		        }

		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;
		        if (!VisibilityManager) {
		            return;
		        }

		        // Parcourir toutes les couches et synchroniser leur √©tat
		        GeoLeaf._GeoJSONShared.state.layers.forEach((layerData, layerId) => {
		            const visState = VisibilityManager.getVisibilityState(layerId);
		            const isVisible = visState ? visState.current : layerData.visible;
		            GeoLeaf.Legend.setLayerVisibility(layerId, isVisible);
		        });
		    };

		})(window);
		return uiSync;
	}

	requireUiSync();

	var themeSelector = {};

	/**
	 * Module Theme Selector
	 * S√©lecteur de th√®mes global (principaux + secondaires)
	 *
	 * D√âPENDANCES:
	 * - Leaflet (L.DomUtil, L.DomEvent)
	 * - GeoLeaf.Log (optionnel)
	 * - GeoLeaf._ThemeLoader
	 * - GeoLeaf._ThemeApplier
	 * - GeoLeaf.Core.getActiveProfile()
	 *
	 * EXPOSE:
	 * - GeoLeaf.ThemeSelector
	 *
	 * @module ThemeSelector
	 * @public
	 */

	var hasRequiredThemeSelector;

	function requireThemeSelector () {
		if (hasRequiredThemeSelector) return themeSelector;
		hasRequiredThemeSelector = 1;
		(function (global) {

		    const GeoLeaf = global.GeoLeaf = global.GeoLeaf || {};
		    const Log = GeoLeaf.Log;

		    // Helper pour utiliser createElement unifi√©
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    /**
		     * √âtat du module
		     */
		    const _state = {
		        initialized: false,
		        profileId: null,
		        config: null,
		        themes: [],
		        primaryThemes: [],
		        secondaryThemes: [],
		        currentTheme: null,
		        // R√©f√©rences UI
		        primaryContainer: null,
		        secondaryContainer: null,
		        dropdown: null,
		        // Event listener cleanup tracking
		        _eventCleanups: []
		    };

		    /**
		     * Module Theme Selector
		     * @namespace ThemeSelector
		     * @public
		     */
		    const ThemeSelector = {
		        /**
		         * Initialise le s√©lecteur de th√®mes
		         * @param {Object} options - Options d'initialisation
		         * @param {string} options.profileId - ID du profil
		         * @param {HTMLElement} [options.primaryContainer] - Conteneur pour boutons principaux
		         * @param {HTMLElement} [options.secondaryContainer] - Conteneur pour dropdown secondaire
		         * @returns {Promise<void>}
		         */
		        init(options) {
		            if (!options || !options.profileId) {
		                return Promise.reject(new Error("profileId requis pour ThemeSelector.init"));
		            }

		            if (Log) Log.debug("[ThemeSelector] Initialisation pour profil:", options.profileId);

		            _state.profileId = options.profileId;
		            _state.primaryContainer = options.primaryContainer || null;
		            _state.secondaryContainer = options.secondaryContainer || null;

		            // Charger la configuration des th√®mes
		            if (!GeoLeaf._ThemeLoader) {
		                return Promise.reject(new Error("Module _ThemeLoader non disponible"));
		            }

		            return GeoLeaf._ThemeLoader.loadThemesConfig(options.profileId)
		                .then((themesConfig) => {
		                    _state.config = themesConfig.config;
		                    _state.themes = themesConfig.themes;
		                    _state.primaryThemes = themesConfig.themes.filter((t) => t.type === "primary");
		                    _state.secondaryThemes = themesConfig.themes.filter((t) => t.type === "secondary");
		                    _state.currentTheme = themesConfig.defaultTheme;

		                    if (Log) Log.debug("[ThemeSelector] Configuration charg√©e:", {
		                        total: _state.themes.length,
		                        primary: _state.primaryThemes.length,
		                        secondary: _state.secondaryThemes.length
		                    });

		                    // Cr√©er l'UI
		                    this._createUI();

		                    // Marquer comme initialis√© AVANT d'appliquer le th√®me
		                    _state.initialized = true;

		                    // Appliquer le th√®me par d√©faut
		                    return this.setTheme(_state.currentTheme);
		                })
		                .then(() => {
		                    if (Log) Log.debug("[ThemeSelector] Initialisation termin√©e");
		                    // √âmettre l'√©v√©nement de fin de chargement des th√®mes
		                    const event = new CustomEvent('geoleaf:themes:ready', { detail: { time: Date.now() } });
		                    document.dispatchEvent(event);
		                })
		                .catch((err) => {
		                    if (Log) Log.warn("[ThemeSelector] Erreur initialisation:", err.message);
		                    // √âmettre l'√©v√©nement m√™me en cas d'erreur
		                    const event = new CustomEvent('geoleaf:themes:ready', { detail: { time: Date.now(), error: err.message } });
		                    document.dispatchEvent(event);
		                    throw err;
		                });
		        },

		        /**
		         * Cr√©e l'interface utilisateur
		         * @private
		         */
		        _createUI() {
		            // V√©rifier si le s√©lecteur de th√®mes est activ√© globalement
		            const uiConfig = GeoLeaf.Config && GeoLeaf.Config.get ? GeoLeaf.Config.get('ui') : null;
		            const showThemeSelector = uiConfig ? (uiConfig.showThemeSelector === true) : false;

		            if (!showThemeSelector) {
		                if (Log) Log.debug("[ThemeSelector] showThemeSelector est false, UI non cr√©√©e");
		                return;
		            }

		            // Cr√©er l'UI des th√®mes principaux
		            if (_state.config.primaryThemes.enabled && _state.primaryContainer) {
		                this._createPrimaryUI();
		            }

		            // Cr√©er l'UI des th√®mes secondaires
		            if (_state.config.secondaryThemes.enabled && _state.secondaryContainer) {
		                this._createSecondaryUI();
		            }
		        },

		        /**
		         * Cr√©e l'UI des th√®mes principaux (boutons)
		         * @private
		         */
		        _createPrimaryUI() {
		            if (!_state.primaryContainer) {
		                return;
		            }

		            // Vider le conteneur
		            GeoLeaf.DOMSecurity.clearElementFast(_state.primaryContainer);

		            // Ajouter la classe CSS
		            _state.primaryContainer.classList.add("gl-theme-selector-primary");

		            // Cr√©er un bouton pour chaque th√®me principal
		            _state.primaryThemes.forEach((theme) => {
		                const btn = global.L.DomUtil.create("button", "gl-theme-btn", _state.primaryContainer);
		                btn.type = "button";
		                btn.dataset.themeId = theme.id;
		                btn.title = theme.description || theme.label;

		                // Contenu du bouton: ic√¥ne + label
		                const iconSpan = global.L.DomUtil.create("span", "gl-theme-btn__icon", btn);
		                iconSpan.textContent = theme.icon || "üìç";

		                const labelSpan = global.L.DomUtil.create("span", "gl-theme-btn__label", btn);
		                labelSpan.textContent = theme.label;

		                // Marquer le th√®me actif
		                if (theme.id === _state.currentTheme) {
		                    btn.classList.add("gl-theme-btn--active");
		                }

		                // Gestionnaire de clic
		                this._attachPrimaryButtonHandler(btn, theme);
		            });

		            if (Log) Log.debug("[ThemeSelector] UI primaire cr√©√©e:", _state.primaryThemes.length, "boutons");
		        },

		        /**
		         * Attache le gestionnaire de clic sur un bouton de th√®me principal
		         * @param {HTMLElement} btn - Bouton
		         * @param {Object} theme - Configuration du th√®me
		         * @private
		         */
		        _attachPrimaryButtonHandler(btn, theme) {
		            const onClick = (ev) => {
		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                }
		                ev.preventDefault();

		                this.setTheme(theme.id);
		            };

		            const events = GeoLeaf.Utils?.events;
		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(btn, "click", onClick);
		                global.L.DomEvent.disableClickPropagation(btn);
		                // Store cleanup for L.DomEvent.off
		                _state._eventCleanups.push(() => {
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.off(btn, "click", onClick);
		                    }
		                });
		            } else if (events) {
		                _state._eventCleanups.push(
		                    events.on(
		                        btn,
		                        "click",
		                        onClick,
		                        false,
		                        'ThemeSelector.primaryButton'
		                    )
		                );
		            } else {
		                btn.addEventListener("click", onClick);
		            }
		        },

		        /**
		         * Cr√©e l'UI des th√®mes secondaires (dropdown + boutons prev/next)
		         * @private
		         */
		        _createSecondaryUI() {
		            if (!_state.secondaryContainer) {
		                if (Log) Log.warn("[ThemeSelector] Conteneur secondaire introuvable");
		                return;
		            }

		            if (Log) Log.debug("[ThemeSelector] Cr√©ation UI secondaire:", _state.secondaryThemes.length, "th√®mes");
		            if (Log) Log.debug("[ThemeSelector] IDs des th√®mes secondaires:", _state.secondaryThemes.map(t => t.id));

		            // Vider le conteneur
		            GeoLeaf.DOMSecurity.clearElementFast(_state.secondaryContainer);

		            // Ajouter la classe CSS
		            _state.secondaryContainer.classList.add("gl-theme-selector-secondary");

		            // Cr√©er le wrapper
		            const wrapper = global.L.DomUtil.create("div", "gl-theme-selector-secondary__wrapper", _state.secondaryContainer);

		            // Bouton pr√©c√©dent (si activ√©)
		            if (_state.config.secondaryThemes.showNavigationButtons) {
		                const prevBtn = global.L.DomUtil.create("button", "gl-theme-nav gl-theme-nav--prev", wrapper);
		                prevBtn.type = "button";
		                prevBtn.textContent = "‚óÄ";
		                prevBtn.title = "Th√®me pr√©c√©dent";
		                this._attachNavButtonHandler(prevBtn, "prev");
		            }

		            // Dropdown
		            const select = global.L.DomUtil.create("select", "gl-theme-dropdown", wrapper);
		            _state.dropdown = select;

		            // Option placeholder
		            const placeholder = $create("option", {
		                value: "",
		                textContent: _state.config.secondaryThemes.placeholder,
		                disabled: true
		            });
		            select.appendChild(placeholder);

		            // Options pour les th√®mes secondaires
		            _state.secondaryThemes.forEach((theme) => {
		                const opt = $create("option", {
		                    value: theme.id,
		                    textContent: theme.label
		                });
		                select.appendChild(opt);
		            });

		            // S√©lectionner le th√®me actif si c'est un th√®me secondaire
		            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
		            if (currentIsSecondary) {
		                select.value = _state.currentTheme;
		            } else {
		                select.value = "";
		            }

		            // Gestionnaire de changement
		            this._attachDropdownHandler(select);

		            // Bouton suivant (si activ√©)
		            if (_state.config.secondaryThemes.showNavigationButtons) {
		                const nextBtn = global.L.DomUtil.create("button", "gl-theme-nav gl-theme-nav--next", wrapper);
		                nextBtn.type = "button";
		                nextBtn.textContent = "‚ñ∂";
		                nextBtn.title = "Th√®me suivant";
		                this._attachNavButtonHandler(nextBtn, "next");
		            }

		            if (Log) Log.debug("[ThemeSelector] UI secondaire cr√©√©e:", _state.secondaryThemes.length, "th√®mes");
		        },

		        /**
		         * Attache le gestionnaire de changement sur le dropdown
		         * @param {HTMLSelectElement} select - Dropdown
		         * @private
		         */
		        _attachDropdownHandler(select) {
		            const onChange = (ev) => {
		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                }

		                const themeId = select.value;
		                if (Log) Log.info(`[ThemeSelector] Dropdown chang√©: ${themeId}`);

		                if (themeId) {
		                    this.setTheme(themeId);
		                } else {
		                    if (Log) Log.warn("[ThemeSelector] Dropdown: themeId vide");
		                }
		            };

		            const events = GeoLeaf.Utils?.events;
		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(select, "change", onChange);
		                global.L.DomEvent.disableClickPropagation(select);
		                // Store cleanup for L.DomEvent.off
		                _state._eventCleanups.push(() => {
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.off(select, "change", onChange);
		                    }
		                });
		            } else if (events) {
		                _state._eventCleanups.push(
		                    events.on(
		                        select,
		                        "change",
		                        onChange,
		                        false,
		                        'ThemeSelector.dropdown'
		                    )
		                );
		            } else {
		                select.addEventListener("change", onChange);
		            }

		            if (Log) Log.debug("[ThemeSelector] Gestionnaire dropdown attach√©");
		        },

		        /**
		         * Attache le gestionnaire sur un bouton de navigation (prev/next)
		         * @param {HTMLElement} btn - Bouton
		         * @param {string} direction - "prev" | "next"
		         * @private
		         */
		        _attachNavButtonHandler(btn, direction) {
		            const onClick = (ev) => {
		                if (global.L && global.L.DomEvent) {
		                    global.L.DomEvent.stopPropagation(ev);
		                }
		                ev.preventDefault();

		                if (direction === "next") {
		                    this.nextTheme();
		                } else {
		                    this.previousTheme();
		                }
		            };

		            const events = GeoLeaf.Utils?.events;
		            if (global.L && global.L.DomEvent) {
		                global.L.DomEvent.on(btn, "click", onClick);
		                global.L.DomEvent.disableClickPropagation(btn);
		                // Store cleanup for L.DomEvent.off
		                _state._eventCleanups.push(() => {
		                    if (global.L && global.L.DomEvent) {
		                        global.L.DomEvent.off(btn, "click", onClick);
		                    }
		                });
		            } else if (events) {
		                _state._eventCleanups.push(
		                    events.on(
		                        btn,
		                        "click",
		                        onClick,
		                        false,
		                        'ThemeSelector.navButton'
		                    )
		                );
		            } else {
		                btn.addEventListener("click", onClick);
		            }
		        },

		        /**
		         * Active un th√®me par son ID
		         * @param {string} themeId - ID du th√®me
		         * @returns {Promise<void>}
		         */
		        setTheme(themeId) {
		            if (!_state.initialized) {
		                return Promise.reject(new Error("ThemeSelector non initialis√©"));
		            }

		            const theme = _state.themes.find((t) => t.id === themeId);
		            if (!theme) {
		                return Promise.reject(new Error(`Th√®me introuvable: ${themeId}`));
		            }

		            if (Log) Log.debug("[ThemeSelector] setTheme:", themeId);

		            // Appliquer le th√®me
		            if (!GeoLeaf._ThemeApplier) {
		                return Promise.reject(new Error("Module _ThemeApplier non disponible"));
		            }

		            return GeoLeaf._ThemeApplier.applyTheme(theme)
		                .then(() => {
		                    _state.currentTheme = themeId;

		                    // Mettre √† jour l'UI
		                    this._updateUIState(themeId);

		                    if (Log) Log.debug("[ThemeSelector] Th√®me activ√©:", themeId);
		                })
		                .catch((err) => {
		                    if (Log) Log.warn("[ThemeSelector] Erreur activation th√®me:", err.message);
		                    throw err;
		                });
		        },

		        /**
		         * Met √† jour l'√©tat visuel de l'UI apr√®s un changement de th√®me
		         * @param {string} themeId - ID du th√®me actif
		         * @private
		         */
		        _updateUIState(themeId) {
		            // Mettre √† jour les boutons principaux
		            if (_state.primaryContainer) {
		                const buttons = _state.primaryContainer.querySelectorAll(".gl-theme-btn");
		                buttons.forEach((btn) => {
		                    if (btn.dataset.themeId === themeId) {
		                        btn.classList.add("gl-theme-btn--active");
		                    } else {
		                        btn.classList.remove("gl-theme-btn--active");
		                    }
		                });
		            }

		            // Mettre √† jour le dropdown
		            if (_state.dropdown) {
		                const isSecondary = _state.secondaryThemes.some((t) => t.id === themeId);
		                if (isSecondary) {
		                    _state.dropdown.value = themeId;
		                } else {
		                    _state.dropdown.value = "";
		                }
		            }
		        },

		        /**
		         * Active le th√®me secondaire suivant
		         */
		        nextTheme() {
		            if (!_state.initialized || _state.secondaryThemes.length === 0) {
		                return;
		            }

		            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
		            let nextIndex = 0;

		            if (currentIsSecondary) {
		                const currentIndex = _state.secondaryThemes.findIndex((t) => t.id === _state.currentTheme);
		                nextIndex = (currentIndex + 1) % _state.secondaryThemes.length;
		            }

		            const nextTheme = _state.secondaryThemes[nextIndex];
		            if (nextTheme) {
		                this.setTheme(nextTheme.id);
		            }
		        },

		        /**
		         * Active le th√®me secondaire pr√©c√©dent
		         */
		        previousTheme() {
		            if (!_state.initialized || _state.secondaryThemes.length === 0) {
		                return;
		            }

		            const currentIsSecondary = _state.secondaryThemes.some((t) => t.id === _state.currentTheme);
		            let prevIndex = _state.secondaryThemes.length - 1;

		            if (currentIsSecondary) {
		                const currentIndex = _state.secondaryThemes.findIndex((t) => t.id === _state.currentTheme);
		                prevIndex = (currentIndex - 1 + _state.secondaryThemes.length) % _state.secondaryThemes.length;
		            }

		            const prevTheme = _state.secondaryThemes[prevIndex];
		            if (prevTheme) {
		                this.setTheme(prevTheme.id);
		            }
		        },

		        /**
		         * R√©cup√®re le th√®me actuellement actif
		         * @returns {string|null}
		         */
		        getCurrentTheme() {
		            return _state.currentTheme;
		        },

		        /**
		         * R√©cup√®re tous les th√®mes
		         * @returns {Array}
		         */
		        getThemes() {
		            return _state.themes;
		        },

		        /**
		         * R√©cup√®re les th√®mes principaux
		         * @returns {Array}
		         */
		        getPrimaryThemes() {
		            return _state.primaryThemes;
		        },

		        /**
		         * R√©cup√®re les th√®mes secondaires
		         * @returns {Array}
		         */
		        getSecondaryThemes() {
		            return _state.secondaryThemes;
		        },

		        /**
		         * V√©rifie si le module est initialis√©
		         * @returns {boolean}
		         */
		        isInitialized() {
		            return _state.initialized;
		        },

		        /**
		         * Cleanup method for event listeners
		         * Call this when destroying the theme selector
		         */
		        destroy() {
		            if (Log) Log.debug("[ThemeSelector] Cleaning up event listeners");

		            if (_state._eventCleanups) {
		                _state._eventCleanups.forEach(cleanup => {
		                    if (typeof cleanup === 'function') {
		                        cleanup();
		                    }
		                });
		                _state._eventCleanups = [];
		            }

		            _state.initialized = false;
		        }
		    };

		    // Exposer dans l'espace de noms
		    GeoLeaf.ThemeSelector = ThemeSelector;

		})(window);
		return themeSelector;
	}

	requireThemeSelector();

	var panel = {};

	/**
	 * GeoLeaf Table - Panel Module
	 * Construction du bottom-sheet drawer pour le tableau
	 */

	var hasRequiredPanel;

	function requirePanel () {
		if (hasRequiredPanel) return panel;
		hasRequiredPanel = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    GeoLeaf._TablePanel = GeoLeaf._TablePanel || {};
		    GeoLeaf._TablePanel._eventCleanups = [];

		    /**
		     * Cr√©e le conteneur principal du tableau (bottom-sheet)
		     * @param {L.Map} map - Instance de la carte Leaflet
		     * @param {Object} config - Configuration du tableau
		     * @returns {HTMLElement} Conteneur du tableau
		     */
		    GeoLeaf._TablePanel.create = function (map, config) {
		        // V√©rifier si le conteneur existe d√©j√†
		        let container = document.querySelector(".gl-table-panel");
		        if (container) {
		            Log.debug("[TablePanel] Conteneur existant r√©utilis√©");
		            return container;
		        }

		        // Cr√©er le conteneur principal
		        container = document.createElement("div");
		        container.className = "gl-table-panel";
		        container.style.height = config.defaultHeight || "40%";

		        // Ajouter la barre de redimensionnement si resizable
		        if (config.resizable) {
		            const resizeHandle = createResizeHandle(container, config);
		            container.appendChild(resizeHandle);
		        }

		        // Cr√©er la barre d'outils (header)
		        const toolbar = createToolbar(map, config);
		        container.appendChild(toolbar);

		        // Cr√©er le wrapper du tableau avec scroll
		        const tableWrapper = document.createElement("div");
		        tableWrapper.className = "gl-table-panel__wrapper";
		        container.appendChild(tableWrapper);

		        // Cr√©er le tableau vide (sera rempli par le renderer)
		        const table = document.createElement("table");
		        table.className = "gl-table-panel__table";
		        tableWrapper.appendChild(table);

		        // Ajouter au body
		        document.body.appendChild(container);

		        // Cr√©er le bouton flottant pour afficher le tableau (quand masqu√©)
		        createFloatingShowButton();

		        Log.info("[TablePanel] Panneau cr√©√© avec succ√®s");
		        return container;
		    };

		    /**
		     * Cr√©e la barre de redimensionnement
		     * @param {HTMLElement} container - Conteneur du tableau
		     * @param {Object} config - Configuration
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createResizeHandle(container, config) {
		        const handle = document.createElement("div");
		        handle.className = "gl-table-panel__resize-handle";
		        const resizeBar = document.createElement("div");
		        resizeBar.className = "gl-table-panel__resize-bar";
		        handle.appendChild(resizeBar);

		        let isResizing = false;
		        let startY = 0;
		        let startHeight = 0;

		        const events = GeoLeaf.Utils?.events;

		        const mouseDownHandler = (e) => {
		            isResizing = true;
		            startY = e.clientY;
		            startHeight = container.offsetHeight;
		            document.body.style.cursor = "ns-resize";
		            document.body.style.userSelect = "none";
		            e.preventDefault();
		        };

		        const mouseMoveHandler = (e) => {
		            if (!isResizing) return;
		            const delta = startY - e.clientY;
		            let newHeight = startHeight + delta;
		            const viewportHeight = window.innerHeight;
		            const minHeightPx = parseHeight(config.minHeight || "20%", viewportHeight);
		            const maxHeightPx = parseHeight(config.maxHeight || "80%", viewportHeight);
		            newHeight = Math.max(minHeightPx, Math.min(maxHeightPx, newHeight));
		            container.style.height = newHeight + "px";
		        };

		        const mouseUpHandler = () => {
		            if (isResizing) {
		                isResizing = false;
		                document.body.style.cursor = "";
		                document.body.style.userSelect = "";
		            }
		        };

		        if (events) {
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(handle, "mousedown", mouseDownHandler, false, 'TablePanel.resizeMouseDown')
		            );
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(document, "mousemove", mouseMoveHandler, false, 'TablePanel.resizeMouseMove')
		            );
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(document, "mouseup", mouseUpHandler, false, 'TablePanel.resizeMouseUp')
		            );
		        } else {
		            handle.addEventListener("mousedown", mouseDownHandler);
		            document.addEventListener("mousemove", mouseMoveHandler);
		            document.addEventListener("mouseup", mouseUpHandler);
		        }

		        return handle;
		    }

		    /**
		     * Parse une valeur de hauteur (%, px, vh) en pixels
		     * @param {string} value - Valeur √† parser ("40%", "300px", "50vh")
		     * @param {number} referenceHeight - Hauteur de r√©f√©rence pour les %
		     * @returns {number} Hauteur en pixels
		     * @private
		     */
		    function parseHeight(value, referenceHeight) {
		        if (typeof value === "number") return value;
		        if (typeof value !== "string") return 300;

		        if (value.endsWith("%")) {
		            const percent = parseFloat(value);
		            return (referenceHeight * percent) / 100;
		        } else if (value.endsWith("px")) {
		            return parseFloat(value);
		        } else if (value.endsWith("vh")) {
		            const vh = parseFloat(value);
		            return (window.innerHeight * vh) / 100;
		        }
		        return 300; // D√©faut
		    }

		    /**
		     * Cr√©e la barre d'outils du tableau
		     * @param {L.Map} map - Instance de la carte
		     * @param {Object} config - Configuration
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createToolbar(map, config) {
		        const toolbar = document.createElement("div");
		        toolbar.className = "gl-table-panel__toolbar";

		        // S√©lecteur de couche
		        const layerSelect = createLayerSelector();
		        toolbar.appendChild(layerSelect);

		        // Champ de recherche
		        const searchInput = createSearchInput();
		        toolbar.appendChild(searchInput);

		        // Bouton Zoom sur la s√©lection
		        const zoomButton = createButton("Zoom sur s√©lection", "zoom", () => {
		            if (GeoLeaf.Table && typeof GeoLeaf.Table.zoomToSelection === "function") {
		                GeoLeaf.Table.zoomToSelection();
		            }
		        });
		        zoomButton.disabled = true;
		        zoomButton.setAttribute("data-table-btn", "zoom");
		        toolbar.appendChild(zoomButton);

		        // Bouton Surbrillance
		        const highlightButton = createButton("Surbrillance", "highlight", () => {
		            const isActive = highlightButton.classList.toggle("is-active");
		            if (GeoLeaf.Table && typeof GeoLeaf.Table.highlightSelection === "function") {
		                GeoLeaf.Table.highlightSelection(isActive);
		            }
		        });
		        highlightButton.disabled = true;
		        highlightButton.setAttribute("data-table-btn", "highlight");
		        toolbar.appendChild(highlightButton);

		        // Bouton Export (si activ√©)
		        if (config.enableExportButton) {
		            const exportButton = createButton("Exporter", "export", () => {
		                if (GeoLeaf.Table && typeof GeoLeaf.Table.exportSelection === "function") {
		                    GeoLeaf.Table.exportSelection();
		                }
		            });
		            exportButton.disabled = true;
		            exportButton.setAttribute("data-table-btn", "export");
		            toolbar.appendChild(exportButton);
		        }

		        // Spacer pour pousser le bouton toggle √† droite
		        const spacer = document.createElement("div");
		        spacer.style.flex = "1";
		        toolbar.appendChild(spacer);

		        // Bouton toggle (masquer/afficher le tableau)
		        const toggleBtn = createToggleButton();
		        toolbar.appendChild(toggleBtn);

		        return toolbar;
		    }

		    /**
		     * Cr√©e le s√©lecteur de couche
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createLayerSelector() {
		        const wrapper = document.createElement("div");
		        wrapper.className = "gl-table-panel__layer-selector";

		        const select = document.createElement("select");
		        select.id = "geoleaf-table-layer-selector";
		        select.name = "geoleaf-table-layer-selector";
		        select.className = "gl-table-panel__select";
		        select.setAttribute("data-table-layer-select", "");

		        // Option par d√©faut
		        const defaultOption = document.createElement("option");
		        defaultOption.value = "";
		        defaultOption.textContent = "S√©lectionner une couche...";
		        select.appendChild(defaultOption);

		        // Peupler avec les couches disponibles
		        populateLayerSelector(select);

		        // √âv√©nement de changement - avec cleanup tracking
		        const changeHandler = (e) => {
		            const layerId = e.target.value;
		            Log.debug("[TablePanel] S√©lecteur chang√©, layerId:", layerId);
		            Log.debug("[TablePanel] GeoLeaf.Table existe:", !!GeoLeaf.Table);
		            Log.debug("[TablePanel] setLayer existe:", typeof GeoLeaf.Table?.setLayer);
		            if (GeoLeaf.Table && typeof GeoLeaf.Table.setLayer === "function") {
		                GeoLeaf.Table.setLayer(layerId);
		            } else {
		                Log.error("[TablePanel] GeoLeaf.Table.setLayer non disponible!");
		            }
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(select, "change", changeHandler, false, 'TablePanel.layerSelect')
		            );
		        } else {
		            select.addEventListener("change", changeHandler);
		        }

		        Log.debug("[TablePanel] √âv√©nement 'change' attach√© au s√©lecteur");

		        wrapper.appendChild(select);
		        return wrapper;
		    }

		    /**
		     * Peuple le s√©lecteur avec les couches disponibles
		     * @param {HTMLSelectElement} select - √âl√©ment select
		     * @private
		     */
		    function populateLayerSelector(select) {
		        Log.debug("[TablePanel] populateLayerSelector appel√©");

		        if (!GeoLeaf.GeoJSON || typeof GeoLeaf.GeoJSON.getAllLayers !== "function") {
		            Log.warn("[TablePanel] Module GeoJSON non disponible");
		            return;
		        }

		        const allLayers = GeoLeaf.GeoJSON.getAllLayers();
		        Log.debug("[TablePanel] getAllLayers retourne:", allLayers.length, "couches");

		        if (allLayers.length === 0) {
		            Log.debug("[TablePanel] Aucune couche charg√©e, le s√©lecteur sera rafra√Æchi par l'√©v√©nement layers-loaded");
		            return;
		        }

		        const VisibilityManager = GeoLeaf._LayerVisibilityManager;

		        // V√©rifier les options existantes pour √©viter les doublons
		        const existingValues = new Set();
		        for (let i = 1; i < select.options.length; i++) {
		            existingValues.add(select.options[i].value);
		        }

		        let addedCount = 0;
		        allLayers.forEach(layer => {
		            const layerData = GeoLeaf.GeoJSON.getLayerData(layer.id);
		            Log.debug("[TablePanel] V√©rification couche:", layer.id, "table enabled:", layerData?.config?.table?.enabled);

		            if (layerData && layerData.config && layerData.config.table && layerData.config.table.enabled) {
		                // V√©rifier que la couche est visible sur la carte
		                let isVisible = true;
		                if (VisibilityManager && typeof VisibilityManager.getVisibilityState === "function") {
		                    const visState = VisibilityManager.getVisibilityState(layer.id);
		                    isVisible = visState && visState.current === true;
		                } else if (layerData._visibility) {
		                    isVisible = layerData._visibility.current === true;
		                }

		                if (!isVisible) {
		                    Log.debug("[TablePanel] Couche", layer.id, "masqu√©e, ignor√©e dans le s√©lecteur");
		                    return;
		                }

		                // N'ajouter que si pas d√©j√† pr√©sent
		                if (!existingValues.has(layer.id)) {
		                    const option = document.createElement("option");
		                    option.value = layer.id;
		                    option.textContent = layer.label || layer.id;
		                    select.appendChild(option);
		                    addedCount++;
		                }
		            }
		        });

		        if (addedCount > 0) {
		            Log.info("[TablePanel] S√©lecteur de couche peupl√©:", addedCount, "couches ajout√©es");
		        }
		    }

		    /**
		     * Cr√©e le champ de recherche
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createSearchInput() {
		        const wrapper = document.createElement("div");
		        wrapper.className = "gl-table-panel__search";

		        const input = document.createElement("input");
		        input.type = "text";
		        input.id = "geoleaf-table-search-input";
		        input.name = "geoleaf-table-search-input";
		        input.placeholder = "Rechercher...";
		        input.className = "gl-table-panel__search-input";
		        input.setAttribute("data-table-search", "");

		        wrapper.appendChild(input);
		        return wrapper;
		    }

		    /**
		     * Cr√©e un bouton g√©n√©rique
		     * @param {string} label - Libell√© du bouton
		     * @param {string} icon - Classe d'ic√¥ne (optionnel)
		     * @param {Function} onClick - Callback au clic
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createButton(label, icon, onClick) {
		        const button = document.createElement("button");
		        button.className = "gl-table-panel__btn";
		        button.textContent = label;

		        if (icon) {
		            button.classList.add("gl-table-panel__btn--" + icon);
		        }

		        if (onClick) {
		            const events = GeoLeaf.Utils?.events;
		            if (events) {
		                GeoLeaf._TablePanel._eventCleanups.push(
		                    events.on(button, "click", onClick, false, 'TablePanel.button')
		                );
		            } else {
		                button.addEventListener("click", onClick);
		            }
		        }

		        return button;
		    }

		    /**
		     * Cr√©e le bouton toggle pour masquer le tableau (int√©gr√© dans le toolbar)
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createToggleButton() {
		        const button = document.createElement("button");
		        button.className = "gl-table-panel__toggle-btn";
		        button.title = "Masquer le tableau";
		        button.setAttribute("aria-label", "Masquer tableau");

		        // Cr√©er l'ic√¥ne SVG (fl√®che vers le bas)
		        const icon = document.createElement("span");
		        icon.className = "gl-table-panel__toggle-btn__icon";
		        // SAFE: SVG statique hardcod√©, pas de donn√©es utilisateur
		        const downSvg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M6 9l6 6 6-6', {
		            stroke: 'currentColor',
		            strokeWidth: '6',
		            fill: 'none'
		        });
		        icon.appendChild(downSvg);
		        button.appendChild(icon);

		        const clickHandler = () => {
		            if (GeoLeaf.Table && typeof GeoLeaf.Table.toggle === "function") {
		                GeoLeaf.Table.toggle();
		            }
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(button, "click", clickHandler, false, 'TablePanel.toggleBtn')
		            );
		        } else {
		            button.addEventListener("click", clickHandler);
		        }

		        return button;
		    }

		    /**
		     * Cr√©e le bouton flottant pour afficher le tableau (visible quand tableau masqu√©)
		     * @private
		     */
		    function createFloatingShowButton() {
		        const button = document.createElement("button");
		        button.className = "gl-table-panel__floating-show-btn";
		        button.title = "Afficher le tableau";
		        button.setAttribute("aria-label", "Afficher tableau");

		        // Cr√©er l'ic√¥ne SVG (fl√®che vers le haut)
		        const icon = document.createElement("span");
		        icon.className = "gl-table-panel__toggle-btn__icon";
		        // SAFE: SVG statique hardcod√©, pas de donn√©es utilisateur
		        const upSvg = GeoLeaf.DOMSecurity.createSVGIcon(16, 16, 'M18 15l-6-6-6 6', {
		            stroke: 'currentColor',
		            strokeWidth: '6',
		            fill: 'none'
		        });
		        icon.appendChild(upSvg);
		        button.appendChild(icon);

		        const clickHandler = () => {
		            if (GeoLeaf.Table && typeof GeoLeaf.Table.show === "function") {
		                GeoLeaf.Table.show();
		            }
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._TablePanel._eventCleanups.push(
		                events.on(button, "click", clickHandler, false, 'TablePanel.floatingShowBtn')
		            );
		        } else {
		            button.addEventListener("click", clickHandler);
		        }

		        document.body.appendChild(button);
		        Log.debug("[TablePanel] Bouton flottant cr√©√©");
		    }

		    /**
		     * Met √† jour l'√©tat des boutons de la toolbar selon la s√©lection
		     * @param {number} selectedCount - Nombre d'entit√©s s√©lectionn√©es
		     */
		    GeoLeaf._TablePanel.updateToolbarButtons = function (selectedCount) {
		        const hasSelection = selectedCount > 0;

		        const zoomBtn = document.querySelector("[data-table-btn='zoom']");
		        const highlightBtn = document.querySelector("[data-table-btn='highlight']");
		        const exportBtn = document.querySelector("[data-table-btn='export']");

		        if (zoomBtn) zoomBtn.disabled = !hasSelection;
		        if (highlightBtn) {
		            highlightBtn.disabled = !hasSelection;
		            // Si plus aucune s√©lection, d√©sactiver la surbrillance
		            if (!hasSelection && highlightBtn.classList.contains("is-active")) {
		                highlightBtn.classList.remove("is-active");
		                if (GeoLeaf.Table && typeof GeoLeaf.Table.highlightSelection === "function") {
		                    GeoLeaf.Table.highlightSelection(false);
		                }
		            }
		        }
		        if (exportBtn) exportBtn.disabled = !hasSelection;

		        Log.debug("[TablePanel] Boutons mis √† jour. S√©lection:", selectedCount);
		    };

		    /**
		     * Rafra√Æchit le s√©lecteur de couche (utile apr√®s chargement de nouvelles couches)
		     */
		    GeoLeaf._TablePanel.refreshLayerSelector = function () {
		        const select = document.querySelector("[data-table-layer-select]");
		        if (!select) return;

		        // Sauvegarder la valeur actuelle
		        const currentValue = select.value;

		        // Vider les options (sauf la premi√®re)
		        while (select.options.length > 1) {
		            select.remove(1);
		        }

		        // Re-peupler
		        populateLayerSelector(select);

		        // V√©rifier si la valeur actuelle est toujours disponible
		        const optionValues = Array.from(select.options).map(o => o.value);
		        if (currentValue && optionValues.includes(currentValue)) {
		            select.value = currentValue;
		        } else if (currentValue && !optionValues.includes(currentValue)) {
		            // La couche active a √©t√© retir√©e (masqu√©e) ‚Äî basculer sur la premi√®re disponible
		            if (select.options.length > 1) {
		                select.value = select.options[1].value;
		                if (GeoLeaf.Table && typeof GeoLeaf.Table.setLayer === "function") {
		                    GeoLeaf.Table.setLayer(select.options[1].value);
		                }
		            } else {
		                // Aucune couche visible ‚Äî vider le tableau
		                select.value = "";
		                if (GeoLeaf.Table && typeof GeoLeaf.Table.setLayer === "function") {
		                    GeoLeaf.Table.setLayer("");
		                }
		            }
		        }

		        // Mettre √† jour le placeholder si aucune couche visible
		        const defaultOption = select.options[0];
		        if (defaultOption) {
		            defaultOption.textContent = select.options.length > 1
		                ? "S√©lectionner une couche..."
		                : "Aucune couche visible";
		        }

		        Log.debug("[TablePanel] S√©lecteur de couche rafra√Æchi,", (select.options.length - 1), "couches disponibles");
		    };

		    /**
		     * Cleanup all event listeners
		     */
		    GeoLeaf._TablePanel.destroy = function() {
		        if (GeoLeaf._TablePanel._eventCleanups && GeoLeaf._TablePanel._eventCleanups.length > 0) {
		            GeoLeaf._TablePanel._eventCleanups.forEach(cleanup => {
		                if (typeof cleanup === 'function') cleanup();
		            });
		            GeoLeaf._TablePanel._eventCleanups = [];
		            Log.info('[TablePanel] Event listeners cleaned up');
		        }
		    };

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return panel;
	}

	requirePanel();

	var renderer = {};

	/**
	 * GeoLeaf Table - Renderer Module
	 * Rendu des colonnes, lignes et pagination avec virtual scrolling
	 */

	var hasRequiredRenderer;

	function requireRenderer () {
		if (hasRequiredRenderer) return renderer;
		hasRequiredRenderer = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Shorthand for createElement
		     */
		    const $create = (tag, props, ...children) => {
		        return GeoLeaf.Utils && GeoLeaf.Utils.createElement
		            ? GeoLeaf.Utils.createElement(tag, props, ...children)
		            : document.createElement(tag);
		    };

		    GeoLeaf._TableRenderer = GeoLeaf._TableRenderer || {};
		    GeoLeaf._TableRenderer._eventCleanups = [];

		    /**
		     * Rend le tableau avec les donn√©es fournies
		     * @param {HTMLElement} container - Conteneur du tableau
		     * @param {Object} options - Options de rendu
		     * @param {string} options.layerId - ID de la couche
		     * @param {Array} options.features - Features √† afficher
		     * @param {Set} options.selectedIds - IDs des entit√©s s√©lectionn√©es
		     * @param {Object} options.sortState - √âtat du tri
		     * @param {Object} options.config - Configuration du tableau
		     */
		    GeoLeaf._TableRenderer.render = function (container, options) {
		        Log.debug("[TableRenderer] render() - D√©but, options:", options);

		        if (!container) {
		            Log.error("[TableRenderer] Conteneur invalide");
		            return;
		        }

		        // R√©initialiser le compteur d'IDs synth√©tiques √† chaque rendu
		        _syntheticIdCounter = 0;

		        const { layerId, features, selectedIds, sortState, config } = options;
		        Log.debug("[TableRenderer] render() - layerId:", layerId, "features:", features ? features.length : 0);

		        const table = container.querySelector(".gl-table-panel__table");
		        if (!table) {
		            Log.error("[TableRenderer] √âl√©ment table introuvable");
		            return;
		        }

		        // Si pas de layerId, vider le tableau
		        if (!layerId) {
		            // SAFE: Cha√Æne vide pour nettoyer le contenu
		            GeoLeaf.DOMSecurity.clearElementFast(table);
		            Log.debug("[TableRenderer] Tableau vid√© (aucune couche s√©lectionn√©e)");
		            return;
		        }

		        // R√©cup√©rer la config du layer
		        const layerData = GeoLeaf.GeoJSON ? GeoLeaf.GeoJSON.getLayerData(layerId) : null;
		        const layerConfig = layerData && layerData.config && layerData.config.table ? layerData.config.table : null;

		        if (!layerConfig || !layerConfig.columns) {
		            Log.warn("[TableRenderer] Aucune configuration de colonne pour", layerId);
		            // SAFE: Cha√Æne vide pour nettoyer le contenu
		            GeoLeaf.DOMSecurity.clearElementFast(table);
		            return;
		        }

		        Log.debug("[TableRenderer] Colonnes:", layerConfig.columns);

		        // Vider le tableau
		        // SAFE: Cha√Æne vide pour nettoyer le contenu avant reconstruction
		        GeoLeaf.DOMSecurity.clearElementFast(table);

		        // Cr√©er le thead
		        const thead = createTableHead(layerConfig.columns, sortState);
		        table.appendChild(thead);

		        // Cr√©er le tbody
		        const tbody = createTableBody(features, layerConfig.columns, selectedIds);
		        table.appendChild(tbody);

		        // Appliquer virtual scrolling si activ√©
		        if (config.virtualScrolling && features.length > config.pageSize) {
		            applyVirtualScrolling(container, features);
		        }

		        Log.debug("[TableRenderer] Tableau rendu:", features.length, "lignes");
		    };

		    /**
		     * Cr√©e l'en-t√™te du tableau (thead)
		     * @param {Array} columns - Configuration des colonnes
		     * @param {Object} sortState - √âtat du tri actuel
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createTableHead(columns, sortState) {
		        const thead = $create("thead");
		        const tr = $create("tr");

		        // Colonne checkbox (s√©lection)
		        const thCheckbox = $create("th", { className: "gl-table-panel__th gl-table-panel__th--checkbox" });

		        const checkboxAll = $create("input", {
		            type: "checkbox",
		            className: "gl-table-panel__checkbox-all",
		            title: "Tout s√©lectionner / Tout d√©s√©lectionner"
		        });

		        const checkboxAllHandler = (e) => {
		            toggleAllRows(e.target.checked);
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._TableRenderer._eventCleanups.push(
		                events.on(checkboxAll, "change", checkboxAllHandler, false, 'TableRenderer.checkboxAll')
		            );
		        } else {
		            checkboxAll.addEventListener("change", checkboxAllHandler);
		        }

		        thCheckbox.appendChild(checkboxAll);
		        tr.appendChild(thCheckbox);

		        // Colonnes de donn√©es
		        columns.forEach(col => {
		            const th = $create("th", { className: "gl-table-panel__th" });
		            th.textContent = col.label || col.field;

		            if (col.width) {
		                th.style.width = col.width;
		            }

		            // Rendre la colonne triable (par d√©faut toutes les colonnes sont triables)
		            const isSortable = col.sortable !== false;
		            if (isSortable) {
		                th.classList.add("gl-table-panel__th--sortable");
		                th.setAttribute("data-field", col.field);

		                // Ajouter les indicateurs de tri
		                const sortIcon = $create("span", { className: "gl-table-panel__sort-icon" });

		                if (sortState.field === col.field) {
		                    if (sortState.direction === "asc") {
		                        sortIcon.textContent = " ‚ñ≤";
		                        th.classList.add("is-sorted-asc");
		                    } else if (sortState.direction === "desc") {
		                        sortIcon.textContent = " ‚ñº";
		                        th.classList.add("is-sorted-desc");
		                    }
		                } else {
		                    sortIcon.textContent = " ‚áÖ";
		                }

		                th.appendChild(sortIcon);

		                // √âv√©nement de tri - avec cleanup tracking
		                const sortHandler = () => {
		                    if (GeoLeaf.Table && typeof GeoLeaf.Table.sortByField === "function") {
		                        GeoLeaf.Table.sortByField(col.field);
		                    }
		                };

		                const events = GeoLeaf.Utils?.events;
		                if (events) {
		                    GeoLeaf._TableRenderer._eventCleanups.push(
		                        events.on(th, "click", sortHandler, false, 'TableRenderer.sort')
		                    );
		                } else {
		                    th.addEventListener("click", sortHandler);
		                }
		            }

		            tr.appendChild(th);
		        });

		        thead.appendChild(tr);
		        return thead;
		    }

		    /**
		     * Cr√©e le corps du tableau (tbody)
		     * @param {Array} features - Features √† afficher
		     * @param {Array} columns - Configuration des colonnes
		     * @param {Set} selectedIds - IDs s√©lectionn√©s
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createTableBody(features, columns, selectedIds) {
		        Log.debug("[TableRenderer] createTableBody() - features:", features.length);

		        const tbody = $create("tbody");

		        // Sprint 3.2: Use DocumentFragment for batch DOM operations
		        const fragment = document.createDocumentFragment();

		        features.forEach((feature, index) => {
		            const tr = createTableRow(feature, columns, selectedIds);
		            fragment.appendChild(tr);
		        });

		        tbody.appendChild(fragment);

		        Log.debug("[TableRenderer] tbody cr√©√© avec", tbody.children.length, "lignes");
		        return tbody;
		    }

		    /**
		     * Cr√©e une ligne du tableau
		     * @param {Object} feature - Feature GeoJSON
		     * @param {Array} columns - Configuration des colonnes
		     * @param {Set} selectedIds - IDs s√©lectionn√©s
		     * @returns {HTMLElement}
		     * @private
		     */
		    function createTableRow(feature, columns, selectedIds) {
		        const tr = $create("tr");
		        const featureId = getFeatureId(feature);
		        tr.setAttribute("data-feature-id", featureId);

		        const isSelected = selectedIds.has(String(featureId));
		        if (isSelected) {
		            tr.classList.add("is-selected");
		        }

		        // Cellule checkbox
		        const tdCheckbox = $create("td", { className: "gl-table-panel__td gl-table-panel__td--checkbox" });

		        const checkbox = $create("input", {
		            type: "checkbox",
		            className: "gl-table-panel__checkbox",
		            checked: isSelected
		        });

		        const checkboxHandler = (e) => {
		            // Pour les checkboxes, toujours traiter comme multi-s√©lection
		            handleRowSelection(featureId, e.target.checked, false, true, true);
		        };

		        const events = GeoLeaf.Utils?.events;
		        if (events) {
		            GeoLeaf._TableRenderer._eventCleanups.push(
		                events.on(checkbox, "change", checkboxHandler, false, 'TableRenderer.checkbox')
		            );
		        } else {
		            checkbox.addEventListener("change", checkboxHandler);
		        }

		        tdCheckbox.appendChild(checkbox);
		        tr.appendChild(tdCheckbox);

		        // Cellules de donn√©es
		        columns.forEach((col, colIndex) => {
		            const td = $create("td", { className: "gl-table-panel__td" });

		            const value = getNestedValue(feature, col.field);
		            const formattedValue = formatValue(value, col.type);

		            td.textContent = formattedValue;

		            // Aligner les nombres √† droite
		            if (col.type === "number") {
		                td.classList.add("gl-table-panel__td--number");
		            }

		            tr.appendChild(td);
		        });

		        // √âv√©nement clic sur la ligne (s√©lection simple) - avec cleanup tracking
		        const rowClickHandler = (e) => {
		            // Ignorer si c'est le checkbox qui a √©t√© cliqu√©
		            if (e.target.type === "checkbox") return;
		            const currentState = tr.classList.contains("is-selected");
		            handleRowSelection(featureId, !currentState, e.shiftKey, e.ctrlKey || e.metaKey);
		        };

		        // Reuse EventListenerManager from outer scope
		        if (events) {
		            GeoLeaf._TableRenderer._eventCleanups.push(
		                events.on(tr, "click", rowClickHandler, false, 'TableRenderer.rowClick')
		            );
		        } else {
		            tr.addEventListener("click", rowClickHandler);
		        }

		        return tr;
		    }

		    /**
		     * G√®re la s√©lection d'une ligne
		     * @param {string} featureId - ID de la feature
		     * @param {boolean} selected - S√©lectionn√© ou non
		     * @param {boolean} shiftKey - Touche Shift enfonc√©e
		     * @param {boolean} ctrlKey - Touche Ctrl/Cmd enfonc√©e
		     * @param {boolean} isCheckbox - Si l'action vient d'une checkbox
		     * @private
		     */
		    function handleRowSelection(featureId, selected, shiftKey, ctrlKey, isCheckbox = false) {
		        Log.debug("[TableRenderer] handleRowSelection - featureId:", featureId, "selected:", selected);

		        if (!GeoLeaf.Table) {
		            Log.error("[TableRenderer] GeoLeaf.Table non disponible");
		            return;
		        }

		        const currentSelection = GeoLeaf.Table.getSelectedIds();

		        if (shiftKey && currentSelection.length > 0) {
		            // S√©lection par plage (Shift+clic)
		            Log.debug("[TableRenderer] Mode SHIFT - S√©lection par plage");
		            selectRange(featureId);
		        } else if (ctrlKey || isCheckbox) {
		            // Multi-s√©lection (Ctrl+clic ou checkbox)
		            Log.debug("[TableRenderer] Mode MULTI - Multi-s√©lection" + (isCheckbox ? " (checkbox)" : " (Ctrl)"));
		            if (selected) {
		                const newSelection = [...currentSelection, featureId];
		                GeoLeaf.Table.setSelection(newSelection, false);
		            } else {
		                const newSelection = currentSelection.filter(id => id !== featureId);
		                GeoLeaf.Table.setSelection(newSelection, false);
		            }
		        } else {
		            // S√©lection simple
		            Log.debug("[TableRenderer] Mode SIMPLE - S√©lection unique");
		            if (selected) {
		                GeoLeaf.Table.setSelection([featureId], false);
		            } else {
		                GeoLeaf.Table.clearSelection();
		            }
		        }

		        // Mettre √† jour l'√©tat des boutons
		        updateToolbarButtonsState();
		    }

		    /**
		     * S√©lectionne une plage de lignes (Shift+clic)
		     * @param {string} targetId - ID de la feature cible
		     * @private
		     */
		    function selectRange(targetId) {
		        const tbody = document.querySelector(".gl-table-panel__table tbody");
		        if (!tbody) return;

		        const rows = Array.from(tbody.querySelectorAll("tr"));
		        const currentSelection = GeoLeaf.Table.getSelectedIds();
		        const lastSelected = currentSelection[currentSelection.length - 1];

		        const targetIndex = rows.findIndex(r => r.getAttribute("data-feature-id") === targetId);
		        const lastIndex = rows.findIndex(r => r.getAttribute("data-feature-id") === lastSelected);

		        if (targetIndex === -1 || lastIndex === -1) return;

		        const start = Math.min(targetIndex, lastIndex);
		        const end = Math.max(targetIndex, lastIndex);

		        const rangeIds = [];
		        for (let i = start; i <= end; i++) {
		            const id = rows[i].getAttribute("data-feature-id");
		            if (id) rangeIds.push(id);
		        }

		        GeoLeaf.Table.setSelection(rangeIds, false);
		        updateToolbarButtonsState();
		    }

		    /**
		     * Toggle toutes les lignes (checkbox "tout s√©lectionner")
		     * @param {boolean} checked - √âtat du checkbox
		     * @private
		     */
		    function toggleAllRows(checked) {
		        const tbody = document.querySelector(".gl-table-panel__table tbody");
		        if (!tbody) return;

		        const rows = tbody.querySelectorAll("tr");
		        const ids = [];

		        rows.forEach(row => {
		            const id = row.getAttribute("data-feature-id");
		            if (id) {
		                ids.push(id);
		                row.classList.toggle("is-selected", checked);
		                const checkbox = row.querySelector(".gl-table-panel__checkbox");
		                if (checkbox) checkbox.checked = checked;
		            }
		        });

		        if (checked) {
		            GeoLeaf.Table.setSelection(ids, false);
		        } else {
		            GeoLeaf.Table.clearSelection();
		        }

		        updateToolbarButtonsState();
		    }

		    /**
		     * Met √† jour la s√©lection visuelle dans le tableau
		     * @param {HTMLElement} container - Conteneur du tableau
		     * @param {Set} selectedIds - IDs s√©lectionn√©s
		     */
		    GeoLeaf._TableRenderer.updateSelection = function (container, selectedIds) {
		        const tbody = container.querySelector(".gl-table-panel__table tbody");
		        if (!tbody) return;

		        const rows = tbody.querySelectorAll("tr");

		        rows.forEach(row => {
		            const id = row.getAttribute("data-feature-id");
		            const isSelected = selectedIds.has(String(id));

		            row.classList.toggle("is-selected", isSelected);

		            const checkbox = row.querySelector(".gl-table-panel__checkbox");
		            if (checkbox) {
		                checkbox.checked = isSelected;
		            }
		        });

		        // Mettre √† jour le checkbox "tout s√©lectionner"
		        const checkboxAll = container.querySelector(".gl-table-panel__checkbox-all");
		        if (checkboxAll) {
		            const totalRows = rows.length;
		            const selectedCount = selectedIds.size;
		            checkboxAll.checked = totalRows > 0 && selectedCount === totalRows;
		            checkboxAll.indeterminate = selectedCount > 0 && selectedCount < totalRows;
		        }

		        updateToolbarButtonsState();
		    };

		    /**
		     * Applique le virtual scrolling pour de grandes listes
		     * @param {HTMLElement} container - Conteneur
		     * @param {Array} features - Features compl√®tes
		     * @param {number} pageSize - Taille de page
		     * @private
		     */
		    function applyVirtualScrolling(container, features, pageSize) {
		        // Implementation simple : pagination au scroll
		        // Pour un vrai virtual scrolling, utiliser IntersectionObserver
		        Log.debug("[TableRenderer] Virtual scrolling activ√© pour", features.length, "entit√©s");
		        // TODO(v3.2): Implement custom cell renderers if necessary for advanced use cases
		    }

		    /**
		     * Met √† jour l'√©tat des boutons de la toolbar
		     * @private
		     */
		    function updateToolbarButtonsState() {
		        if (!GeoLeaf.Table) return;

		        const selectedCount = GeoLeaf.Table.getSelectedIds().length;

		        if (GeoLeaf._TablePanel && typeof GeoLeaf._TablePanel.updateToolbarButtons === "function") {
		            GeoLeaf._TablePanel.updateToolbarButtons(selectedCount);
		        }
		    }

		    /**
		     * Compteur interne pour g√©n√©rer des IDs synth√©tiques
		     * @type {number}
		     * @private
		     */
		    let _syntheticIdCounter = 0;

		    /**
		     * R√©cup√®re l'ID d'une feature de mani√®re fiable
		     * Parcourt plusieurs propri√©t√©s candidates puis g√©n√®re un ID synth√©tique si n√©cessaire
		     * @param {Object} feature - Feature GeoJSON
		     * @returns {string}
		     * @private
		     */
		    function getFeatureId(feature) {
		        // 1. ID standard GeoJSON
		        if (feature.id != null && feature.id !== "") return String(feature.id);

		        const p = feature.properties;
		        if (!p) return "__gl_row_" + (_syntheticIdCounter++);

		        // 2. Propri√©t√©s d'identifiant courantes
		        if (p.id != null && p.id !== "") return String(p.id);
		        if (p.fid != null && p.fid !== "") return String(p.fid);
		        if (p.osm_id != null && p.osm_id !== "") return String(p.osm_id);
		        if (p.OBJECTID != null && p.OBJECTID !== "") return String(p.OBJECTID);
		        if (p.SITE_ID != null && p.SITE_ID !== "") return String(p.SITE_ID);
		        if (p.code != null && p.code !== "") return String(p.code);
		        if (p.IN1 != null && p.IN1 !== "") return String(p.IN1);

		        // 3. Fallback : ID synth√©tique bas√© sur un compteur
		        return "__gl_row_" + (_syntheticIdCounter++);
		    }

		    /**
		     * R√©cup√®re une valeur imbriqu√©e dans un objet
		     * @param {Object} obj - Objet source
		     * @param {string} path - Chemin avec notation point
		     * @returns {*}
		     * @private
		     */
		    function getNestedValue(obj, path) {
		        if (!obj || !path) return null;
		        return path.split('.').reduce((current, prop) =>
		            current && current[prop] !== undefined ? current[prop] : null, obj);
		    }

		    /**
		     * Formate une valeur selon son type
		     * @param {*} value - Valeur √† formater
		     * @param {string} type - Type de donn√©es (string, number, date)
		     * @returns {string}
		     * @private
		     */
		    function formatValue(value, type) {
		        if (value == null || value === "") return "‚Äì";

		        if (type === "number") {
		            const num = Number(value);
		            if (isNaN(num)) return String(value);
		            // Formater avec s√©parateurs de milliers
		            return num.toLocaleString("fr-FR");
		        }

		        if (type === "date") {
		            const date = new Date(value);
		            if (isNaN(date.getTime())) return String(value);
		            return date.toLocaleDateString("fr-FR");
		        }

		        return String(value);
		    }

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return renderer;
	}

	requireRenderer();

	var geoleaf_table = {};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredGeoleaf_table;

	function requireGeoleaf_table () {
		if (hasRequiredGeoleaf_table) return geoleaf_table;
		hasRequiredGeoleaf_table = 1;
		/**
		 * GeoLeaf Table Module
		 * Affichage tabulaire des donn√©es cartographiques avec tri, recherche et s√©lection
		 * Version: 1.0.0
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log;

		    /**
		     * Module GeoLeaf.Table
		     * Vue tabulaire compl√©mentaire √† la carte
		     */
		    const TableModule = {
		        /**
		         * R√©f√©rence vers la carte Leaflet
		         * @type {L.Map|null}
		         */
		        _map: null,

		        /**
		         * Configuration du module table depuis geoleaf.config.json
		         * @type {Object|null}
		         */
		        _config: null,

		        /**
		         * Couche actuellement affich√©e dans le tableau
		         * @type {string|null}
		         */
		        _currentLayerId: null,

		        /**
		         * IDs des entit√©s s√©lectionn√©es
		         * @type {Set<string>}
		         */
		        _selectedIds: new Set(),

		        /**
		         * Donn√©es en cache (features filtr√©es)
		         * @type {Array}
		         */
		        _cachedData: [],

		        /**
		         * Mapping featureId ‚Üí index dans _cachedData (synchronis√© avec le renderer)
		         * @type {Map<string, number>}
		         */
		        _featureIdMap: new Map(),

		        /**
		         * Couches Leaflet de surbrillance actuellement actives
		         * @type {Array<L.Layer>}
		         */
		        _highlightLayers: [],

		        /**
		         * Indique si la surbrillance est activ√©e
		         * @type {boolean}
		         */
		        _highlightActive: false,

		        /**
		         * √âtat actuel du tri
		         * @type {Object}
		         */
		        _sortState: {
		            field: null,
		            direction: null // 'asc' | 'desc' | null
		        },

		        /**
		         * Conteneur DOM du tableau
		         * @type {HTMLElement|null}
		         */
		        _container: null,

		        /**
		         * Indique si le tableau est visible
		         * @type {boolean}
		         */
		        _isVisible: false,

		        /**
		         * Initialise le module Table
		         * @param {Object} options - Options d'initialisation
		         * @param {L.Map} options.map - Instance de la carte Leaflet
		         * @param {Object} [options.config] - Configuration personnalis√©e
		         */
		        init(options) {
		            if (!options || !options.map) {
		                Log.error("[Table] init() n√©cessite une instance de carte Leaflet");
		                return;
		            }

		            this._map = options.map;

		            // R√©cup√©rer la config depuis GeoLeaf.Config
		            const globalConfig = GeoLeaf.Config ? GeoLeaf.Config.get("tableConfig") : null;
		            this._config = Object.assign({
		                enabled: true,
		                defaultVisible: false,
		                pageSize: 50,
		                maxRowsPerLayer: 1000,
		                enableExportButton: true,
		                virtualScrolling: true,
		                defaultHeight: "40%",
		                minHeight: "20%",
		                maxHeight: "60%",
		                resizable: false
		            }, globalConfig, options.config);

		            if (!this._config.enabled) {
		                Log.info("[Table] Module d√©sactiv√© via configuration");
		                return;
		            }

		            Log.info("[Table] Initialisation du module Table", this._config);

		            // Cr√©er le panel si besoin
		            if (GeoLeaf._TablePanel && typeof GeoLeaf._TablePanel.create === "function") {
		                this._container = GeoLeaf._TablePanel.create(this._map, this._config);
		            } else {
		                Log.error("[Table] Module table/panel.js non charg√©");
		                return;
		            }

		            // D√©finir la visibilit√© initiale
		            if (this._config.defaultVisible) {
		                this.show();
		            }

		            // √âcouter les √©v√©nements carte
		            this._attachMapEvents();

		            Log.info("[Table] Module Table initialis√© avec succ√®s");
		        },

		        /**
		         * Attache les listeners d'√©v√©nements Leaflet
		         * @private
		         */
		        _attachMapEvents() {
		            if (!this._map) return;

		            // Timer pour debounce du rafra√Æchissement du s√©lecteur
		            let refreshSelectorTimer = null;
		            const debouncedRefreshSelector = () => {
		                if (refreshSelectorTimer) clearTimeout(refreshSelectorTimer);
		                refreshSelectorTimer = setTimeout(() => {
		                    if (GeoLeaf._TablePanel && typeof GeoLeaf._TablePanel.refreshLayerSelector === "function") {
		                        GeoLeaf._TablePanel.refreshLayerSelector();
		                    }
		                }, 150);
		            };

		            // Synchroniser avec les changements de filtres
		            this._map.on("geoleaf:filters:changed", () => {
		                if (this._isVisible && this._currentLayerId) {
		                    this.refresh();
		                }
		            });

		            // Rafra√Æchir le s√©lecteur quand les couches GeoJSON sont charg√©es
		            this._map.on("geoleaf:geojson:layers-loaded", () => {
		                Log.debug("[Table] √âv√©nement layers-loaded re√ßu, rafra√Æchissement du s√©lecteur");
		                debouncedRefreshSelector();
		            });

		            // Rafra√Æchir le s√©lecteur quand un th√®me est appliqu√©
		            // (c'est √† ce moment que la visibilit√© est r√©ellement d√©finie)
		            document.addEventListener("geoleaf:theme:applied", () => {
		                Log.debug("[Table] √âv√©nement theme:applied re√ßu, rafra√Æchissement du s√©lecteur");
		                debouncedRefreshSelector();
		            });

		            // Synchroniser avec les changements de visibilit√© des couches
		            this._map.on("geoleaf:geojson:visibility-changed", (e) => {
		                // Rafra√Æchir le s√©lecteur (debounced pour grouper les changements multiples)
		                debouncedRefreshSelector();

		                // Si la couche active est celle qui a chang√© de visibilit√©
		                if (this._currentLayerId === e.layerId) {
		                    if (e.visible) {
		                        this.refresh();
		                    } else {
		                        // La couche active a √©t√© masqu√©e : basculer sur la premi√®re couche visible
		                        // Attendre le debounce pour que le s√©lecteur soit √† jour
		                        setTimeout(() => {
		                            const available = this._getAvailableVisibleLayers();
		                            if (available.length > 0) {
		                                this.setLayer(available[0].id);
		                                const select = document.querySelector("[data-table-layer-select]");
		                                if (select) select.value = available[0].id;
		                            } else {
		                                this.setLayer("");
		                            }
		                        }, 200);
		                    }
		                }
		            });
		        },

		        /**
		         * Affiche le tableau
		         */
		        show() {
		            if (!this._container) {
		                Log.warn("[Table] Conteneur non initialis√©");
		                return;
		            }

		            this._container.classList.add("is-visible");
		            this._isVisible = true;

		            this._fireEvent("table:opened", {});
		            Log.debug("[Table] Tableau affich√©");
		        },

		        /**
		         * Masque le tableau
		         */
		        hide() {
		            if (!this._container) return;

		            // Nettoyer la surbrillance
		            this._clearHighlightLayers();
		            this._highlightActive = false;

		            this._container.classList.remove("is-visible");
		            this._isVisible = false;

		            this._fireEvent("table:closed", {});
		            Log.debug("[Table] Tableau masqu√©");
		        },

		        /**
		         * Toggle la visibilit√© du tableau
		         */
		        toggle() {
		            if (this._isVisible) {
		                this.hide();
		            } else {
		                this.show();
		            }
		        },

		        /**
		         * D√©finit la couche √† afficher dans le tableau
		         * @param {string} layerId - ID de la couche
		         */
		        setLayer(layerId) {
		            Log.debug("[Table] setLayer appel√© avec:", layerId);

		            // Si layerId est vide, vider le tableau
		            if (!layerId) {
		                this._currentLayerId = null;
		                this._selectedIds.clear();
		                this._clearHighlightLayers();
		                this._highlightActive = false;
		                this._featureIdMap.clear();
		                this._sortState = { field: null, direction: null };
		                this._cachedData = [];

		                // Vider le tableau visuellement
		                if (GeoLeaf._TableRenderer && this._container) {
		                    GeoLeaf._TableRenderer.render(this._container, {
		                        layerId: null,
		                        features: [],
		                        selectedIds: this._selectedIds,
		                        sortState: this._sortState,
		                        config: this._config
		                    });
		                }

		                this._fireEvent("table:layerChanged", { layerId: null });
		                Log.debug("[Table] Tableau vid√© (aucune couche s√©lectionn√©e)");
		                return;
		            }

		            const layers = this._getAvailableLayers();
		            const layer = layers.find(l => l.id === layerId);

		            if (!layer) {
		                Log.warn("[Table] Couche introuvable ou non activ√©e pour le tableau:", layerId);
		                return;
		            }

		            this._currentLayerId = layerId;
		            this._selectedIds.clear();
		            this._clearHighlightLayers();
		            this._highlightActive = false;
		            this._sortState = { field: null, direction: null };

		            // D√©finir le tri par d√©faut depuis la config du layer
		            const layerData = GeoLeaf.GeoJSON ? GeoLeaf.GeoJSON.getLayerData(layerId) : null;
		            if (layerData && layerData.config && layerData.config.table && layerData.config.table.defaultSort) {
		                this._sortState.field = layerData.config.table.defaultSort.field;
		                this._sortState.direction = layerData.config.table.defaultSort.direction || layerData.config.table.defaultSort.order || "asc";
		            }

		            this.refresh();

		            this._fireEvent("table:layerChanged", { layerId });
		            Log.debug("[Table] Couche chang√©e:", layerId);
		        },

		        /**
		         * Rafra√Æchit les donn√©es affich√©es dans le tableau
		         */
		        refresh() {
		            if (!this._currentLayerId) {
		                Log.debug("[Table] Aucune couche s√©lectionn√©e, impossible de rafra√Æchir");
		                return;
		            }

		            // R√©cup√©rer les donn√©es depuis GeoJSON
		            const features = this._getLayerFeatures(this._currentLayerId);
		            this._cachedData = features;

		            // Construire le mapping ID‚Üíindex (miroir de la logique du renderer)
		            this._featureIdMap.clear();
		            let syntheticCounter = 0;
		            features.forEach((feature, index) => {
		                const id = this._resolveFeatureId(feature, syntheticCounter);
		                if (id.startsWith("__gl_row_")) syntheticCounter++;
		                this._featureIdMap.set(id, index);
		            });

		            Log.debug("[Table] Features r√©cup√©r√©es:", features.length);

		            // Appliquer le tri si d√©fini
		            if (this._sortState.field && this._sortState.direction) {
		                this._applySorting();
		            }

		            // Rafra√Æchir le rendu
		            if (GeoLeaf._TableRenderer && typeof GeoLeaf._TableRenderer.render === "function") {
		                GeoLeaf._TableRenderer.render(this._container, {
		                    layerId: this._currentLayerId,
		                    features: this._cachedData,
		                    selectedIds: this._selectedIds,
		                    sortState: this._sortState,
		                    config: this._config
		                });
		            } else {
		                Log.error("[Table] Renderer non disponible");
		            }

		            Log.debug("[Table] Donn√©es rafra√Æchies:", features.length, "entit√©s");
		        },

		        /**
		         * R√©cup√®re les features d'une couche avec les filtres appliqu√©s
		         * @param {string} layerId - ID de la couche
		         * @returns {Array} Features
		         * @private
		         */
		        _getLayerFeatures(layerId) {
		            if (!GeoLeaf.GeoJSON || typeof GeoLeaf.GeoJSON.getLayerData !== "function") {
		                Log.warn("[Table] Module GeoJSON non disponible");
		                return [];
		            }

		            const layerData = GeoLeaf.GeoJSON.getLayerData(layerId);

		            if (!layerData || !layerData.features) {
		                Log.warn("[Table] Aucune donn√©e pour la couche:", layerId);
		                return [];
		            }

		            Log.debug("[Table] _getLayerFeatures - Nombre de features:", layerData.features.length);

		            // Appliquer la limite de lignes
		            const maxRows = this._config.maxRowsPerLayer || 1000;
		            if (layerData.features.length > maxRows) {
		                Log.warn("[Table] Donn√©es volumineuses (" + layerData.features.length + " entit√©s). Limit√© √† " + maxRows);
		                return layerData.features.slice(0, maxRows);
		            }

		            return layerData.features || [];
		        },

		        /**
		         * R√©cup√®re les couches disponibles pour le tableau (table.enabled)
		         * @returns {Array} Liste des couches avec table.enabled = true
		         * @private
		         */
		        _getAvailableLayers() {
		            if (!GeoLeaf.GeoJSON || typeof GeoLeaf.GeoJSON.getAllLayers !== "function") {
		                return [];
		            }

		            const allLayers = GeoLeaf.GeoJSON.getAllLayers();
		            const availableLayers = [];

		            allLayers.forEach(layer => {
		                const layerData = GeoLeaf.GeoJSON.getLayerData(layer.id);
		                if (layerData && layerData.config && layerData.config.table && layerData.config.table.enabled) {
		                    availableLayers.push({
		                        id: layer.id,
		                        label: layer.label || layer.id,
		                        config: layerData.config.table
		                    });
		                }
		            });

		            return availableLayers;
		        },

		        /**
		         * R√©cup√®re les couches disponibles ET visibles pour le tableau
		         * @returns {Array} Liste des couches avec table.enabled = true et visibles sur la carte
		         * @private
		         */
		        _getAvailableVisibleLayers() {
		            const available = this._getAvailableLayers();
		            const VisibilityManager = GeoLeaf._LayerVisibilityManager;

		            return available.filter(layer => {
		                if (VisibilityManager && typeof VisibilityManager.getVisibilityState === "function") {
		                    const visState = VisibilityManager.getVisibilityState(layer.id);
		                    return visState && visState.current === true;
		                }
		                // Fallback : v√©rifier via layerData
		                const layerData = GeoLeaf.GeoJSON.getLayerData(layer.id);
		                return layerData && layerData._visibility && layerData._visibility.current === true;
		            });
		        },

		        /**
		         * Applique le tri sur les donn√©es en cache
		         * @private
		         */
		        _applySorting() {
		            if (!this._sortState.field || !this._sortState.direction) return;

		            const field = this._sortState.field;
		            const direction = this._sortState.direction;

		            this._cachedData.sort((a, b) => {
		                const valA = this._getNestedValue(a, field);
		                const valB = this._getNestedValue(b, field);

		                // Gestion des valeurs nulles
		                if (valA == null && valB == null) return 0;
		                if (valA == null) return direction === "asc" ? 1 : -1;
		                if (valB == null) return direction === "asc" ? -1 : 1;

		                // Comparaison
		                let result = 0;
		                if (typeof valA === "number" && typeof valB === "number") {
		                    result = valA - valB;
		                } else {
		                    result = String(valA).localeCompare(String(valB));
		                }

		                return direction === "asc" ? result : -result;
		            });

		            Log.debug("[Table] Tri appliqu√©:", field, direction);
		        },

		        /**
		         * Change le tri sur une colonne
		         * @param {string} field - Chemin du champ
		         */
		        sortByField(field) {
		            if (this._sortState.field === field) {
		                // Cycle : asc ‚Üí desc ‚Üí null
		                if (this._sortState.direction === "asc") {
		                    this._sortState.direction = "desc";
		                } else if (this._sortState.direction === "desc") {
		                    this._sortState.field = null;
		                    this._sortState.direction = null;
		                } else {
		                    this._sortState.direction = "asc";
		                }
		            } else {
		                this._sortState.field = field;
		                this._sortState.direction = "asc";
		            }

		            this.refresh();
		            this._fireEvent("table:sortChanged", this._sortState);
		        },

		        /**
		         * S√©lectionne ou d√©s√©lectionne des entit√©s
		         * @param {Array<string>} ids - IDs √† s√©lectionner
		         * @param {boolean} [add=false] - Ajouter √† la s√©lection existante ou remplacer
		         */
		        setSelection(ids, add = false) {
		            if (!add) {
		                this._selectedIds.clear();
		            }

		            ids.forEach(id => this._selectedIds.add(String(id)));

		            this._fireEvent("table:selectionChanged", {
		                layerId: this._currentLayerId,
		                selectedIds: Array.from(this._selectedIds)
		            });

		            // Rafra√Æchir le rendu pour mettre √† jour les cases coch√©es
		            if (GeoLeaf._TableRenderer && typeof GeoLeaf._TableRenderer.updateSelection === "function") {
		                GeoLeaf._TableRenderer.updateSelection(this._container, this._selectedIds);
		            }

		            Log.debug("[Table] S√©lection mise √† jour:", this._selectedIds.size, "entit√©s");
		        },

		        /**
		         * Retourne les IDs des entit√©s s√©lectionn√©es
		         * @returns {Array<string>}
		         */
		        getSelectedIds() {
		            return Array.from(this._selectedIds);
		        },

		        /**
		         * Efface la s√©lection
		         */
		        clearSelection() {
		            this._selectedIds.clear();
		            this._fireEvent("table:selectionChanged", {
		                layerId: this._currentLayerId,
		                selectedIds: []
		            });

		            if (GeoLeaf._TableRenderer && typeof GeoLeaf._TableRenderer.updateSelection === "function") {
		                GeoLeaf._TableRenderer.updateSelection(this._container, this._selectedIds);
		            }

		            Log.debug("[Table] S√©lection effac√©e");
		        },

		        /**
		         * Zoom sur les entit√©s s√©lectionn√©es
		         */
		        zoomToSelection() {
		            if (this._selectedIds.size === 0) {
		                Log.warn("[Table] Aucune entit√© s√©lectionn√©e pour le zoom");
		                return;
		            }

		            const selectedFeatures = this._getSelectedFeatures();
		            if (selectedFeatures.length === 0) {
		                Log.warn("[Table] Aucune feature trouv√©e pour les IDs s√©lectionn√©s");
		                return;
		            }

		            const bounds = L.latLngBounds([]);

		            selectedFeatures.forEach(feature => {
		                if (feature.geometry && feature.geometry.coordinates) {
		                    this._extendBoundsFromGeometry(bounds, feature.geometry);
		                }
		            });

		            if (bounds.isValid()) {
		                this._map.fitBounds(bounds, { padding: [50, 50], maxZoom: 16 });
		                this._fireEvent("table:zoomToSelection", {
		                    layerId: this._currentLayerId,
		                    selectedIds: Array.from(this._selectedIds)
		                });
		                Log.debug("[Table] Zoom sur la s√©lection (", selectedFeatures.length, "entit√©s)");
		            } else {
		                Log.warn("[Table] Bounds invalides pour la s√©lection");
		            }
		        },

		        /**
		         * Active/d√©sactive la surbrillance des entit√©s s√©lectionn√©es sur la carte
		         * @param {boolean} active - Activer ou non
		         */
		        highlightSelection(active) {
		            // Toujours nettoyer les anciennes surbrillances
		            this._clearHighlightLayers();

		            this._highlightActive = active;

		            if (!active) {
		                Log.debug("[Table] Surbrillance d√©sactiv√©e");
		                this._fireEvent("table:highlightSelection", {
		                    layerId: this._currentLayerId,
		                    selectedIds: Array.from(this._selectedIds),
		                    active: false
		                });
		                return;
		            }

		            if (this._selectedIds.size === 0) {
		                Log.warn("[Table] Aucune entit√© s√©lectionn√©e pour la surbrillance");
		                return;
		            }

		            const selectedFeatures = this._getSelectedFeatures();
		            if (selectedFeatures.length === 0) {
		                Log.warn("[Table] Aucune feature trouv√©e pour la surbrillance");
		                return;
		            }

		            // Style de surbrillance (contour jaune √©pais)
		            const highlightStyle = {
		                color: "#FFD600",
		                weight: 4,
		                opacity: 1,
		                fillOpacity: 0.15,
		                fillColor: "#FFD600",
		                dashArray: "",
		                interactive: false
		            };

		            selectedFeatures.forEach(feature => {
		                try {
		                    if (feature.geometry) {
		                        const geomType = feature.geometry.type;
		                        if (geomType === "Point") {
		                            // Pour les points, cr√©er un cercle de surbrillance
		                            const coords = feature.geometry.coordinates;
		                            const circle = L.circleMarker(
		                                [coords[1], coords[0]],
		                                {
		                                    radius: 14,
		                                    color: "#FFD600",
		                                    weight: 4,
		                                    opacity: 1,
		                                    fillOpacity: 0.25,
		                                    fillColor: "#FFD600",
		                                    interactive: false
		                                }
		                            );
		                            circle.addTo(this._map);
		                            this._highlightLayers.push(circle);
		                        } else {
		                            // Pour les polygones/polylines, superposer le contour
		                            const highlightLayer = L.geoJSON(feature, {
		                                style: function() { return highlightStyle; },
		                                interactive: false,
		                                pointToLayer: function(f, latlng) {
		                                    return L.circleMarker(latlng, highlightStyle);
		                                }
		                            });
		                            highlightLayer.addTo(this._map);
		                            this._highlightLayers.push(highlightLayer);
		                        }
		                    }
		                } catch (e) {
		                    Log.warn("[Table] Erreur surbrillance feature:", e);
		                }
		            });

		            this._fireEvent("table:highlightSelection", {
		                layerId: this._currentLayerId,
		                selectedIds: Array.from(this._selectedIds),
		                active: true
		            });

		            Log.debug("[Table] Surbrillance activ√©e pour", selectedFeatures.length, "entit√©s");
		        },

		        /**
		         * Supprime toutes les couches de surbrillance de la carte
		         * @private
		         */
		        _clearHighlightLayers() {
		            this._highlightLayers.forEach(layer => {
		                try {
		                    if (this._map && this._map.hasLayer(layer)) {
		                        this._map.removeLayer(layer);
		                    }
		                } catch (e) {
		                    // Silencieux
		                }
		            });
		            this._highlightLayers = [];
		        },

		        /**
		         * Exporte les entit√©s s√©lectionn√©es au format GeoJSON (t√©l√©chargement)
		         */
		        exportSelection() {
		            if (this._selectedIds.size === 0) {
		                Log.warn("[Table] Aucune entit√© s√©lectionn√©e pour l'export");
		                return;
		            }

		            const selectedFeatures = this._getSelectedFeatures();

		            if (selectedFeatures.length === 0) {
		                Log.warn("[Table] Aucune feature trouv√©e pour l'export");
		                return;
		            }

		            // Construire le GeoJSON FeatureCollection
		            const geojson = {
		                type: "FeatureCollection",
		                features: selectedFeatures.map(f => ({
		                    type: "Feature",
		                    properties: f.properties || {},
		                    geometry: f.geometry || null
		                }))
		            };

		            // T√©l√©charger le fichier
		            try {
		                const json = JSON.stringify(geojson, null, 2);
		                const blob = new Blob([json], { type: "application/geo+json" });
		                const url = URL.createObjectURL(blob);
		                const a = document.createElement("a");
		                a.href = url;
		                a.download = (this._currentLayerId || "export") + "_selection.geojson";
		                document.body.appendChild(a);
		                a.click();
		                document.body.removeChild(a);
		                URL.revokeObjectURL(url);

		                Log.info("[Table] Export GeoJSON:", selectedFeatures.length, "entit√©s export√©es");
		            } catch (e) {
		                Log.error("[Table] Erreur lors de l'export:", e);
		            }

		            this._fireEvent("table:exportSelection", {
		                layerId: this._currentLayerId,
		                selectedIds: Array.from(this._selectedIds),
		                rows: selectedFeatures
		            });
		        },

		        /**
		         * R√©cup√®re les features s√©lectionn√©es √† partir du cache via le mapping d'IDs
		         * @returns {Array} Features GeoJSON correspondant √† la s√©lection
		         * @private
		         */
		        _getSelectedFeatures() {
		            const result = [];
		            this._selectedIds.forEach(id => {
		                const index = this._featureIdMap.get(id);
		                if (index != null && this._cachedData[index]) {
		                    result.push(this._cachedData[index]);
		                }
		            });
		            return result;
		        },

		        /**
		         * R√©sout l'ID d'une feature en miroir de la logique du renderer
		         * @param {Object} feature - Feature GeoJSON
		         * @param {number} syntheticIndex - Index pour les IDs synth√©tiques
		         * @returns {string}
		         * @private
		         */
		        _resolveFeatureId(feature, syntheticIndex) {
		            // 1. ID standard GeoJSON
		            if (feature.id != null && feature.id !== "") return String(feature.id);

		            const p = feature.properties;
		            if (!p) return "__gl_row_" + syntheticIndex;

		            // 2. Propri√©t√©s d'identifiant courantes (miroir exact du renderer)
		            if (p.id != null && p.id !== "") return String(p.id);
		            if (p.fid != null && p.fid !== "") return String(p.fid);
		            if (p.osm_id != null && p.osm_id !== "") return String(p.osm_id);
		            if (p.OBJECTID != null && p.OBJECTID !== "") return String(p.OBJECTID);
		            if (p.SITE_ID != null && p.SITE_ID !== "") return String(p.SITE_ID);
		            if (p.code != null && p.code !== "") return String(p.code);
		            if (p.IN1 != null && p.IN1 !== "") return String(p.IN1);

		            // 3. Fallback : ID synth√©tique (miroir du renderer)
		            return "__gl_row_" + syntheticIndex;
		        },

		        /**
		         * √âtend les bounds √† partir d'une g√©om√©trie GeoJSON
		         * @param {L.LatLngBounds} bounds - Bounds √† √©tendre
		         * @param {Object} geometry - G√©om√©trie GeoJSON
		         * @private
		         */
		        _extendBoundsFromGeometry(bounds, geometry) {
		            const coords = geometry.coordinates;
		            const type = geometry.type;

		            if (type === "Point") {
		                bounds.extend([coords[1], coords[0]]);
		            } else if (type === "LineString") {
		                coords.forEach(c => bounds.extend([c[1], c[0]]));
		            } else if (type === "MultiLineString") {
		                coords.forEach(line => line.forEach(c => bounds.extend([c[1], c[0]])));
		            } else if (type === "Polygon") {
		                coords[0].forEach(c => bounds.extend([c[1], c[0]]));
		            } else if (type === "MultiPolygon") {
		                coords.forEach(poly => {
		                    poly[0].forEach(c => bounds.extend([c[1], c[0]]));
		                });
		            } else if (type === "MultiPoint") {
		                coords.forEach(c => bounds.extend([c[1], c[0]]));
		            }
		        },

		        /**
		         * R√©cup√®re une valeur imbriqu√©e dans un objet
		         * @param {Object} obj - Objet source
		         * @param {string} path - Chemin avec notation point
		         * @returns {*}
		         * @private
		         */
		        _getNestedValue(obj, path) {
		            if (!obj || !path) return null;
		            return path.split('.').reduce((current, prop) =>
		                current && current[prop] !== undefined ? current[prop] : null, obj);
		        },

		        /**
		         * √âmet un √©v√©nement personnalis√©
		         * @param {string} eventName - Nom de l'√©v√©nement
		         * @param {Object} detail - Donn√©es de l'√©v√©nement
		         * @private
		         */
		        _fireEvent(eventName, detail) {
		            if (this._map && typeof this._map.fire === "function") {
		                this._map.fire("geoleaf:" + eventName, detail);
		            }

		            if (typeof document !== "undefined" && document.dispatchEvent) {
		                document.dispatchEvent(new CustomEvent("geoleaf:" + eventName, { detail }));
		            }
		        }
		    };

		    // Exposer le module
		    GeoLeaf.Table = TableModule;

		})(typeof window !== "undefined" ? window : commonjsGlobal);
		return geoleaf_table;
	}

	requireGeoleaf_table();

	var moduleManager = {};

	/**
	 * API Module Manager - Sprint 4.3 (Version Robuste)
	 * Gestionnaire centralis√© d'acc√®s aux modules GeoLeaf
	 * @module APIModuleManager
	 */

	var hasRequiredModuleManager;

	function requireModuleManager () {
		if (hasRequiredModuleManager) return moduleManager;
		hasRequiredModuleManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Gestionnaire d'acc√®s aux modules GeoLeaf
		     */
		    class APIModuleManager {
		        constructor() {
		            this.modules = new Map();
		            this.aliases = new Map();
		            this.isInitialized = false;
		            this.stats = {
		                totalModules: 0,
		                accessCount: 0,
		                errors: 0
		            };
		        }

		        /**
		         * Initialise le gestionnaire avec les modules existants
		         * @returns {boolean} Succ√®s de l'initialisation
		         */
		        init() {
		            try {
		                if (this.isInitialized) {
		                    if (Log) Log.debug('[APIModuleManager] Already initialized');
		                    return true;
		                }

		                if (Log) Log.info('[APIModuleManager] Initializing module manager');

		                // Scanner tous les modules disponibles dans le namespace GeoLeaf
		                this._scanExistingModules();

		                // Configurer les alias pour compatibilit√©
		                this._setupAliases();

		                this.isInitialized = true;

		                if (Log) Log.info(`[APIModuleManager] Initialized with ${this.stats.totalModules} modules`);
		                return true;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error('[APIModuleManager] Initialization failed:', error);
		                return false;
		            }
		        }

		        /**
		         * Scanner les modules existants dans GeoLeaf
		         * @private
		         */
		        _scanExistingModules() {
		            if (!global.GeoLeaf) return;

		            const moduleList = [
		                'Core', 'UI', 'Config', 'Baselayers', 'BaseLayers',
		                'POI', 'GeoJSON', 'Route', 'Legend', 'LayerManager',
		                'Storage', 'Filters', 'Log', 'Security', 'Utils',
		                'Constants', 'Validators', 'Errors'
		            ];

		            moduleList.forEach(name => {
		                if (global.GeoLeaf[name]) {
		                    this.modules.set(name, global.GeoLeaf[name]);
		                    this.stats.totalModules++;
		                }
		            });

		            // Scanner les modules priv√©s (pr√©fixe _)
		            Object.keys(global.GeoLeaf).forEach(key => {
		                if (key.startsWith('_') && !this.modules.has(key)) {
		                    this.modules.set(key, global.GeoLeaf[key]);
		                    this.stats.totalModules++;
		                }
		            });
		        }

		        /**
		         * Configure les alias pour compatibilit√©
		         * @private
		         */
		        _setupAliases() {
		            const aliases = {
		                'Baselayers': 'BaseLayers',
		                'BaseLayers': 'Baselayers',
		                'Logger': 'Log',
		                'Log': 'Logger'
		            };

		            Object.entries(aliases).forEach(([alias, target]) => {
		                if (this.modules.has(target)) {
		                    this.aliases.set(alias, target);
		                }
		            });
		        }

		        /**
		         * Obtient un module par nom
		         * @param {string} name - Nom du module
		         * @returns {*} Module ou null si non trouv√©
		         */
		        getModule(name) {
		            try {
		                this.stats.accessCount++;

		                if (!name || typeof name !== 'string') {
		                    if (Log) Log.warn(`[APIModuleManager] Invalid module name:`, name);
		                    this.stats.errors++;
		                    return null;
		                }

		                // Recherche directe
		                if (this.modules.has(name)) {
		                    return this.modules.get(name);
		                }

		                // Recherche par alias
		                if (this.aliases.has(name)) {
		                    const targetName = this.aliases.get(name);
		                    return this.modules.get(targetName);
		                }

		                // Fallback vers acc√®s global direct
		                if (global.GeoLeaf && global.GeoLeaf[name]) {
		                    // Ajouter √† notre cache pour les prochains acc√®s
		                    this.modules.set(name, global.GeoLeaf[name]);
		                    this.stats.totalModules++;
		                    return global.GeoLeaf[name];
		                }

		                // Module non trouv√©
		                if (Log) Log.debug(`[APIModuleManager] Module '${name}' not found`);
		                return null;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error(`[APIModuleManager] Error accessing module '${name}':`, error);
		                return null;
		            }
		        }

		        /**
		         * Enregistre manuellement un module
		         * @param {string} name - Nom du module
		         * @param {*} module - Instance du module
		         */
		        registerModule(name, module) {
		            try {
		                if (!name || typeof name !== 'string') {
		                    throw new Error('Module name must be a non-empty string');
		                }

		                if (!module) {
		                    throw new Error('Module cannot be null or undefined');
		                }

		                this.modules.set(name, module);
		                this.stats.totalModules++;

		                if (Log) Log.debug(`[APIModuleManager] Module '${name}' registered`);
		                return true;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error(`[APIModuleManager] Failed to register module '${name}':`, error);
		                return false;
		            }
		        }

		        /**
		         * V√©rifie si un module existe
		         * @param {string} name - Nom du module
		         * @returns {boolean}
		         */
		        hasModule(name) {
		            try {
		                return this.modules.has(name) ||
		                       this.aliases.has(name) ||
		                       !!(global.GeoLeaf && global.GeoLeaf[name]);
		            } catch (error) {
		                if (Log) Log.error(`[APIModuleManager] Error checking module '${name}':`, error);
		                return false;
		            }
		        }

		        /**
		         * Obtient la liste des modules disponibles
		         * @returns {Array<string>}
		         */
		        getModuleList() {
		            const moduleNames = Array.from(this.modules.keys());

		            // Ajouter les modules du namespace global non encore dans notre cache
		            if (global.GeoLeaf) {
		                Object.keys(global.GeoLeaf).forEach(key => {
		                    if (!moduleNames.includes(key)) {
		                        moduleNames.push(key);
		                    }
		                });
		            }

		            return moduleNames.sort();
		        }

		        /**
		         * Obtient les statistiques d'usage
		         * @returns {Object}
		         */
		        getStats() {
		            return {
		                ...this.stats,
		                cachedModules: this.modules.size,
		                aliases: this.aliases.size,
		                isInitialized: this.isInitialized
		            };
		        }

		        /**
		         * Rafra√Æchit le cache des modules
		         */
		        refresh() {
		            if (Log) Log.info('[APIModuleManager] Refreshing module cache');

		            this.modules.clear();
		            this.aliases.clear();
		            this.stats.totalModules = 0;

		            this._scanExistingModules();
		            this._setupAliases();
		        }

		        /**
		         * R√©initialise le gestionnaire
		         */
		        reset() {
		            this.modules.clear();
		            this.aliases.clear();
		            this.isInitialized = false;
		            this.stats = {
		                totalModules: 0,
		                accessCount: 0,
		                errors: 0
		            };

		            if (Log) Log.info('[APIModuleManager] Manager reset');
		        }
		    }

		    // Export vers le namespace GeoLeaf
		    GeoLeaf.API = GeoLeaf.API || {};
		    GeoLeaf.API.APIModuleManager = APIModuleManager; // Nom correct pour controller
		    GeoLeaf.API.ModuleManager = APIModuleManager; // Alias pour compatibilit√©

		    if (Log) Log.info('[APIModuleManager] Module manager loaded (Sprint 4.3 - Robust)');

		})(window);
		return moduleManager;
	}

	requireModuleManager();

	var initializationManager = {};

	/**
	 * API Initialization Manager - Sprint 4.3 (Version Robuste)
	 * Gestionnaire des op√©rations d'initialisation GeoLeaf
	 * @module APIInitializationManager
	 */

	var hasRequiredInitializationManager;

	function requireInitializationManager () {
		if (hasRequiredInitializationManager) return initializationManager;
		hasRequiredInitializationManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Gestionnaire d'initialisation pour GeoLeaf
		     */
		    class APIInitializationManager {
		        constructor() {
		            this.isReady = true; // Manager pr√™t sans init s√©par√©e
		            this.pendingPromise = null;
		            this.cancelled = false;
		            this.stats = {
		                initCalls: 0,
		                configLoads: 0,
		                errors: 0
		            };
		        }

		        /**
		         * Initialise GeoLeaf avec les options fournies
		         * @param {Object} options - Options d'initialisation
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {*} R√©sultat de l'initialisation
		         */
		        init(options, getModule) {
		            try {
		                this.stats.initCalls++;

		                if (Log) Log.info('[APIInitializationManager] Initializing GeoLeaf');

		                // Validation des param√®tres
		                const validationResult = this._validateInitParams(options, getModule);
		                if (!validationResult.valid) {
		                    throw new Error(validationResult.error);
		                }

		                // Obtenir le module Core
		                const Core = getModule("Core");
		                if (!Core || typeof Core.init !== "function") {
		                    throw new Error("[GeoLeaf.init] GeoLeaf.Core.init() is not available. Core module must be loaded before API.");
		                }

		                // Normaliser les options
		                const normalizedOptions = this._normalizeInitOptions(options);
		                if (Log) Log.info('[APIInitializationManager] Initializing with options:', normalizedOptions);

		                // Appeler l'initialisation du Core
		                const result = Core.init(normalizedOptions);

		                if (Log) Log.info('[APIInitializationManager] Initialization completed successfully');
		                return result;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error('[APIInitializationManager] Initialization failed:', error);
		                throw error;
		            }
		        }

		        /**
		         * Charge une configuration depuis URL ou donn√©es
		         * @param {string|Object} input - Source de configuration
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {Promise<Object>} Donn√©es de configuration
		         */
		        async loadConfig(input, getModule) {
		            try {
		                this.stats.configLoads++;

		                if (Log) Log.info('[APIInitializationManager] Loading configuration');

		                // Validation des param√®tres
		                if (!input) {
		                    throw new Error('Configuration input is required');
		                }

		                if (!getModule || typeof getModule !== 'function') {
		                    throw new Error('getModule function is required');
		                }

		                // Obtenir le module Config
		                const Config = getModule("Config");
		                if (!Config || typeof Config.init !== "function") {
		                    throw new Error("[GeoLeaf.loadConfig] GeoLeaf.Config.init() is not available. Config module must be loaded.");
		                }

		                // Normaliser les options de configuration
		                const options = this._normalizeConfigOptions(input);

		                // Annuler la requ√™te pr√©c√©dente si elle existe
		                if (this.pendingPromise) {
		                    this.cancelled = true;
		                    if (Log) Log.info('[APIInitializationManager] Cancelling previous config load request');
		                }

		                this.cancelled = false;

		                // Charger la configuration
		                this.pendingPromise = Config.init(options);
		                const result = await this.pendingPromise;

		                this.pendingPromise = null;

		                if (this.cancelled) {
		                    if (Log) Log.info('[APIInitializationManager] Config load was cancelled');
		                    return null;
		                }

		                if (Log) Log.info('[APIInitializationManager] Configuration loaded successfully');
		                return result;

		            } catch (error) {
		                this.stats.errors++;
		                this.pendingPromise = null;
		                if (Log) Log.error('[APIInitializationManager] Config loading failed:', error);
		                throw error;
		            }
		        }

		        /**
		         * Change le th√®me de l'interface
		         * @param {string} theme - Nom du th√®me
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {boolean} Succ√®s du changement
		         */
		        setTheme(theme, getModule) {
		            try {
		                if (Log) Log.info(`[APIInitializationManager] Setting theme: ${theme}`);

		                // Validation
		                if (!theme || typeof theme !== 'string') {
		                    throw new Error('Theme name must be a non-empty string');
		                }

		                if (!getModule || typeof getModule !== 'function') {
		                    throw new Error('getModule function is required');
		                }

		                // Obtenir le module UI
		                const UI = getModule("UI");
		                if (!UI) {
		                    throw new Error("[GeoLeaf.setTheme] GeoLeaf.UI is not available. UI module must be loaded.");
		                }

		                // Appliquer le th√®me - utilise applyTheme comme dans geoleaf.ui.js
		                let result = false;
		                if (typeof UI.applyTheme === 'function') {
		                    result = UI.applyTheme(theme);
		                } else if (typeof UI.setTheme === 'function') {
		                    result = UI.setTheme(theme);
		                } else if (typeof UI.theme === 'function') {
		                    result = UI.theme(theme);
		                } else {
		                    throw new Error('UI module does not provide applyTheme, setTheme or theme method');
		                }

		                if (Log) Log.info(`[APIInitializationManager] Theme '${theme}' applied successfully`);
		                return result;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error(`[APIInitializationManager] Failed to set theme '${theme}':`, error);
		                return false;
		            }
		        }

		        /**
		         * Valide les param√®tres d'initialisation
		         * @private
		         */
		        _validateInitParams(options, getModule) {
		            if (!options || typeof options !== "object") {
		                return { valid: false, error: "[GeoLeaf.init] An options object is required." };
		            }

		            if (!getModule || typeof getModule !== 'function') {
		                return { valid: false, error: "getModule function is required" };
		            }

		            return { valid: true };
		        }

		        /**
		         * Normalise les options d'initialisation
		         * @private
		         */
		        _normalizeInitOptions(options) {
		            // Mode "structur√©" (recommand√©) : options.map / options.ui
		            let mapOpts = options.map || {};
		            let uiOpts = options.ui || {};

		            // Mode "aplati" (legacy) : target/mapId / center / zoom / theme √† la racine
		            if (!options.map) {
		                mapOpts = {
		                    target: options.target || options.mapId,
		                    center: options.center,
		                    zoom: options.zoom
		                };
		                uiOpts = {
		                    theme: options.theme
		                };
		            }

		            // Validation du target
		            const target = mapOpts.target || mapOpts.mapId;
		            if (!target) {
		                throw new Error("[GeoLeaf.init] The 'map.target' (or 'target'/'mapId') option is required.");
		            }

		            // R√©cup√©rer les constantes par d√©faut
		            const CONSTANTS = global.GeoLeaf.CONSTANTS || {};
		            const center = Array.isArray(mapOpts.center) ? mapOpts.center : CONSTANTS.DEFAULT_CENTER || [0, 0];
		            const zoom = Number.isFinite(mapOpts.zoom) ? mapOpts.zoom : CONSTANTS.DEFAULT_ZOOM || 12;
		            const theme = uiOpts.theme || mapOpts.theme || "light";

		            // Adapter √† la signature Core.init
		            return {
		                mapId: String(target), // Core.init attend 'mapId' pas 'target'
		                center,
		                zoom,
		                theme
		            };
		        }

		        /**
		         * Normalise les options de configuration
		         * @private
		         */
		        _normalizeConfigOptions(input) {
		            if (typeof input === 'string') {
		                // URL string
		                return {
		                    source: 'url',
		                    url: input,
		                    autoEvent: true
		                };
		            } else if (input && typeof input === 'object') {
		                // Configuration object
		                return {
		                    source: input.url ? 'url' : 'data',
		                    url: input.url,
		                    data: input.data,
		                    profileId: input.profileId,
		                    autoEvent: input.autoEvent !== false, // true par d√©faut
		                    ...input
		                };
		            } else {
		                throw new Error('Configuration input must be a URL string or options object');
		            }
		        }

		        /**
		         * Obtient les statistiques du manager
		         * @returns {Object}
		         */
		        getStats() {
		            return {
		                ...this.stats,
		                isReady: this.isReady,
		                hasPendingRequest: !!this.pendingPromise
		            };
		        }

		        /**
		         * R√©initialise le manager
		         */
		        reset() {
		            if (this.pendingPromise) {
		                this.cancelled = true;
		            }

		            this.pendingPromise = null;
		            this.cancelled = false;
		            this.stats = {
		                initCalls: 0,
		                configLoads: 0,
		                errors: 0
		            };

		            if (Log) Log.info('[APIInitializationManager] Manager reset');
		        }
		    }

		    // Export vers le namespace GeoLeaf
		    GeoLeaf.API = GeoLeaf.API || {};
		    GeoLeaf.API.APIInitializationManager = APIInitializationManager; // Nom correct pour controller
		    GeoLeaf.API.InitializationManager = APIInitializationManager; // Alias pour compatibilit√©

		    if (Log) Log.info('[APIInitializationManager] Initialization manager loaded (Sprint 4.3 - Robust)');

		})(window);
		return initializationManager;
	}

	requireInitializationManager();

	var namespaceManager = {};

	/**
	 * API Namespace Manager - Sprint 4.3 (Version Robuste)
	 * Gestionnaire des op√©rations sur les namespaces GeoLeaf
	 * @module APINamespaceManager
	 */

	var hasRequiredNamespaceManager;

	function requireNamespaceManager () {
		if (hasRequiredNamespaceManager) return namespaceManager;
		hasRequiredNamespaceManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Gestionnaire des namespaces GeoLeaf
		     */
		    class APINamespaceManager {
		        constructor() {
		            this.isReady = true;
		            this.stats = {
		                operations: 0,
		                errors: 0
		            };
		        }

		        /**
		         * Initialise le gestionnaire avec la fonction d'acc√®s aux modules
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {boolean} Succ√®s
		         */
		        init(getModule) {
		            try {
		                if (!getModule || typeof getModule !== 'function') {
		                    throw new Error('getModule function is required');
		                }

		                this.getModule = getModule;

		                if (Log) Log.info('[APINamespaceManager] Namespace manager initialized');
		                return true;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error('[APINamespaceManager] Initialization failed:', error);
		                return false;
		            }
		        }

		        /**
		         * Obtient les statistiques
		         */
		        getStats() {
		            return {
		                ...this.stats,
		                isReady: this.isReady
		            };
		        }

		        /**
		         * R√©initialise le gestionnaire
		         */
		        reset() {
		            this.getModule = null;
		            this.stats = {
		                operations: 0,
		                errors: 0
		            };

		            if (Log) Log.info('[APINamespaceManager] Manager reset');
		        }
		    }

		    // Export vers le namespace GeoLeaf
		    GeoLeaf.API = GeoLeaf.API || {};
		    GeoLeaf.API.APINamespaceManager = APINamespaceManager; // Nom correct pour controller
		    GeoLeaf.API.NamespaceManager = APINamespaceManager; // Alias pour compatibilit√©

		    if (Log) Log.info('[APINamespaceManager] Namespace manager loaded (Sprint 4.3 - Robust)');

		})(window);
		return namespaceManager;
	}

	requireNamespaceManager();

	var factoryManager = {};

	/**
	 * API Factory Manager - Sprint 4.3 (Version Robuste)
	 * Gestionnaire pour la cr√©ation d'instances multi-cartes
	 * @module APIFactoryManager
	 */

	var hasRequiredFactoryManager;

	function requireFactoryManager () {
		if (hasRequiredFactoryManager) return factoryManager;
		hasRequiredFactoryManager = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Gestionnaire de factory pour multi-cartes
		     */
		    class APIFactoryManager {
		        constructor() {
		            this.isReady = true;
		            this.mapInstances = new Map();
		            this.stats = {
		                mapsCreated: 0,
		                errors: 0
		            };
		        }

		        /**
		         * Initialise le gestionnaire avec la fonction d'acc√®s aux modules
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {boolean} Succ√®s
		         */
		        init(getModule) {
		            try {
		                if (!getModule || typeof getModule !== 'function') {
		                    throw new Error('getModule function is required');
		                }

		                this.getModule = getModule;

		                if (Log) Log.info('[APIFactoryManager] Factory manager initialized');
		                return true;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error('[APIFactoryManager] Initialization failed:', error);
		                return false;
		            }
		        }

		        /**
		         * Cr√©e une nouvelle instance de carte
		         * @param {string} targetId - ID de l'√©l√©ment cible
		         * @param {Object} options - Options de configuration
		         * @param {Function} getModule - Fonction d'acc√®s aux modules
		         * @returns {*} Instance de carte ou null
		         */
		        createMap(targetId, options, getModule) {
		            try {
		                this.stats.mapsCreated++;

		                if (!targetId) {
		                    throw new Error('Target ID is required');
		                }

		                const Core = getModule('Core');
		                if (!Core || typeof Core.init !== 'function') {
		                    throw new Error('Core module not available for map creation');
		                }

		                // Cr√©er la carte avec les options fournies
		                const mapOptions = {
		                    target: targetId,
		                    ...options
		                };

		                const mapInstance = Core.init(mapOptions);

		                if (mapInstance) {
		                    this.mapInstances.set(targetId, mapInstance);
		                    if (Log) Log.info(`[APIFactoryManager] Map created for target: ${targetId}`);
		                }

		                return mapInstance;

		            } catch (error) {
		                this.stats.errors++;
		                if (Log) Log.error(`[APIFactoryManager] Failed to create map for ${targetId}:`, error);
		                return null;
		            }
		        }

		        /**
		         * Obtient une instance de carte par ID
		         * @param {string} targetId - ID de l'√©l√©ment cible
		         * @returns {*} Instance de carte ou null
		         */
		        getMapInstance(targetId) {
		            return this.mapInstances.get(targetId) || null;
		        }

		        /**
		         * Obtient toutes les instances de carte
		         * @returns {Array} Liste des instances
		         */
		        getAllMapInstances() {
		            return Array.from(this.mapInstances.values());
		        }

		        /**
		         * Obtient les statistiques
		         */
		        getStats() {
		            return {
		                ...this.stats,
		                activeInstances: this.mapInstances.size,
		                isReady: this.isReady
		            };
		        }

		        /**
		         * R√©initialise le gestionnaire
		         */
		        reset() {
		            this.mapInstances.clear();
		            this.getModule = null;
		            this.stats = {
		                mapsCreated: 0,
		                errors: 0
		            };

		            if (Log) Log.info('[APIFactoryManager] Manager reset');
		        }
		    }

		    // Export vers le namespace GeoLeaf
		    GeoLeaf.API = GeoLeaf.API || {};
		    GeoLeaf.API.APIFactoryManager = APIFactoryManager; // Nom correct pour controller
		    GeoLeaf.API.FactoryManager = APIFactoryManager; // Alias pour compatibilit√©

		    if (Log) Log.info('[APIFactoryManager] Factory manager loaded (Sprint 4.3 - Robust)');

		})(window);
		return factoryManager;
	}

	requireFactoryManager();

	var controller = {};

	/**
	 * API Controller - Sprint 4.3 (Version Robuste)
	 * Orchestrateur principal pour les op√©rations API GeoLeaf
	 * Architecture modulaire avec validation renforc√©e
	 * @module APIController
	 */

	var hasRequiredController;

	function requireController () {
		if (hasRequiredController) return controller;
		hasRequiredController = 1;
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const Log = GeoLeaf.Log || console;

		    /**
		     * Contr√¥leur principal pour l'API GeoLeaf
		     * G√®re l'orchestration des managers sp√©cialis√©s
		     */
		    class APIController {
		        constructor() {
		            this.isInitialized = false;
		            this.managers = {};
		            this.moduleAccessFn = null;

		            // √âtat de sanit√© du contr√¥leur
		            this.healthStatus = {
		                managers: 0,
		                errors: [],
		                lastUpdate: null
		            };
		        }

		        /**
		         * Initialise le contr√¥leur et tous ses managers
		         * @returns {boolean} Succ√®s de l'initialisation
		         */
		        init() {
		            try {
		                if (this.isInitialized) {
		                    if (Log) Log.debug('[APIController] Already initialized');
		                    return true;
		                }

		                if (Log) Log.info('[APIController] Initializing API controller (Sprint 4.3 - Robust)');

		                // Initialiser les managers dans l'ordre
		                this._initializeManagers();

		                // Configurer l'acc√®s aux modules
		                const success = this._setupModuleAccess();
		                if (!success) {
		                    throw new Error('Module access setup failed');
		                }

		                // Valider l'√©tat final
		                this._validateInitialization();

		                this.isInitialized = true;
		                this.healthStatus.lastUpdate = new Date().toISOString();

		                if (Log) Log.info('[APIController] API controller initialized successfully');
		                return true;

		            } catch (error) {
		                this.healthStatus.errors.push({
		                    message: error.message,
		                    timestamp: new Date().toISOString(),
		                    stack: error.stack
		                });

		                if (Log) Log.error('[APIController] Initialization failed:', error);
		                return false;
		            }
		        }

		        /**
		         * Initialise tous les managers disponibles
		         * @private
		         */
		        _initializeManagers() {
		            const managerTypes = ['module', 'initialization', 'namespace', 'factory'];

		            managerTypes.forEach(type => {
		                const ManagerClass = this._getManagerClass(type);
		                if (ManagerClass) {
		                    try {
		                        this.managers[type] = new ManagerClass();
		                        this.healthStatus.managers++;
		                        if (Log) Log.debug(`[APIController] ${type} manager loaded`);
		                    } catch (error) {
		                        if (Log) Log.warn(`[APIController] Failed to load ${type} manager:`, error);
		                        this.healthStatus.errors.push({
		                            manager: type,
		                            error: error.message
		                        });
		                    }
		                }
		            });

		            if (Log) Log.info(`[APIController] Loaded ${this.healthStatus.managers} managers`);
		        }

		        /**
		         * Obtient la classe d'un manager
		         * @private
		         */
		        _getManagerClass(type) {
		            const classNames = {
		                module: 'APIModuleManager',
		                initialization: 'APIInitializationManager',
		                namespace: 'APINamespaceManager',
		                factory: 'APIFactoryManager'
		            };

		            const className = classNames[type];
		            return GeoLeaf.API && GeoLeaf.API[className] ? GeoLeaf.API[className] : null;
		        }

		        /**
		         * Configure l'acc√®s aux modules
		         * @private
		         */
		        _setupModuleAccess() {
		            // Le module manager doit √™tre initialis√© en premier
		            if (!this.managers.module) {
		                if (Log) Log.error('[APIController] Module manager not available');
		                return false;
		            }

		            // Initialiser le module manager avec les modules existants
		            const initSuccess = this.managers.module.init ? this.managers.module.init() : true;
		            if (!initSuccess) {
		                if (Log) Log.error('[APIController] Module manager initialization failed');
		                return false;
		            }

		            // Cr√©er la fonction d'acc√®s aux modules avec validation
		            this.moduleAccessFn = (name) => {
		                try {
		                    if (!name || typeof name !== 'string') {
		                        if (Log) Log.warn('[APIController] Invalid module name:', name);
		                        return null;
		                    }

		                    if (this.managers.module && typeof this.managers.module.getModule === 'function') {
		                        return this.managers.module.getModule(name);
		                    }

		                    // Fallback vers l'acc√®s global
		                    if (global.GeoLeaf && global.GeoLeaf[name]) {
		                        return global.GeoLeaf[name];
		                    }

		                    return null;
		                } catch (error) {
		                    if (Log) Log.warn(`[APIController] Error accessing module ${name}:`, error);
		                    return null;
		                }
		            };

		            if (Log) Log.info('[APIController] Module access configured');
		            return true;
		        }

		        /**
		         * Valide l'√©tat de l'initialisation
		         * @private
		         */
		        _validateInitialization() {
		            const checks = [
		                { name: 'moduleAccessFn', value: this.moduleAccessFn, type: 'function' },
		                { name: 'managers', value: this.managers, type: 'object' },
		                { name: 'moduleManager', value: this.managers.module, type: 'object' }
		            ];

		            const failures = checks.filter(check => {
		                return !check.value || typeof check.value !== check.type;
		            });

		            if (failures.length > 0) {
		                const failureNames = failures.map(f => f.name).join(', ');
		                throw new Error(`Validation failed for: ${failureNames}`);
		            }

		            if (Log) Log.debug('[APIController] Validation passed');
		        }

		        /**
		         * GeoLeaf.init() - Initialisation de carte
		         */
		        geoleafInit(options) {
		            if (!this._ensureInitialized()) return null;

		            try {
		                if (!this.managers.initialization) {
		                    throw new Error('Initialization manager not available');
		                }

		                return this.managers.initialization.init(options, this.moduleAccessFn);
		            } catch (error) {
		                if (Log) Log.error('[APIController] geoleafInit failed:', error);
		                return null;
		            }
		        }

		        /**
		         * GeoLeaf.loadConfig() - Chargement configuration
		         */
		        geoleafLoadConfig(input) {
		            if (!this._ensureInitialized()) return Promise.resolve(null);

		            try {
		                if (!this.managers.initialization) {
		                    throw new Error('Initialization manager not available');
		                }

		                return this.managers.initialization.loadConfig(input, this.moduleAccessFn);
		            } catch (error) {
		                if (Log) Log.error('[APIController] geoleafLoadConfig failed:', error);
		                return Promise.resolve(null);
		            }
		        }

		        /**
		         * GeoLeaf.setTheme() - Changement de th√®me
		         */
		        geoleafSetTheme(theme) {
		            if (!this._ensureInitialized()) return false;

		            try {
		                if (!this.managers.initialization) {
		                    throw new Error('Initialization manager not available');
		                }

		                return this.managers.initialization.setTheme(theme, this.moduleAccessFn);
		            } catch (error) {
		                if (Log) Log.error('[APIController] geoleafSetTheme failed:', error);
		                return false;
		            }
		        }

		        /**
		         * GeoLeaf.createMap() - Cr√©ation multi-cartes
		         */
		        geoleafCreateMap(targetId, options) {
		            if (!this._ensureInitialized()) return null;

		            try {
		                if (!this.managers.factory) {
		                    throw new Error('Factory manager not available');
		                }

		                return this.managers.factory.createMap(targetId, options, this.moduleAccessFn);
		            } catch (error) {
		                if (Log) Log.error('[APIController] geoleafCreateMap failed:', error);
		                return null;
		            }
		        }

		        /**
		         * S'assure que le contr√¥leur est initialis√©
		         * @private
		         */
		        _ensureInitialized() {
		            if (!this.isInitialized) {
		                if (Log) Log.error('[APIController] Controller not initialized');
		                return false;
		            }
		            return true;
		        }

		        /**
		         * Obtient l'√©tat de sant√© du contr√¥leur
		         */
		        getHealthStatus() {
		            return {
		                ...this.healthStatus,
		                isInitialized: this.isInitialized,
		                managersCount: Object.keys(this.managers).length,
		                hasModuleAccess: !!this.moduleAccessFn
		            };
		        }

		        /**
		         * R√©initialise le contr√¥leur
		         */
		        reset() {
		            this.isInitialized = false;
		            this.managers = {};
		            this.moduleAccessFn = null;
		            this.healthStatus = {
		                managers: 0,
		                errors: [],
		                lastUpdate: null
		            };

		            if (Log) Log.info('[APIController] Controller reset');
		        }
		    }

		    // Export vers le namespace GeoLeaf
		    GeoLeaf.API = GeoLeaf.API || {};
		    GeoLeaf.API.Controller = APIController;

		    // Cr√©er et exposer une instance globale _APIController
		    if (!GeoLeaf._APIController) {
		        const controllerInstance = new APIController();

		        // Tentative d'initialisation automatique
		        const initSuccess = controllerInstance.init();
		        if (initSuccess) {
		            GeoLeaf._APIController = controllerInstance;
		            if (Log) Log.info('[APIController] Global instance created and initialized successfully');
		        } else {
		            if (Log) Log.warn('[APIController] Failed to auto-initialize - will try manual init later');
		            GeoLeaf._APIController = controllerInstance; // Exposer quand m√™me pour debug
		        }
		    }

		    if (Log) Log.info('[APIController] Controller class loaded (Sprint 4.3 - Robust)');

		})(window);
		return controller;
	}

	requireController();

	var geoleaf_api$1 = {exports: {}};

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */
	var geoleaf_api = geoleaf_api$1.exports;

	var hasRequiredGeoleaf_api;

	function requireGeoleaf_api () {
		if (hasRequiredGeoleaf_api) return geoleaf_api$1.exports;
		hasRequiredGeoleaf_api = 1;
		(function (module) {
			/*!
			 * GeoLeaf ‚Äì API publique unifi√©e
			 * Point d'entr√©e pour futurs bundles (CDN / UMD / ESM)
			 * Phase 4.3 ‚Äî Architecture Controller refactoris√©e robuste
			 */
			/* global define */
			(function (root, factory) {

			    // UMD minimal : AMD, CommonJS, global
			    if (module.exports) {
			        module.exports = factory(root);
			    } else {
			        root.GeoLeaf = factory(root);
			    }
			}(typeof self !== "undefined" ? self : geoleaf_api, function (root) {

			    // ---------------------------------------------------------------------
			    // Architecture Controller - D√©l√©gation robuste vers APIController
			    // ---------------------------------------------------------------------

			    // R√©cup√©ration de l'√©ventuel GeoLeaf d√©j√† attach√© par les modules
			    const existing = root.GeoLeaf || {};

			    // Logger unifi√© (d√©fini par geoleaf.logger-shim.js)
			    const Log = existing.Log;

			    // V√©rification de la disponibilit√© d'APIController
			    const APIController = existing._APIController;

			    if (!APIController) {
			        Log.error("[GeoLeaf.API] APIController non disponible. Les modules API Controller doivent √™tre charg√©s avant geoleaf.api.js");
			        throw new Error("APIController manquant - v√©rifiez que les modules API sont charg√©s");
			    }

			    // Validation de l'√©tat de l'APIController
			    if (!APIController.isInitialized) {
			        Log.error("[GeoLeaf.API] APIController en √©tat d√©faillant. V√©rification de l'√©tat :", APIController.getHealthStatus());
			        throw new Error("APIController en √©tat d√©faillant");
			    }

			    // ---------------------------------------------------------------------
			    // API publique d√©l√©gu√©e vers APIController
			    // ---------------------------------------------------------------------

			    /**
			     * GeoLeaf.init(options) - Initialisation compl√®te
			     * D√©l√®gue vers APIController.geoleafInit()
			     */
			    function geoleafInit(options) {
			        try {
			            return APIController.geoleafInit(options);
			        } catch (error) {
			            Log.error("[GeoLeaf.init] Erreur lors de l'initialisation :", error);
			            throw error;
			        }
			    }

			    /**
			     * GeoLeaf.setTheme(theme) - Application de th√®me
			     * D√©l√®gue vers APIController.geoleafSetTheme()
			     */
			    function geoleafSetTheme(theme) {
			        try {
			            return APIController.geoleafSetTheme(theme);
			        } catch (error) {
			            Log.error("[GeoLeaf.setTheme] Erreur lors de l'application du th√®me :", error);
			            throw error;
			        }
			    }

			    /**
			     * GeoLeaf.loadConfig(input) - Chargement de configuration
			     * D√©l√®gue vers APIController.geoleafLoadConfig()
			     */
			    function geoleafLoadConfig(input) {
			        try {
			            return APIController.geoleafLoadConfig(input);
			        } catch (error) {
			            Log.error("[GeoLeaf.loadConfig] Erreur lors du chargement de configuration :", error);
			            throw error;
			        }
			    }

			    // ---------------------------------------------------------------------
			    // Constantes et utilitaires
			    // ---------------------------------------------------------------------

			    const CONSTANTS = {
			        VERSION: "4.3.0-robust",
			        DEFAULT_CENTER: [0, 0],
			        DEFAULT_ZOOM: 3,
			        THEMES: ["light", "dark", "satellite", "custom"]
			    };

			    // ---------------------------------------------------------------------
			    // Construction de l'API finale
			    // ---------------------------------------------------------------------

			    const GeoLeaf = Object.assign(existing, {
			        // M√©thodes principales
			        init: geoleafInit,
			        setTheme: geoleafSetTheme,
			        loadConfig: geoleafLoadConfig,

			        // Constantes
			        CONSTANTS,

			        // Acc√®s aux modules via APIController
			        getModule: function(name) {
			            return APIController.moduleAccessFn ? APIController.moduleAccessFn(name) : null;
			        },

			        hasModule: function(name) {
			            const module = APIController.moduleAccessFn ? APIController.moduleAccessFn(name) : null;
			            return !!module;
			        },

			        // Acc√®s aux namespaces via APIController
			        getNamespace: function(name) {
			            return APIController.managers && APIController.managers.namespace ?
			                APIController.managers.namespace.get(name) : null;
			        },

			        // Gestion des instances de cartes via APIController
			        createMap: function(id, options) {
			            return APIController.geoleafCreateMap ? APIController.geoleafCreateMap(id, options) : null;
			        },

			        getMap: function(id) {
			            return APIController.managers && APIController.managers.factory ?
			                APIController.managers.factory.get(id) : null;
			        },

			        getAllMaps: function() {
			            return APIController.managers && APIController.managers.factory ?
			                APIController.managers.factory.getAll() : {};
			        },

			        removeMap: function(id) {
			            return APIController.managers && APIController.managers.factory ?
			                APIController.managers.factory.remove(id) : false;
			        },

			        // M√©triques et monitoring
			        getHealth: function() {
			            return APIController.getHealthStatus ? APIController.getHealthStatus() : null;
			        },

			        getMetrics: function() {
			            return APIController.getHealthStatus ? APIController.getHealthStatus() : null;
			        },

			        // Acc√®s interne pour modules (ne pas utiliser publiquement)
			        _APIController: APIController
			    });

			    // Log de l'initialisation r√©ussie
			    if (Log) {
			        Log.info(`[GeoLeaf.API] API publique v${CONSTANTS.VERSION} initialis√©e avec succ√®s`);
			        Log.info(`[GeoLeaf.API] Sant√© APIController :`, APIController.getHealthStatus());
			    }

			    return GeoLeaf;
			})); 
		} (geoleaf_api$1));
		return geoleaf_api$1.exports;
	}

	requireGeoleaf_api();

	var helpers = {};

	/*!
	 * GeoLeaf Core ‚Äì App / Helpers
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredHelpers;

	function requireHelpers () {
		if (hasRequiredHelpers) return helpers;
		hasRequiredHelpers = 1;
		/**
		 * GeoLeaf Application Helpers
		 * Syst√®me de logs production, d√©tection de chemin, v√©rification des plugins,
		 * et helper de notification.
		 *
		 * Ce fichier cr√©e le namespace partag√© GeoLeaf._app utilis√© par
		 * app/init.js et app/boot.js.
		 *
		 * @module app/helpers
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});

		    /**
		     * Namespace interne pour le module Application Bootstrap.
		     * Partag√© entre app/helpers.js, app/init.js et app/boot.js.
		     * @namespace GeoLeaf._app
		     * @private
		     */
		    const _app = GeoLeaf._app = GeoLeaf._app || {};

		    // ============================================================
		    // Syst√®me de logs production
		    // ============================================================
		    _app.AppLog = {
		        log(...args) {
		            if (location.search.includes('debug=true')) {
		                console.log('[GeoLeaf]', ...args);
		            }
		        },
		        info(...args) {
		            console.info('[GeoLeaf]', ...args);
		        },
		        error(...args) {
		            console.error('[GeoLeaf]', ...args);
		        },
		        warn(...args) {
		            console.warn('[GeoLeaf]', ...args);
		        }
		    };

		    // ============================================================
		    // D√©tection automatique du chemin vers profiles/
		    // ============================================================
		    /**
		     * D√©tecte automatiquement le chemin de base vers le dossier profiles/
		     * en fonction de l'URL courante.
		     * @returns {string} Chemin relatif vers profiles/
		     */
		    _app.getProfilesBasePath = function () {
		        const currentPath = global.location.pathname;
		        if (currentPath.includes('/demo/')) {
		            return '../profiles/';
		        }
		        return './profiles/';
		    };

		    // ============================================================
		    // V√©rification des plugins au boot
		    // ============================================================
		    /**
		     * V√©rifie que les plugins requis par la configuration sont bien charg√©s
		     * et affiche des avertissements dans la console si ce n'est pas le cas.
		     * @param {Object} cfg - Configuration du profil actif
		     */
		    _app.checkPlugins = function (cfg) {
		        const AppLog = _app.AppLog;

		        // Avertissement si config attend AddPOI mais plugin non charg√©
		        if (cfg && cfg.ui && cfg.ui.showAddPoi === true) {
		            if (!GeoLeaf.POI || !GeoLeaf.POI.AddForm) {
		                AppLog.warn(
		                    '‚ö†Ô∏è Config has showAddPoi=true but AddPOI plugin is not loaded. ' +
		                    'Load geoleaf-addpoi.plugin.js before calling GeoLeaf.boot().'
		                );
		            }
		        }

		        // Avertissement si config attend Storage mais plugin non charg√©
		        if (cfg && cfg.storage) {
		            if (!GeoLeaf.Storage) {
		                AppLog.warn(
		                    '‚ö†Ô∏è Config references storage but Storage plugin is not loaded. ' +
		                    'Load geoleaf-storage.plugin.js before calling GeoLeaf.boot().'
		                );
		            }

		            // Avertissement si enableServiceWorker mais sw-register absent
		            if (cfg.storage.enableServiceWorker && !GeoLeaf._SWRegister) {
		                AppLog.warn(
		                    '‚ö†Ô∏è Config has enableServiceWorker=true but SW Register module is not available. ' +
		                    'Ensure sw-register.js is included in the Storage plugin bundle.'
		                );
		            }
		        }

		        // Avertissement si SyncHandler est charg√© sans Storage
		        if (GeoLeaf.POI && GeoLeaf.POI.SyncHandler && !GeoLeaf.Storage) {
		            AppLog.warn(
		                '‚ö†Ô∏è SyncHandler loaded without Storage plugin ‚Äî sync operations will be disabled. ' +
		                'POI add/edit/delete will work in online-only mode.'
		            );
		        }
		    };

		    // ============================================================
		    // Helper : afficher une notification
		    // ============================================================
		    /**
		     * Affiche une notification via le syst√®me UI de GeoLeaf.
		     * Tente d'abord GeoLeaf.UI.Notifications, puis GeoLeaf._UINotifications.
		     * @param {string} message - Message √† afficher
		     * @param {number} [duration=3500] - Dur√©e d'affichage en millisecondes
		     * @returns {boolean} true si la notification a √©t√© affich√©e
		     */
		    _app.showNotification = function (message, duration) {
		        duration = duration || 3500;
		        if (GeoLeaf.UI && GeoLeaf.UI.Notifications && typeof GeoLeaf.UI.Notifications.success === "function") {
		            try { GeoLeaf.UI.Notifications.success(message, duration); return true; } catch (e) {}
		        }
		        if (GeoLeaf._UINotifications && typeof GeoLeaf._UINotifications.success === "function") {
		            try { GeoLeaf._UINotifications.success(message, duration); return true; } catch (e) {}
		        }
		        _app.AppLog.log(message + " (notifications indisponibles)");
		        return false;
		    };

		})(window);
		return helpers;
	}

	requireHelpers();

	var init = {};

	/*!
	 * GeoLeaf Core ‚Äì App / Init
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredInit;

	function requireInit () {
		if (hasRequiredInit) return init;
		hasRequiredInit = 1;
		/**
		 * GeoLeaf Application Init
		 * Fonction principale d'initialisation de l'application :
		 * - Initialisation de la carte
		 * - Chargement des modules (POI, Routes, GeoJSON, etc.)
		 * - Configuration des composants UI
		 * - M√©canisme de reveal (loader / spinner)
		 *
		 * @module app/init
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const _app = GeoLeaf._app = GeoLeaf._app || {};

		    // ============================================================
		    // Fonction principale : initialiser l'application
		    // ============================================================
		    _app.initApp = function (cfg) {
		        cfg = cfg || {};
		        const AppLog = _app.AppLog;
		        AppLog.log("Initialisation avec config:", cfg);

		        // V√©rifier les plugins
		        _app.checkPlugins(cfg);

		        // ========================================================
		        // Initialisation de la carte
		        // La carte est cr√©√©e directement sur l'emprise du profil
		        // (map.bounds obligatoire dans le profil).
		        // ========================================================
		        const mapTarget = (cfg.map && (cfg.map.target || cfg.map.id)) || "geoleaf-map";
		        const uiTheme = (cfg.ui && cfg.ui.theme) || "light";

		        // Bounds obligatoires ‚Äî pas de fallback carte monde
		        if (!cfg.map || !Array.isArray(cfg.map.bounds) || cfg.map.bounds.length !== 2) {
		            AppLog.error(
		                "[GeoLeaf] Le profil actif ne d√©finit pas de map.bounds valide. " +
		                "L'emprise (map.bounds) est obligatoire dans le fichier profile.json. " +
		                "Exemple : \"bounds\": [[43.0, 1.0], [44.0, 2.0]]"
		            );
		            return;
		        }

		        // Calculer le centre depuis les bounds pour √©viter le flash carte monde
		        const profileBounds = cfg.map.bounds;
		        const profileMaxZoom = cfg.map.maxZoom || 12;
		        const profilePadding = cfg.map.padding || [50, 50];
		        const mapCenter = [
		            (profileBounds[0][0] + profileBounds[1][0]) / 2,
		            (profileBounds[0][1] + profileBounds[1][1]) / 2
		        ];

		        let map = null;

		        try {
		            map = GeoLeaf.init({
		                map: {
		                    target: mapTarget,
		                    center: mapCenter,
		                    zoom: profileMaxZoom
		                },
		                ui: {
		                    theme: uiTheme
		                }
		            });
		        } catch (e) {
		            AppLog.error("GeoLeaf.init() a lev√© une erreur :", e);
		            return;
		        }

		        if (!map) {
		            AppLog.error("GeoLeaf.init() n'a pas renvoy√© de carte valide.");
		            return;
		        }

		        // Positionnement pr√©cis via fitBounds (ajuste le zoom aux dimensions r√©elles du conteneur)
		        try {
		            map.fitBounds(profileBounds, {
		                maxZoom: profileMaxZoom,
		                padding: profilePadding,
		                animate: false
		            });
		            AppLog.log("Carte positionn√©e via map.bounds du profil.");
		        } catch (e) {
		            AppLog.warn("Erreur fitBounds depuis profile.map.bounds :", e);
		        }

		        // ========================================================
		        // Initialiser le Storage avec la config du profil (si plugin charg√©)
		        // ========================================================
		        if (GeoLeaf.Storage && typeof GeoLeaf.Storage.init === "function") {
		            try {
		                const storageConfig = cfg.storage || {};
		                AppLog.log("Initialisation du Storage avec config:", storageConfig);

		                GeoLeaf.Storage.init({
		                    indexedDB: { name: 'geoleaf-db', version: 2 },
		                    cache: storageConfig.cache || {
		                        enableProfileCache: true,
		                        enableTileCache: true
		                    },
		                    offline: {},
		                    enableOfflineDetector: !!(storageConfig.enableOfflineDetector),
		                    enableServiceWorker: !!(storageConfig.enableServiceWorker)
		                }).then(() => {
		                    AppLog.log("Storage initialis√© avec succ√®s");
		                }).catch(err => {
		                    AppLog.warn("Erreur initialisation Storage:", err);
		                });
		            } catch (e) {
		                AppLog.warn("Erreur lors de l'initialisation du Storage:", e);
		            }
		        } else {
		            AppLog.log("Plugin Storage non charg√© ‚Äî fonctionnement en mode cache navigateur standard.");
		        }

		        // ========================================================
		        // Initialiser le syst√®me de notifications UI
		        // ========================================================
		        if (GeoLeaf._UINotifications && typeof GeoLeaf._UINotifications.init === "function") {
		            try {
		                let notificationContainer = document.getElementById('gl-notifications');
		                if (!notificationContainer) {
		                    notificationContainer = document.createElement('div');
		                    notificationContainer.id = 'gl-notifications';
		                    notificationContainer.className = 'gl-notifications gl-notifications--bottom-center';
		                    document.body.appendChild(notificationContainer);
		                }

		                GeoLeaf._UINotifications.init({
		                    container: '#gl-notifications',
		                    position: 'bottom-center',
		                    maxVisible: 3,
		                    animations: true
		                });

		                AppLog.log("Syst√®me de notifications initialis√©");
		            } catch (e) {
		                AppLog.warn("Erreur lors de l'initialisation des notifications:", e);
		            }
		        }

		        // ========================================================
		        // Toast de chargement persistant pendant le chargement des couches
		        // Affich√© d√®s que le ThemeApplier commence √† charger un th√®me,
		        // ferm√© quand geoleaf:theme:applied est √©mis.
		        // ========================================================
		        let _loadingToast = null;

		        document.addEventListener('geoleaf:theme:applying', function(event) {
		            // Afficher un toast persistant si le syst√®me de notifications est pr√™t
		            if (GeoLeaf._UINotifications && GeoLeaf._UINotifications.container) {
		                _loadingToast = GeoLeaf._UINotifications.info(
		                    'Chargement des donn√©es en cours, patientez‚Ä¶',
		                    { persistent: true, dismissible: false }
		                );
		            }
		        });

		        // ========================================================
		        // √âcouteurs d'√©v√©nements (notifications profile & theme)
		        // ========================================================
		        let pendingProfileToastDetail = null;

		        function notificationsReady() {
		            try {
		                if (GeoLeaf.UI && GeoLeaf.UI.Notifications && typeof GeoLeaf.UI.Notifications.getStatus === "function") {
		                    return !!GeoLeaf.UI.Notifications.getStatus().initialized;
		                }
		                if (GeoLeaf._UINotifications && GeoLeaf._UINotifications.container) {
		                    return true;
		                }
		            } catch (e) {}
		            return false;
		        }

		        function tryShowProfileToast(detail) {
		            if (!detail || !detail.data) return false;
		            const profile = detail.data.profile || {};
		            const profileName = profile.label || profile.name || profile.title || detail.profileId || 'Profil';
		            const message = profileName + " charg√©";
		            if (!notificationsReady()) {
		                pendingProfileToastDetail = detail;
		                return false;
		            }
		            const shown = _app.showNotification(message);
		            if (shown) pendingProfileToastDetail = null;
		            else pendingProfileToastDetail = detail;
		            return shown;
		        }

		        document.addEventListener("geoleaf:profile:loaded", function(event) {
		            if (event && event.detail) {
		                pendingProfileToastDetail = event.detail;
		                tryShowProfileToast(event.detail);
		            }
		        });

		        document.addEventListener("geoleaf:theme:applied", function(event) {
		            // Fermer le toast de chargement persistant
		            if (_loadingToast && GeoLeaf._UINotifications && typeof GeoLeaf._UINotifications.dismiss === 'function') {
		                GeoLeaf._UINotifications.dismiss(_loadingToast);
		                _loadingToast = null;
		            }
		            if (event && event.detail) {
		                const detail = event.detail;
		                _app.showNotification(`Th√®me "${detail.themeName}" charg√© (${detail.layerCount} couches visibles)`, 3500);
		            }
		        });

		        // √âcouter la fin de chargement pour les notifications en attente
		        document.addEventListener("geoleaf:map:ready", function() {
		            if (pendingProfileToastDetail) {
		                tryShowProfileToast(pendingProfileToastDetail);
		            }
		        });

		        // ========================================================
		        // Th√®me UI via GeoLeaf.setTheme() + initialisation UI
		        // ========================================================
		        try {
		            if (typeof GeoLeaf.setTheme === "function") {
		                GeoLeaf.setTheme(uiTheme);
		            }
		        } catch (e) {
		            AppLog.warn("Erreur lors de l'appel √† GeoLeaf.setTheme :", e);
		        }

		        if (GeoLeaf.UI && typeof GeoLeaf.UI.init === "function") {
		            try {
		                const mapContainer = document.querySelector('.gl-main') || document.getElementById(mapTarget);
		                GeoLeaf.UI.init({
		                    buttonSelector: '[data-gl-role="theme-toggle"]',
		                    map: map,
		                    mapContainer: mapContainer,
		                    config: cfg
		                });
		            } catch (e) {
		                AppLog.warn("GeoLeaf.UI.init() a lev√© une erreur :", e);
		            }
		        }

		        // Construction du panneau de filtres
		        if (GeoLeaf.UI && typeof GeoLeaf.UI.buildFilterPanelFromActiveProfile === "function") {
		            try {
		                let filterContainer = document.getElementById("gl-filter-panel");
		                if (!filterContainer) {
		                    filterContainer = document.createElement("div");
		                    filterContainer.id = "gl-filter-panel";
		                    filterContainer.setAttribute("data-gl-role", "filter-panel");
		                    const glMain = document.querySelector('.gl-main');
		                    if (glMain) glMain.appendChild(filterContainer);
		                    else document.body.appendChild(filterContainer);
		                }

		                GeoLeaf.UI.buildFilterPanelFromActiveProfile({ container: filterContainer });

		                if (typeof GeoLeaf.UI.initFilterToggle === "function") {
		                    GeoLeaf.UI.initFilterToggle();
		                }
		                if (typeof GeoLeaf.UI.initProximityFilter === "function") {
		                    GeoLeaf.UI.initProximityFilter(map);
		                }
		            } catch (e) {
		                AppLog.warn("Erreur lors de la construction du panneau de filtres :", e);
		            }
		        }

		        // Initialisation du module Table
		        if (GeoLeaf.Table && typeof GeoLeaf.Table.init === "function" && cfg.tableConfig && cfg.tableConfig.enabled) {
		            try {
		                GeoLeaf.Table.init({ map: map, config: cfg.tableConfig });
		                AppLog.log("Module Table initialis√©.");
		            } catch (e) {
		                AppLog.warn("Erreur lors de l'initialisation du module Table :", e);
		            }
		        }

		        // Initialisation du bouton de cache offline (si plugin Storage charg√©)
		        if (GeoLeaf.UI && GeoLeaf.UI.CacheButton && typeof GeoLeaf.UI.CacheButton.init === "function") {
		            try {
		                GeoLeaf.UI.CacheButton.init(map, cfg);
		                AppLog.log("Bouton de cache initialis√©.");
		            } catch (e) {
		                AppLog.warn("Erreur lors de l'initialisation du bouton de cache :", e);
		            }
		        }

		        // ========================================================
		        // Basemaps via GeoLeaf.BaseLayers
		        // ========================================================
		        (function initBasemaps() {
		            const baseLayersModule = GeoLeaf.BaseLayers || GeoLeaf.Baselayers;
		            if (!baseLayersModule || typeof baseLayersModule.init !== "function") {
		                AppLog.warn("Module BaseLayers introuvable.");
		                return;
		            }

		            let activeKey = "street";
		            const basemapsFromConfig = {};
		            if (cfg.basemaps && typeof cfg.basemaps === 'object') {
		                Object.keys(cfg.basemaps).forEach(function(key) {
		                    const def = cfg.basemaps[key];
		                    if (def.defaultBasemap === true) activeKey = def.id || key;
		                    basemapsFromConfig[key] = {
		                        id: def.id || key,
		                        label: def.label || key,
		                        url: def.url,
		                        options: {
		                            minZoom: def.minZoom || 0,
		                            maxZoom: def.maxZoom || 19,
		                            attribution: def.attribution || ''
		                        }
		                    };
		                });
		            }

		            try {
		                baseLayersModule.init({
		                    map: map,
		                    baselayers: basemapsFromConfig,
		                    activeKey: activeKey,
		                    ui: cfg.ui,
		                    basemaps: cfg.basemaps
		                });
		            } catch (e) {
		                AppLog.warn("BaseLayers.init a lev√© une exception :", e);
		            }
		        })();

		        // ========================================================
		        // POI via GeoLeaf.POI
		        // ========================================================
		        (function initPOI() {
		            const poiApi = GeoLeaf.POI;
		            if (!poiApi || typeof poiApi.add !== "function") {
		                AppLog.warn("GeoLeaf.POI.add() indisponible, aucun POI ne sera affich√©.");
		                return;
		            }

		            try {
		                if (typeof poiApi.init === "function") {
		                    poiApi.init({ map: map, config: cfg.poiConfig || {} });

		                    // Chargement des l√©gendes POI
		                    if (GeoLeaf.Legend && typeof GeoLeaf.Legend.loadLayerLegend === "function" && cfg.layers && Array.isArray(cfg.layers)) {
		                        cfg.layers.forEach(function(layerRef) {
		                            if (layerRef.id && layerRef.id.includes('poi') && layerRef.configFile) {
		                                fetch(layerRef.configFile)
		                                    .then(response => response.json())
		                                    .then(layerConfig => {
		                                        let styleId = 'default';
		                                        if (layerConfig.styles && layerConfig.styles.available && layerConfig.styles.available.length > 0) {
		                                            styleId = layerConfig.styles.available[0].id || 'default';
		                                        }
		                                        GeoLeaf.Legend.loadLayerLegend(layerRef.id, styleId, layerConfig);
		                                        if (typeof GeoLeaf.Legend.setLayerVisibility === "function") {
		                                            GeoLeaf.Legend.setLayerVisibility(layerRef.id, true);
		                                        }
		                                    })
		                                    .catch(err => AppLog.warn(`Erreur chargement config couche ${layerRef.id}:`, err));
		                            }
		                        });
		                    }
		                }
		            } catch (e) {
		                AppLog.warn("GeoLeaf.POI.init() a lev√© une erreur :", e);
		            }

		            const showFilterPanel = cfg.ui && cfg.ui.showFilterPanel === true;
		            if (showFilterPanel) {
		                AppLog.info("Panneau de filtres activ√© : les POI seront charg√©s via le syst√®me de filtres.");
		                if (GeoLeaf.UI && typeof GeoLeaf.UI.applyFiltersInitial === "function") {
		                    GeoLeaf.UI.applyFiltersInitial();
		                }
		                return;
		            }

		            if (!Array.isArray(cfg.poi) || cfg.poi.length === 0) {
		                return;
		            }

		            const bounds = [];
		            cfg.poi.forEach(function (poiItem) {
		                let latlng = null;
		                if (poiItem.latlng && Array.isArray(poiItem.latlng) && poiItem.latlng.length === 2) {
		                    latlng = poiItem.latlng;
		                } else if (poiItem.location && typeof poiItem.location.lat === "number" && typeof poiItem.location.lng === "number") {
		                    latlng = [poiItem.location.lat, poiItem.location.lng];
		                }
		                if (latlng) bounds.push(latlng);
		            });

		            if (bounds.length > 0) {
		                // fitBounds POI uniquement si pas de bounds dans le profil ET pas de couches GeoJSON
		                const hasBoundsFromProfile = cfg.map && Array.isArray(cfg.map.bounds) && cfg.map.bounds.length === 2;
		                const hasGeoJSONLayers = cfg.layers && Array.isArray(cfg.layers) && cfg.layers.length > 0;
		                if (!hasBoundsFromProfile && !hasGeoJSONLayers) {
		                    try {
		                        map.fitBounds(L.latLngBounds(bounds), { padding: [80, 80], maxZoom: 12, animate: false });
		                    } catch (e) {
		                        AppLog.warn("Erreur lors de fitBounds :", e);
		                    }
		                }
		                if (GeoLeaf.UI && typeof GeoLeaf.UI.refreshFilterTags === "function") {
		                    GeoLeaf.UI.refreshFilterTags();
		                }
		            }
		        })();

		        // ========================================================
		        // Itin√©raires via GeoLeaf.Route
		        // ========================================================
		        (function initRoute() {
		            const routeApi = GeoLeaf.Route;
		            if (!routeApi || typeof routeApi.init !== "function" || typeof routeApi.loadFromConfig !== "function") {
		                return;
		            }
		            try {
		                routeApi.init({ map: map, fitBoundsOnLoad: false, maxZoomOnFit: 12 });
		            } catch (e) {
		                AppLog.warn("GeoLeaf.Route.init() a lev√© une erreur :", e);
		                return;
		            }
		            if (Array.isArray(cfg.routes) && cfg.routes.length > 0) {
		                try {
		                    routeApi.loadFromConfig(cfg.routes);
		                    AppLog.log("Itin√©raires charg√©s.");
		                } catch (e) {
		                    AppLog.warn("GeoLeaf.Route.loadFromConfig() a lev√© une erreur :", e);
		                }
		            }
		        })();

		        // ========================================================
		        // Couches GeoJSON via GeoLeaf.GeoJSON
		        // ========================================================
		        (function initGeoJSON() {
		            const geoJsonApi = GeoLeaf.GeoJSON;
		            if (!geoJsonApi || typeof geoJsonApi.init !== "function") {
		                AppLog.log("GeoLeaf.GeoJSON.init() indisponible ‚Äî pas de couches GeoJSON.");
		                return;
		            }

		            try {
		                geoJsonApi.init({ map: map, fitBoundsOnLoad: false, maxZoomOnFit: 12 });
		            } catch (e) {
		                AppLog.warn("GeoLeaf.GeoJSON.init() a lev√© une erreur :", e);
		                return;
		            }

		            if (map && typeof map.on === "function") {
		                map.on("geoleaf:geojson:layers-loaded", function(event) {
		                    if (event && event.detail && typeof event.detail.count === "number") {
		                        const count = event.detail.count;
		                        const message = count === 1 ? "1 couche GeoJSON charg√©e" : count + " couches GeoJSON charg√©es";
		                        _app.showNotification(message, 3000);
		                    }
		                });
		            }

		            // Initialisation du syst√®me de th√®mes
		            const loadAllConfigsPromise = (function() {
		                if (GeoLeaf._GeoJSONLoader && typeof GeoLeaf._GeoJSONLoader.loadAllLayersConfigsForLayerManager === "function") {
		                    const activeProfile = GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfile === "function"
		                        ? GeoLeaf.Config.getActiveProfile() : null;
		                    if (activeProfile) {
		                        return GeoLeaf._GeoJSONLoader.loadAllLayersConfigsForLayerManager(activeProfile)
		                            .catch(err => { AppLog.warn("Erreur chargement configs couches:", err); return []; });
		                    }
		                }
		                return Promise.resolve();
		            })();

		            loadAllConfigsPromise.then(function() {
		                if (!GeoLeaf.ThemeSelector || typeof GeoLeaf.ThemeSelector.init !== "function") {
		                    AppLog.warn("ThemeSelector non disponible");
		                    return;
		                }

		                let currentProfileId = null;
		                if (GeoLeaf.Config && typeof GeoLeaf.Config.getActiveProfileId === "function") {
		                    currentProfileId = GeoLeaf.Config.getActiveProfileId();
		                }

		                const primaryContainer = document.getElementById("gl-theme-primary-container");
		                const secondaryContainer = document.getElementById("gl-theme-secondary-container");

		                if (!currentProfileId || !primaryContainer || !secondaryContainer) {
		                    AppLog.warn("ThemeSelector : conteneurs ou profil manquants");
		                    return;
		                }

		                GeoLeaf.ThemeSelector.init({
		                    profileId: currentProfileId,
		                    primaryContainer: primaryContainer,
		                    secondaryContainer: secondaryContainer
		                }).then(function() {
		                    AppLog.log("ThemeSelector initialis√© et th√®me appliqu√©");

		                    if (GeoLeaf._GeoJSONLayerManager && typeof GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs === "function") {
		                        const activeThemeConfig = GeoLeaf.ThemeSelector.getActiveTheme ? GeoLeaf.ThemeSelector.getActiveTheme() : null;
		                        GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs(activeThemeConfig);
		                    }

		                    document.addEventListener('geoleaf:theme:applied', function() {
		                        if (GeoLeaf._GeoJSONLayerManager && typeof GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs === "function") {
		                            const activeThemeConfig = GeoLeaf.ThemeSelector.getActiveTheme ? GeoLeaf.ThemeSelector.getActiveTheme() : null;
		                            GeoLeaf._GeoJSONLayerManager.populateLayerManagerWithAllConfigs(activeThemeConfig);
		                        }
		                    });
		                }).catch(function(e) {
		                    AppLog.warn("Erreur initialisation ThemeSelector:", e);
		                });
		            });
		        })();

		        // ========================================================
		        // Branding
		        // ========================================================
		        if (GeoLeaf.UI && GeoLeaf.UI.Branding && typeof GeoLeaf.UI.Branding.init === "function") {
		            try {
		                GeoLeaf.UI.Branding.init(map);
		            } catch (e) {
		                AppLog.warn("GeoLeaf.UI.Branding.init() a lev√© une erreur :", e);
		            }
		        }

		        // ========================================================
		        // L√©gende et gestionnaire de couches
		        // ========================================================
		        if (cfg.ui && cfg.ui.showLegend !== false && GeoLeaf.Legend && typeof GeoLeaf.Legend.init === "function") {
		            try {
		                GeoLeaf.Legend.init(map, {
		                    position: "bottomleft",
		                    collapsible: true,
		                    collapsed: false,
		                    title: "L√©gende"
		                });
		            } catch (e) {
		                AppLog.warn("Erreur lors de l'initialisation du module Legend:", e);
		            }
		        }

		        if (cfg.ui && cfg.ui.showLayerManager !== false && GeoLeaf.LayerManager && typeof GeoLeaf.LayerManager.init === "function") {
		            try {
		                GeoLeaf.LayerManager.init({ map: map, position: "bottomright" });
		            } catch (e) {
		                AppLog.warn("GeoLeaf.LayerManager.init() a lev√© une erreur :", e);
		            }
		        }

		        // ========================================================
		        // Contr√¥le d'√©chelle
		        // ========================================================
		        if (GeoLeaf.initScaleControl && typeof GeoLeaf.initScaleControl === "function") {
		            try { GeoLeaf.initScaleControl(map); } catch (e) {
		                AppLog.warn("GeoLeaf.initScaleControl() a lev√© une erreur :", e);
		            }
		        }

		        // ========================================================
		        // Syst√®me de labels
		        // ========================================================
		        if (GeoLeaf.Labels && typeof GeoLeaf.Labels.init === "function") {
		            try { GeoLeaf.Labels.init({ map: map }); } catch (e) {
		                AppLog.warn("GeoLeaf.Labels.init() a lev√© une erreur :", e);
		            }
		        }

		        // ========================================================
		        // Affichage des coordonn√©es
		        // ========================================================
		        if (cfg.ui && cfg.ui.showCoordinates !== false && GeoLeaf.UI && GeoLeaf.UI.CoordinatesDisplay && typeof GeoLeaf.UI.CoordinatesDisplay.init === "function") {
		            try {
		                GeoLeaf.UI.CoordinatesDisplay.init(map, { position: "bottomleft", decimals: 6 });
		            } catch (e) {
		                AppLog.warn("GeoLeaf.UI.CoordinatesDisplay.init() a lev√© une erreur :", e);
		            }
		        }

		        // ========================================================
		        // R√©v√©ler l'application quand les couches sont pr√™tes
		        // Le spinner #gl-loader reste opaque pendant que la carte
		        // et les couches GeoJSON se chargent derri√®re.
		        // On attend l'√©v√©nement geoleaf:theme:applied (= toutes
		        // les couches visibles sont charg√©es) avant de r√©v√©ler.
		        // ========================================================
		        let _appRevealed = false;
		        function revealApp(reason) {
		            if (_appRevealed) return;
		            _appRevealed = true;
		            const loader = document.getElementById('gl-loader');
		            if (loader) {
		                loader.classList.add('gl-loader--fade');
		                // Supprimer du DOM apr√®s la transition CSS (400ms)
		                loader.addEventListener('transitionend', function() {
		                    loader.style.display = 'none';
		                }, { once: true });
		                // Fallback si transitionend ne se d√©clenche pas
		                setTimeout(function() { loader.style.display = 'none'; }, 500);
		            }

		            // Correctif : le loader (#gl-loader) recouvrait la carte (position: fixed; inset: 0)
		            // ‚Üí Leaflet calculait fitBounds sur un conteneur de dimensions incorrectes.
		            // On recalcule apr√®s le retrait du loader.
		            if (map) {
		                map.invalidateSize({ pan: false });
		                setTimeout(function() {
		                    try {
		                        map.fitBounds(profileBounds, {
		                            maxZoom:  profileMaxZoom,
		                            padding:  profilePadding,
		                            animate:  true,
		                            duration: 0.6
		                        });
		                    } catch (e) {
		                        AppLog.warn("[GeoLeaf] Correctif fitBounds au reveal :", e);
		                    }
		                }, 120);
		            }

		            document.dispatchEvent(new CustomEvent("geoleaf:map:ready"));
		            AppLog.info("Application pr√™te ‚Äî " + reason);
		        }

		        // Attendre que toutes les couches du th√®me soient charg√©es
		        document.addEventListener('geoleaf:theme:applied', function() {
		            revealApp('th√®me appliqu√©, couches charg√©es');
		        }, { once: true });

		        // S√©curit√© : r√©v√©ler apr√®s 15s max (r√©seau lent, erreur‚Ä¶)
		        setTimeout(function() { revealApp('timeout s√©curit√© 15s'); }, 15000);

		        AppLog.info("Application initialis√©e, chargement des couches en arri√®re-plan‚Ä¶");
		    };

		})(window);
		return init;
	}

	requireInit();

	var boot = {};

	/*!
	 * GeoLeaf Core ‚Äì App / Boot
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */

	var hasRequiredBoot;

	function requireBoot () {
		if (hasRequiredBoot) return boot;
		hasRequiredBoot = 1;
		/**
		 * GeoLeaf Application Boot
		 * Chargement de la configuration et lancement de l'initialisation.
		 * Expose l'API publique GeoLeaf.boot().
		 *
		 * Usage : <script>GeoLeaf.boot();</script>
		 *
		 * @module app/boot
		 */
		(function (global) {

		    const GeoLeaf = (global.GeoLeaf = global.GeoLeaf || {});
		    const _app = GeoLeaf._app = GeoLeaf._app || {};

		    // ============================================================
		    // Fonction startApp : chargement config + lancement initApp
		    // ============================================================
		    _app.startApp = function () {
		        const AppLog = _app.AppLog;

		        if (!GeoLeaf) {
		            AppLog.error("GeoLeaf global introuvable. Le bundle core doit √™tre charg√© avant GeoLeaf.boot().");
		            return;
		        }

		        if (typeof GeoLeaf.loadConfig !== "function") {
		            AppLog.error("GeoLeaf.loadConfig() est introuvable. V√©rifiez que le bundle core est complet.");
		            return;
		        }

		        AppLog.info("D√©marrage de l'application...");

		        let selectedProfile = null;
		        try {
		            selectedProfile = sessionStorage.getItem('gl-selected-profile');
		            if (selectedProfile) {
		                AppLog.log('Profil s√©lectionn√© depuis sessionStorage:', selectedProfile);
		                sessionStorage.removeItem('gl-selected-profile');
		            }
		        } catch (e) {
		            AppLog.warn('Impossible de lire sessionStorage:', e);
		        }

		        const profilesPath = _app.getProfilesBasePath();

		        GeoLeaf.loadConfig({
		            url: profilesPath + "geoleaf.config.json",
		            profileId: selectedProfile,
		            autoEvent: true,

		            onLoaded: function (cfg) {
		                AppLog.log("Configuration charg√©e via GeoLeaf.loadConfig :", cfg || {});

		                if (GeoLeaf.Config && typeof GeoLeaf.Config.getCategories === "function") {
		                    try { GeoLeaf.Config.getCategories(); } catch (e) {
		                        AppLog.warn("Erreur lors de la lecture du mapping cat√©gories :", e);
		                    }
		                }

		                const baseCfg = cfg || {};

		                if (GeoLeaf.Config && typeof GeoLeaf.Config.loadActiveProfileResources === "function") {
		                    GeoLeaf.Config.loadActiveProfileResources()
		                        .then(function (profileCfg) {
		                            AppLog.info("Ressources du profil actif charg√©es.");
		                            _app.initApp(profileCfg || baseCfg);
		                        })
		                        .catch(function (err) {
		                            AppLog.warn("Erreur lors du chargement des ressources de profil :", err);
		                            _app.initApp(baseCfg);
		                        });
		                } else {
		                    _app.initApp(baseCfg);
		                }
		            },

		            onError: function (err) {
		                AppLog.error("Erreur chargement config via GeoLeaf.loadConfig :", err);
		            }
		        });
		    };

		    // ============================================================
		    // Exposer GeoLeaf.boot() ‚Äî API publique
		    // ============================================================

		    /**
		     * D√©marre l'application GeoLeaf.
		     * Charge la configuration, initialise la carte et tous les modules.
		     * Les plugins optionnels (Storage, AddPOI) doivent √™tre charg√©s avant cet appel.
		     *
		     * @example
		     * <script src="dist/geoleaf.umd.js"></script>
		     * <script src="dist/geoleaf-storage.plugin.js"></script>  <!-- optionnel -->
		     * <script src="dist/geoleaf-addpoi.plugin.js"></script>   <!-- optionnel -->
		     * <script>GeoLeaf.boot();</script>
		     */
		    GeoLeaf.boot = function() {
		        if (document.readyState === 'loading') {
		            document.addEventListener('DOMContentLoaded', _app.startApp);
		        } else {
		            _app.startApp();
		        }
		    };

		})(window);
		return boot;
	}

	requireBoot();

	/*!
	 * GeoLeaf Core
	 * ¬© 2026 Mattieu Pottier
	 * Released under the MIT License
	 * https://geoleaf.dev
	 */


	// Export du namespace global GeoLeaf
	var bundleEntry = (typeof window !== 'undefined' ? window.GeoLeaf : {});

	exports.default = bundleEntry;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=geoleaf.umd.js.map
